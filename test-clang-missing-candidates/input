# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/test/nomalloc.cpp"
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/test/nomalloc.cpp" 1
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 138 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/test/nomalloc.cpp" 2
# 35 "/home/pipping/Downloads/eigen-eigen-3.0.3/test/nomalloc.cpp"
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/test/main.h" 1
# 26 "/home/pipping/Downloads/eigen-eigen-3.0.3/test/main.h"
# 1 "/usr/include/c++/4.5.3/cstdlib" 1 3
# 41 "/usr/include/c++/4.5.3/cstdlib" 3
# 41 "/usr/include/c++/4.5.3/cstdlib" 3

# 1 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/c++config.h" 1 3
# 275 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/c++config.h" 3
# 1 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/os_defines.h" 1 3
# 39 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/os_defines.h" 3
# 1 "/usr/include/features.h" 1 3 4
# 356 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 353 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 354 "/usr/include/sys/cdefs.h" 2 3 4
# 357 "/usr/include/features.h" 2 3 4
# 380 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4



# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 5 "/usr/include/gnu/stubs.h" 2 3 4




# 1 "/usr/include/gnu/stubs-64.h" 1 3 4
# 10 "/usr/include/gnu/stubs.h" 2 3 4
# 381 "/usr/include/features.h" 2 3 4
# 40 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/os_defines.h" 2 3
# 276 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/c++config.h" 2 3


# 1 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/cpu_defines.h" 1 3
# 279 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/c++config.h" 2 3
# 43 "/usr/include/c++/4.5.3/cstdlib" 2 3
# 1 "/usr/include/c++/4.5.3/cstddef" 1 3
# 41 "/usr/include/c++/4.5.3/cstddef" 3
# 41 "/usr/include/c++/4.5.3/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 31 "/usr/bin/../lib/clang/3.0/include/stddef.h" 3 4
typedef __typeof__(((int*)0)-((int*)0)) ptrdiff_t;



typedef __typeof__(sizeof(int)) size_t;
# 44 "/usr/include/c++/4.5.3/cstddef" 2 3




namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::ptrdiff_t;
  using ::size_t;

}
# 44 "/usr/include/c++/4.5.3/cstdlib" 2 3
# 67 "/usr/include/c++/4.5.3/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 33 "/usr/include/stdlib.h" 3 4
# 1 "/usr/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 34 "/usr/include/stdlib.h" 2 3 4

extern "C" {







# 1 "/usr/include/bits/waitflags.h" 1 3 4
# 43 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
# 65 "/usr/include/bits/waitstatus.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
# 38 "/usr/include/endian.h" 2 3 4
# 61 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 28 "/usr/include/bits/byteswap.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/byteswap.h" 2 3 4
# 62 "/usr/include/endian.h" 2 3 4
# 66 "/usr/include/bits/waitstatus.h" 2 3 4

union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 44 "/usr/include/stdlib.h" 2 3 4
# 98 "/usr/include/stdlib.h" 3 4
typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 140 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) ;




extern double atof (__const char *__nptr)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (__const char *__nptr)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (__const char *__nptr)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (__const char *__nptr)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (__const char *__restrict __nptr,
        char **__restrict __endptr)
             __attribute__ ((__nonnull__ (1))) ;





extern float strtof (__const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nonnull__ (1))) ;

extern long double strtold (__const char *__restrict __nptr,
       char **__restrict __endptr)
             __attribute__ ((__nonnull__ (1))) ;





extern long int strtol (__const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
             __attribute__ ((__nonnull__ (1))) ;

extern unsigned long int strtoul (__const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
             __attribute__ ((__nonnull__ (1))) ;




__extension__
extern long long int strtoq (__const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
             __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtouq (__const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
             __attribute__ ((__nonnull__ (1))) ;





__extension__
extern long long int strtoll (__const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
             __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtoull (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
             __attribute__ ((__nonnull__ (1))) ;
# 236 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/xlocale.h" 1 3 4
# 28 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 237 "/usr/include/stdlib.h" 2 3 4



extern long int strtol_l (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) __attribute__ ((__nonnull__ (1, 4))) ;

extern unsigned long int strtoul_l (__const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
             __attribute__ ((__nonnull__ (1, 4))) ;

__extension__
extern long long int strtoll_l (__const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
             __attribute__ ((__nonnull__ (1, 4))) ;

__extension__
extern unsigned long long int strtoull_l (__const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
             __attribute__ ((__nonnull__ (1, 4))) ;

extern double strtod_l (__const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
             __attribute__ ((__nonnull__ (1, 3))) ;

extern float strtof_l (__const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
             __attribute__ ((__nonnull__ (1, 3))) ;

extern long double strtold_l (__const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
             __attribute__ ((__nonnull__ (1, 3))) ;
# 311 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) ;


extern long int a64l (__const char *__s)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





# 1 "/usr/include/sys/types.h" 1 3 4
# 28 "/usr/include/sys/types.h" 3 4
extern "C" {


# 1 "/usr/include/bits/types.h" 1 3 4
# 28 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 131 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 132 "/usr/include/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef long int __swblk_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;

typedef long int __ssize_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
# 31 "/usr/include/sys/types.h" 2 3 4



typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __pid_t pid_t;





typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 133 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 60 "/usr/include/time.h" 3 4
typedef __clock_t clock_t;
# 76 "/usr/include/time.h" 3 4
typedef __time_t time_t;
# 92 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 104 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 134 "/usr/include/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;






# 1 "/usr/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 148 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 195 "/usr/include/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 220 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/select.h" 1 3 4
# 31 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
# 23 "/usr/include/bits/select.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 24 "/usr/include/bits/select.h" 2 3 4
# 32 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 24 "/usr/include/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 35 "/usr/include/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;






# 1 "/usr/include/time.h" 1 3 4
# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    long int tv_nsec;
  };
# 45 "/usr/include/sys/select.h" 2 3 4

# 1 "/usr/include/bits/time.h" 1 3 4
# 75 "/usr/include/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 47 "/usr/include/sys/select.h" 2 3 4








typedef long int __fd_mask;
# 67 "/usr/include/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 99 "/usr/include/sys/select.h" 3 4
extern "C" {
# 109 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 121 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);


}
# 221 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/sysmacros.h" 1 3 4
# 30 "/usr/include/sys/sysmacros.h" 3 4
__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
            ;
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
            ;
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
            ;
# 224 "/usr/include/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 263 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;






# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 24 "/usr/include/bits/pthreadtypes.h" 2 3 4
# 50 "/usr/include/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


typedef union
{
  char __size[56];
  long int __align;
} pthread_attr_t;



typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 76 "/usr/include/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    int __spins;
    __pthread_list_t __list;
# 101 "/usr/include/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    unsigned long int __pad1;
    unsigned long int __pad2;


    unsigned int __flags;
  } __data;
# 187 "/usr/include/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 272 "/usr/include/sys/types.h" 2 3 4


}
# 321 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) ;


extern void srandom (unsigned int __seed) ;





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
             __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
             __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
             __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) ;

extern void srand (unsigned int __seed) ;




extern int rand_r (unsigned int *__seed) ;







extern double drand48 (void) ;
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) ;
extern long int nrand48 (unsigned short int __xsubi[3])
             __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) ;
extern long int jrand48 (unsigned short int __xsubi[3])
             __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) ;
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
             __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
             __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
             __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
             __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
             __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
             __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
             __attribute__ ((__nonnull__ (1, 2)));
# 471 "/usr/include/stdlib.h" 3 4
extern void *malloc (size_t __size) __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
             __attribute__ ((__malloc__)) ;
# 485 "/usr/include/stdlib.h" 3 4
extern void *realloc (void *__ptr, size_t __size)
             __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) ;




extern void cfree (void *__ptr) ;




# 1 "/usr/include/alloca.h" 1 3 4
# 25 "/usr/include/alloca.h" 3 4
# 1 "/usr/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 26 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) ;





}
# 498 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
             __attribute__ ((__nonnull__ (1))) ;




extern void abort (void) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nonnull__ (1)));






extern "C++" int at_quick_exit (void (*__func) (void))
             __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));
# 536 "/usr/include/stdlib.h" 3 4
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
             __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) __attribute__ ((__noreturn__));







extern void quick_exit (int __status) __attribute__ ((__noreturn__));







extern void _Exit (int __status) __attribute__ ((__noreturn__));






extern char *getenv (__const char *__name) __attribute__ ((__nonnull__ (1))) ;




extern char *__secure_getenv (__const char *__name)
             __attribute__ ((__nonnull__ (1))) ;





extern int putenv (char *__string) __attribute__ ((__nonnull__ (1)));





extern int setenv (__const char *__name, __const char *__value, int __replace)
             __attribute__ ((__nonnull__ (2)));


extern int unsetenv (__const char *__name) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) ;
# 606 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 620 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 630 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 642 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 652 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 663 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 674 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 684 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 694 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 706 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 717 "/usr/include/stdlib.h" 3 4
extern int system (__const char *__command) ;






extern char *canonicalize_file_name (__const char *__name)
             __attribute__ ((__nonnull__ (1))) ;
# 734 "/usr/include/stdlib.h" 3 4
extern char *realpath (__const char *__restrict __name,
         char *__restrict __resolved) ;






typedef int (*__compar_fn_t) (__const void *, __const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (__const void *, __const void *, void *);





extern void *bsearch (__const void *__key, __const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;



extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
             __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
             __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
             __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
             __attribute__ ((__const__)) ;
# 808 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
             __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
             __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
             __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
             __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
             __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
             __attribute__ ((__nonnull__ (3, 4, 5)));







extern int mblen (__const char *__s, size_t __n) ;


extern int mbtowc (wchar_t *__restrict __pwc,
     __const char *__restrict __s, size_t __n) ;


extern int wctomb (char *__s, wchar_t __wchar) ;



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   __const char *__restrict __s, size_t __n) ;

extern size_t wcstombs (char *__restrict __s,
   __const wchar_t *__restrict __pwcs, size_t __n)
            ;
# 885 "/usr/include/stdlib.h" 3 4
extern int rpmatch (__const char *__response) __attribute__ ((__nonnull__ (1))) ;
# 896 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *__const *__restrict __tokens,
        char **__restrict __valuep)
             __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (__const char *__key) __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) ;



extern int unlockpt (int __fd) ;




extern char *ptsname (int __fd) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
             __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
             __attribute__ ((__nonnull__ (1)));
# 964 "/usr/include/stdlib.h" 3 4
}
# 68 "/usr/include/c++/4.5.3/cstdlib" 2 3
# 99 "/usr/include/c++/4.5.3/cstdlib" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;


  inline long
  abs(long __i) { return labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }

}
# 156 "/usr/include/c++/4.5.3/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {


  using ::lldiv_t;





  using ::_Exit;


  inline long long
  abs(long long __x) { return __x >= 0 ? __x : -__x; }


  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 189 "/usr/include/c++/4.5.3/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;

}

namespace std __attribute__ ((__visibility__ ("default"))) {


  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;
  using ::__gnu_cxx::abs;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;

}
# 27 "/home/pipping/Downloads/eigen-eigen-3.0.3/test/main.h" 2
# 1 "/usr/include/c++/4.5.3/cerrno" 1 3
# 41 "/usr/include/c++/4.5.3/cerrno" 3
# 41 "/usr/include/c++/4.5.3/cerrno" 3

# 1 "/usr/include/errno.h" 1 3 4
# 32 "/usr/include/errno.h" 3 4
extern "C" {




# 1 "/usr/include/bits/errno.h" 1 3 4
# 25 "/usr/include/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4



# 1 "/usr/include/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4



# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 5 "/usr/include/asm-generic/errno.h" 2 3 4
# 2 "/usr/include/asm/errno.h" 2 3 4
# 5 "/usr/include/linux/errno.h" 2 3 4
# 26 "/usr/include/bits/errno.h" 2 3 4
# 47 "/usr/include/bits/errno.h" 3 4
extern int *__errno_location (void) __attribute__ ((__const__));
# 37 "/usr/include/errno.h" 2 3 4
# 55 "/usr/include/errno.h" 3 4
extern char *program_invocation_name, *program_invocation_short_name;



}
# 69 "/usr/include/errno.h" 3 4
typedef int error_t;
# 43 "/usr/include/c++/4.5.3/cerrno" 2 3
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/test/main.h" 2
# 1 "/usr/include/c++/4.5.3/ctime" 1 3
# 41 "/usr/include/c++/4.5.3/ctime" 3
# 41 "/usr/include/c++/4.5.3/ctime" 3

# 1 "/usr/include/c++/4.5.3/cstddef" 1 3
# 41 "/usr/include/c++/4.5.3/cstddef" 3
# 41 "/usr/include/c++/4.5.3/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.5.3/cstddef" 2 3
# 43 "/usr/include/c++/4.5.3/ctime" 2 3
# 1 "/usr/include/time.h" 1 3 4
# 30 "/usr/include/time.h" 3 4
extern "C" {








# 1 "/usr/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 39 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/time.h" 1 3 4
# 43 "/usr/include/time.h" 2 3 4
# 133 "/usr/include/time.h" 3 4
struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  __const char *tm_zone;




};
# 161 "/usr/include/time.h" 3 4
struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;
# 183 "/usr/include/time.h" 3 4
extern clock_t clock (void) ;


extern time_t time (time_t *__timer) ;


extern double difftime (time_t __time1, time_t __time0)
             __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) ;





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   __const char *__restrict __format,
   __const struct tm *__restrict __tp) ;





extern char *strptime (__const char *__restrict __s,
         __const char *__restrict __fmt, struct tm *__tp)
            ;







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     __const char *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) ;



extern char *strptime_l (__const char *__restrict __s,
    __const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) ;






extern struct tm *gmtime (__const time_t *__timer) ;



extern struct tm *localtime (__const time_t *__timer) ;





extern struct tm *gmtime_r (__const time_t *__restrict __timer,
       struct tm *__restrict __tp) ;



extern struct tm *localtime_r (__const time_t *__restrict __timer,
          struct tm *__restrict __tp) ;





extern char *asctime (__const struct tm *__tp) ;


extern char *ctime (__const time_t *__timer) ;







extern char *asctime_r (__const struct tm *__restrict __tp,
   char *__restrict __buf) ;


extern char *ctime_r (__const time_t *__restrict __timer,
        char *__restrict __buf) ;




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) ;



extern int daylight;
extern long int timezone;





extern int stime (__const time_t *__when) ;
# 313 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) ;


extern time_t timelocal (struct tm *__tp) ;


extern int dysize (int __year) __attribute__ ((__const__));
# 328 "/usr/include/time.h" 3 4
extern int nanosleep (__const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) ;


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) ;


extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp)
            ;






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       __const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) ;




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) ;


extern int timer_delete (timer_t __timerid) ;


extern int timer_settime (timer_t __timerid, int __flags,
     __const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) ;


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
            ;


extern int timer_getoverrun (timer_t __timerid) ;
# 390 "/usr/include/time.h" 3 4
extern int getdate_err;
# 399 "/usr/include/time.h" 3 4
extern struct tm *getdate (__const char *__string);
# 413 "/usr/include/time.h" 3 4
extern int getdate_r (__const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 44 "/usr/include/c++/4.5.3/ctime" 2 3
# 59 "/usr/include/c++/4.5.3/ctime" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::clock_t;
  using ::time_t;
  using ::tm;

  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;

}
# 29 "/home/pipping/Downloads/eigen-eigen-3.0.3/test/main.h" 2
# 1 "/usr/include/c++/4.5.3/iostream" 1 3
# 37 "/usr/include/c++/4.5.3/iostream" 3
# 37 "/usr/include/c++/4.5.3/iostream" 3


# 1 "/usr/include/c++/4.5.3/ostream" 1 3
# 38 "/usr/include/c++/4.5.3/ostream" 3
# 38 "/usr/include/c++/4.5.3/ostream" 3

# 1 "/usr/include/c++/4.5.3/ios" 1 3
# 37 "/usr/include/c++/4.5.3/ios" 3
# 37 "/usr/include/c++/4.5.3/ios" 3

# 1 "/usr/include/c++/4.5.3/iosfwd" 1 3
# 38 "/usr/include/c++/4.5.3/iosfwd" 3
# 38 "/usr/include/c++/4.5.3/iosfwd" 3


# 1 "/usr/include/c++/4.5.3/bits/stringfwd.h" 1 3
# 39 "/usr/include/c++/4.5.3/bits/stringfwd.h" 3
# 39 "/usr/include/c++/4.5.3/bits/stringfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Alloc>
    class allocator;







  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;

  typedef basic_string<char> string;


  template<> struct char_traits<wchar_t>;

  typedef basic_string<wchar_t> wstring;
# 82 "/usr/include/c++/4.5.3/bits/stringfwd.h" 3
}
# 41 "/usr/include/c++/4.5.3/iosfwd" 2 3
# 1 "/usr/include/c++/4.5.3/bits/postypes.h" 1 3
# 40 "/usr/include/c++/4.5.3/bits/postypes.h" 3
# 40 "/usr/include/c++/4.5.3/bits/postypes.h" 3

# 1 "/usr/include/c++/4.5.3/cwchar" 1 3
# 41 "/usr/include/c++/4.5.3/cwchar" 3
# 41 "/usr/include/c++/4.5.3/cwchar" 3


# 1 "/usr/include/c++/4.5.3/cstddef" 1 3
# 41 "/usr/include/c++/4.5.3/cstddef" 3
# 41 "/usr/include/c++/4.5.3/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.5.3/cstddef" 2 3
# 44 "/usr/include/c++/4.5.3/cwchar" 2 3


# 1 "/usr/include/wchar.h" 1 3 4
# 37 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/stdio.h" 1 3 4
# 45 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;
# 65 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 38 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/bin/../lib/clang/3.0/include/stdarg.h" 1 3 4
# 30 "/usr/bin/../lib/clang/3.0/include/stdarg.h" 3 4
typedef __builtin_va_list va_list;
# 48 "/usr/bin/../lib/clang/3.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 41 "/usr/include/wchar.h" 2 3 4

# 1 "/usr/include/bits/wchar.h" 1 3 4
# 43 "/usr/include/wchar.h" 2 3 4
# 52 "/usr/include/wchar.h" 3 4
# 1 "/usr/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 61 "/usr/bin/../lib/clang/3.0/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 53 "/usr/include/wchar.h" 2 3 4
# 83 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 106 "/usr/include/wchar.h" 3 4
typedef __mbstate_t mbstate_t;
# 129 "/usr/include/wchar.h" 3 4
extern "C" {




struct tm;
# 144 "/usr/include/wchar.h" 3 4
extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) ;

extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
            ;


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) ;

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
            ;


extern int wcscmp (__const wchar_t *__s1, __const wchar_t *__s2)
             __attribute__ ((__pure__));

extern int wcsncmp (__const wchar_t *__s1, __const wchar_t *__s2, size_t __n)
             __attribute__ ((__pure__));




extern int wcscasecmp (__const wchar_t *__s1, __const wchar_t *__s2) ;


extern int wcsncasecmp (__const wchar_t *__s1, __const wchar_t *__s2,
   size_t __n) ;





extern int wcscasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
    __locale_t __loc) ;

extern int wcsncasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
     size_t __n, __locale_t __loc) ;





extern int wcscoll (__const wchar_t *__s1, __const wchar_t *__s2) ;



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         __const wchar_t *__restrict __s2, size_t __n) ;
# 203 "/usr/include/wchar.h" 3 4
extern int wcscoll_l (__const wchar_t *__s1, __const wchar_t *__s2,
        __locale_t __loc) ;




extern size_t wcsxfrm_l (wchar_t *__s1, __const wchar_t *__s2,
    size_t __n, __locale_t __loc) ;


extern wchar_t *wcsdup (__const wchar_t *__s) __attribute__ ((__malloc__));
# 224 "/usr/include/wchar.h" 3 4
extern wchar_t *wcschr (__const wchar_t *__wcs, wchar_t __wc)
             __attribute__ ((__pure__));
# 234 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsrchr (__const wchar_t *__wcs, wchar_t __wc)
             __attribute__ ((__pure__));






extern wchar_t *wcschrnul (__const wchar_t *__s, wchar_t __wc)
             __attribute__ ((__pure__));





extern size_t wcscspn (__const wchar_t *__wcs, __const wchar_t *__reject)
             __attribute__ ((__pure__));


extern size_t wcsspn (__const wchar_t *__wcs, __const wchar_t *__accept)
             __attribute__ ((__pure__));
# 263 "/usr/include/wchar.h" 3 4
extern wchar_t *wcspbrk (__const wchar_t *__wcs, __const wchar_t *__accept)
             __attribute__ ((__pure__));
# 274 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsstr (__const wchar_t *__haystack, __const wchar_t *__needle)
             __attribute__ ((__pure__));



extern wchar_t *wcstok (wchar_t *__restrict __s,
   __const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) ;


extern size_t wcslen (__const wchar_t *__s) __attribute__ ((__pure__));
# 296 "/usr/include/wchar.h" 3 4
extern wchar_t *wcswcs (__const wchar_t *__haystack, __const wchar_t *__needle)
             __attribute__ ((__pure__));





extern size_t wcsnlen (__const wchar_t *__s, size_t __maxlen)
             __attribute__ ((__pure__));
# 317 "/usr/include/wchar.h" 3 4
extern wchar_t *wmemchr (__const wchar_t *__s, wchar_t __c, size_t __n)
             __attribute__ ((__pure__));



extern int wmemcmp (__const wchar_t *__restrict __s1,
      __const wchar_t *__restrict __s2, size_t __n)
             __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    __const wchar_t *__restrict __s2, size_t __n) ;



extern wchar_t *wmemmove (wchar_t *__s1, __const wchar_t *__s2, size_t __n)
            ;


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) ;





extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     __const wchar_t *__restrict __s2, size_t __n)
            ;






extern wint_t btowc (int __c) ;



extern int wctob (wint_t __c) ;



extern int mbsinit (__const mbstate_t *__ps) __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         __const char *__restrict __s, size_t __n,
         mbstate_t *__p) ;


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) ;


extern size_t __mbrlen (__const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) ;
extern size_t mbrlen (__const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) ;
# 406 "/usr/include/wchar.h" 3 4
extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    __const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) ;



extern size_t wcsrtombs (char *__restrict __dst,
    __const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) ;






extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     __const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) ;



extern size_t wcsnrtombs (char *__restrict __dst,
     __const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) ;






extern int wcwidth (wchar_t __c) ;



extern int wcswidth (__const wchar_t *__s, size_t __n) ;






extern double wcstod (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) ;





extern float wcstof (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) ;
extern long double wcstold (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) ;







extern long int wcstol (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) ;



extern unsigned long int wcstoul (__const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
            ;






__extension__
extern long long int wcstoll (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
            ;



__extension__
extern unsigned long long int wcstoull (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) ;






__extension__
extern long long int wcstoq (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
            ;



__extension__
extern unsigned long long int wcstouq (__const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) ;
# 528 "/usr/include/wchar.h" 3 4
extern long int wcstol_l (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     __locale_t __loc) ;

extern unsigned long int wcstoul_l (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, __locale_t __loc) ;

__extension__
extern long long int wcstoll_l (__const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, __locale_t __loc) ;

__extension__
extern unsigned long long int wcstoull_l (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, __locale_t __loc)
            ;

extern double wcstod_l (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, __locale_t __loc)
            ;

extern float wcstof_l (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, __locale_t __loc)
            ;

extern long double wcstold_l (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         __locale_t __loc) ;




extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) ;



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
            ;
# 578 "/usr/include/wchar.h" 3 4
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) ;






extern int fwide (__FILE *__fp, int __mode) ;






extern int fwprintf (__FILE *__restrict __stream,
       __const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (__const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       __const wchar_t *__restrict __format, ...)
                                                                   ;





extern int vfwprintf (__FILE *__restrict __s,
        __const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (__const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        __const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                                   ;






extern int fwscanf (__FILE *__restrict __stream,
      __const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (__const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (__const wchar_t *__restrict __s,
      __const wchar_t *__restrict __format, ...)
                                                                  ;
# 687 "/usr/include/wchar.h" 3 4
extern int vfwscanf (__FILE *__restrict __s,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (__const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (__const wchar_t *__restrict __s,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                                  ;
# 743 "/usr/include/wchar.h" 3 4
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (__const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
# 799 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 825 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 835 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (__const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);







extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   __const wchar_t *__restrict __format,
   __const struct tm *__restrict __tp) ;







extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     __const wchar_t *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) ;
# 889 "/usr/include/wchar.h" 3 4
}
# 47 "/usr/include/c++/4.5.3/cwchar" 2 3
# 64 "/usr/include/c++/4.5.3/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::mbstate_t;

}
# 138 "/usr/include/c++/4.5.3/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;


  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }


}







namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {






  using ::wcstold;
# 257 "/usr/include/c++/4.5.3/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;


}

namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;

}
# 42 "/usr/include/c++/4.5.3/bits/postypes.h" 2 3
# 69 "/usr/include/c++/4.5.3/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 87 "/usr/include/c++/4.5.3/bits/postypes.h" 3
  typedef long streamoff;
# 97 "/usr/include/c++/4.5.3/bits/postypes.h" 3
  typedef ptrdiff_t streamsize;
# 110 "/usr/include/c++/4.5.3/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 132 "/usr/include/c++/4.5.3/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;
# 238 "/usr/include/c++/4.5.3/bits/postypes.h" 3
}
# 42 "/usr/include/c++/4.5.3/iosfwd" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 73 "/usr/include/c++/4.5.3/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;




  typedef basic_ios<char> ios;
  typedef basic_streambuf<char> streambuf;
  typedef basic_istream<char> istream;
  typedef basic_ostream<char> ostream;
  typedef basic_iostream<char> iostream;
  typedef basic_stringbuf<char> stringbuf;
  typedef basic_istringstream<char> istringstream;
  typedef basic_ostringstream<char> ostringstream;
  typedef basic_stringstream<char> stringstream;
  typedef basic_filebuf<char> filebuf;
  typedef basic_ifstream<char> ifstream;
  typedef basic_ofstream<char> ofstream;
  typedef basic_fstream<char> fstream;


  typedef basic_ios<wchar_t> wios;
  typedef basic_streambuf<wchar_t> wstreambuf;
  typedef basic_istream<wchar_t> wistream;
  typedef basic_ostream<wchar_t> wostream;
  typedef basic_iostream<wchar_t> wiostream;
  typedef basic_stringbuf<wchar_t> wstringbuf;
  typedef basic_istringstream<wchar_t> wistringstream;
  typedef basic_ostringstream<wchar_t> wostringstream;
  typedef basic_stringstream<wchar_t> wstringstream;
  typedef basic_filebuf<wchar_t> wfilebuf;
  typedef basic_ifstream<wchar_t> wifstream;
  typedef basic_ofstream<wchar_t> wofstream;
  typedef basic_fstream<wchar_t> wfstream;



}
# 39 "/usr/include/c++/4.5.3/ios" 2 3
# 1 "/usr/include/c++/4.5.3/exception" 1 3
# 35 "/usr/include/c++/4.5.3/exception" 3
# 35 "/usr/include/c++/4.5.3/exception" 3

#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 60 "/usr/include/c++/4.5.3/exception" 3
  class exception
  {
  public:
    exception() { }
    virtual ~exception() ;



    virtual const char* what() const ;
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() { }



    virtual ~bad_exception() ;


    virtual const char* what() const ;
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) ;



  void terminate() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) ;



  void unexpected() __attribute__ ((__noreturn__));
# 117 "/usr/include/c++/4.5.3/exception" 3
  bool uncaught_exception() __attribute__ ((__pure__));


}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 140 "/usr/include/c++/4.5.3/exception" 3
  void __verbose_terminate_handler();

}

}

#pragma GCC visibility pop
# 40 "/usr/include/c++/4.5.3/ios" 2 3
# 1 "/usr/include/c++/4.5.3/bits/char_traits.h" 1 3
# 39 "/usr/include/c++/4.5.3/bits/char_traits.h" 3
# 39 "/usr/include/c++/4.5.3/bits/char_traits.h" 3

# 1 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 1 3
# 61 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 3
# 1 "/usr/include/c++/4.5.3/cstddef" 1 3
# 41 "/usr/include/c++/4.5.3/cstddef" 3
# 41 "/usr/include/c++/4.5.3/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.5.3/cstddef" 2 3
# 62 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.5.3/bits/functexcept.h" 1 3
# 37 "/usr/include/c++/4.5.3/bits/functexcept.h" 3
# 1 "/usr/include/c++/4.5.3/exception_defines.h" 1 3
# 38 "/usr/include/c++/4.5.3/bits/functexcept.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {


  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));

}
# 63 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.5.3/bits/cpp_type_traits.h" 1 3
# 36 "/usr/include/c++/4.5.3/bits/cpp_type_traits.h" 3
# 36 "/usr/include/c++/4.5.3/bits/cpp_type_traits.h" 3
# 68 "/usr/include/c++/4.5.3/bits/cpp_type_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {

  template<typename _Iterator, typename _Container>
    class __normal_iterator;

}

namespace std __attribute__ ((__visibility__ ("default"))) {

  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };




  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 193 "/usr/include/c++/4.5.3/bits/cpp_type_traits.h" 3
  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
# 416 "/usr/include/c++/4.5.3/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    class __is_iterator_helper
    {
      typedef char __one;
      typedef struct { char __arr[2]; } __two;

      template<typename _Up>
        struct _Wrap_type
 { };

      template<typename _Up>
        static __one __test(_Wrap_type<typename _Up::iterator_category>*);

      template<typename _Up>
        static __two __test(...);

    public:
      static const bool __value = (sizeof(__test<_Tp>(0)) == 1
       || __is_pointer<_Tp>::__value);
    };

  template<typename _Tp>
    struct __is_iterator
    {
      enum { __value = __is_iterator_helper<_Tp>::__value };
      typedef typename __truth_type<__value>::__type __type;
    };

}
# 64 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.5.3/ext/type_traits.h" 1 3
# 32 "/usr/include/c++/4.5.3/ext/type_traits.h" 3
# 32 "/usr/include/c++/4.5.3/ext/type_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {


  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };

  template<typename _Tp>
    struct __promote<_Tp, false>
    { typedef _Tp __type; };

  template<typename _Tp, typename _Up>
    struct __promote_2
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;

    public:
      typedef __typeof__(__type1() + __type2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp>
    struct __promote_3
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;
      typedef typename __promote<_Vp>::__type __type3;

    public:
      typedef __typeof__(__type1() + __type2() + __type3()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp>
    struct __promote_4
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;
      typedef typename __promote<_Vp>::__type __type3;
      typedef typename __promote<_Wp>::__type __type4;

    public:
      typedef __typeof__(__type1() + __type2() + __type3() + __type4()) __type;
    };

}
# 65 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.5.3/ext/numeric_traits.h" 1 3
# 32 "/usr/include/c++/4.5.3/ext/numeric_traits.h" 3
# 32 "/usr/include/c++/4.5.3/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 51 "/usr/include/c++/4.5.3/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 96 "/usr/include/c++/4.5.3/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 3010 / 10000);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };

}
# 66 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.5.3/bits/stl_pair.h" 1 3
# 60 "/usr/include/c++/4.5.3/bits/stl_pair.h" 3
# 1 "/usr/include/c++/4.5.3/bits/move.h" 1 3
# 34 "/usr/include/c++/4.5.3/bits/move.h" 3
# 1 "/usr/include/c++/4.5.3/cstddef" 1 3
# 41 "/usr/include/c++/4.5.3/cstddef" 3
# 41 "/usr/include/c++/4.5.3/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.5.3/cstddef" 2 3
# 35 "/usr/include/c++/4.5.3/bits/move.h" 2 3
# 1 "/usr/include/c++/4.5.3/bits/concept_check.h" 1 3
# 33 "/usr/include/c++/4.5.3/bits/concept_check.h" 3
# 33 "/usr/include/c++/4.5.3/bits/concept_check.h" 3
# 36 "/usr/include/c++/4.5.3/bits/move.h" 2 3
# 95 "/usr/include/c++/4.5.3/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 104 "/usr/include/c++/4.5.3/bits/move.h" 3
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
    {



      _Tp __tmp = (__a);
      __a = (__b);
      __b = (__tmp);
    }



  template<typename _Tp, size_t _Nm>
    inline void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }

}
# 61 "/usr/include/c++/4.5.3/bits/stl_pair.h" 2 3






namespace std __attribute__ ((__visibility__ ("default"))) {


  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





      pair()
      : first(), second() { }


      pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
# 113 "/usr/include/c++/4.5.3/bits/stl_pair.h" 3
      template<class _U1, class _U2>
        pair(const pair<_U1, _U2>& __p)
 : first(__p.first),
   second(__p.second) { }
# 149 "/usr/include/c++/4.5.3/bits/stl_pair.h" 3
    };


  template<class _T1, class _T2>
    inline bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
# 211 "/usr/include/c++/4.5.3/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
    { return pair<_T1, _T2>(__x, __y); }
# 257 "/usr/include/c++/4.5.3/bits/stl_pair.h" 3
}
# 67 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.5.3/bits/stl_iterator_base_types.h" 1 3
# 63 "/usr/include/c++/4.5.3/bits/stl_iterator_base_types.h" 3
# 63 "/usr/include/c++/4.5.3/bits/stl_iterator_base_types.h" 3


# 1 "/usr/include/c++/4.5.3/cstddef" 1 3
# 41 "/usr/include/c++/4.5.3/cstddef" 3
# 41 "/usr/include/c++/4.5.3/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.5.3/cstddef" 2 3
# 66 "/usr/include/c++/4.5.3/bits/stl_iterator_base_types.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 84 "/usr/include/c++/4.5.3/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 111 "/usr/include/c++/4.5.3/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 135 "/usr/include/c++/4.5.3/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator>
    struct iterator_traits
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };


  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }



}
# 68 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.5.3/bits/stl_iterator_base_funcs.h" 1 3
# 63 "/usr/include/c++/4.5.3/bits/stl_iterator_base_funcs.h" 3
# 63 "/usr/include/c++/4.5.3/bits/stl_iterator_base_funcs.h" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {



      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {



      return __last - __first;
    }
# 108 "/usr/include/c++/4.5.3/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {


      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {



      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {



      __i += __n;
    }
# 166 "/usr/include/c++/4.5.3/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }

}
# 69 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.5.3/bits/stl_iterator.h" 1 3
# 68 "/usr/include/c++/4.5.3/bits/stl_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 94 "/usr/include/c++/4.5.3/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;







      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }






      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }






      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }






      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 281 "/usr/include/c++/4.5.3/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>







    inline typename reverse_iterator<_IteratorL>::difference_type
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)

    { return __y.base() - __x.base(); }
# 393 "/usr/include/c++/4.5.3/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
# 420 "/usr/include/c++/4.5.3/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_back(__value);
 return *this;
      }
# 443 "/usr/include/c++/4.5.3/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 469 "/usr/include/c++/4.5.3/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 484 "/usr/include/c++/4.5.3/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
# 510 "/usr/include/c++/4.5.3/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_front(__value);
 return *this;
      }
# 533 "/usr/include/c++/4.5.3/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 559 "/usr/include/c++/4.5.3/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 578 "/usr/include/c++/4.5.3/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
# 621 "/usr/include/c++/4.5.3/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }
# 647 "/usr/include/c++/4.5.3/bits/stl_iterator.h" 3
      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 673 "/usr/include/c++/4.5.3/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }



}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 694 "/usr/include/c++/4.5.3/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i)
        : _M_current(__i.base()) { }


      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
      { return _M_current; }
    };
# 792 "/usr/include/c++/4.5.3/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>







    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)

    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }

}
# 70 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/4.5.3/debug/debug.h" 1 3
# 47 "/usr/include/c++/4.5.3/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
# 72 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {




  template<bool _BoolType>
    struct __iter_swap
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          typedef typename iterator_traits<_ForwardIterator1>::value_type
            _ValueType1;
          _ValueType1 __tmp = (*__a);
          *__a = (*__b);
          *__b = (__tmp);
 }
    };

  template<>
    struct __iter_swap<true>
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          swap(*__a, *__b);
        }
    };
# 115 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;
# 134 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 3
      typedef typename iterator_traits<_ForwardIterator1>::reference
 _ReferenceType1;
      typedef typename iterator_traits<_ForwardIterator2>::reference
 _ReferenceType2;
      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
 && __are_same<_ValueType1&, _ReferenceType1>::__value
 && __are_same<_ValueType2&, _ReferenceType2>::__value>::
 iter_swap(__a, __b);
    }
# 156 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {





                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 184 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {



      if (__b < __a)
 return __b;
      return __a;
    }
# 207 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {



      if (__a < __b)
 return __b;
      return __a;
    }
# 230 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 251 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }




  template<typename _Iterator, bool _HasBase>
    struct _Iter_base
    {
      typedef _Iterator iterator_type;
      static iterator_type
      _S_base(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct _Iter_base<_Iterator, true>
    {
      typedef typename _Iterator::iterator_type iterator_type;
      static iterator_type
      _S_base(_Iterator __it)
      { return __it.base(); }
    };



  template<typename _Iterator>
    struct _Niter_base
    : _Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Niter_base<_Iterator>::iterator_type
    __niter_base(_Iterator __it)
    { return std::_Niter_base<_Iterator>::_S_base(__it); }


  template<typename _Iterator>
    struct _Miter_base
    : _Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Miter_base<_Iterator>::iterator_type
    __miter_base(_Iterator __it)
    { return std::_Miter_base<_Iterator>::_S_base(__it); }







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };
# 339 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 3
  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };
# 377 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 3
  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_pod(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
# 462 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {




                                                     ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 514 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 3
  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };
# 542 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 3
  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };
# 572 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 3
  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_pod(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
# 631 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {






                                                     ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 689 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      __builtin_memset(__first, static_cast<unsigned char>(__tmp),
         __last - __first);
    }
# 733 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {



                                                     ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (; __n > 0; --__n, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __n > 0; --__n, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
# 791 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {



      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)
       * (__last1 - __first1));
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = (__is_integer<_ValueType1>::__value
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }


  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 typedef typename iterator_traits<_II1>::iterator_category _Category1;
 typedef typename iterator_traits<_II2>::iterator_category _Category2;
 typedef std::__lc_rai<_Category1, _Category2> __rai_type;

 __last1 = __rai_type::__newlast1(__first1, __last1,
      __first2, __last2);
 for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
      ++__first1, ++__first2)
   {
     if (*__first1 < *__first2)
       return true;
     if (*__first2 < *__first1)
       return false;
   }
 return __first1 == __last1 && __first2 != __last2;
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   const int __result = __builtin_memcmp(__first1, __first2,
      std::min(__len1, __len2));
   return __result != 0 ? __result < 0 : __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }
# 952 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;




                                                                  ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }



  template<typename _Size>
    inline _Size
    __lg(_Size __n)
    {
      _Size __k;
      for (__k = 0; __n != 0; __n >>= 1)
 ++__k;
      return __k - 1;
    }

  inline int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

}

namespace std __attribute__ ((__visibility__ ("default"))) {
# 1028 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {






                                                       ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
# 1060 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {



                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
# 1091 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {

      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;




                                                       ;
                                                       ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
# 1125 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;




                                                       ;
                                                       ;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
# 1165 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {






                                                       ;

      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1202 "/usr/include/c++/4.5.3/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {



                                                       ;

      while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }

}
# 41 "/usr/include/c++/4.5.3/bits/char_traits.h" 2 3

# 1 "/usr/include/c++/4.5.3/cwchar" 1 3
# 41 "/usr/include/c++/4.5.3/cwchar" 3
# 41 "/usr/include/c++/4.5.3/cwchar" 3


# 1 "/usr/include/c++/4.5.3/cstddef" 1 3
# 41 "/usr/include/c++/4.5.3/cstddef" 3
# 41 "/usr/include/c++/4.5.3/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.5.3/cstddef" 2 3
# 44 "/usr/include/c++/4.5.3/cwchar" 2 3


# 1 "/usr/include/wchar.h" 1 3 4
# 47 "/usr/include/c++/4.5.3/cwchar" 2 3
# 43 "/usr/include/c++/4.5.3/bits/char_traits.h" 2 3








namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 63 "/usr/include/c++/4.5.3/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 88 "/usr/include/c++/4.5.3/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }

}

namespace std __attribute__ ((__visibility__ ("default"))) {
# 229 "/usr/include/c++/4.5.3/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return __builtin_memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }



      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static char_type
      to_char_type(const int_type& __c)
      { return char_type(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return int_type(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((0xffffffffu)); }

      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };


}
# 41 "/usr/include/c++/4.5.3/ios" 2 3
# 1 "/usr/include/c++/4.5.3/bits/localefwd.h" 1 3
# 39 "/usr/include/c++/4.5.3/bits/localefwd.h" 3
# 39 "/usr/include/c++/4.5.3/bits/localefwd.h" 3


# 1 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/c++locale.h" 1 3
# 40 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/c++locale.h" 3
# 40 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/c++locale.h" 3

# 1 "/usr/include/c++/4.5.3/clocale" 1 3
# 41 "/usr/include/c++/4.5.3/clocale" 3
# 41 "/usr/include/c++/4.5.3/clocale" 3


# 1 "/usr/include/locale.h" 1 3 4
# 29 "/usr/include/locale.h" 3 4
# 1 "/usr/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/bits/locale.h" 1 3 4
# 27 "/usr/include/bits/locale.h" 3 4
enum
{
  __LC_CTYPE = 0,
  __LC_NUMERIC = 1,
  __LC_TIME = 2,
  __LC_COLLATE = 3,
  __LC_MONETARY = 4,
  __LC_MESSAGES = 5,
  __LC_ALL = 6,
  __LC_PAPER = 7,
  __LC_NAME = 8,
  __LC_ADDRESS = 9,
  __LC_TELEPHONE = 10,
  __LC_MEASUREMENT = 11,
  __LC_IDENTIFICATION = 12
};
# 31 "/usr/include/locale.h" 2 3 4

extern "C" {
# 54 "/usr/include/locale.h" 3 4
struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 121 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, __const char *__locale) ;


extern struct lconv *localeconv (void) ;
# 152 "/usr/include/locale.h" 3 4
extern __locale_t newlocale (int __category_mask, __const char *__locale,
        __locale_t __base) ;
# 187 "/usr/include/locale.h" 3 4
extern __locale_t duplocale (__locale_t __dataset) ;



extern void freelocale (__locale_t __dataset) ;






extern __locale_t uselocale (__locale_t __dataset) ;







}
# 44 "/usr/include/c++/4.5.3/clocale" 2 3








namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::lconv;
  using ::setlocale;
  using ::localeconv;

}
# 42 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/c++locale.h" 2 3
# 1 "/usr/include/c++/4.5.3/cstddef" 1 3
# 41 "/usr/include/c++/4.5.3/cstddef" 3
# 41 "/usr/include/c++/4.5.3/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.5.3/cstddef" 2 3
# 43 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/c++locale.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {

  extern "C" __typeof(uselocale) __uselocale;

}


namespace std __attribute__ ((__visibility__ ("default"))) {

  typedef __locale_t __c_locale;





  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 84 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/c++locale.h" 3
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }

}
# 42 "/usr/include/c++/4.5.3/bits/localefwd.h" 2 3

# 1 "/usr/include/c++/4.5.3/cctype" 1 3
# 41 "/usr/include/c++/4.5.3/cctype" 3
# 41 "/usr/include/c++/4.5.3/cctype" 3


# 1 "/usr/include/ctype.h" 1 3 4
# 30 "/usr/include/ctype.h" 3 4
extern "C" {
# 48 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 81 "/usr/include/ctype.h" 3 4
extern __const unsigned short int **__ctype_b_loc (void)
             __attribute__ ((__const));
extern __const __int32_t **__ctype_tolower_loc (void)
             __attribute__ ((__const));
extern __const __int32_t **__ctype_toupper_loc (void)
             __attribute__ ((__const));
# 102 "/usr/include/ctype.h" 3 4
extern int isalnum (int) ;
extern int isalpha (int) ;
extern int iscntrl (int) ;
extern int isdigit (int) ;
extern int islower (int) ;
extern int isgraph (int) ;
extern int isprint (int) ;
extern int ispunct (int) ;
extern int isspace (int) ;
extern int isupper (int) ;
extern int isxdigit (int) ;



extern int tolower (int __c) ;


extern int toupper (int __c) ;
# 128 "/usr/include/ctype.h" 3 4
extern int isblank (int) ;






extern int isctype (int __c, int __mask) ;






extern int isascii (int __c) ;



extern int toascii (int __c) ;



extern int _toupper (int) ;
extern int _tolower (int) ;
# 247 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) ;
extern int isalpha_l (int, __locale_t) ;
extern int iscntrl_l (int, __locale_t) ;
extern int isdigit_l (int, __locale_t) ;
extern int islower_l (int, __locale_t) ;
extern int isgraph_l (int, __locale_t) ;
extern int isprint_l (int, __locale_t) ;
extern int ispunct_l (int, __locale_t) ;
extern int isspace_l (int, __locale_t) ;
extern int isupper_l (int, __locale_t) ;
extern int isxdigit_l (int, __locale_t) ;

extern int isblank_l (int, __locale_t) ;



extern int __tolower_l (int __c, __locale_t __l) ;
extern int tolower_l (int __c, __locale_t __l) ;


extern int __toupper_l (int __c, __locale_t __l) ;
extern int toupper_l (int __c, __locale_t __l) ;
# 323 "/usr/include/ctype.h" 3 4
}
# 44 "/usr/include/c++/4.5.3/cctype" 2 3
# 63 "/usr/include/c++/4.5.3/cctype" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;

}
# 44 "/usr/include/c++/4.5.3/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 54 "/usr/include/c++/4.5.3/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) ;

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;


  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;


  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;

  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;

  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;


  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;

}
# 42 "/usr/include/c++/4.5.3/ios" 2 3
# 1 "/usr/include/c++/4.5.3/bits/ios_base.h" 1 3
# 39 "/usr/include/c++/4.5.3/bits/ios_base.h" 3
# 39 "/usr/include/c++/4.5.3/bits/ios_base.h" 3

# 1 "/usr/include/c++/4.5.3/ext/atomicity.h" 1 3
# 34 "/usr/include/c++/4.5.3/ext/atomicity.h" 3
# 1 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/gthr.h" 1 3
# 30 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 162 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/gthr.h" 3
# 1 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/gthr-default.h" 1 3
# 41 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/gthr-default.h" 3
# 1 "/usr/include/pthread.h" 1 3 4
# 25 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 30 "/usr/include/sched.h" 3 4
# 1 "/usr/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 31 "/usr/include/sched.h" 2 3 4
# 43 "/usr/include/sched.h" 3 4
# 1 "/usr/include/bits/sched.h" 1 3 4
# 74 "/usr/include/bits/sched.h" 3 4
struct sched_param
  {
    int __sched_priority;
  };

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) ;


extern int unshare (int __flags) ;


extern int sched_getcpu (void) ;


}







struct __sched_param
  {
    int __sched_priority;
  };
# 116 "/usr/include/bits/sched.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 199 "/usr/include/bits/sched.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
         ;
extern cpu_set_t *__sched_cpualloc (size_t __count) ;
extern void __sched_cpufree (cpu_set_t *__set) ;

}
# 44 "/usr/include/sched.h" 2 3 4




extern "C" {


extern int sched_setparam (__pid_t __pid, __const struct sched_param *__param)
            ;


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) ;


extern int sched_setscheduler (__pid_t __pid, int __policy,
          __const struct sched_param *__param) ;


extern int sched_getscheduler (__pid_t __pid) ;


extern int sched_yield (void) ;


extern int sched_get_priority_max (int __algorithm) ;


extern int sched_get_priority_min (int __algorithm) ;


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) ;
# 118 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         __const cpu_set_t *__cpuset) ;


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) ;


}
# 26 "/usr/include/pthread.h" 2 3 4



# 1 "/usr/include/bits/setjmp.h" 1 3 4
# 27 "/usr/include/bits/setjmp.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 30 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 31 "/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 115 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 147 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 182 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 220 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      __const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) ;







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     __const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) ;



extern pthread_t pthread_self (void) __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2) ;







extern int pthread_attr_init (pthread_attr_t *__attr) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
             __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (__const pthread_attr_t *__attr,
     int *__detachstate)
             __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
             __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (__const pthread_attr_t *__attr,
          size_t *__guardsize)
             __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
             __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (__const pthread_attr_t *__restrict
           __attr,
           struct sched_param *__restrict __param)
             __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           __const struct sched_param *__restrict
           __param) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (__const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
             __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
             __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (__const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
             __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
             __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (__const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
             __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
             __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (__const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
             __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
             __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (__const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
             __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
             __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (__const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
             __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     __const cpu_set_t *__cpuset)
             __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (__const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
             __attribute__ ((__nonnull__ (1, 3)));





extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
             __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      __const struct sched_param *__param)
             __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
             __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
            ;




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
             __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, __const char *__name)
             __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) ;


extern int pthread_setconcurrency (int __level) ;







extern int pthread_yield (void) ;




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       __const cpu_set_t *__cpuset)
             __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
             __attribute__ ((__nonnull__ (3)));
# 478 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 490 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 524 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};




class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
# 726 "/usr/include/pthread.h" 3 4
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) ;





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          __const pthread_mutexattr_t *__mutexattr)
             __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
             __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
             __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
             __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        __const struct timespec *__restrict
        __abstime) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
             __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (__const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
             __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
             __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
             __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
             __attribute__ ((__nonnull__ (1)));
# 790 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
             __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
             __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (__const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
             __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
             __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (__const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
             __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
             __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (__const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
             __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
             __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (__const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
             __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
             __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (__const pthread_mutexattr_t *__attr,
     int *__robustness)
             __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (__const pthread_mutexattr_t *__attr,
        int *__robustness)
             __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
             __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
             __attribute__ ((__nonnull__ (1)));
# 872 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    __const pthread_rwlockattr_t *__restrict
    __attr) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
             __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
             __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
          __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           __const struct timespec *__restrict
           __abstime) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
             __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
             __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           __const struct timespec *__restrict
           __abstime) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
             __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
             __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
             __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (__const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
             __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
             __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (__const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
             __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         __const pthread_condattr_t *__restrict
         __cond_attr) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
             __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
             __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
             __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 984 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       __const struct timespec *__restrict
       __abstime) __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
             __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
             __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (__const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
             __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (__const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
             __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
             __attribute__ ((__nonnull__ (1)));
# 1028 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
             __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
             __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
             __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
             __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
             __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     __const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
             __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
             __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
             __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
             __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
             __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (__const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
             __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
             __attribute__ ((__nonnull__ (1)));
# 1095 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
             __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) ;


extern void *pthread_getspecific (pthread_key_t __key) ;


extern int pthread_setspecific (pthread_key_t __key,
    __const void *__pointer) ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
             __attribute__ ((__nonnull__ (2)));
# 1129 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) ;
# 1143 "/usr/include/pthread.h" 3 4
}
# 42 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/gthr-default.h" 2 3
# 1 "/usr/include/unistd.h" 1 3 4
# 28 "/usr/include/unistd.h" 3 4
extern "C" {
# 203 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/bits/posix_opt.h" 1 3 4
# 204 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/bits/environments.h" 1 3 4
# 23 "/usr/include/bits/environments.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 24 "/usr/include/bits/environments.h" 2 3 4
# 208 "/usr/include/unistd.h" 2 3 4
# 227 "/usr/include/unistd.h" 3 4
# 1 "/usr/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 228 "/usr/include/unistd.h" 2 3 4
# 268 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 288 "/usr/include/unistd.h" 3 4
extern int access (__const char *__name, int __type) __attribute__ ((__nonnull__ (1)));




extern int euidaccess (__const char *__name, int __type)
             __attribute__ ((__nonnull__ (1)));


extern int eaccess (__const char *__name, int __type)
             __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, __const char *__file, int __type, int __flag)
             __attribute__ ((__nonnull__ (2))) ;
# 331 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) ;
# 342 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
            ;






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, __const void *__buf, size_t __n) ;
# 373 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, __const void *__buf, size_t __n,
         __off_t __offset) ;
# 401 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, __const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) ;




extern int pipe2 (int __pipedes[2], int __flags) ;
# 429 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) ;
# 441 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
            ;






extern int usleep (__useconds_t __useconds);
# 466 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (__const char *__file, __uid_t __owner, __gid_t __group)
             __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) ;




extern int lchown (__const char *__file, __uid_t __owner, __gid_t __group)
             __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, __const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
             __attribute__ ((__nonnull__ (2))) ;



extern int chdir (__const char *__path) __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) ;
# 508 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) ;





extern char *get_current_dir_name (void) ;







extern char *getwd (char *__buf)
             __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) ;


extern int dup2 (int __fd, int __fd2) ;




extern int dup3 (int __fd, int __fd2, int __flags) ;



extern char **__environ;

extern char **environ;





extern int execve (__const char *__path, char *__const __argv[],
     char *__const __envp[]) __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *__const __argv[], char *__const __envp[])
             __attribute__ ((__nonnull__ (2)));




extern int execv (__const char *__path, char *__const __argv[])
             __attribute__ ((__nonnull__ (1, 2)));



extern int execle (__const char *__path, __const char *__arg, ...)
             __attribute__ ((__nonnull__ (1, 2)));



extern int execl (__const char *__path, __const char *__arg, ...)
             __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (__const char *__file, char *__const __argv[])
             __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (__const char *__file, __const char *__arg, ...)
             __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (__const char *__file, char *__const __argv[],
      char *__const __envp[])
             __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));






# 1 "/usr/include/bits/confname.h" 1 3 4
# 26 "/usr/include/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 607 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (__const char *__path, int __name)
             __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) ;


extern long int sysconf (int __name) ;



extern size_t confstr (int __name, char *__buf, size_t __len) ;




extern __pid_t getpid (void) ;


extern __pid_t getppid (void) ;




extern __pid_t getpgrp (void) ;
# 643 "/usr/include/unistd.h" 3 4
extern __pid_t __getpgid (__pid_t __pid) ;

extern __pid_t getpgid (__pid_t __pid) ;






extern int setpgid (__pid_t __pid, __pid_t __pgid) ;
# 669 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) ;
# 686 "/usr/include/unistd.h" 3 4
extern __pid_t setsid (void) ;



extern __pid_t getsid (__pid_t __pid) ;



extern __uid_t getuid (void) ;


extern __uid_t geteuid (void) ;


extern __gid_t getgid (void) ;


extern __gid_t getegid (void) ;




extern int getgroups (int __size, __gid_t __list[]) ;



extern int group_member (__gid_t __gid) ;






extern int setuid (__uid_t __uid) ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) ;




extern int seteuid (__uid_t __uid) ;






extern int setgid (__gid_t __gid) ;




extern int setregid (__gid_t __rgid, __gid_t __egid) ;




extern int setegid (__gid_t __gid) ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
            ;



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
            ;



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
            ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
            ;






extern __pid_t fork (void) ;







extern __pid_t vfork (void) ;





extern char *ttyname (int __fd) ;



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
             __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) ;





extern int ttyslot (void) ;




extern int link (__const char *__from, __const char *__to)
             __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, __const char *__from, int __tofd,
     __const char *__to, int __flags)
             __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (__const char *__from, __const char *__to)
             __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (__const char *__restrict __path,
    char *__restrict __buf, size_t __len)
             __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (__const char *__from, int __tofd,
        __const char *__to) __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, __const char *__restrict __path,
      char *__restrict __buf, size_t __len)
             __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (__const char *__name) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, __const char *__name, int __flag)
             __attribute__ ((__nonnull__ (2)));



extern int rmdir (__const char *__path) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) ;


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) ;






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (__const char *__name) __attribute__ ((__nonnull__ (1)));
# 890 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/getopt.h" 1 3 4
# 50 "/usr/include/getopt.h" 3 4
extern "C" {
# 59 "/usr/include/getopt.h" 3 4
extern char *optarg;
# 73 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 152 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
              ;
# 187 "/usr/include/getopt.h" 3 4
}
# 891 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nonnull__ (1)));






extern int sethostname (__const char *__name, size_t __len)
             __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) ;





extern int getdomainname (char *__name, size_t __len)
             __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (__const char *__name, size_t __len)
             __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) ;


extern int revoke (__const char *__file) __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
             __attribute__ ((__nonnull__ (1)));





extern int acct (__const char *__name) ;



extern char *getusershell (void) ;
extern void endusershell (void) ;
extern void setusershell (void) ;





extern int daemon (int __nochdir, int __noclose) ;






extern int chroot (__const char *__path) __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (__const char *__prompt) __attribute__ ((__nonnull__ (1)));
# 976 "/usr/include/unistd.h" 3 4
extern int fsync (int __fd);






extern long int gethostid (void);


extern void sync (void) ;





extern int getpagesize (void) __attribute__ ((__const__));




extern int getdtablesize (void) ;
# 1007 "/usr/include/unistd.h" 3 4
extern int truncate (__const char *__file, __off_t __length)
             __attribute__ ((__nonnull__ (1))) ;
# 1019 "/usr/include/unistd.h" 3 4
extern int truncate64 (__const char *__file, __off64_t __length)
             __attribute__ ((__nonnull__ (1))) ;





extern int ftruncate (int __fd, __off_t __length) ;
# 1036 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) ;
# 1047 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) ;





extern void *sbrk (intptr_t __delta) ;
# 1068 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) ;
# 1091 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1101 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1122 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes);







extern char *crypt (__const char *__key, __const char *__salt)
             __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__block, int __edflag) __attribute__ ((__nonnull__ (1)));






extern void swab (__const void *__restrict __from, void *__restrict __to,
    ssize_t __n) __attribute__ ((__nonnull__ (1, 2)));







extern char *ctermid (char *__s) ;
# 1160 "/usr/include/unistd.h" 3 4
}
# 43 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/gthr-default.h" 2 3

typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 118 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once")));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific")));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific")));

static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create")));
static __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join")));
static __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal")));
static __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self")));
static __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach")));
static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel")));
static __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield")));

static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock")));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock")));


static __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock")));


static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock")));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init")));
static __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy")));

static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast")));
static __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal")));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait")));
static __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait")));
static __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy")));


static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create")));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete")));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init")));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype")));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy")));
# 237 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &__gthrw_pthread_cancel;
  return __gthread_active_ptr != 0;
}
# 648 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return __gthrw_pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_pthread_setspecific (__key, __ptr);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (__mutex);
  else
    return 0;
}



static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}



static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (__mutex);
  else
    return 0;
}
# 791 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}



static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}



static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait_recursive (__gthread_cond_t *__cond,
        __gthread_recursive_mutex_t *__mutex,
        const __gthread_time_t *__abs_timeout)
{
  return __gthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_pthread_cond_destroy (__cond);
}
# 163 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/gthr.h" 2 3







#pragma GCC visibility pop
# 35 "/usr/include/c++/4.5.3/ext/atomicity.h" 2 3
# 1 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/atomic_word.h" 1 3
# 32 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 36 "/usr/include/c++/4.5.3/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {






  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __sync_fetch_and_add(__mem, __val); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __sync_fetch_and_add(__mem, __val); }
# 61 "/usr/include/c++/4.5.3/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }

}
# 41 "/usr/include/c++/4.5.3/bits/ios_base.h" 2 3

# 1 "/usr/include/c++/4.5.3/bits/locale_classes.h" 1 3
# 39 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
# 39 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3


# 1 "/usr/include/c++/4.5.3/string" 1 3
# 38 "/usr/include/c++/4.5.3/string" 3
# 38 "/usr/include/c++/4.5.3/string" 3




# 1 "/usr/include/c++/4.5.3/bits/allocator.h" 1 3
# 48 "/usr/include/c++/4.5.3/bits/allocator.h" 3
# 1 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/c++allocator.h" 1 3
# 34 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/c++allocator.h" 3
# 1 "/usr/include/c++/4.5.3/ext/new_allocator.h" 1 3
# 33 "/usr/include/c++/4.5.3/ext/new_allocator.h" 3
# 1 "/usr/include/c++/4.5.3/new" 1 3
# 39 "/usr/include/c++/4.5.3/new" 3
# 39 "/usr/include/c++/4.5.3/new" 3

# 1 "/usr/include/c++/4.5.3/cstddef" 1 3
# 41 "/usr/include/c++/4.5.3/cstddef" 3
# 41 "/usr/include/c++/4.5.3/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.5.3/cstddef" 2 3
# 41 "/usr/include/c++/4.5.3/new" 2 3


#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() { }



    virtual ~bad_alloc() ;


    virtual const char* what() const ;
  };

  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) ;
}
# 92 "/usr/include/c++/4.5.3/new" 3
void* operator new(std::size_t) ;
void* operator new[](std::size_t) ;
void operator delete(void*) ;
void operator delete[](void*) ;
void* operator new(std::size_t, const std::nothrow_t&) ;
void* operator new[](std::size_t, const std::nothrow_t&) ;
void operator delete(void*, const std::nothrow_t&) ;
void operator delete[](void*, const std::nothrow_t&) ;


inline void* operator new(std::size_t, void* __p) { return __p; }
inline void* operator new[](std::size_t, void* __p) { return __p; }


inline void operator delete (void*, void*) { }
inline void operator delete[](void*, void*) { }

}

#pragma GCC visibility pop
# 34 "/usr/include/c++/4.5.3/ext/new_allocator.h" 2 3



namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {

  using std::size_t;
  using std::ptrdiff_t;
# 50 "/usr/include/c++/4.5.3/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

      new_allocator() { }

      new_allocator(const new_allocator&) { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) { }

      ~new_allocator() { }

      pointer
      address(reference __x) const { return &__x; }

      const_pointer
      address(const_reference __x) const { return &__x; }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const
      { return size_t(-1) / sizeof(_Tp); }



      void
      construct(pointer __p, const _Tp& __val)
      { ::new((void *)__p) _Tp(__val); }
# 114 "/usr/include/c++/4.5.3/ext/new_allocator.h" 3
      void
      destroy(pointer __p) { __p->~_Tp(); }
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }

}
# 35 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/c++allocator.h" 2 3
# 49 "/usr/include/c++/4.5.3/bits/allocator.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 59 "/usr/include/c++/4.5.3/bits/allocator.h" 3
  template<typename _Tp>
    class allocator;


  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
    };
# 85 "/usr/include/c++/4.5.3/bits/allocator.h" 3
  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };

      allocator() { }

      allocator(const allocator& __a)
      : __gnu_cxx::new_allocator<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) { }

      ~allocator() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    { return false; }





  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two)
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };
# 204 "/usr/include/c++/4.5.3/bits/allocator.h" 3
}
# 43 "/usr/include/c++/4.5.3/string" 2 3


# 1 "/usr/include/c++/4.5.3/bits/ostream_insert.h" 1 3
# 33 "/usr/include/c++/4.5.3/bits/ostream_insert.h" 3
# 33 "/usr/include/c++/4.5.3/bits/ostream_insert.h" 3


# 1 "/usr/include/c++/4.5.3/cxxabi-forced.h" 1 3
# 33 "/usr/include/c++/4.5.3/cxxabi-forced.h" 3
# 33 "/usr/include/c++/4.5.3/cxxabi-forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() ;


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 36 "/usr/include/c++/4.5.3/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }





  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);



}
# 46 "/usr/include/c++/4.5.3/string" 2 3



# 1 "/usr/include/c++/4.5.3/bits/stl_function.h" 1 3
# 60 "/usr/include/c++/4.5.3/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 99 "/usr/include/c++/4.5.3/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {
      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {
      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;
      typedef _Result result_type;
    };
# 134 "/usr/include/c++/4.5.3/bits/stl_function.h" 3
  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
# 198 "/usr/include/c++/4.5.3/bits/stl_function.h" 3
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
# 262 "/usr/include/c++/4.5.3/bits/stl_function.h" 3
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };
# 345 "/usr/include/c++/4.5.3/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 416 "/usr/include/c++/4.5.3/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st : public unary_function<_Pair,
           typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }
    };

  template<typename _Pair>
    struct _Select2nd : public unary_function<_Pair,
           typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 523 "/usr/include/c++/4.5.3/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }



}



# 1 "/usr/include/c++/4.5.3/backward/binders.h" 1 3
# 60 "/usr/include/c++/4.5.3/backward/binders.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 97 "/usr/include/c++/4.5.3/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } ;


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } ;


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }


}
# 713 "/usr/include/c++/4.5.3/bits/stl_function.h" 2 3
# 50 "/usr/include/c++/4.5.3/string" 2 3


# 1 "/usr/include/c++/4.5.3/bits/basic_string.h" 1 3
# 39 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
# 39 "/usr/include/c++/4.5.3/bits/basic_string.h" 3



# 1 "/usr/include/c++/4.5.3/initializer_list" 1 3
# 33 "/usr/include/c++/4.5.3/initializer_list" 3
# 33 "/usr/include/c++/4.5.3/initializer_list" 3
# 43 "/usr/include/c++/4.5.3/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 103 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _CharT_alloc_type::size_type size_type;
      typedef typename _CharT_alloc_type::difference_type difference_type;
      typedef typename _CharT_alloc_type::reference reference;
      typedef typename _CharT_alloc_type::const_reference const_reference;
      typedef typename _CharT_alloc_type::pointer pointer;
      typedef typename _CharT_alloc_type::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
# 140 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };

      struct _Rep : _Rep_base
      {

 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
# 165 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
 static const size_type _S_max_size;
 static const _CharT _S_terminal;



        static size_type _S_empty_rep_storage[];

        static _Rep&
        _S_empty_rep()
        {



   void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
   return *reinterpret_cast<_Rep*>(__p);
 }

        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }

        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }

        void
 _M_set_leaked()
        { this->_M_refcount = -1; }

        void
 _M_set_sharable()
        { this->_M_refcount = 0; }

 void
 _M_set_length_and_sharable(size_type __n)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {
       this->_M_set_sharable();
       this->_M_length = __n;
       traits_type::assign(this->_M_refdata()[__n], _S_terminal);


     }
 }

 _CharT*
 _M_refdata()
 { return reinterpret_cast<_CharT*>(this + 1); }

 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }


 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);

 void
 _M_dispose(const _Alloc& __a)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
             -1) <= 0)
       _M_destroy(__a);
 }

 void
 _M_destroy(const _Alloc&) ;

 _CharT*
 _M_refcopy()
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
   return _M_refdata();
 }

 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };


      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }

 _CharT* _M_p;
      };

    public:




      static const size_type npos = static_cast<size_type>(-1);

    private:

      mutable _Alloc_hider _M_dataplus;

      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }



      iterator
      _M_ibegin() const
      { return iterator(_M_data()); }

      iterator
      _M_iend() const
      { return iterator(_M_data() + this->size()); }

      void
      _M_leak()
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }


      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2)
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }

    public:







      basic_string()

      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }







      explicit
      basic_string(const _Alloc& __a);






      basic_string(const basic_string& __str);






      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
# 468 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());





      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());






      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());
# 516 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());




      ~basic_string()
      { _M_rep()->_M_dispose(this->get_allocator()); }





      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 549 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 589 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      iterator
      begin()
      {
 _M_leak();
 return iterator(_M_data());
      }





      const_iterator
      begin() const
      { return const_iterator(_M_data()); }





      iterator
      end()
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }





      const_iterator
      end() const
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->begin()); }
# 695 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
    public:



      size_type
      size() const
      { return _M_rep()->_M_length; }



      size_type
      length() const
      { return _M_rep()->_M_length; }


      size_type
      max_size() const
      { return _Rep::_S_max_size; }
# 724 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 737 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }
# 757 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      size_type
      capacity() const
      { return _M_rep()->_M_capacity; }
# 778 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear()
      { _M_mutate(0, this->size(), 0); }





      bool
      empty() const
      { return this->size() == 0; }
# 807 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const
      {
                                       ;
 return _M_data()[__pos];
      }
# 824 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {

                                       ;

                                         ;
 _M_leak();
 return _M_data()[__pos];
      }
# 845 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }
# 864 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }







      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }
# 920 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str);
# 935 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);







      basic_string&
      append(const _CharT* __s, size_type __n);






      basic_string&
      append(const _CharT* __s)
      {
                               ;
 return this->append(__s, traits_type::length(__s));
      }
# 967 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c);
# 989 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __len = 1 + this->size();
 if (__len > this->capacity() || _M_rep()->_M_is_shared())
   this->reserve(__len);
 traits_type::assign(_M_data()[this->size()], __c);
 _M_rep()->_M_set_length_and_sharable(__len);
      }






      basic_string&
      assign(const basic_string& __str);
# 1045 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
# 1061 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n);
# 1073 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
                               ;
 return this->assign(__s, traits_type::length(__s));
      }
# 1089 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 1101 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
# 1129 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
# 1144 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
# 1175 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
# 1197 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
# 1220 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
# 1238 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
                               ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
# 1261 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1278 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      iterator
      insert(iterator __p, _CharT __c)
      {
                                                                 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1302 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_mutate(_M_check(__pos, "basic_string::erase"),
    _M_limit(__pos, __n), size_type(0));
 return *this;
      }
# 1318 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      iterator
      erase(iterator __position)
      {

                               ;
 const size_type __pos = __position - _M_ibegin();
 _M_mutate(__pos, size_type(1), size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1338 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 1357 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1379 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1403 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
# 1422 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
                               ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1445 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1463 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 1481 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {

                          ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
# 1502 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
                               ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 1523 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {

                          ;
 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
# 1545 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {

                            ;
                                             ;
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }



      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 1620 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2);



      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }



      template<class _Integer>
        static _CharT*
        _S_construct_aux(_Integer __beg, _Integer __end,
    const _Alloc& __a, __true_type)
        { return _S_construct_aux_2(static_cast<size_type>(__beg),
        __end, __a); }

      static _CharT*
      _S_construct_aux_2(size_type __req, _CharT __c, const _Alloc& __a)
      { return _S_construct(__req, __c, __a); }

      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }


      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);



      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:
# 1701 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 1711 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      void
      swap(basic_string& __s);
# 1721 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      const _CharT*
      c_str() const
      { return _M_data(); }







      const _CharT*
      data() const
      { return _M_data(); }




      allocator_type
      get_allocator() const
      { return _M_dataplus; }
# 1753 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
# 1766 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      { return this->find(__str.data(), __pos, __str.size()); }
# 1780 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
                               ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 1797 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const;
# 1810 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 1825 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
# 1838 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 1855 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const;
# 1868 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 1883 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1896 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
                               ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 1915 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const
      { return this->find(__c, __pos); }
# 1929 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 1944 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1957 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 1976 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const
      { return this->rfind(__c, __pos); }
# 1990 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 2005 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
# 2019 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
                               ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 2036 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const;
# 2049 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 2065 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
# 2078 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 2095 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const;
# 2110 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2128 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 2158 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2182 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
# 2200 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
# 2223 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 2248 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };
# 2260 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }
# 2331 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 2377 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 2414 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 2451 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 2488 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 2525 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 2562 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
# 2579 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 2597 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 2620 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 2638 "/usr/include/c++/4.5.3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return getline(__is, __str, __is.widen('\n')); }

  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);


}
# 53 "/usr/include/c++/4.5.3/string" 2 3


# 1 "/usr/include/c++/4.5.3/bits/basic_string.tcc" 1 3
# 42 "/usr/include/c++/4.5.3/bits/basic_string.tcc" 3
# 42 "/usr/include/c++/4.5.3/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;



  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 _M_copy(__r->_M_refdata(), __buf, __len);
 try
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {

      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__len);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   __throw_logic_error(("basic_string::_S_construct NULL not valid"));

 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));

 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 try
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__dnew);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {

      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();


      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 _M_assign(__r->_M_refdata(), __n, __c);

      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }
# 239 "/usr/include/c++/4.5.3/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {

   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
                                             ;
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
 return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
 {

   const size_type __pos = __s - _M_data();
   if (__pos >= __n)
     _M_copy(_M_data(), __s, __n);
   else if (__pos)
     _M_move(_M_data(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__n);
   return *this;
 }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_assign(_M_data() + this->size(), __n, __c);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
                                             ;
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     {
       if (_M_disjunct(__s))
  this->reserve(__len);
       else
  {
    const size_type __off = __s - _M_data();
    this->reserve(__len);
    __s = _M_data() + __off;
  }
     }
   _M_copy(_M_data() + this->size(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
 {
   const size_type __len = __size + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data(), __size);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
 {
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
                                              ;
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {

           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     typename basic_string<_CharT, _Traits, _Alloc>::iterator
     basic_string<_CharT, _Traits, _Alloc>::
     erase(iterator __first, iterator __last)
     {

                           ;




       const size_type __size = __last - __first;
       if (__size)
  {
    const size_type __pos = __first - _M_ibegin();
    _M_mutate(__pos, __size, size_type(0));
    _M_rep()->_M_set_leaked();
    return iterator(_M_data() + __pos);
  }
       else
  return __first;
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
                                               ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {

    size_type __off = __s - _M_data();
    __left ? __off : (__off += __n2 - __n1);
    _M_mutate(__pos, __n1, __n2);
    _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
    return *this;
  }
       else
  {

    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a)
    {
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {

      if (_M_rep() == &_S_empty_rep())
 return;

      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
 {

   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);

   if (__pos)
     _M_copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     _M_copy(__r->_M_refdata() + __pos + __len2,
      _M_data() + __pos + __len1, __how_much);

   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {

   _M_move(_M_data() + __pos + __len2,
    _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {

   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }

      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {


      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
# 576 "/usr/include/c++/4.5.3/bits/basic_string.tcc" 3
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);







      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 __capacity = 2 * __old_capacity;




      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);

      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);

   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }



      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;







      __p->_M_set_sharable();
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {

      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);

      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
      size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
                                      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
                                             ;
      if (__n)
 _M_copy(__s, _M_data() + __pos, __n);

      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
                                    ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
                                    ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
                                              ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }





  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);



}
# 56 "/usr/include/c++/4.5.3/string" 2 3
# 42 "/usr/include/c++/4.5.3/bits/locale_classes.h" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {
# 61 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) ;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 97 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 116 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
    locale() ;
# 125 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
    locale(const locale& __other) ;
# 135 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 150 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 163 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 175 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() ;
# 189 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) ;
# 204 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    string
    name() const;
# 223 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const ;







    bool
    operator!=(const locale& __other) const
    { return !(this->operator==(__other)); }
# 251 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 267 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
    static locale
    global(const locale&);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 302 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 6 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) ;

    static void
    _S_initialize();

    static void
    _S_initialize_once() ;

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };
# 336 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 367 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) ;

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);



    static __c_locale
    _S_get_c_locale();

    __attribute__ ((__const__)) static const char*
    _S_get_c_name() ;

  private:
    void
    _M_add_reference() const
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const
    {
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    facet(const facet&);

    facet&
    operator=(const facet&);
  };
# 431 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) ;




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const ;
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) ;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference()
    {
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) ;

   ~_Impl() ;

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    void
    _M_install_cache(const facet*, size_t);
  };
# 574 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) ;
# 591 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc);
# 608 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
  template<typename _CharT>
    class collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 635 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 649 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 666 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 685 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 699 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const ;

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const ;

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 728 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 744 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 757 "/usr/include/c++/4.5.3/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const ;

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const ;


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const ;

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const ;



  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }

    protected:
      virtual
      ~collate_byname() { }
    };

}



# 1 "/usr/include/c++/4.5.3/bits/locale_classes.tcc" 1 3
# 37 "/usr/include/c++/4.5.3/bits/locale_classes.tcc" 3
# 37 "/usr/include/c++/4.5.3/bits/locale_classes.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }


  template<typename _Facet>
    bool
    has_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }

  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }





  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);



}
# 815 "/usr/include/c++/4.5.3/bits/locale_classes.h" 2 3
# 43 "/usr/include/c++/4.5.3/bits/ios_base.h" 2 3
# 53 "/usr/include/c++/4.5.3/bits/ios_base.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {





  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16
    };

  inline _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }

  inline _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16
    };

  inline _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }

  inline _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16
    };

  inline _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }

  inline _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };
# 206 "/usr/include/c++/4.5.3/bits/ios_base.h" 3
  class ios_base
  {
  public:







    class failure : public exception
    {
    public:


      explicit
      failure(const string& __str) ;



      virtual
      ~failure() ;

      virtual const char*
      what() const ;

    private:
      string _M_msg;
    };
# 262 "/usr/include/c++/4.5.3/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 337 "/usr/include/c++/4.5.3/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 368 "/usr/include/c++/4.5.3/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 400 "/usr/include/c++/4.5.3/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;


    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
# 426 "/usr/include/c++/4.5.3/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 443 "/usr/include/c++/4.5.3/bits/ios_base.h" 3
    typedef void (*event_callback) (event, ios_base&, int);
# 455 "/usr/include/c++/4.5.3/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;



    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      { return __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1); }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) ;

    void
    _M_dispose_callbacks(void) ;


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init() ;

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
# 559 "/usr/include/c++/4.5.3/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 575 "/usr/include/c++/4.5.3/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 592 "/usr/include/c++/4.5.3/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
# 618 "/usr/include/c++/4.5.3/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 669 "/usr/include/c++/4.5.3/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 681 "/usr/include/c++/4.5.3/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc) ;
# 692 "/usr/include/c++/4.5.3/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
# 703 "/usr/include/c++/4.5.3/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
# 722 "/usr/include/c++/4.5.3/bits/ios_base.h" 3
    static int
    xalloc() ;
# 738 "/usr/include/c++/4.5.3/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 759 "/usr/include/c++/4.5.3/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 776 "/usr/include/c++/4.5.3/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base() ;



  private:
    ios_base(const ios_base&);

    ios_base&
    operator=(const ios_base&);
  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }

}
# 43 "/usr/include/c++/4.5.3/ios" 2 3
# 1 "/usr/include/c++/4.5.3/streambuf" 1 3
# 37 "/usr/include/c++/4.5.3/streambuf" 3
# 37 "/usr/include/c++/4.5.3/streambuf" 3








namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 113 "/usr/include/c++/4.5.3/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(__streambuf_type*, __streambuf_type*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:
# 179 "/usr/include/c++/4.5.3/streambuf" 3
      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 203 "/usr/include/c++/4.5.3/streambuf" 3
      locale
      pubimbue(const locale &__loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 220 "/usr/include/c++/4.5.3/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 233 "/usr/include/c++/4.5.3/streambuf" 3
      __streambuf_type*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }

      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }

      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }

      int
      pubsync() { return this->sync(); }
# 260 "/usr/include/c++/4.5.3/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 274 "/usr/include/c++/4.5.3/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 292 "/usr/include/c++/4.5.3/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 314 "/usr/include/c++/4.5.3/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 333 "/usr/include/c++/4.5.3/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 348 "/usr/include/c++/4.5.3/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 373 "/usr/include/c++/4.5.3/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 400 "/usr/include/c++/4.5.3/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 426 "/usr/include/c++/4.5.3/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 440 "/usr/include/c++/4.5.3/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 458 "/usr/include/c++/4.5.3/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 474 "/usr/include/c++/4.5.3/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 485 "/usr/include/c++/4.5.3/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 505 "/usr/include/c++/4.5.3/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 521 "/usr/include/c++/4.5.3/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 531 "/usr/include/c++/4.5.3/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 552 "/usr/include/c++/4.5.3/streambuf" 3
      virtual void
      imbue(const locale&)
      { }
# 567 "/usr/include/c++/4.5.3/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 578 "/usr/include/c++/4.5.3/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 590 "/usr/include/c++/4.5.3/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 603 "/usr/include/c++/4.5.3/streambuf" 3
      virtual int
      sync() { return 0; }
# 625 "/usr/include/c++/4.5.3/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 641 "/usr/include/c++/4.5.3/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 663 "/usr/include/c++/4.5.3/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 676 "/usr/include/c++/4.5.3/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 700 "/usr/include/c++/4.5.3/streambuf" 3
      virtual int_type
      pbackfail(int_type = traits_type::eof())
      { return traits_type::eof(); }
# 718 "/usr/include/c++/4.5.3/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 744 "/usr/include/c++/4.5.3/streambuf" 3
      virtual int_type
      overflow(int_type = traits_type::eof())
      { return traits_type::eof(); }



    public:
# 759 "/usr/include/c++/4.5.3/streambuf" 3
      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }


    private:


      basic_streambuf(const __streambuf_type& __sb)
      : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur),
      _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg),
      _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur),
      _M_buf_locale(__sb._M_buf_locale)
      { }

      __streambuf_type&
      operator=(const __streambuf_type&) { return *this; };
    };


  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);


}



# 1 "/usr/include/c++/4.5.3/bits/streambuf.tcc" 1 3
# 38 "/usr/include/c++/4.5.3/bits/streambuf.tcc" 3
# 38 "/usr/include/c++/4.5.3/bits/streambuf.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }





  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);



}
# 799 "/usr/include/c++/4.5.3/streambuf" 2 3
# 44 "/usr/include/c++/4.5.3/ios" 2 3
# 1 "/usr/include/c++/4.5.3/bits/basic_ios.h" 1 3
# 35 "/usr/include/c++/4.5.3/bits/basic_ios.h" 3
# 35 "/usr/include/c++/4.5.3/bits/basic_ios.h" 3



# 1 "/usr/include/c++/4.5.3/bits/locale_facets.h" 1 3
# 39 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
# 39 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3

# 1 "/usr/include/c++/4.5.3/cwctype" 1 3
# 41 "/usr/include/c++/4.5.3/cwctype" 3
# 41 "/usr/include/c++/4.5.3/cwctype" 3




# 1 "/usr/include/wctype.h" 1 3 4
# 34 "/usr/include/wctype.h" 3 4
# 1 "/usr/include/wchar.h" 1 3 4
# 35 "/usr/include/wctype.h" 2 3 4
# 53 "/usr/include/wctype.h" 3 4
typedef unsigned long int wctype_t;
# 72 "/usr/include/wctype.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};



extern "C" {
# 112 "/usr/include/wctype.h" 3 4
extern int iswalnum (wint_t __wc) ;





extern int iswalpha (wint_t __wc) ;


extern int iswcntrl (wint_t __wc) ;



extern int iswdigit (wint_t __wc) ;



extern int iswgraph (wint_t __wc) ;




extern int iswlower (wint_t __wc) ;


extern int iswprint (wint_t __wc) ;




extern int iswpunct (wint_t __wc) ;




extern int iswspace (wint_t __wc) ;




extern int iswupper (wint_t __wc) ;




extern int iswxdigit (wint_t __wc) ;





extern int iswblank (wint_t __wc) ;
# 172 "/usr/include/wctype.h" 3 4
extern wctype_t wctype (__const char *__property) ;



extern int iswctype (wint_t __wc, wctype_t __desc) ;
# 187 "/usr/include/wctype.h" 3 4
typedef __const __int32_t *wctrans_t;







extern wint_t towlower (wint_t __wc) ;


extern wint_t towupper (wint_t __wc) ;


}
# 214 "/usr/include/wctype.h" 3 4
extern "C" {




extern wctrans_t wctrans (__const char *__property) ;


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) ;
# 231 "/usr/include/wctype.h" 3 4
extern int iswalnum_l (wint_t __wc, __locale_t __locale) ;





extern int iswalpha_l (wint_t __wc, __locale_t __locale) ;


extern int iswcntrl_l (wint_t __wc, __locale_t __locale) ;



extern int iswdigit_l (wint_t __wc, __locale_t __locale) ;



extern int iswgraph_l (wint_t __wc, __locale_t __locale) ;




extern int iswlower_l (wint_t __wc, __locale_t __locale) ;


extern int iswprint_l (wint_t __wc, __locale_t __locale) ;




extern int iswpunct_l (wint_t __wc, __locale_t __locale) ;




extern int iswspace_l (wint_t __wc, __locale_t __locale) ;




extern int iswupper_l (wint_t __wc, __locale_t __locale) ;




extern int iswxdigit_l (wint_t __wc, __locale_t __locale) ;




extern int iswblank_l (wint_t __wc, __locale_t __locale) ;



extern wctype_t wctype_l (__const char *__property, __locale_t __locale)
            ;



extern int iswctype_l (wint_t __wc, wctype_t __desc, __locale_t __locale)
            ;







extern wint_t towlower_l (wint_t __wc, __locale_t __locale) ;


extern wint_t towupper_l (wint_t __wc, __locale_t __locale) ;



extern wctrans_t wctrans_l (__const char *__property, __locale_t __locale)
            ;


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      __locale_t __locale) ;



}
# 46 "/usr/include/c++/4.5.3/cwctype" 2 3
# 75 "/usr/include/c++/4.5.3/cwctype" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;

}
# 41 "/usr/include/c++/4.5.3/bits/locale_facets.h" 2 3
# 1 "/usr/include/c++/4.5.3/cctype" 1 3
# 41 "/usr/include/c++/4.5.3/cctype" 3
# 41 "/usr/include/c++/4.5.3/cctype" 3
# 42 "/usr/include/c++/4.5.3/bits/locale_facets.h" 2 3
# 1 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/ctype_base.h" 1 3
# 37 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/ctype_base.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {


  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalpha | _ISdigit;
  };

}
# 43 "/usr/include/c++/4.5.3/bits/locale_facets.h" 2 3






# 1 "/usr/include/c++/4.5.3/bits/streambuf_iterator.h" 1 3
# 35 "/usr/include/c++/4.5.3/bits/streambuf_iterator.h" 3
# 35 "/usr/include/c++/4.5.3/bits/streambuf_iterator.h" 3




namespace std __attribute__ ((__visibility__ ("default"))) {
# 48 "/usr/include/c++/4.5.3/bits/streambuf_iterator.h" 3
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*, _CharT&>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

    private:







      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;

    public:

      istreambuf_iterator()
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(istream_type& __s)
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s)
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }


      istreambuf_iterator&
      operator++()
      {


                        ;
 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {


                        ;

 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }

      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s)
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s)
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }



}
# 50 "/usr/include/c++/4.5.3/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 63 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) ;


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) ;

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) ;

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) ;



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 141 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 159 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 176 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 192 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 208 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 222 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 237 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 251 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 266 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 283 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 302 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 321 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 343 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char *__to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 368 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 387 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 406 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 425 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 443 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const = 0;
# 460 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 476 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const = 0;
# 493 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 512 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const = 0;
# 533 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi,
        char_type* __dest) const = 0;
# 555 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const = 0;
# 579 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const = 0;
    };
# 602 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 671 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 708 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 721 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 734 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 749 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 763 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 777 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 792 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 809 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 825 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 842 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 862 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 889 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 920 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 953 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char *__to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const
      { return _M_table; }


      static const mask*
      classic_table() ;
    protected:







      virtual
      ~ctype();
# 1002 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
# 1019 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1035 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
# 1052 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1072 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1095 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const
      {
 __builtin_memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }
# 1121 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char) const
      { return __c; }
# 1147 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char, char* __dest) const
      {
 __builtin_memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
# 1172 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1205 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1216 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const ;


      virtual
      ~ctype();
# 1240 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1259 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1277 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1295 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1312 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
# 1329 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1345 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
# 1362 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1382 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const;
# 1404 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;
# 1427 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const;
# 1453 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;


      void
      _M_initialize_ctype() ;
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };


}



# 1 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/ctype_inline.h" 1 3
# 37 "/usr/include/c++/4.5.3//x86_64-pc-linux-gnu/bits/ctype_inline.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }

}
# 1509 "/usr/include/c++/4.5.3/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {


  class __num_base
  {
  public:


    enum
      {
        _S_ominus,
        _S_oplus,
        _S_ox,
        _S_oX,
        _S_odigits,
        _S_odigits_end = _S_odigits + 16,
        _S_oudigits = _S_odigits_end,
        _S_oudigits_end = _S_oudigits + 16,
        _S_oe = _S_odigits + 14,
        _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) ;
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(__null), _M_grouping_size(0), _M_use_grouping(false),
      _M_truename(__null), _M_truename_size(0), _M_falsename(__null),
      _M_falsename_size(0), _M_decimal_point(_CharT()),
      _M_thousands_sep(_CharT()), _M_allocated(false)
      { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }
# 1634 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0) : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(); }
# 1671 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1685 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(__cloc); }
# 1699 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1712 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1743 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1756 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1769 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1786 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1798 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1811 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1824 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1837 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = __null);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~numpunct_byname() { }
    };
# 1907 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1928 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1954 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 1990 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2049 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2091 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
        iter_type
        _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
        _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
        _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2162 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      void*&) const;
# 2227 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2245 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2266 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2284 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2326 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __f, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2389 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, double __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2414 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __f, __fill, __v); }

    protected:
      template<typename _ValueT>
        iter_type
        _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
        iter_type
        _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { };
# 2462 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, double __v) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long double __v) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, const void* __v) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;
# 2520 "/usr/include/c++/4.5.3/bits/locale_facets.h" 3
  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }


  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }

}



# 1 "/usr/include/c++/4.5.3/bits/locale_facets.tcc" 1 3
# 35 "/usr/include/c++/4.5.3/bits/locale_facets.tcc" 3
# 35 "/usr/include/c++/4.5.3/bits/locale_facets.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {



  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = __null;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      try
 {
   _M_grouping_size = __np.grouping().size();
   __grouping = new char[_M_grouping_size];
   __np.grouping().copy(__grouping, _M_grouping_size);
   _M_grouping = __grouping;
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(_M_grouping[0]) > 0
        && (_M_grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   _M_truename_size = __np.truename().size();
   __truename = new _CharT[_M_truename_size];
   __np.truename().copy(__truename, _M_truename_size);
   _M_truename = __truename;

   _M_falsename_size = __np.falsename().size();
   __falsename = new _CharT[_M_falsename_size];
   __np.falsename().copy(__falsename, _M_falsename_size);
   _M_falsename = __falsename;

   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
   throw;
 }
    }
# 135 "/usr/include/c++/4.5.3/bits/locale_facets.tcc" 3
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) ;



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
   ? -__gnu_cxx::__numeric_traits<_ValueT>::__min
   : __gnu_cxx::__numeric_traits<_ValueT>::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative
  && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
     else
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
# 729 "/usr/include/c++/4.5.3/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 965 "/usr/include/c++/4.5.3/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);




 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
          __fbuf, __prec, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
       __fbuf, __prec, __v);
   }
# 1026 "/usr/include/c++/4.5.3/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1151 "/usr/include/c++/4.5.3/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }
# 1188 "/usr/include/c++/4.5.3/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }





  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class numpunct<wchar_t>;
  extern template class numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);



}
# 2601 "/usr/include/c++/4.5.3/bits/locale_facets.h" 2 3
# 39 "/usr/include/c++/4.5.3/bits/basic_ios.h" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
# 60 "/usr/include/c++/4.5.3/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:







      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }

      bool
      operator!() const
      { return this->fail(); }
# 125 "/usr/include/c++/4.5.3/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 136 "/usr/include/c++/4.5.3/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 189 "/usr/include/c++/4.5.3/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 210 "/usr/include/c++/4.5.3/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 245 "/usr/include/c++/4.5.3/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 283 "/usr/include/c++/4.5.3/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 295 "/usr/include/c++/4.5.3/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 335 "/usr/include/c++/4.5.3/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 349 "/usr/include/c++/4.5.3/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 378 "/usr/include/c++/4.5.3/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 398 "/usr/include/c++/4.5.3/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 418 "/usr/include/c++/4.5.3/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
# 437 "/usr/include/c++/4.5.3/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);

      void
      _M_cache_locale(const locale& __loc);
    };

}



# 1 "/usr/include/c++/4.5.3/bits/basic_ios.tcc" 1 3
# 34 "/usr/include/c++/4.5.3/bits/basic_ios.tcc" 3
# 34 "/usr/include/c++/4.5.3/bits/basic_ios.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 144 "/usr/include/c++/4.5.3/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }





  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;



}
# 471 "/usr/include/c++/4.5.3/bits/basic_ios.h" 2 3
# 45 "/usr/include/c++/4.5.3/ios" 2 3
# 40 "/usr/include/c++/4.5.3/ostream" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {
# 53 "/usr/include/c++/4.5.3/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 80 "/usr/include/c++/4.5.3/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 106 "/usr/include/c++/4.5.3/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 163 "/usr/include/c++/4.5.3/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }


      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
# 248 "/usr/include/c++/4.5.3/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 281 "/usr/include/c++/4.5.3/ostream" 3
      __ostream_type&
      put(char_type __c);


      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 309 "/usr/include/c++/4.5.3/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 322 "/usr/include/c++/4.5.3/ostream" 3
      __ostream_type&
      flush();
# 333 "/usr/include/c++/4.5.3/ostream" 3
      pos_type
      tellp();
# 344 "/usr/include/c++/4.5.3/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 356 "/usr/include/c++/4.5.3/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }

      template<typename _ValueT>
        __ostream_type&
        _M_insert(_ValueT __v);
    };
# 375 "/usr/include/c++/4.5.3/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 394 "/usr/include/c++/4.5.3/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
# 404 "/usr/include/c++/4.5.3/ostream" 3
      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
# 425 "/usr/include/c++/4.5.3/ostream" 3
      operator bool() const
      { return _M_ok; }
    };
# 446 "/usr/include/c++/4.5.3/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 488 "/usr/include/c++/4.5.3/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 538 "/usr/include/c++/4.5.3/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }







  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
# 582 "/usr/include/c++/4.5.3/ostream" 3
}



# 1 "/usr/include/c++/4.5.3/bits/ostream.tcc" 1 3
# 39 "/usr/include/c++/4.5.3/bits/ostream.tcc" 3
# 39 "/usr/include/c++/4.5.3/bits/ostream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }





  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);



}
# 586 "/usr/include/c++/4.5.3/ostream" 2 3
# 40 "/usr/include/c++/4.5.3/iostream" 2 3
# 1 "/usr/include/c++/4.5.3/istream" 1 3
# 38 "/usr/include/c++/4.5.3/istream" 3
# 38 "/usr/include/c++/4.5.3/istream" 3




namespace std __attribute__ ((__visibility__ ("default"))) {
# 53 "/usr/include/c++/4.5.3/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:
# 89 "/usr/include/c++/4.5.3/istream" 3
      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 118 "/usr/include/c++/4.5.3/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 165 "/usr/include/c++/4.5.3/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 237 "/usr/include/c++/4.5.3/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 247 "/usr/include/c++/4.5.3/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 279 "/usr/include/c++/4.5.3/istream" 3
      int_type
      get();
# 293 "/usr/include/c++/4.5.3/istream" 3
      __istream_type&
      get(char_type& __c);
# 320 "/usr/include/c++/4.5.3/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 331 "/usr/include/c++/4.5.3/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 354 "/usr/include/c++/4.5.3/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 364 "/usr/include/c++/4.5.3/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 393 "/usr/include/c++/4.5.3/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 404 "/usr/include/c++/4.5.3/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 428 "/usr/include/c++/4.5.3/istream" 3
      __istream_type&
      ignore();

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore(streamsize __n, int_type __delim);
# 445 "/usr/include/c++/4.5.3/istream" 3
      int_type
      peek();
# 463 "/usr/include/c++/4.5.3/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 482 "/usr/include/c++/4.5.3/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 498 "/usr/include/c++/4.5.3/istream" 3
      __istream_type&
      putback(char_type __c);
# 513 "/usr/include/c++/4.5.3/istream" 3
      __istream_type&
      unget();
# 531 "/usr/include/c++/4.5.3/istream" 3
      int
      sync();
# 545 "/usr/include/c++/4.5.3/istream" 3
      pos_type
      tellg();
# 560 "/usr/include/c++/4.5.3/istream" 3
      __istream_type&
      seekg(pos_type);
# 576 "/usr/include/c++/4.5.3/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }

      template<typename _ValueT>
        __istream_type&
        _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 631 "/usr/include/c++/4.5.3/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {

      bool _M_ok;

    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 667 "/usr/include/c++/4.5.3/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 680 "/usr/include/c++/4.5.3/istream" 3
      operator bool() const
      { return _M_ok; }
    };
# 697 "/usr/include/c++/4.5.3/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 739 "/usr/include/c++/4.5.3/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 767 "/usr/include/c++/4.5.3/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }
    };
# 828 "/usr/include/c++/4.5.3/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);
# 850 "/usr/include/c++/4.5.3/istream" 3
}



# 1 "/usr/include/c++/4.5.3/bits/istream.tcc" 1 3
# 39 "/usr/include/c++/4.5.3/bits/istream.tcc" 3
# 39 "/usr/include/c++/4.5.3/bits/istream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && bool(__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();




       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 512 "/usr/include/c++/4.5.3/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
           ios_base::in);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {


      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {

       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::in);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {


      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {

       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::in);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }





  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;



}
# 854 "/usr/include/c++/4.5.3/istream" 2 3
# 41 "/usr/include/c++/4.5.3/iostream" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 58 "/usr/include/c++/4.5.3/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;

}
# 30 "/home/pipping/Downloads/eigen-eigen-3.0.3/test/main.h" 2

# 1 "/usr/include/c++/4.5.3/vector" 1 3
# 59 "/usr/include/c++/4.5.3/vector" 3
# 59 "/usr/include/c++/4.5.3/vector" 3



# 1 "/usr/include/c++/4.5.3/bits/stl_construct.h" 1 3
# 63 "/usr/include/c++/4.5.3/bits/stl_construct.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {





  template<typename _T1, typename _T2>
    inline void




    _Construct(_T1* __p, const _T2& __value)

    {


      ::new(static_cast<void*>(__p)) _T1((__value));
    }




  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(&*__first);
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }







  template <typename _Tp> class allocator;

  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      for (; __first != __last; ++__first)
 __alloc.destroy(&*__first);
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }

}
# 63 "/usr/include/c++/4.5.3/vector" 2 3
# 1 "/usr/include/c++/4.5.3/bits/stl_uninitialized.h" 1 3
# 60 "/usr/include/c++/4.5.3/bits/stl_uninitialized.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<bool>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        uninitialized_copy(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++__first, ++__cur)
  std::_Construct(&*__cur, *__first);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__result, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        uninitialized_copy(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 104 "/usr/include/c++/4.5.3/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;

      return std::__uninitialized_copy<(__is_pod(_ValueType1)
     && __is_pod(_ValueType2))>::
 uninitialized_copy(__first, __last, __result);
    }


  template<bool>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        uninitialized_fill(_ForwardIterator __first,
      _ForwardIterator __last, const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(&*__cur, __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        uninitialized_fill(_ForwardIterator __first,
      _ForwardIterator __last, const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 161 "/usr/include/c++/4.5.3/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill<__is_pod(_ValueType)>::
 uninitialized_fill(__first, __last, __x);
    }


  template<bool>
    struct __uninitialized_construct_range_dispatch
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __ucr(_ForwardIterator __first, _ForwardIterator __last,
       _Tp& __value)
        {
   if(__first == __last)
     return;

   _ForwardIterator __cur = __first;
   try
     {
       std::_Construct(&*__first, (__value));
       _ForwardIterator __prev = __cur;
       ++__cur;
       for(; __cur != __last; ++__cur, ++__prev)
  std::_Construct(&*__cur, (*__prev));
       __value = (*__prev);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_construct_range_dispatch<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __ucr(_ForwardIterator, _ForwardIterator, _Tp&) { }
    };
# 221 "/usr/include/c++/4.5.3/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_construct_range(_ForwardIterator __first,
        _ForwardIterator __last,
        _Tp& __value)
    {
      typedef typename std::iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_construct_range_dispatch<
        __has_trivial_constructor(_ValueType)>::
   __ucr(__first, __last, __value);
    }


  template<bool>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        uninitialized_fill_n(_ForwardIterator __first, _Size __n,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(&*__cur, __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        uninitialized_fill_n(_ForwardIterator __first, _Size __n,
        const _Tp& __x)
        { std::fill_n(__first, __n, __x); }
    };
# 277 "/usr/include/c++/4.5.3/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill_n<__is_pod(_ValueType)>::
 uninitialized_fill_n(__first, __n, __x);
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __first != __last; ++__first, ++__cur)
     __alloc.construct(&*__cur, *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a((__first),
      (__last),
      __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __cur != __last; ++__cur)
     __alloc.construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __n > 0; --__n, ++__cur)
     __alloc.construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill_n(__first, __n, __x); }
# 391 "/usr/include/c++/4.5.3/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }
# 537 "/usr/include/c++/4.5.3/bits/stl_uninitialized.h" 3
}
# 64 "/usr/include/c++/4.5.3/vector" 2 3
# 1 "/usr/include/c++/4.5.3/bits/stl_vector.h" 1 3
# 65 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {


  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _Vector_impl
      : public _Tp_alloc_type
      {
 typename _Tp_alloc_type::pointer _M_start;
 typename _Tp_alloc_type::pointer _M_finish;
 typename _Tp_alloc_type::pointer _M_end_of_storage;

 _Vector_impl()
 : _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }

 _Vector_impl(_Tp_alloc_type const& __a)
 : _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base()
      : _M_impl() { }

      _Vector_base(const allocator_type& __a)
      : _M_impl(__a) { }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
# 131 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      typename _Tp_alloc_type::pointer
      _M_allocate(size_t __n)
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(typename _Tp_alloc_type::pointer __p, size_t __n)
      {
 if (__p)
   _M_impl.deallocate(__p, __n);
      }
    };
# 169 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;



      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:





      vector()
      : _Base() { }





      explicit
      vector(const allocator_type& __a)
      : _Base(__a) { }
# 226 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const value_type& __value = value_type(),
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_fill_initialize(__n, __value); }
# 241 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(), __x._M_get_Tp_allocator())
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 296 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
      template<typename _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }







      ~vector()
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator()); }
# 324 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 374 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 390 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }
# 417 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
      using _Base::get_allocator;







      iterator
      begin()
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end()
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }
# 532 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
      size_type
      size() const
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const
      { return _M_get_Tp_allocator().max_size(); }
# 552 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
 if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
 else
   insert(end(), __new_size - size(), __x);
      }
# 572 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
      size_type
      capacity() const
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const
      { return begin() == end(); }
# 602 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 617 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
      reference
      operator[](size_type __n)
      { return *(this->_M_impl._M_start + __n); }
# 632 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const
      { return *(this->_M_impl._M_start + __n); }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("vector::_M_range_check"));
      }

    public:
# 657 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 675 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      { return *(end() - 1); }





      const_reference
      back() const
      { return *(end() - 1); }
# 721 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
      pointer
      data()
      { return pointer(this->_M_impl._M_start); }

      const_pointer
      data() const
      { return const_pointer(this->_M_impl._M_start); }
# 740 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     this->_M_impl.construct(this->_M_impl._M_finish, __x);
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(end(), __x);
      }
# 771 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
      void
      pop_back()
      {
 --this->_M_impl._M_finish;
 this->_M_impl.destroy(this->_M_impl._M_finish);
      }
# 807 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 857 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 875 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 900 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
      iterator
      erase(iterator __position);
# 921 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 933 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
      void
      swap(vector& __x)
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_end_of_storage,
    __x._M_impl._M_end_of_storage);



 std::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
          __x._M_get_Tp_allocator());
      }







      void
      clear()
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
        {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }
# 988 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
   this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
   this->_M_impl._M_end_of_storage =
     this->_M_impl._M_start + static_cast<size_type>(__n);
   _M_fill_initialize(static_cast<size_type>(__n), __value);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
       _InputIterator __last, std::input_iterator_tag)
        {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag)
        {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
          _M_get_Tp_allocator());
 this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
      }
# 1052 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);
# 1092 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
        { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_insert(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);



      void
      _M_insert_aux(iterator __position, const value_type& __x);







      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }





      void
      _M_erase_at_end(pointer __pos)
      {
 std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
 this->_M_impl._M_finish = __pos;
      }
    };
# 1170 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 1187 "/usr/include/c++/4.5.3/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    { __x.swap(__y); }

}
# 65 "/usr/include/c++/4.5.3/vector" 2 3
# 1 "/usr/include/c++/4.5.3/bits/stl_bvector.h" 1 3
# 62 "/usr/include/c++/4.5.3/bits/stl_bvector.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() : _M_p(0), _M_mask(0) { }

    operator bool() const
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x)
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x)
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip()
    { *_M_p ^= _M_mask; }
  };

  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
  {
    for (; __first != __last; ++__first)
      *__first = __x;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
 __fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
 __fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      __fill_bvector(__first, __last, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename _Alloc::template rebind<_Bit_type>::other
        _Bit_alloc_type;

      struct _Bvector_impl
      : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_type* _M_end_of_storage;

 _Bvector_impl()
 : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }

 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator()
      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Bit_allocator()); }

      _Bvector_base()
      : _M_impl() { }

      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }
# 429 "/usr/include/c++/4.5.3/bits/stl_bvector.h" 3
      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_type*
      _M_allocate(size_t __n)
      { return _M_impl.allocate((__n + int(_S_word_bit) - 1)
    / int(_S_word_bit)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   _M_impl.deallocate(_M_impl._M_start._M_p,
        _M_impl._M_end_of_storage - _M_impl._M_start._M_p);
      }
    };

}




namespace std __attribute__ ((__visibility__ ("default"))) {
# 473 "/usr/include/c++/4.5.3/bits/stl_bvector.h" 3
template<typename _Alloc>
  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
  {
    typedef _Bvector_base<_Alloc> _Base;





  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;
    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef _Alloc allocator_type;

    allocator_type get_allocator() const
    { return _Base::get_allocator(); }

  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_M_get_Bit_allocator;

  public:
    vector()
    : _Base() { }

    explicit
    vector(const allocator_type& __a)
    : _Base(__a) { }

    explicit
    vector(size_type __n, const bool& __value = bool(),
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage,
  __value ? ~0 : 0);
    }

    vector(const vector& __x)
    : _Base(__x._M_get_Bit_allocator())
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }
# 542 "/usr/include/c++/4.5.3/bits/stl_bvector.h" 3
    template<typename _InputIterator>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_initialize_dispatch(__first, __last, _Integral());
      }

    ~vector() { }

    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;
      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
      begin());
      return *this;
    }
# 591 "/usr/include/c++/4.5.3/bits/stl_bvector.h" 3
    void
    assign(size_type __n, const bool& __x)
    { _M_fill_assign(__n, __x); }

    template<typename _InputIterator>
      void
      assign(_InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_assign_dispatch(__first, __last, _Integral());
      }







    iterator
    begin()
    { return this->_M_impl._M_start; }

    const_iterator
    begin() const
    { return this->_M_impl._M_start; }

    iterator
    end()
    { return this->_M_impl._M_finish; }

    const_iterator
    end() const
    { return this->_M_impl._M_finish; }

    reverse_iterator
    rbegin()
    { return reverse_iterator(end()); }

    const_reverse_iterator
    rbegin() const
    { return const_reverse_iterator(end()); }

    reverse_iterator
    rend()
    { return reverse_iterator(begin()); }

    const_reverse_iterator
    rend() const
    { return const_reverse_iterator(begin()); }
# 659 "/usr/include/c++/4.5.3/bits/stl_bvector.h" 3
    size_type
    size() const
    { return size_type(end() - begin()); }

    size_type
    max_size() const
    {
      const size_type __isize =
 __gnu_cxx::__numeric_traits<difference_type>::__max
 - int(_S_word_bit) + 1;
      const size_type __asize = _M_get_Bit_allocator().max_size();
      return (__asize <= __isize / int(_S_word_bit)
       ? __asize * int(_S_word_bit) : __isize);
    }

    size_type
    capacity() const
    { return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0)
         - begin()); }

    bool
    empty() const
    { return begin() == end(); }

    reference
    operator[](size_type __n)
    {
      return *iterator(this->_M_impl._M_start._M_p
         + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

    const_reference
    operator[](size_type __n) const
    {
      return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

  protected:
    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
        __throw_out_of_range(("vector<bool>::_M_range_check"));
    }

  public:
    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    void
    reserve(size_type __n);

    reference
    front()
    { return *begin(); }

    const_reference
    front() const
    { return *begin(); }

    reference
    back()
    { return *(end() - 1); }

    const_reference
    back() const
    { return *(end() - 1); }






    void
    data() { }

    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void
    swap(vector& __x)
    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);



      std::__alloc_swap<typename _Base::_Bit_alloc_type>::
 _S_do_it(_M_get_Bit_allocator(), __x._M_get_Bit_allocator());
    }


    static void
    swap(reference __x, reference __y)
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator
    insert(iterator __position, const bool& __x = bool())
    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }

    template<typename _InputIterator>
      void
      insert(iterator __position,
      _InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_insert_dispatch(__position, __first, __last, _Integral());
      }

    void
    insert(iterator __position, size_type __n, const bool& __x)
    { _M_fill_insert(__position, __n, __x); }






    void
    pop_back()
    { --this->_M_impl._M_finish; }

    iterator
    erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

    iterator
    erase(iterator __first, iterator __last)
    {
      _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }

    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        _M_erase_at_end(begin() + difference_type(__new_size));
      else
        insert(end(), __new_size - size(), __x);
    }







    void
    flip()
    {
      for (_Bit_type * __p = this->_M_impl._M_start._M_p;
    __p != this->_M_impl._M_end_of_storage; ++__p)
        *__p = ~*__p;
    }

    void
    clear()
    { _M_erase_at_end(begin()); }


  protected:

    iterator
    _M_copy_aligned(const_iterator __first, const_iterator __last,
      iterator __result)
    {
      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
      return std::copy(const_iterator(__last._M_p, 0), __last,
         iterator(__q, 0));
    }

    void
    _M_initialize(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_end_of_storage = (__q
      + ((__n + int(_S_word_bit) - 1)
         / int(_S_word_bit)));
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }





    template<typename _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
 _M_initialize(static_cast<size_type>(__n));
 std::fill(this->_M_impl._M_start._M_p,
    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
      }

    template<typename _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }

    template<typename _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   push_back(*__first);
      }

    template<typename _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 _M_initialize(__n);
 std::copy(__first, __last, this->_M_impl._M_start);
      }



    template<typename _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign(__n, __val); }

    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   _M_erase_at_end(begin() + __n);
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
 }
    }

    template<typename _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

    template<typename _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len < size())
   _M_erase_at_end(std::copy(__first, __last, begin()));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, begin());
     insert(end(), __mid, __last);
   }
      }





    template<typename _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
    __true_type)
      { _M_fill_insert(__pos, __n, __x); }

    template<typename _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
    _InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_insert_range(__pos, __first, __last,
   std::__iterator_category(__first)); }

    void
    _M_fill_insert(iterator __position, size_type __n, bool __x);

    template<typename _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

    template<typename _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag);

    void
    _M_insert_aux(iterator __position, bool __x);

    size_type
    _M_check_len(size_type __n, const char* __s) const
    {
      if (max_size() - size() < __n)
 __throw_length_error((__s));

      const size_type __len = size() + std::max(size(), __n);
      return (__len < size() || __len > max_size()) ? max_size() : __len;
    }

    void
    _M_erase_at_end(iterator __pos)
    { this->_M_impl._M_finish = __pos; }
  };

}
# 66 "/usr/include/c++/4.5.3/vector" 2 3


# 1 "/usr/include/c++/4.5.3/bits/vector.tcc" 1 3
# 60 "/usr/include/c++/4.5.3/bits/vector.tcc" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
   (this->_M_impl._M_start),
   (this->_M_impl._M_finish));
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }
# 104 "/usr/include/c++/4.5.3/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
   && __position == end())
 {
   this->_M_impl.construct(this->_M_impl._M_finish, __x);
   ++this->_M_impl._M_finish;
 }
      else
 {
# 126 "/usr/include/c++/4.5.3/bits/vector.tcc" 3
     _M_insert_aux(__position, __x);
 }
      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __position)
    {
      if (__position + 1 != end())
 std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      this->_M_impl.destroy(this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__last != end())
 std::copy(__last, end(), __first);
      _M_erase_at_end(__first.base() + (end() - __last));
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {
   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp.swap(*this);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
     __n - size(), __val,
     _M_get_Tp_allocator());
   this->_M_impl._M_finish += __n - size();
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
   }
      }
# 293 "/usr/include/c++/4.5.3/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_insert_aux(iterator __position, const _Tp& __x)

    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 {
   this->_M_impl.construct(this->_M_impl._M_finish,
      (*(this->_M_impl._M_finish - 1)));

   ++this->_M_impl._M_finish;

   _Tp __x_copy = __x;

   std::copy_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1);



   *__position = __x_copy;



 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector::_M_insert_aux");
   const size_type __elems_before = __position - begin();
   pointer __new_start(this->_M_allocate(__len));
   pointer __new_finish(__new_start);
   try
     {




       this->_M_impl.construct(__new_start + __elems_before,



                               __x);

       __new_finish = 0;

       __new_finish =
  std::__uninitialized_move_a(this->_M_impl._M_start,
         __position.base(), __new_start,
         _M_get_Tp_allocator());
       ++__new_finish;

       __new_finish =
  std::__uninitialized_move_a(__position.base(),
         this->_M_impl._M_finish,
         __new_finish,
         _M_get_Tp_allocator());
     }
          catch(...)
     {
       if (!__new_finish)
  this->_M_impl.destroy(__new_start + __elems_before);
       else
  std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
       _M_deallocate(__new_start, __len);
       throw;
     }
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __new_start;
   this->_M_impl._M_finish = __new_finish;
   this->_M_impl._M_end_of_storage = __new_start + __len;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       value_type __x_copy = __x;
       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    std::copy_backward(__position.base(), __old_finish - __n, __old_finish);

    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
      __n - __elems_after,
      __x_copy,
      _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n - __elems_after;
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __position - begin();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {

    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = 0;

    __new_finish =
      std::__uninitialized_move_a(this->_M_impl._M_start,
      __position.base(),
      __new_start,
      _M_get_Tp_allocator());
    __new_finish += __n;

    __new_finish =
      std::__uninitialized_move_a(__position.base(),
      this->_M_impl._M_finish,
      __new_finish,
      _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      std::copy_backward(__position.base(), __old_finish - __n, __old_finish);

      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish =
        std::__uninitialized_move_a(this->_M_impl._M_start,
        __position.base(),
        __new_start,
        _M_get_Tp_allocator());
      __new_finish =
        std::__uninitialized_copy_a(__first, __last,
        __new_finish,
        _M_get_Tp_allocator());
      __new_finish =
        std::__uninitialized_move_a(__position.base(),
        this->_M_impl._M_finish,
        __new_finish,
        _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }




  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   _Bit_type* __q = this->_M_allocate(__n);
   this->_M_impl._M_finish = _M_copy_aligned(begin(), end(),
          iterator(__q, 0));
   this->_M_deallocate();
   this->_M_impl._M_start = iterator(__q, 0);
   this->_M_impl._M_end_of_storage = (__q + (__n + int(_S_word_bit) - 1)
          / int(_S_word_bit));
 }
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   std::fill(__i, __i + difference_type(__n), __x);
   this->_M_impl._M_finish = std::copy(__position, end(),
           __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_type * __q = this->_M_allocate(__len);
  iterator __i = _M_copy_aligned(begin(), __position,
            iterator(__q, 0));
  __i = std::copy(__first, __last, __i);
  this->_M_impl._M_finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = (__q
         + ((__len
             + int(_S_word_bit) - 1)
            / int(_S_word_bit)));
  this->_M_impl._M_start = iterator(__q, 0);
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   *__i++ = __x;
   this->_M_impl._M_finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

}
# 69 "/usr/include/c++/4.5.3/vector" 2 3
# 32 "/home/pipping/Downloads/eigen-eigen-3.0.3/test/main.h" 2
# 1 "/usr/include/c++/4.5.3/typeinfo" 1 3
# 34 "/usr/include/c++/4.5.3/typeinfo" 3
# 34 "/usr/include/c++/4.5.3/typeinfo" 3



#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 78 "/usr/include/c++/4.5.3/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const
    { return __name[0] == '*' ? __name + 1 : __name; }
# 113 "/usr/include/c++/4.5.3/typeinfo" 3
    bool before(const type_info& __arg) const
    { return (__name[0] == '*' && __arg.__name[0] == '*')
 ? __name < __arg.__name
 : __builtin_strcmp (__name, __arg.__name) < 0; }

    bool operator==(const type_info& __arg) const
    {
      return ((__name == __arg.__name)
       || (__name[0] != '*' &&
    __builtin_strcmp (__name, __arg.__name) == 0));
    }
# 134 "/usr/include/c++/4.5.3/typeinfo" 3
    bool operator!=(const type_info& __arg) const
    { return !operator==(__arg); }


    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() { }



    virtual ~bad_cast() ;


    virtual const char* what() const ;
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () { }



    virtual ~bad_typeid() ;


    virtual const char* what() const ;
  };
}

#pragma GCC visibility pop

}
# 33 "/home/pipping/Downloads/eigen-eigen-3.0.3/test/main.h" 2
# 1 "/usr/include/c++/4.5.3/limits" 1 3
# 41 "/usr/include/c++/4.5.3/limits" 3
# 41 "/usr/include/c++/4.5.3/limits" 3
# 147 "/usr/include/c++/4.5.3/limits" 3
namespace std __attribute__ ((__visibility__ ("default"))) {






  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 189 "/usr/include/c++/4.5.3/limits" 3
  struct __numeric_limits_base
  {


    static const bool is_specialized = false;




    static const int digits = 0;

    static const int digits10 = 0;






    static const bool is_signed = false;


    static const bool is_integer = false;




    static const bool is_exact = false;


    static const int radix = 0;



    static const int min_exponent = 0;


    static const int min_exponent10 = 0;



    static const int max_exponent = 0;


    static const int max_exponent10 = 0;


    static const bool has_infinity = false;


    static const bool has_quiet_NaN = false;


    static const bool has_signaling_NaN = false;

    static const float_denorm_style has_denorm = denorm_absent;


    static const bool has_denorm_loss = false;



    static const bool is_iec559 = false;



    static const bool is_bounded = false;




    static const bool is_modulo = false;


    static const bool traps = false;

    static const bool tinyness_before = false;



    static const float_round_style round_style = round_toward_zero;
  };
# 282 "/usr/include/c++/4.5.3/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static _Tp min() { return static_cast<_Tp>(0); }

      static _Tp max() { return static_cast<_Tp>(0); }







      static _Tp epsilon() { return static_cast<_Tp>(0); }

      static _Tp round_error() { return static_cast<_Tp>(0); }

      static _Tp infinity() { return static_cast<_Tp>(0); }



      static _Tp quiet_NaN() { return static_cast<_Tp>(0); }


      static _Tp signaling_NaN() { return static_cast<_Tp>(0); }



      static _Tp denorm_min() { return static_cast<_Tp>(0); }
    };
# 333 "/usr/include/c++/4.5.3/limits" 3
  template<>
    struct numeric_limits<bool>
    {
      static const bool is_specialized = true;

      static bool min()
      { return false; }
      static bool max()
      { return true; }




      static const int digits = 1;
      static const int digits10 = 0;



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static bool epsilon()
      { return false; }
      static bool round_error()
      { return false; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static bool infinity()
      { return false; }
      static bool quiet_NaN()
      { return false; }
      static bool signaling_NaN()
      { return false; }
      static bool denorm_min()
      { return false; }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;




      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static const bool is_specialized = true;

      static char min()
      { return (((char)(-1) < 0) ? (char)1 << (sizeof(char) * 8 - ((char)(-1) < 0)) : (char)0); }
      static char max()
      { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }





      static const int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static const int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643 / 2136);



      static const bool is_signed = ((char)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static char epsilon()
      { return 0; }
      static char round_error()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static char infinity()
      { return char(); }
      static char quiet_NaN()
      { return char(); }
      static char signaling_NaN()
      { return char(); }
      static char denorm_min()
      { return static_cast<char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static const bool is_specialized = true;

      static signed char min()
      { return -127 - 1; }
      static signed char max()
      { return 127; }





      static const int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static const int digits10 = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643 / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static signed char epsilon()
      { return 0; }
      static signed char round_error()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static signed char infinity()
      { return static_cast<signed char>(0); }
      static signed char quiet_NaN()
      { return static_cast<signed char>(0); }
      static signed char signaling_NaN()
      { return static_cast<signed char>(0); }
      static signed char denorm_min()
      { return static_cast<signed char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static const bool is_specialized = true;

      static unsigned char min()
      { return 0; }
      static unsigned char max()
      { return 127 * 2U + 1; }





      static const int digits = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643 / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned char epsilon()
      { return 0; }
      static unsigned char round_error()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned char infinity()
      { return static_cast<unsigned char>(0); }
      static unsigned char quiet_NaN()
      { return static_cast<unsigned char>(0); }
      static unsigned char signaling_NaN()
      { return static_cast<unsigned char>(0); }
      static unsigned char denorm_min()
      { return static_cast<unsigned char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static const bool is_specialized = true;

      static wchar_t min()
      { return (((wchar_t)(-1) < 0) ? (wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) : (wchar_t)0); }
      static wchar_t max()
      { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }





      static const int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static const int digits10 = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643 / 2136);



      static const bool is_signed = ((wchar_t)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static wchar_t epsilon()
      { return 0; }
      static wchar_t round_error()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static wchar_t infinity()
      { return wchar_t(); }
      static wchar_t quiet_NaN()
      { return wchar_t(); }
      static wchar_t signaling_NaN()
      { return wchar_t(); }
      static wchar_t denorm_min()
      { return wchar_t(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
# 743 "/usr/include/c++/4.5.3/limits" 3
  template<>
    struct numeric_limits<short>
    {
      static const bool is_specialized = true;

      static short min()
      { return -32767 - 1; }
      static short max()
      { return 32767; }





      static const int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static const int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643 / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static short epsilon()
      { return 0; }
      static short round_error()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static short infinity()
      { return short(); }
      static short quiet_NaN()
      { return short(); }
      static short signaling_NaN()
      { return short(); }
      static short denorm_min()
      { return short(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static const bool is_specialized = true;

      static unsigned short min()
      { return 0; }
      static unsigned short max()
      { return 32767 * 2U + 1; }





      static const int digits = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643 / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned short epsilon()
      { return 0; }
      static unsigned short round_error()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned short infinity()
      { return static_cast<unsigned short>(0); }
      static unsigned short quiet_NaN()
      { return static_cast<unsigned short>(0); }
      static unsigned short signaling_NaN()
      { return static_cast<unsigned short>(0); }
      static unsigned short denorm_min()
      { return static_cast<unsigned short>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static const bool is_specialized = true;

      static int min()
      { return -2147483647 - 1; }
      static int max()
      { return 2147483647; }





      static const int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static const int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643 / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static int epsilon()
      { return 0; }
      static int round_error()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static int infinity()
      { return static_cast<int>(0); }
      static int quiet_NaN()
      { return static_cast<int>(0); }
      static int signaling_NaN()
      { return static_cast<int>(0); }
      static int denorm_min()
      { return static_cast<int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static const bool is_specialized = true;

      static unsigned int min()
      { return 0; }
      static unsigned int max()
      { return 2147483647 * 2U + 1; }





      static const int digits = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643 / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned int epsilon()
      { return 0; }
      static unsigned int round_error()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned int infinity()
      { return static_cast<unsigned int>(0); }
      static unsigned int quiet_NaN()
      { return static_cast<unsigned int>(0); }
      static unsigned int signaling_NaN()
      { return static_cast<unsigned int>(0); }
      static unsigned int denorm_min()
      { return static_cast<unsigned int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static const bool is_specialized = true;

      static long min()
      { return -9223372036854775807L - 1; }
      static long max()
      { return 9223372036854775807L; }





      static const int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static const int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643 / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long epsilon()
      { return 0; }
      static long round_error()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static long infinity()
      { return static_cast<long>(0); }
      static long quiet_NaN()
      { return static_cast<long>(0); }
      static long signaling_NaN()
      { return static_cast<long>(0); }
      static long denorm_min()
      { return static_cast<long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static const bool is_specialized = true;

      static unsigned long min()
      { return 0; }
      static unsigned long max()
      { return 9223372036854775807L * 2UL + 1; }





      static const int digits = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643 / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long epsilon()
      { return 0; }
      static unsigned long round_error()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long infinity()
      { return static_cast<unsigned long>(0); }
      static unsigned long quiet_NaN()
      { return static_cast<unsigned long>(0); }
      static unsigned long signaling_NaN()
      { return static_cast<unsigned long>(0); }
      static unsigned long denorm_min()
      { return static_cast<unsigned long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static const bool is_specialized = true;

      static long long min()
      { return -9223372036854775807LL - 1; }
      static long long max()
      { return 9223372036854775807LL; }





      static const int digits = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static const int digits10 = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643 / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long long epsilon()
      { return 0; }
      static long long round_error()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static long long infinity()
      { return static_cast<long long>(0); }
      static long long quiet_NaN()
      { return static_cast<long long>(0); }
      static long long signaling_NaN()
      { return static_cast<long long>(0); }
      static long long denorm_min()
      { return static_cast<long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static const bool is_specialized = true;

      static unsigned long long min()
      { return 0; }
      static unsigned long long max()
      { return 9223372036854775807LL * 2ULL + 1; }





      static const int digits = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643 / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long long epsilon()
      { return 0; }
      static unsigned long long round_error()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long long infinity()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long quiet_NaN()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long signaling_NaN()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long denorm_min()
      { return static_cast<unsigned long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<float>
    {
      static const bool is_specialized = true;

      static float min()
      { return 1.17549435e-38F; }
      static float max()
      { return 3.40282347e+38F; }





      static const int digits = 24;
      static const int digits10 = 6;




      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static float epsilon()
      { return 1.19209290e-7F; }
      static float round_error()
      { return 0.5F; }

      static const int min_exponent = (-125);
      static const int min_exponent10 = (-37);
      static const int max_exponent = 128;
      static const int max_exponent10 = 38;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;

      static float infinity()
      { return __builtin_huge_valf (); }
      static float quiet_NaN()
      { return __builtin_nanf (""); }
      static float signaling_NaN()
      { return __builtin_nansf (""); }
      static float denorm_min()
      { return 1.40129846e-45F; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static const bool is_specialized = true;

      static double min()
      { return 2.2250738585072014e-308; }
      static double max()
      { return 1.7976931348623157e+308; }





      static const int digits = 53;
      static const int digits10 = 15;




      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static double epsilon()
      { return 2.2204460492503131e-16; }
      static double round_error()
      { return 0.5; }

      static const int min_exponent = (-1021);
      static const int min_exponent10 = (-307);
      static const int max_exponent = 1024;
      static const int max_exponent10 = 308;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;

      static double infinity()
      { return __builtin_huge_val(); }
      static double quiet_NaN()
      { return __builtin_nan (""); }
      static double signaling_NaN()
      { return __builtin_nans (""); }
      static double denorm_min()
      { return 4.9406564584124654e-324; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static const bool is_specialized = true;

      static long double min()
      { return 3.36210314311209350626e-4932L; }
      static long double max()
      { return 1.18973149535723176502e+4932L; }





      static const int digits = 64;
      static const int digits10 = 18;




      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static long double epsilon()
      { return 1.08420217248550443401e-19L; }
      static long double round_error()
      { return 0.5L; }

      static const int min_exponent = (-16381);
      static const int min_exponent10 = (-4931);
      static const int max_exponent = 16384;
      static const int max_exponent10 = 4932;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
 = false;

      static long double infinity()
      { return __builtin_huge_vall (); }
      static long double quiet_NaN()
      { return __builtin_nanl (""); }
      static long double signaling_NaN()
      { return __builtin_nansl (""); }
      static long double denorm_min()
      { return 3.64519953188247460253e-4951L; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };





}
# 34 "/home/pipping/Downloads/eigen-eigen-3.0.3/test/main.h" 2
# 1 "/usr/include/c++/4.5.3/algorithm" 1 3
# 59 "/usr/include/c++/4.5.3/algorithm" 3
# 59 "/usr/include/c++/4.5.3/algorithm" 3

# 1 "/usr/include/c++/4.5.3/utility" 1 3
# 59 "/usr/include/c++/4.5.3/utility" 3
# 59 "/usr/include/c++/4.5.3/utility" 3
# 69 "/usr/include/c++/4.5.3/utility" 3
# 1 "/usr/include/c++/4.5.3/bits/stl_relops.h" 1 3
# 67 "/usr/include/c++/4.5.3/bits/stl_relops.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  namespace rel_ops
  {
# 83 "/usr/include/c++/4.5.3/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 96 "/usr/include/c++/4.5.3/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 109 "/usr/include/c++/4.5.3/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 122 "/usr/include/c++/4.5.3/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }

  }

}
# 70 "/usr/include/c++/4.5.3/utility" 2 3
# 61 "/usr/include/c++/4.5.3/algorithm" 2 3

# 1 "/usr/include/c++/4.5.3/bits/stl_algo.h" 1 3
# 60 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
# 1 "/usr/include/c++/4.5.3/cstdlib" 1 3
# 41 "/usr/include/c++/4.5.3/cstdlib" 3
# 41 "/usr/include/c++/4.5.3/cstdlib" 3


# 1 "/usr/include/c++/4.5.3/cstddef" 1 3
# 41 "/usr/include/c++/4.5.3/cstddef" 3
# 41 "/usr/include/c++/4.5.3/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.5.3/cstddef" 2 3
# 44 "/usr/include/c++/4.5.3/cstdlib" 2 3
# 61 "/usr/include/c++/4.5.3/bits/stl_algo.h" 2 3
# 1 "/usr/include/c++/4.5.3/bits/algorithmfwd.h" 1 3
# 33 "/usr/include/c++/4.5.3/bits/algorithmfwd.h" 3
# 33 "/usr/include/c++/4.5.3/bits/algorithmfwd.h" 3






namespace std __attribute__ ((__visibility__ ("default"))) {
# 198 "/usr/include/c++/4.5.3/bits/algorithmfwd.h" 3
  template<typename _FIter, typename _Tp>
    bool
    binary_search(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    bool
    binary_search(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _IIter, typename _OIter>
    _OIter
    copy(_IIter, _IIter, _OIter);

  template<typename _BIter1, typename _BIter2>
    _BIter2
    copy_backward(_BIter1, _BIter1, _BIter2);
# 227 "/usr/include/c++/4.5.3/bits/algorithmfwd.h" 3
  template<typename _FIter, typename _Tp>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _FIter, typename _Tp>
    void
    fill(_FIter, _FIter, const _Tp&);

  template<typename _OIter, typename _Size, typename _Tp>
    _OIter
    fill_n(_OIter, _Size, const _Tp&);



  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);
# 266 "/usr/include/c++/4.5.3/bits/algorithmfwd.h" 3
  template<typename _IIter1, typename _IIter2>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _BIter>
    void
    inplace_merge(_BIter, _BIter, _BIter);

  template<typename _BIter, typename _Compare>
    void
    inplace_merge(_BIter, _BIter, _BIter, _Compare);
# 320 "/usr/include/c++/4.5.3/bits/algorithmfwd.h" 3
  template<typename _FIter1, typename _FIter2>
    void
    iter_swap(_FIter1, _FIter2);

  template<typename _FIter, typename _Tp>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _RAIter>
    void
    make_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    make_heap(_RAIter, _RAIter, _Compare);

  template<typename _Tp>
    const _Tp&
    max(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    const _Tp&
    max(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    const _Tp&
    min(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    const _Tp&
    min(const _Tp&, const _Tp&, _Compare);
# 405 "/usr/include/c++/4.5.3/bits/algorithmfwd.h" 3
  template<typename _BIter>
    bool
    next_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    next_permutation(_BIter, _BIter, _Compare);
# 422 "/usr/include/c++/4.5.3/bits/algorithmfwd.h" 3
  template<typename _IIter, typename _RAIter>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);

  template<typename _IIter, typename _RAIter, typename _Compare>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);
# 443 "/usr/include/c++/4.5.3/bits/algorithmfwd.h" 3
  template<typename _RAIter>
    void
    pop_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    pop_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter>
    bool
    prev_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    prev_permutation(_BIter, _BIter, _Compare);

  template<typename _RAIter>
    void
    push_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    push_heap(_RAIter, _RAIter, _Compare);



  template<typename _FIter, typename _Tp>
    _FIter
    remove(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Predicate>
    _FIter
    remove_if(_FIter, _FIter, _Predicate);

  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    remove_copy(_IIter, _IIter, _OIter, const _Tp&);

  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    remove_copy_if(_IIter, _IIter, _OIter, _Predicate);



  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    replace_copy(_IIter, _IIter, _OIter, const _Tp&, const _Tp&);

  template<typename _Iter, typename _OIter, typename _Predicate, typename _Tp>
    _OIter
    replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp&);



  template<typename _BIter>
    void
    reverse(_BIter, _BIter);

  template<typename _BIter, typename _OIter>
    _OIter
    reverse_copy(_BIter, _BIter, _OIter);

  template<typename _FIter>
    void
    rotate(_FIter, _FIter, _FIter);

  template<typename _FIter, typename _OIter>
    _OIter
    rotate_copy(_FIter, _FIter, _FIter, _OIter);
# 526 "/usr/include/c++/4.5.3/bits/algorithmfwd.h" 3
  template<typename _RAIter>
    void
    sort_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    stable_partition(_BIter, _BIter, _Predicate);

  template<typename _Tp>
    void
    swap(_Tp&, _Tp&);

  template<typename _Tp, size_t _Nm>
    void
    swap(_Tp (&)[_Nm], _Tp (&)[_Nm]);

  template<typename _FIter1, typename _FIter2>
    _FIter2
    swap_ranges(_FIter1, _FIter1, _FIter2);



  template<typename _FIter>
    _FIter
    unique(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    unique(_FIter, _FIter, _BinaryPredicate);



  template<typename _FIter, typename _Tp>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&, _Compare);

}

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _FIter>
    _FIter
    adjacent_find(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    adjacent_find(_FIter, _FIter, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    typename iterator_traits<_IIter>::difference_type
    count(_IIter, _IIter, const _Tp&);

  template<typename _IIter, typename _Predicate>
    typename iterator_traits<_IIter>::difference_type
    count_if(_IIter, _IIter, _Predicate);

  template<typename _IIter1, typename _IIter2>
    bool
    equal(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    bool
    equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    _IIter
    find(_IIter, _IIter, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _IIter, typename _Predicate>
    _IIter
    find_if(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Funct>
    _Funct
    for_each(_IIter, _IIter, _Funct);

  template<typename _FIter, typename _Generator>
    void
    generate(_FIter, _FIter, _Generator);

  template<typename _OIter, typename _Size, typename _Generator>
    _OIter
    generate_n(_OIter, _Size, _Generator);

  template<typename _IIter1, typename _IIter2>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _FIter>
    _FIter
    max_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    max_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _FIter>
    _FIter
    min_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    min_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _RAIter>
    void
    nth_element(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    nth_element(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    partial_sort(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    partition(_BIter, _BIter, _Predicate);

  template<typename _RAIter>
    void
    random_shuffle(_RAIter, _RAIter);

  template<typename _RAIter, typename _Generator>
    void
    random_shuffle(_RAIter, _RAIter,



     _Generator&);


  template<typename _FIter, typename _Tp>
    void
    replace(_FIter, _FIter, const _Tp&, const _Tp&);

  template<typename _FIter, typename _Predicate, typename _Tp>
    void
    replace_if(_FIter, _FIter, _Predicate, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _FIter, typename _Size, typename _Tp>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&);

  template<typename _FIter, typename _Size, typename _Tp,
    typename _BinaryPredicate>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&, _BinaryPredicate);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2,
        _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _RAIter>
    void
    sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    stable_sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    stable_sort(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _OIter, typename _UnaryOperation>
    _OIter
    transform(_IIter, _IIter, _OIter, _UnaryOperation);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _BinaryOperation>
    _OIter
    transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);

  template<typename _IIter, typename _OIter>
    _OIter
    unique_copy(_IIter, _IIter, _OIter);

  template<typename _IIter, typename _OIter, typename _BinaryPredicate>
    _OIter
    unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);

}
# 62 "/usr/include/c++/4.5.3/bits/stl_algo.h" 2 3
# 1 "/usr/include/c++/4.5.3/bits/stl_heap.h" 1 3
# 62 "/usr/include/c++/4.5.3/bits/stl_heap.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {






  template<typename _RandomAccessIterator, typename _Distance>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__first[__parent] < __first[__child])
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n,
      _Compare __comp)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first[__parent], __first[__child]))
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }



  template<typename _RandomAccessIterator, typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    { return std::__is_heap_until(__first, __n) == __n; }

  template<typename _RandomAccessIterator, typename _Compare,
    typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
    { return std::__is_heap_until(__first, __n, __comp) == __n; }

  template<typename _RandomAccessIterator>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    { return std::__is_heap(__first, __comp, std::distance(__first, __last)); }




  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && *(__first + __parent) < __value)
 {
   *(__first + __holeIndex) = (*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = (__value);
    }
# 152 "/usr/include/c++/4.5.3/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;





                                                     ;
                                                  ;

      _ValueType __value = (*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), (__value));
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
    typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
  _Distance __topIndex, _Tp __value, _Compare __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex
      && __comp(*(__first + __parent), __value))
 {
   *(__first + __holeIndex) = (*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = (__value);
    }
# 201 "/usr/include/c++/4.5.3/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;




                                                     ;
                                                               ;

      _ValueType __value = (*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), (__value), __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = (*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = (*(__first + (__secondChild - 1)));

   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex,
         (__value));
    }

  template<typename _RandomAccessIterator>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = (*__result);
      *__result = (*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    (__value));
    }
# 274 "/usr/include/c++/4.5.3/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                     ;
                                              ;

      --__last;
      std::__pop_heap(__first, __last, __last);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (__comp(*(__first + __secondChild),
       *(__first + (__secondChild - 1))))
     __secondChild--;
   *(__first + __holeIndex) = (*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = (*(__first + (__secondChild - 1)));

   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex,
         (__value), __comp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = (*__result);
      *__result = (*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    (__value), __comp);
    }
# 348 "/usr/include/c++/4.5.3/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {



                                                     ;
                                                           ;

      --__last;
      std::__pop_heap(__first, __last, __last, __comp);
    }
# 371 "/usr/include/c++/4.5.3/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;





                                                     ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = (*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, (__value));
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 411 "/usr/include/c++/4.5.3/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;




                                                     ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = (*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, (__value),
        __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 450 "/usr/include/c++/4.5.3/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                     ;
                                              ;

      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last);
 }
    }
# 479 "/usr/include/c++/4.5.3/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {



                                                     ;
                                                           ;

      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
# 576 "/usr/include/c++/4.5.3/bits/stl_heap.h" 3
}
# 63 "/usr/include/c++/4.5.3/bits/stl_algo.h" 2 3
# 1 "/usr/include/c++/4.5.3/bits/stl_tempbuf.h" 1 3
# 64 "/usr/include/c++/4.5.3/bits/stl_tempbuf.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 83 "/usr/include/c++/4.5.3/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len)
    {
      const ptrdiff_t __max =
 __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       std::nothrow));
   if (__tmp != 0)
     return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 110 "/usr/include/c++/4.5.3/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, std::nothrow); }







  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {



    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };

  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {
      try
 {
   std::pair<pointer, size_type> __p(std::get_temporary_buffer<
         value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if(_M_buffer)
     std::__uninitialized_construct_range(_M_buffer, _M_buffer + _M_len,
       *__first);
 }
      catch(...)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   throw;
 }
    }

}
# 64 "/usr/include/c++/4.5.3/bits/stl_algo.h" 2 3







namespace std __attribute__ ((__visibility__ ("default"))) {


  template<typename _Iterator>
    void
    __move_median_first(_Iterator __a, _Iterator __b, _Iterator __c)
    {




      if (*__a < *__b)
 {
   if (*__b < *__c)
     std::iter_swap(__a, __b);
   else if (*__a < *__c)
     std::iter_swap(__a, __c);
 }
      else if (*__a < *__c)
 return;
      else if (*__b < *__c)
 std::iter_swap(__a, __c);
      else
 std::iter_swap(__a, __b);
    }


  template<typename _Iterator, typename _Compare>
    void
    __move_median_first(_Iterator __a, _Iterator __b, _Iterator __c,
   _Compare __comp)
    {





      if (__comp(*__a, *__b))
 {
   if (__comp(*__b, *__c))
     std::iter_swap(__a, __b);
   else if (__comp(*__a, *__c))
     std::iter_swap(__a, __c);
 }
      else if (__comp(*__a, *__c))
 return;
      else if (__comp(*__b, *__c))
 std::iter_swap(__a, __c);
      else
 std::iter_swap(__a, __b);
    }




  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    __find(_InputIterator __first, _InputIterator __last,
    const _Tp& __val, input_iterator_tag)
    {
      while (__first != __last && !(*__first == __val))
 ++__first;
      return __first;
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !bool(__pred(*__first)))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __find(_RandomAccessIterator __first, _RandomAccessIterator __last,
    const _Tp& __val, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (*__first == __val)
     return __first;
   ++__first;
 case 2:
   if (*__first == __val)
     return __first;
   ++__first;
 case 1:
   if (*__first == __val)
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }
# 322 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        std::forward_iterator_tag)
    {
      __first = std::find(__first, __last, __val);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && *__i == __val)
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::find(++__i, __last, __val);
 }
      return __last;
    }






  template<typename _RandomAccessIter, typename _Integer, typename _Tp>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        std::random_access_iterator_tag)
    {

      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      const _DistanceType __pattSize = __count;

      if (__tailSize < __pattSize)
        return __last;

      const _DistanceType __skipOffset = __pattSize - 1;
      _RandomAccessIter __lookAhead = __first + __skipOffset;
      __tailSize -= __pattSize;

      while (1)
 {


   while (!(*__lookAhead == __val))
     {
       if (__tailSize < __pattSize)
  return __last;
       __lookAhead += __pattSize;
       __tailSize -= __pattSize;
     }
   _DistanceType __remainder = __skipOffset;
   for (_RandomAccessIter __backTrack = __lookAhead - 1;
        *__backTrack == __val; --__backTrack)
     {
       if (--__remainder == 0)
  return (__lookAhead - __skipOffset);
     }
   if (__remainder > __tailSize)
     return __last;
   __lookAhead += __remainder;
   __tailSize -= __remainder;
 }
    }
# 407 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::forward_iterator_tag)
    {
      while (__first != __last && !bool(__binary_pred(*__first, __val)))
        ++__first;

      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && bool(__binary_pred(*__i, __val)))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = ++__i;
   while (__first != __last
   && !bool(__binary_pred(*__first, __val)))
     ++__first;
 }
      return __last;
    }







  template<typename _RandomAccessIter, typename _Integer, typename _Tp,
    typename _BinaryPredicate>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::random_access_iterator_tag)
    {

      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      const _DistanceType __pattSize = __count;

      if (__tailSize < __pattSize)
        return __last;

      const _DistanceType __skipOffset = __pattSize - 1;
      _RandomAccessIter __lookAhead = __first + __skipOffset;
      __tailSize -= __pattSize;

      while (1)
 {


   while (!bool(__binary_pred(*__lookAhead, __val)))
     {
       if (__tailSize < __pattSize)
  return __last;
       __lookAhead += __pattSize;
       __tailSize -= __pattSize;
     }
   _DistanceType __remainder = __skipOffset;
   for (_RandomAccessIter __backTrack = __lookAhead - 1;
        __binary_pred(*__backTrack, __val); --__backTrack)
     {
       if (--__remainder == 0)
  return (__lookAhead - __skipOffset);
     }
   if (__remainder > __tailSize)
     return __last;
   __lookAhead += __remainder;
   __tailSize -= __remainder;
 }
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2, __last2);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2,
      __last2, __comp);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag)
    {






      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1),
             __rlast1,
             _RevIterator2(__last2),
             __rlast2);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }

  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {






      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
         _RevIterator2(__last2), __rlast2,
         __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
# 645 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {






                                                       ;
                                                       ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2));
    }
# 691 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {






                                                       ;
                                                       ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __comp);
    }
# 870 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {






                                                     ;

      for (; __first != __last; ++__first)
 if (!(*__first == __value))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 907 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {






                                                     ;

      for (; __first != __last; ++__first)
 if (!bool(__pred(*__first)))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 1082 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {





                                                     ;

      __first = std::find(__first, __last, __value);
      if(__first == __last)
        return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for(; __first != __last; ++__first)
        if(!(*__first == __value))
          {
            *__result = (*__first);
            ++__result;
          }
      return __result;
    }
# 1125 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      __first = std::find_if(__first, __last, __pred);
      if(__first == __last)
        return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for(; __first != __last; ++__first)
        if(!bool(__pred(*__first)))
          {
            *__result = (*__first);
            ++__result;
          }
      return __result;
    }
# 1165 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {





                                                     ;


      __first = std::adjacent_find(__first, __last);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!(*__dest == *__first))
   *++__dest = (*__first);
      return ++__dest;
    }
# 1205 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
           _BinaryPredicate __binary_pred)
    {






                                                     ;


      __first = std::adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!bool(__binary_pred(*__dest, *__first)))
   *++__dest = (*__first);
      return ++__dest;
    }






  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result,
    forward_iterator_tag, output_iterator_tag)
    {

      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!(*__first == *__next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }






  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result,
    input_iterator_tag, output_iterator_tag)
    {

      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!(__value == *__first))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }






  template<typename _InputIterator, typename _ForwardIterator>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result,
    input_iterator_tag, forward_iterator_tag)
    {

      *__result = *__first;
      while (++__first != __last)
 if (!(*__result == *__first))
   *++__result = *__first;
      return ++__result;
    }







  template<typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag)
    {





      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!bool(__binary_pred(*__first, *__next)))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag)
    {





      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!bool(__binary_pred(__value, *__first)))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag)
    {





      *__result = *__first;
      while (++__first != __last)
 if (!bool(__binary_pred(*__result, *__first)))
   *++__result = *__first;
      return ++__result;
    }






  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }






  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
# 1433 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {



                                                     ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
# 1460 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
   _OutputIterator __result)
    {





                                                     ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }





  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }


  template<typename _ForwardIterator>
    void
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle || __last == __middle)
 return;

      _ForwardIterator __first2 = __middle;
      do
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      __first2 = __middle;

      while (__first2 != __last)
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
    }


  template<typename _BidirectionalIterator>
    void
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {




      if (__first == __middle || __last == __middle)
 return;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 {
   std::iter_swap(__first, --__last);
   ++__first;
 }

      if (__first == __middle)
 std::__reverse(__middle, __last, bidirectional_iterator_tag());
      else
 std::__reverse(__first, __middle, bidirectional_iterator_tag());
    }


  template<typename _RandomAccessIterator>
    void
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {




      if (__first == __middle || __last == __middle)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      _Distance __n = __last - __first;
      _Distance __k = __middle - __first;

      if (__k == __n - __k)
 {
   std::swap_ranges(__first, __middle, __middle);
   return;
 }

      _RandomAccessIterator __p = __first;

      for (;;)
 {
   if (__k < __n - __k)
     {
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = (*__p);
    std::copy(__p + 1, __p + __n, __p);
    *(__p + __n - 1) = (__t);
    return;
  }
       _RandomAccessIterator __q = __p + __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    std::iter_swap(__p, __q);
    ++__p;
    ++__q;
  }
       __n %= __k;
       if (__n == 0)
  return;
       std::swap(__n, __k);
       __k = __n - __k;
     }
   else
     {
       __k = __n - __k;
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = (*(__p + __n - 1));
    std::copy_backward(__p, __p + __n - 1, __p + __n);
    *__p = (__t);
    return;
  }
       _RandomAccessIterator __q = __p + __n;
       __p = __q - __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    --__p;
    --__q;
    std::iter_swap(__p, __q);
  }
       __n %= __k;
       if (__n == 0)
  return;
       std::swap(__n, __k);
     }
 }
    }
# 1664 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline void
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {



                                                       ;
                                                      ;

      typedef typename iterator_traits<_ForwardIterator>::iterator_category
 _IterType;
      std::__rotate(__first, __middle, __last, _IterType());
    }
# 1698 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                _ForwardIterator __last, _OutputIterator __result)
    {




                                                       ;
                                                      ;

      return std::copy(__first, __middle,
                       std::copy(__middle, __last, __result));
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred, forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     std::iter_swap(__first, __next);
     ++__first;
   }

      return __first;
    }


  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred, bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!bool(__pred(*__last)))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }




  template<typename _ForwardIterator, typename _Predicate, typename _Distance>
    _ForwardIterator
    __inplace_stable_partition(_ForwardIterator __first,
          _ForwardIterator __last,
          _Predicate __pred, _Distance __len)
    {
      if (__len == 1)
 return __pred(*__first) ? __last : __first;
      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __begin = std::__inplace_stable_partition(__first,
         __middle,
         __pred,
         __len / 2);
      _ForwardIterator __end = std::__inplace_stable_partition(__middle, __last,
              __pred,
              __len
              - __len / 2);
      std::rotate(__begin, __middle, __end);
      std::advance(__begin, std::distance(__middle, __end));
      return __begin;
    }


  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;
   for (; __first != __last; ++__first)
     if (__pred(*__first))
       {
  *__result1 = (*__first);
  ++__result1;
       }
     else
       {
  *__result2 = (*__first);
  ++__result2;
       }
   std::copy(__buffer, __result2, __result1);
   return __result1;
 }
      else
 {
   _ForwardIterator __middle = __first;
   std::advance(__middle, __len / 2);
   _ForwardIterator __begin =
     std::__stable_partition_adaptive(__first, __middle, __pred,
          __len / 2, __buffer,
          __buffer_size);
   _ForwardIterator __end =
     std::__stable_partition_adaptive(__middle, __last, __pred,
          __len - __len / 2,
          __buffer, __buffer_size);
   std::rotate(__begin, __middle, __end);
   std::advance(__begin, std::distance(__middle, __end));
   return __begin;
 }
    }
# 1856 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      if (__first == __last)
 return __first;
      else
 {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;
   typedef typename iterator_traits<_ForwardIterator>::difference_type
     _DistanceType;

   _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first,
        __last);
 if (__buf.size() > 0)
   return
     std::__stable_partition_adaptive(__first, __last, __pred,
       _DistanceType(__buf.requested_size()),
       __buf.begin(),
       _DistanceType(__buf.size()));
 else
   return
     std::__inplace_stable_partition(__first, __last, __pred,
      _DistanceType(__buf.requested_size()));
 }
    }


  template<typename _RandomAccessIterator>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last)
    {
      std::make_heap(__first, __middle);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (*__i < *__first)
   std::__pop_heap(__first, __middle, __i);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp)
    {
      std::make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(*__i, *__first))
   std::__pop_heap(__first, __middle, __i, __comp);
    }
# 1938 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
# 1958 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
                                                     ;
                                                                   ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last);
      while (__first != __last)
 {
   if (*__first < *__result_first)
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first));
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last);
      return __result_real_last;
    }
# 2004 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
# 2028 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
                                                     ;
                                                                   ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(*__first, *__result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first),
          __comp);
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }


  template<typename _RandomAccessIterator>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
 __val = (*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__val < *__next)
 {
   *__last = (*__next);
   __last = __next;
   --__next;
 }
      *__last = (__val);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last,
         _Compare __comp)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
 __val = (*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, *__next))
 {
   *__last = (*__next);
   __last = __next;
   --__next;
 }
      *__last = (__val);
    }


  template<typename _RandomAccessIterator>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last)
    {
      if (__first == __last)
 return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   if (*__i < *__first)
     {
       typename iterator_traits<_RandomAccessIterator>::value_type
  __val = (*__i);
       std::copy_backward(__first, __i, __i + 1);
       *__first = (__val);
     }
   else
     std::__unguarded_linear_insert(__i);
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   if (__comp(*__i, *__first))
     {
       typename iterator_traits<_RandomAccessIterator>::value_type
  __val = (*__i);
       std::copy_backward(__first, __i, __i + 1);
       *__first = (__val);
     }
   else
     std::__unguarded_linear_insert(__i, __comp);
 }
    }


  template<typename _RandomAccessIterator>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, __comp);
    }





  enum { _S_threshold = 16 };


  template<typename _RandomAccessIterator>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold));
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last);
 }
      else
 std::__insertion_sort(__first, __last);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }


  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last, const _Tp& __pivot)
    {
      while (true)
 {
   while (*__first < __pivot)
     ++__first;
   --__last;
   while (__pivot < *__last)
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     const _Tp& __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(*__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, *__last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator>
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
    _RandomAccessIterator __last)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_first(__first, __mid, (__last - 1));
      return std::__unguarded_partition(__first + 1, __last, *__first);
    }



  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
    _RandomAccessIterator __last, _Compare __comp)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_first(__first, __mid, (__last - 1), __comp);
      return std::__unguarded_partition(__first + 1, __last, *__first, __comp);
    }


  template<typename _RandomAccessIterator, typename _Size>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit)
    {
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last);
   std::__introsort_loop(__cut, __last, __depth_limit);
   __last = __cut;
 }
    }


  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }



  template<typename _RandomAccessIterator, typename _Size>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last);


       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last, __comp);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
# 2388 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;






                    ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 2437 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;




                                                                  ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__val < *__middle)
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2488 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;






                    ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2543 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;





                                                                  ;
                                                                  ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__val < *__middle)
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2605 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val,
  _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;
# 2623 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
                    ;

                    ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val, __comp);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val, __comp);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2666 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




                                                                  ;
                                                                  ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val);
      return __i != __last && !(__val < *__i);
    }
# 2699 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;






                    ;

                    ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val, __comp);
      return __i != __last && !bool(__comp(__val, *__i));
    }




  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (*__last2 < *__last1)
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(*__last2, *__last1))
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   __buffer_end = std::copy(__middle, __last, __buffer);
   std::copy_backward(__first, __middle, __last);
   return std::copy(__buffer, __buffer_end, __first);
 }
      else if (__len1 <= __buffer_size)
 {
   __buffer_end = std::copy(__first, __middle, __buffer);
   std::copy(__middle, __last, __first);
   return std::copy_backward(__buffer, __buffer_end, __last);
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::merge((__buffer),
    (__buffer_end),
    (__middle),
    (__last),
    __first);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__merge_backward((__first),
    (__middle),
    (__buffer),
    (__buffer_end),
    __last);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last,
           *__first_cut);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle,
          *__second_cut);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer, __buffer_size);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer, typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::merge((__buffer),
    (__buffer_end),
    (__middle),
    (__last),
    __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__merge_backward((__first),
    (__middle),
    (__buffer),
    (__buffer_end),
    __last,__comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last, *__first_cut,
           __comp);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle, *__second_cut,
          __comp);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (*__middle < *__first)
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22);
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
                           _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (__comp(*__middle, *__first))
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut,
       __comp);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut,
      __comp);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }
# 3059 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;





                                                  ;
                                                 ;

      if (__first == __middle || __middle == __last)
 return;

      _DistanceType __len1 = std::distance(__first, __middle);
      _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1, __len2);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()));
    }
# 3114 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;






                                                               ;
                                                              ;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1,
        __len2, __comp);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()),
         __comp);
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result,
        _Distance __step_size)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::merge(
   (__first),
   (__first + __step_size),
   (__first + __step_size),
   (__first + __two_step),
   __result);
   __first += __two_step;
 }

      __step_size = std::min(_Distance(__last - __first), __step_size);
      std::merge((__first),
       (__first + __step_size),

       (__first + __step_size),

       (__last),
       __result);
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::merge(
   (__first),
   (__first + __step_size),
   (__first + __step_size),
   (__first + __two_step),
   __result, __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::merge((__first),
       (__first + __step_size),

       (__first + __step_size),

       (__last),
       __result, __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Pointer>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer, __step_size);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle,
          __buffer, __buffer_size);
   std::__stable_sort_adaptive(__middle, __last,
          __buffer, __buffer_size);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer);
   std::__merge_sort_with_buffer(__middle, __last, __buffer);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size);
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size,
                           _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }


  template<typename _RandomAccessIterator>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle);
      std::__inplace_stable_sort(__middle, __last);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
# 3412 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;






                                                                ;
                                                                ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first2 < *__first1)
   return false;
 else if(*__first1 < *__first2)
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 3461 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 3480 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first2, *__first1))
   return false;
 else if(__comp(*__first1, *__first2))
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 3516 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {





                                                     ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__i < *__ii)
     {
       _BidirectionalIterator __j = __last;
       while (!(*__i < *--__j))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3573 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {






                                                     ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__i, *__ii))
     {
       _BidirectionalIterator __j = __last;
       while (!bool(__comp(*__i, *--__j)))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3629 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {





                                                     ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__ii < *__i)
     {
       _BidirectionalIterator __j = __last;
       while (!(*--__j < *__i))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3686 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {






                                                     ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__ii, *__i))
     {
       _BidirectionalIterator __j = __last;
       while (!bool(__comp(*--__j, *__i)))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3746 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {






                                                     ;

      for (; __first != __last; ++__first, ++__result)
 if (*__first == __old_value)
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 3783 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {






                                                     ;

      for (; __first != __last; ++__first, ++__result)
 if (__pred(*__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 4161 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
}

namespace std __attribute__ ((__visibility__ ("default"))) {
# 4177 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {


                                                     ;
      for (; __first != __last; ++__first)
 __f(*__first);
      return (__f);
    }
# 4198 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {




                                                     ;
      return std::__find(__first, __last, __val,
           std::__iterator_category(__first));
    }
# 4222 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {




                                                     ;
      return std::__find_if(__first, __last, __pred,
       std::__iterator_category(__first));
    }
# 4251 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {






                                                       ;
                                                       ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
# 4290 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {






                                                       ;
                                                       ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
# 4322 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (*__first == *__next)
     return __first;
   __first = __next;
 }
      return __last;
    }
# 4354 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {





                                                     ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (__binary_pred(*__first, *__next))
     return __first;
   __first = __next;
 }
      return __last;
    }
# 4386 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {




                                                     ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (*__first == __value)
   ++__n;
      return __n;
    }
# 4411 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {




                                                     ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(*__first))
   ++__n;
      return __n;
    }
# 4451 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {






                                                       ;
                                                       ;


      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::find(__first1, __last1, *__first2);


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   __first1 = std::find(__first1, __last1, *__first2);
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (*__current == *__p)
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 4522 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {






                                                       ;
                                                       ;


      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 {
   while (__first1 != __last1
   && !bool(__predicate(*__first1, *__first2)))
     ++__first1;
   return __first1;
 }


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   while (__first1 != __last1
   && !bool(__predicate(*__first1, *__first2)))
     ++__first1;
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(*__current, *__p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 4596 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {




                                                     ;

      if (__count <= 0)
 return __first;
      if (__count == 1)
 return std::find(__first, __last, __val);
      return std::__search_n(__first, __last, __count, __val,
        std::__iterator_category(__first));
    }
# 4632 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {




                                                     ;

      if (__count <= 0)
 return __first;
      if (__count == 1)
 {
   while (__first != __last && !bool(__binary_pred(*__first, __val)))
     ++__first;
   return __first;
 }
      return std::__search_n(__first, __last, __count, __val, __binary_pred,
        std::__iterator_category(__first));
    }
# 4674 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {





                                                     ;

      for (; __first != __last; ++__first, ++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
# 4710 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {






                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 4743 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {







                                                     ;

      for (; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
# 4775 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {







                                                     ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
# 4807 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {




                                                     ;

      for (; __first != __last; ++__first)
 *__first = __gen();
    }
# 4838 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {





      for (; __n > 0; --__n, ++__first)
 *__first = __gen();
      return __first;
    }
# 4874 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {






                                                     ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4913 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {




                                                     ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result, __binary_pred,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4945 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {



                                                     ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   std::iter_swap(__i, __first + (std::rand() % ((__i - __first) + 1)));
    }
# 4973 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,



     _RandomNumberGenerator& __rand)

    {



                                                     ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __rand((__i - __first) + 1));
    }
# 5009 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }
# 5043 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                       ;
                                                      ;

      std::__heap_select(__first, __middle, __last);
      std::sort_heap(__first, __middle);
    }
# 5082 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;






                                                       ;
                                                      ;

      std::__heap_select(__first, __middle, __last, __comp);
      std::sort_heap(__first, __middle, __comp);
    }
# 5120 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                    ;
                                                   ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2);
    }
# 5159 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;






                                                    ;
                                                   ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2, __comp);
    }
# 5197 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                     ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2);
   std::__final_insertion_sort(__first, __last);
 }
    }
# 5233 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;






                                                     ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2, __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }
# 5274 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5294 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
                                                                ;
                                                                ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5337 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5358 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5397 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;





                                                     ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()));
    }
# 5439 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;







                                                     ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()), __comp);
    }
# 5485 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5506 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
                                                                ;
                                                                ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first1 < *__first2)
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5552 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5575 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first1, *__first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5619 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5638 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
                                                                ;
                                                                ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   ++__first1;
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 5676 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5697 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   ++__first1;
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 5734 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5753 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
                                                                ;
                                                                ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 5795 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5816 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 5853 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5874 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
                                                                ;
                                                                ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2, std::copy(__first1,
          __last1, __result));
    }
# 5919 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5943 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5976 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__first < *__result)
   __result = __first;
      return __result;
    }
# 6004 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {





                                                     ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__first, *__result))
   __result = __first;
      return __result;
    }
# 6032 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__result < *__first)
   __result = __first;
      return __result;
    }
# 6060 "/usr/include/c++/4.5.3/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {





                                                     ;

      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__result, *__first))
   __result = __first;
      return __result;
    }

}
# 63 "/usr/include/c++/4.5.3/algorithm" 2 3
# 35 "/home/pipping/Downloads/eigen-eigen-3.0.3/test/main.h" 2
# 1 "/usr/include/c++/4.5.3/sstream" 1 3
# 37 "/usr/include/c++/4.5.3/sstream" 3
# 37 "/usr/include/c++/4.5.3/sstream" 3




namespace std __attribute__ ((__visibility__ ("default"))) {
# 56 "/usr/include/c++/4.5.3/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

    protected:

      ios_base::openmode _M_mode;


      __string_type _M_string;

    public:
# 90 "/usr/include/c++/4.5.3/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
# 103 "/usr/include/c++/4.5.3/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
      { _M_stringbuf_init(__mode); }
# 118 "/usr/include/c++/4.5.3/sstream" 3
      __string_type
      str() const
      {
 __string_type __ret;
 if (this->pptr())
   {

     if (this->pptr() > this->egptr())
       __ret = __string_type(this->pbase(), this->pptr());
     else
        __ret = __string_type(this->pbase(), this->egptr());
   }
 else
   __ret = _M_string;
 return __ret;
      }
# 142 "/usr/include/c++/4.5.3/sstream" 3
      void
      str(const __string_type& __s)
      {

 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(_M_mode);
      }

    protected:

      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 _M_mode = __mode;
 __size_type __len = 0;
 if (_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }

      virtual streamsize
      showmanyc()
      {
 streamsize __ret = -1;
 if (_M_mode & ios_base::in)
   {
     _M_update_egptr();
     __ret = this->egptr() - this->gptr();
   }
 return __ret;
      }

      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = traits_type::eof());

      virtual int_type
      overflow(int_type __c = traits_type::eof());
# 194 "/usr/include/c++/4.5.3/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {






     _M_string.clear();


     _M_sync(__s, __n, 0);
   }
 return this;
      }

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);




      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o);



      void
      _M_update_egptr()
      {
 const bool __testin = _M_mode & ios_base::in;
 if (this->pptr() && this->pptr() > this->egptr())
   {
     if (__testin)
       this->setg(this->eback(), this->gptr(), this->pptr());
     else
       this->setg(this->pptr(), this->pptr(), this->pptr());
   }
      }
    };
# 254 "/usr/include/c++/4.5.3/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 290 "/usr/include/c++/4.5.3/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
# 308 "/usr/include/c++/4.5.3/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }







      ~basic_istringstream()
      { }
# 330 "/usr/include/c++/4.5.3/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 364 "/usr/include/c++/4.5.3/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 400 "/usr/include/c++/4.5.3/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
# 418 "/usr/include/c++/4.5.3/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }







      ~basic_ostringstream()
      { }
# 440 "/usr/include/c++/4.5.3/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 474 "/usr/include/c++/4.5.3/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 508 "/usr/include/c++/4.5.3/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
# 524 "/usr/include/c++/4.5.3/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }







      ~basic_stringstream()
      { }
# 546 "/usr/include/c++/4.5.3/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };

}



# 1 "/usr/include/c++/4.5.3/bits/sstream.tcc" 1 3
# 39 "/usr/include/c++/4.5.3/bits/sstream.tcc" 3
# 39 "/usr/include/c++/4.5.3/bits/sstream.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {


   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();

      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);

      const __size_type __capacity = _M_string.capacity();
      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();



      const char_type __conv = traits_type::to_char_type(__c);
      if (!__testput)
 {
# 109 "/usr/include/c++/4.5.3/bits/sstream.tcc" 3
   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp;
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   __tmp.push_back(__conv);
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      else
 *this->pptr() = __conv;
      this->pbump(1);
      return __c;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {

   _M_update_egptr();

   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);



      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();

   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;

   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->gbump((__beg + __newoffi) - this->gptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       this->pbump((__beg + __newoffo) - this->pptr());
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;

      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !off_type(__sp)) && (__testin || __testout))
 {
   _M_update_egptr();

   const off_type __pos(__sp);
   const bool __testpos = (0 <= __pos
      && __pos <= this->egptr() - __beg);
   if (__testpos)
     {
       if (__testin)
  this->gbump((__beg + __pos) - this->gptr());
       if (__testout)
                this->pbump((__beg + __pos) - this->pptr());
       __ret = __sp;
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_sync(char_type* __base, __size_type __i, __size_type __o)
    {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout = _M_mode & ios_base::out;
      char_type* __endg = __base + _M_string.size();
      char_type* __endp = __base + _M_string.capacity();

      if (__base != _M_string.data())
 {

   __endg += __i;
   __i = 0;
   __endp = __endg;
 }

      if (__testin)
 this->setg(__base, __base + __i, __endg);
      if (__testout)
 {
   this->setp(__base, __endp);
   this->pbump(__o);



   if (!__testin)
     this->setg(__endg, __endg, __endg);
 }
    }





  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;


  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;



}
# 573 "/usr/include/c++/4.5.3/sstream" 2 3
# 36 "/home/pipping/Downloads/eigen-eigen-3.0.3/test/main.h" 2
# 1 "/usr/include/c++/4.5.3/complex" 1 3
# 41 "/usr/include/c++/4.5.3/complex" 3
# 41 "/usr/include/c++/4.5.3/complex" 3




# 1 "/usr/include/c++/4.5.3/cmath" 1 3
# 41 "/usr/include/c++/4.5.3/cmath" 3
# 41 "/usr/include/c++/4.5.3/cmath" 3




# 1 "/usr/include/math.h" 1 3 4
# 30 "/usr/include/math.h" 3 4
extern "C" {




# 1 "/usr/include/bits/huge_val.h" 1 3 4
# 35 "/usr/include/math.h" 2 3 4

# 1 "/usr/include/bits/huge_valf.h" 1 3 4
# 37 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/huge_vall.h" 1 3 4
# 38 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/inf.h" 1 3 4
# 41 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/nan.h" 1 3 4
# 44 "/usr/include/math.h" 2 3 4



# 1 "/usr/include/bits/mathdef.h" 1 3 4
# 26 "/usr/include/bits/mathdef.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 27 "/usr/include/bits/mathdef.h" 2 3 4




typedef float float_t;
typedef double double_t;
# 48 "/usr/include/math.h" 2 3 4
# 71 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 55 "/usr/include/bits/mathcalls.h" 3 4
extern double acos (double __x) ; extern double __acos (double __x) ;

extern double asin (double __x) ; extern double __asin (double __x) ;

extern double atan (double __x) ; extern double __atan (double __x) ;

extern double atan2 (double __y, double __x) ; extern double __atan2 (double __y, double __x) ;


extern double cos (double __x) ; extern double __cos (double __x) ;

extern double sin (double __x) ; extern double __sin (double __x) ;

extern double tan (double __x) ; extern double __tan (double __x) ;




extern double cosh (double __x) ; extern double __cosh (double __x) ;

extern double sinh (double __x) ; extern double __sinh (double __x) ;

extern double tanh (double __x) ; extern double __tanh (double __x) ;




extern void sincos (double __x, double *__sinx, double *__cosx) ; extern void __sincos (double __x, double *__sinx, double *__cosx) ;






extern double acosh (double __x) ; extern double __acosh (double __x) ;

extern double asinh (double __x) ; extern double __asinh (double __x) ;

extern double atanh (double __x) ; extern double __atanh (double __x) ;







extern double exp (double __x) ; extern double __exp (double __x) ;


extern double frexp (double __x, int *__exponent) ; extern double __frexp (double __x, int *__exponent) ;


extern double ldexp (double __x, int __exponent) ; extern double __ldexp (double __x, int __exponent) ;


extern double log (double __x) ; extern double __log (double __x) ;


extern double log10 (double __x) ; extern double __log10 (double __x) ;


extern double modf (double __x, double *__iptr) ; extern double __modf (double __x, double *__iptr) ;




extern double exp10 (double __x) ; extern double __exp10 (double __x) ;

extern double pow10 (double __x) ; extern double __pow10 (double __x) ;





extern double expm1 (double __x) ; extern double __expm1 (double __x) ;


extern double log1p (double __x) ; extern double __log1p (double __x) ;


extern double logb (double __x) ; extern double __logb (double __x) ;






extern double exp2 (double __x) ; extern double __exp2 (double __x) ;


extern double log2 (double __x) ; extern double __log2 (double __x) ;
# 154 "/usr/include/bits/mathcalls.h" 3 4
extern double pow (double __x, double __y) ; extern double __pow (double __x, double __y) ;


extern double sqrt (double __x) ; extern double __sqrt (double __x) ;





extern double hypot (double __x, double __y) ; extern double __hypot (double __x, double __y) ;






extern double cbrt (double __x) ; extern double __cbrt (double __x) ;
# 179 "/usr/include/bits/mathcalls.h" 3 4
extern double ceil (double __x) __attribute__ ((__const__)); extern double __ceil (double __x) __attribute__ ((__const__));


extern double fabs (double __x) __attribute__ ((__const__)); extern double __fabs (double __x) __attribute__ ((__const__));


extern double floor (double __x) __attribute__ ((__const__)); extern double __floor (double __x) __attribute__ ((__const__));


extern double fmod (double __x, double __y) ; extern double __fmod (double __x, double __y) ;




extern int __isinf (double __value) __attribute__ ((__const__));


extern int __finite (double __value) __attribute__ ((__const__));





extern int isinf (double __value) __attribute__ ((__const__));


extern int finite (double __value) __attribute__ ((__const__));


extern double drem (double __x, double __y) ; extern double __drem (double __x, double __y) ;



extern double significand (double __x) ; extern double __significand (double __x) ;





extern double copysign (double __x, double __y) __attribute__ ((__const__)); extern double __copysign (double __x, double __y) __attribute__ ((__const__));






extern double nan (__const char *__tagb) __attribute__ ((__const__)); extern double __nan (__const char *__tagb) __attribute__ ((__const__));





extern int __isnan (double __value) __attribute__ ((__const__));



extern int isnan (double __value) __attribute__ ((__const__));


extern double j0 (double) ; extern double __j0 (double) ;
extern double j1 (double) ; extern double __j1 (double) ;
extern double jn (int, double) ; extern double __jn (int, double) ;
extern double y0 (double) ; extern double __y0 (double) ;
extern double y1 (double) ; extern double __y1 (double) ;
extern double yn (int, double) ; extern double __yn (int, double) ;






extern double erf (double) ; extern double __erf (double) ;
extern double erfc (double) ; extern double __erfc (double) ;
extern double lgamma (double) ; extern double __lgamma (double) ;






extern double tgamma (double) ; extern double __tgamma (double) ;





extern double gamma (double) ; extern double __gamma (double) ;






extern double lgamma_r (double, int *__signgamp) ; extern double __lgamma_r (double, int *__signgamp) ;







extern double rint (double __x) ; extern double __rint (double __x) ;


extern double nextafter (double __x, double __y) __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) __attribute__ ((__const__));



extern double remainder (double __x, double __y) ; extern double __remainder (double __x, double __y) ;



extern double scalbn (double __x, int __n) ; extern double __scalbn (double __x, int __n) ;



extern int ilogb (double __x) ; extern int __ilogb (double __x) ;




extern double scalbln (double __x, long int __n) ; extern double __scalbln (double __x, long int __n) ;



extern double nearbyint (double __x) ; extern double __nearbyint (double __x) ;



extern double round (double __x) __attribute__ ((__const__)); extern double __round (double __x) __attribute__ ((__const__));



extern double trunc (double __x) __attribute__ ((__const__)); extern double __trunc (double __x) __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) ; extern double __remquo (double __x, double __y, int *__quo) ;






extern long int lrint (double __x) ; extern long int __lrint (double __x) ;
extern long long int llrint (double __x) ; extern long long int __llrint (double __x) ;



extern long int lround (double __x) ; extern long int __lround (double __x) ;
extern long long int llround (double __x) ; extern long long int __llround (double __x) ;



extern double fdim (double __x, double __y) ; extern double __fdim (double __x, double __y) ;


extern double fmax (double __x, double __y) ; extern double __fmax (double __x, double __y) ;


extern double fmin (double __x, double __y) ; extern double __fmin (double __x, double __y) ;



extern int __fpclassify (double __value)
     __attribute__ ((__const__));


extern int __signbit (double __value)
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) ; extern double __fma (double __x, double __y, double __z) ;
# 364 "/usr/include/bits/mathcalls.h" 3 4
extern double scalb (double __x, double __n) ; extern double __scalb (double __x, double __n) ;
# 72 "/usr/include/math.h" 2 3 4
# 94 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 55 "/usr/include/bits/mathcalls.h" 3 4
extern float acosf (float __x) ; extern float __acosf (float __x) ;

extern float asinf (float __x) ; extern float __asinf (float __x) ;

extern float atanf (float __x) ; extern float __atanf (float __x) ;

extern float atan2f (float __y, float __x) ; extern float __atan2f (float __y, float __x) ;


extern float cosf (float __x) ; extern float __cosf (float __x) ;

extern float sinf (float __x) ; extern float __sinf (float __x) ;

extern float tanf (float __x) ; extern float __tanf (float __x) ;




extern float coshf (float __x) ; extern float __coshf (float __x) ;

extern float sinhf (float __x) ; extern float __sinhf (float __x) ;

extern float tanhf (float __x) ; extern float __tanhf (float __x) ;




extern void sincosf (float __x, float *__sinx, float *__cosx) ; extern void __sincosf (float __x, float *__sinx, float *__cosx) ;






extern float acoshf (float __x) ; extern float __acoshf (float __x) ;

extern float asinhf (float __x) ; extern float __asinhf (float __x) ;

extern float atanhf (float __x) ; extern float __atanhf (float __x) ;







extern float expf (float __x) ; extern float __expf (float __x) ;


extern float frexpf (float __x, int *__exponent) ; extern float __frexpf (float __x, int *__exponent) ;


extern float ldexpf (float __x, int __exponent) ; extern float __ldexpf (float __x, int __exponent) ;


extern float logf (float __x) ; extern float __logf (float __x) ;


extern float log10f (float __x) ; extern float __log10f (float __x) ;


extern float modff (float __x, float *__iptr) ; extern float __modff (float __x, float *__iptr) ;




extern float exp10f (float __x) ; extern float __exp10f (float __x) ;

extern float pow10f (float __x) ; extern float __pow10f (float __x) ;





extern float expm1f (float __x) ; extern float __expm1f (float __x) ;


extern float log1pf (float __x) ; extern float __log1pf (float __x) ;


extern float logbf (float __x) ; extern float __logbf (float __x) ;






extern float exp2f (float __x) ; extern float __exp2f (float __x) ;


extern float log2f (float __x) ; extern float __log2f (float __x) ;
# 154 "/usr/include/bits/mathcalls.h" 3 4
extern float powf (float __x, float __y) ; extern float __powf (float __x, float __y) ;


extern float sqrtf (float __x) ; extern float __sqrtf (float __x) ;





extern float hypotf (float __x, float __y) ; extern float __hypotf (float __x, float __y) ;






extern float cbrtf (float __x) ; extern float __cbrtf (float __x) ;
# 179 "/usr/include/bits/mathcalls.h" 3 4
extern float ceilf (float __x) __attribute__ ((__const__)); extern float __ceilf (float __x) __attribute__ ((__const__));


extern float fabsf (float __x) __attribute__ ((__const__)); extern float __fabsf (float __x) __attribute__ ((__const__));


extern float floorf (float __x) __attribute__ ((__const__)); extern float __floorf (float __x) __attribute__ ((__const__));


extern float fmodf (float __x, float __y) ; extern float __fmodf (float __x, float __y) ;




extern int __isinff (float __value) __attribute__ ((__const__));


extern int __finitef (float __value) __attribute__ ((__const__));





extern int isinff (float __value) __attribute__ ((__const__));


extern int finitef (float __value) __attribute__ ((__const__));


extern float dremf (float __x, float __y) ; extern float __dremf (float __x, float __y) ;



extern float significandf (float __x) ; extern float __significandf (float __x) ;





extern float copysignf (float __x, float __y) __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) __attribute__ ((__const__));






extern float nanf (__const char *__tagb) __attribute__ ((__const__)); extern float __nanf (__const char *__tagb) __attribute__ ((__const__));





extern int __isnanf (float __value) __attribute__ ((__const__));



extern int isnanf (float __value) __attribute__ ((__const__));


extern float j0f (float) ; extern float __j0f (float) ;
extern float j1f (float) ; extern float __j1f (float) ;
extern float jnf (int, float) ; extern float __jnf (int, float) ;
extern float y0f (float) ; extern float __y0f (float) ;
extern float y1f (float) ; extern float __y1f (float) ;
extern float ynf (int, float) ; extern float __ynf (int, float) ;






extern float erff (float) ; extern float __erff (float) ;
extern float erfcf (float) ; extern float __erfcf (float) ;
extern float lgammaf (float) ; extern float __lgammaf (float) ;






extern float tgammaf (float) ; extern float __tgammaf (float) ;





extern float gammaf (float) ; extern float __gammaf (float) ;






extern float lgammaf_r (float, int *__signgamp) ; extern float __lgammaf_r (float, int *__signgamp) ;







extern float rintf (float __x) ; extern float __rintf (float __x) ;


extern float nextafterf (float __x, float __y) __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) __attribute__ ((__const__));



extern float remainderf (float __x, float __y) ; extern float __remainderf (float __x, float __y) ;



extern float scalbnf (float __x, int __n) ; extern float __scalbnf (float __x, int __n) ;



extern int ilogbf (float __x) ; extern int __ilogbf (float __x) ;




extern float scalblnf (float __x, long int __n) ; extern float __scalblnf (float __x, long int __n) ;



extern float nearbyintf (float __x) ; extern float __nearbyintf (float __x) ;



extern float roundf (float __x) __attribute__ ((__const__)); extern float __roundf (float __x) __attribute__ ((__const__));



extern float truncf (float __x) __attribute__ ((__const__)); extern float __truncf (float __x) __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) ; extern float __remquof (float __x, float __y, int *__quo) ;






extern long int lrintf (float __x) ; extern long int __lrintf (float __x) ;
extern long long int llrintf (float __x) ; extern long long int __llrintf (float __x) ;



extern long int lroundf (float __x) ; extern long int __lroundf (float __x) ;
extern long long int llroundf (float __x) ; extern long long int __llroundf (float __x) ;



extern float fdimf (float __x, float __y) ; extern float __fdimf (float __x, float __y) ;


extern float fmaxf (float __x, float __y) ; extern float __fmaxf (float __x, float __y) ;


extern float fminf (float __x, float __y) ; extern float __fminf (float __x, float __y) ;



extern int __fpclassifyf (float __value)
     __attribute__ ((__const__));


extern int __signbitf (float __value)
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) ; extern float __fmaf (float __x, float __y, float __z) ;
# 364 "/usr/include/bits/mathcalls.h" 3 4
extern float scalbf (float __x, float __n) ; extern float __scalbf (float __x, float __n) ;
# 95 "/usr/include/math.h" 2 3 4
# 141 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 55 "/usr/include/bits/mathcalls.h" 3 4
extern long double acosl (long double __x) ; extern long double __acosl (long double __x) ;

extern long double asinl (long double __x) ; extern long double __asinl (long double __x) ;

extern long double atanl (long double __x) ; extern long double __atanl (long double __x) ;

extern long double atan2l (long double __y, long double __x) ; extern long double __atan2l (long double __y, long double __x) ;


extern long double cosl (long double __x) ; extern long double __cosl (long double __x) ;

extern long double sinl (long double __x) ; extern long double __sinl (long double __x) ;

extern long double tanl (long double __x) ; extern long double __tanl (long double __x) ;




extern long double coshl (long double __x) ; extern long double __coshl (long double __x) ;

extern long double sinhl (long double __x) ; extern long double __sinhl (long double __x) ;

extern long double tanhl (long double __x) ; extern long double __tanhl (long double __x) ;




extern void sincosl (long double __x, long double *__sinx, long double *__cosx) ; extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) ;






extern long double acoshl (long double __x) ; extern long double __acoshl (long double __x) ;

extern long double asinhl (long double __x) ; extern long double __asinhl (long double __x) ;

extern long double atanhl (long double __x) ; extern long double __atanhl (long double __x) ;







extern long double expl (long double __x) ; extern long double __expl (long double __x) ;


extern long double frexpl (long double __x, int *__exponent) ; extern long double __frexpl (long double __x, int *__exponent) ;


extern long double ldexpl (long double __x, int __exponent) ; extern long double __ldexpl (long double __x, int __exponent) ;


extern long double logl (long double __x) ; extern long double __logl (long double __x) ;


extern long double log10l (long double __x) ; extern long double __log10l (long double __x) ;


extern long double modfl (long double __x, long double *__iptr) ; extern long double __modfl (long double __x, long double *__iptr) ;




extern long double exp10l (long double __x) ; extern long double __exp10l (long double __x) ;

extern long double pow10l (long double __x) ; extern long double __pow10l (long double __x) ;





extern long double expm1l (long double __x) ; extern long double __expm1l (long double __x) ;


extern long double log1pl (long double __x) ; extern long double __log1pl (long double __x) ;


extern long double logbl (long double __x) ; extern long double __logbl (long double __x) ;






extern long double exp2l (long double __x) ; extern long double __exp2l (long double __x) ;


extern long double log2l (long double __x) ; extern long double __log2l (long double __x) ;
# 154 "/usr/include/bits/mathcalls.h" 3 4
extern long double powl (long double __x, long double __y) ; extern long double __powl (long double __x, long double __y) ;


extern long double sqrtl (long double __x) ; extern long double __sqrtl (long double __x) ;





extern long double hypotl (long double __x, long double __y) ; extern long double __hypotl (long double __x, long double __y) ;






extern long double cbrtl (long double __x) ; extern long double __cbrtl (long double __x) ;
# 179 "/usr/include/bits/mathcalls.h" 3 4
extern long double ceill (long double __x) __attribute__ ((__const__)); extern long double __ceill (long double __x) __attribute__ ((__const__));


extern long double fabsl (long double __x) __attribute__ ((__const__)); extern long double __fabsl (long double __x) __attribute__ ((__const__));


extern long double floorl (long double __x) __attribute__ ((__const__)); extern long double __floorl (long double __x) __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) ; extern long double __fmodl (long double __x, long double __y) ;




extern int __isinfl (long double __value) __attribute__ ((__const__));


extern int __finitel (long double __value) __attribute__ ((__const__));





extern int isinfl (long double __value) __attribute__ ((__const__));


extern int finitel (long double __value) __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) ; extern long double __dreml (long double __x, long double __y) ;



extern long double significandl (long double __x) ; extern long double __significandl (long double __x) ;





extern long double copysignl (long double __x, long double __y) __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) __attribute__ ((__const__));






extern long double nanl (__const char *__tagb) __attribute__ ((__const__)); extern long double __nanl (__const char *__tagb) __attribute__ ((__const__));





extern int __isnanl (long double __value) __attribute__ ((__const__));



extern int isnanl (long double __value) __attribute__ ((__const__));


extern long double j0l (long double) ; extern long double __j0l (long double) ;
extern long double j1l (long double) ; extern long double __j1l (long double) ;
extern long double jnl (int, long double) ; extern long double __jnl (int, long double) ;
extern long double y0l (long double) ; extern long double __y0l (long double) ;
extern long double y1l (long double) ; extern long double __y1l (long double) ;
extern long double ynl (int, long double) ; extern long double __ynl (int, long double) ;






extern long double erfl (long double) ; extern long double __erfl (long double) ;
extern long double erfcl (long double) ; extern long double __erfcl (long double) ;
extern long double lgammal (long double) ; extern long double __lgammal (long double) ;






extern long double tgammal (long double) ; extern long double __tgammal (long double) ;





extern long double gammal (long double) ; extern long double __gammal (long double) ;






extern long double lgammal_r (long double, int *__signgamp) ; extern long double __lgammal_r (long double, int *__signgamp) ;







extern long double rintl (long double __x) ; extern long double __rintl (long double __x) ;


extern long double nextafterl (long double __x, long double __y) __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) __attribute__ ((__const__));



extern long double remainderl (long double __x, long double __y) ; extern long double __remainderl (long double __x, long double __y) ;



extern long double scalbnl (long double __x, int __n) ; extern long double __scalbnl (long double __x, int __n) ;



extern int ilogbl (long double __x) ; extern int __ilogbl (long double __x) ;




extern long double scalblnl (long double __x, long int __n) ; extern long double __scalblnl (long double __x, long int __n) ;



extern long double nearbyintl (long double __x) ; extern long double __nearbyintl (long double __x) ;



extern long double roundl (long double __x) __attribute__ ((__const__)); extern long double __roundl (long double __x) __attribute__ ((__const__));



extern long double truncl (long double __x) __attribute__ ((__const__)); extern long double __truncl (long double __x) __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) ; extern long double __remquol (long double __x, long double __y, int *__quo) ;






extern long int lrintl (long double __x) ; extern long int __lrintl (long double __x) ;
extern long long int llrintl (long double __x) ; extern long long int __llrintl (long double __x) ;



extern long int lroundl (long double __x) ; extern long int __lroundl (long double __x) ;
extern long long int llroundl (long double __x) ; extern long long int __llroundl (long double __x) ;



extern long double fdiml (long double __x, long double __y) ; extern long double __fdiml (long double __x, long double __y) ;


extern long double fmaxl (long double __x, long double __y) ; extern long double __fmaxl (long double __x, long double __y) ;


extern long double fminl (long double __x, long double __y) ; extern long double __fminl (long double __x, long double __y) ;



extern int __fpclassifyl (long double __value)
     __attribute__ ((__const__));


extern int __signbitl (long double __value)
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) ; extern long double __fmal (long double __x, long double __y, long double __z) ;
# 364 "/usr/include/bits/mathcalls.h" 3 4
extern long double scalbl (long double __x, long double __n) ; extern long double __scalbl (long double __x, long double __n) ;
# 142 "/usr/include/math.h" 2 3 4
# 157 "/usr/include/math.h" 3 4
extern int signgam;
# 198 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN,

    FP_INFINITE,

    FP_ZERO,

    FP_SUBNORMAL,

    FP_NORMAL

  };
# 291 "/usr/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
# 314 "/usr/include/math.h" 3 4
struct __exception



  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };


extern int matherr (struct __exception *__exc) ;
# 472 "/usr/include/math.h" 3 4
}
# 46 "/usr/include/c++/4.5.3/cmath" 2 3
# 76 "/usr/include/c++/4.5.3/cmath" 3
namespace std __attribute__ ((__visibility__ ("default"))) {



  template<typename _Tp>
    _Tp __cmath_power(_Tp, unsigned int);

  template<typename _Tp>
    inline _Tp
    __pow_helper(_Tp __x, int __n)
    {
      return __n < 0
        ? _Tp(1)/__cmath_power(__x, -__n)
        : __cmath_power(__x, __n);
    }

  inline double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    abs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::acos;

  inline float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline long double
  acos(long double __x)
  { return __builtin_acosl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;

  inline float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline long double
  asin(long double __x)
  { return __builtin_asinl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;

  inline float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline long double
  atan(long double __x)
  { return __builtin_atanl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;

  inline float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }

  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<
    typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value
        && __is_arithmetic<_Up>::__value,
        _Tp>::__type, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;

  inline float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;

  inline float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline long double
  cos(long double __x)
  { return __builtin_cosl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;

  inline float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;

  inline float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline long double
  exp(long double __x)
  { return __builtin_expl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;

  inline float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;

  inline float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline long double
  floor(long double __x)
  { return __builtin_floorl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;

  inline float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }

  using ::frexp;

  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;

  inline float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
  ldexp(_Tp __x, int __exp)
  { return __builtin_ldexp(__x, __exp); }

  using ::log;

  inline float
  log(float __x)
  { return __builtin_logf(__x); }

  inline long double
  log(long double __x)
  { return __builtin_logl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;

  inline float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline long double
  log10(long double __x)
  { return __builtin_log10l(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;

  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }

  using ::pow;

  inline float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }




  inline double
  pow(double __x, int __i)
  { return __builtin_powi(__x, __i); }

  inline float
  pow(float __x, int __n)
  { return __builtin_powif(__x, __n); }

  inline long double
  pow(long double __x, int __n)
  { return __builtin_powil(__x, __n); }


  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<
    typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value
        && __is_arithmetic<_Up>::__value,
        _Tp>::__type, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;

  inline float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline long double
  sin(long double __x)
  { return __builtin_sinl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;

  inline float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;

  inline float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;

  inline float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline long double
  tan(long double __x)
  { return __builtin_tanl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;

  inline float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }

}
# 497 "/usr/include/c++/4.5.3/cmath" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    fpclassify(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL,
      FP_SUBNORMAL, FP_ZERO, __type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isfinite(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isfinite(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isinf(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isinf(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isnan(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isnan(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isnormal(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isnormal(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    signbit(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_signbit(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isgreater(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isgreater(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isgreaterequal(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isgreaterequal(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isless(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isless(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    islessequal(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_islessequal(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    islessgreater(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_islessgreater(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isunordered(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isunordered(__type(__f1), __type(__f2));
    }

}






# 1 "/usr/include/c++/4.5.3/bits/cmath.tcc" 1 3
# 35 "/usr/include/c++/4.5.3/bits/cmath.tcc" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Tp>
    inline _Tp
    __cmath_power(_Tp __x, unsigned int __n)
    {
      _Tp __y = __n % 2 ? __x : _Tp(1);

      while (__n >>= 1)
        {
          __x = __x * __x;
          if (__n % 2)
            __y = __y * __x;
        }

      return __y;
    }

}
# 615 "/usr/include/c++/4.5.3/cmath" 2 3
# 46 "/usr/include/c++/4.5.3/complex" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {
# 59 "/usr/include/c++/4.5.3/complex" 3
  template<typename _Tp> class complex;
  template<> class complex<float>;
  template<> class complex<double>;
  template<> class complex<long double>;


  template<typename _Tp> _Tp abs(const complex<_Tp>&);

  template<typename _Tp> _Tp arg(const complex<_Tp>&);

  template<typename _Tp> _Tp norm(const complex<_Tp>&);


  template<typename _Tp> complex<_Tp> conj(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> polar(const _Tp&, const _Tp& = 0);



  template<typename _Tp> complex<_Tp> cos(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> cosh(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> exp(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> log(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> log10(const complex<_Tp>&);



  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, int);


  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, const _Tp&);

  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&,
                                          const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> pow(const _Tp&, const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sin(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sinh(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sqrt(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> tan(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> tanh(const complex<_Tp>&);
# 120 "/usr/include/c++/4.5.3/complex" 3
  template<typename _Tp>
    struct complex
    {

      typedef _Tp value_type;



      complex(const _Tp& __r = _Tp(), const _Tp& __i = _Tp())
      : _M_real(__r), _M_imag(__i) { }




      template<typename _Up>
        complex(const complex<_Up>& __z)
 : _M_real(__z.real()), _M_imag(__z.imag()) { }
# 148 "/usr/include/c++/4.5.3/complex" 3
      _Tp& real()
      { return _M_real; }


      const _Tp& real() const
      { return _M_real; }


      _Tp& imag()
      { return _M_imag; }


      const _Tp& imag() const
      { return _M_imag; }




      void real(_Tp __val)
      { _M_real = __val; }

      void imag(_Tp __val)
      { _M_imag = __val; }


      complex<_Tp>& operator=(const _Tp&);



      complex<_Tp>&
      operator+=(const _Tp& __t)
      {
 _M_real += __t;
 return *this;
      }



      complex<_Tp>&
      operator-=(const _Tp& __t)
      {
 _M_real -= __t;
 return *this;
      }


      complex<_Tp>& operator*=(const _Tp&);

      complex<_Tp>& operator/=(const _Tp&);





      template<typename _Up>
        complex<_Tp>& operator=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator+=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator-=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator*=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator/=(const complex<_Up>&);

      const complex& __rep() const
      { return *this; }

    private:
      _Tp _M_real;
      _Tp _M_imag;
    };

  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator=(const _Tp& __t)
    {
     _M_real = __t;
     _M_imag = _Tp();
     return *this;
    }


  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator*=(const _Tp& __t)
    {
      _M_real *= __t;
      _M_imag *= __t;
      return *this;
    }


  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator/=(const _Tp& __t)
    {
      _M_real /= __t;
      _M_imag /= __t;
      return *this;
    }

  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator=(const complex<_Up>& __z)
    {
      _M_real = __z.real();
      _M_imag = __z.imag();
      return *this;
    }


  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator+=(const complex<_Up>& __z)
    {
      _M_real += __z.real();
      _M_imag += __z.imag();
      return *this;
    }


  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator-=(const complex<_Up>& __z)
    {
      _M_real -= __z.real();
      _M_imag -= __z.imag();
      return *this;
    }



  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator*=(const complex<_Up>& __z)
    {
      const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
      _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
      _M_real = __r;
      return *this;
    }



  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator/=(const complex<_Up>& __z)
    {
      const _Tp __r = _M_real * __z.real() + _M_imag * __z.imag();
      const _Tp __n = std::norm(__z);
      _M_imag = (_M_imag * __z.real() - _M_real * __z.imag()) / __n;
      _M_real = __r / __n;
      return *this;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r += __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r += __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator+(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __y;
      __r += __x;
      return __r;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r -= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r -= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator-(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r(__x, -__y.imag());
      __r -= __y.real();
      return __r;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator*(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r *= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator*(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r *= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator*(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __y;
      __r *= __x;
      return __r;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator/(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator/(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator/(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }



  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x)
    { return __x; }


  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x)
    { return complex<_Tp>(-__x.real(), -__x.imag()); }



  template<typename _Tp>
    inline bool
    operator==(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x.real() == __y.real() && __x.imag() == __y.imag(); }

  template<typename _Tp>
    inline bool
    operator==(const complex<_Tp>& __x, const _Tp& __y)
    { return __x.real() == __y && __x.imag() == _Tp(); }

  template<typename _Tp>
    inline bool
    operator==(const _Tp& __x, const complex<_Tp>& __y)
    { return __x == __y.real() && _Tp() == __y.imag(); }




  template<typename _Tp>
    inline bool
    operator!=(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x.real() != __y.real() || __x.imag() != __y.imag(); }

  template<typename _Tp>
    inline bool
    operator!=(const complex<_Tp>& __x, const _Tp& __y)
    { return __x.real() != __y || __x.imag() != _Tp(); }

  template<typename _Tp>
    inline bool
    operator!=(const _Tp& __x, const complex<_Tp>& __y)
    { return __x != __y.real() || _Tp() != __y.imag(); }



  template<typename _Tp, typename _CharT, class _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, complex<_Tp>& __x)
    {
      _Tp __re_x, __im_x;
      _CharT __ch;
      __is >> __ch;
      if (__ch == '(')
 {
   __is >> __re_x >> __ch;
   if (__ch == ',')
     {
       __is >> __im_x >> __ch;
       if (__ch == ')')
  __x = complex<_Tp>(__re_x, __im_x);
       else
  __is.setstate(ios_base::failbit);
     }
   else if (__ch == ')')
     __x = __re_x;
   else
     __is.setstate(ios_base::failbit);
 }
      else
 {
   __is.putback(__ch);
   __is >> __re_x;
   __x = __re_x;
 }
      return __is;
    }


  template<typename _Tp, typename _CharT, class _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const complex<_Tp>& __x)
    {
      basic_ostringstream<_CharT, _Traits> __s;
      __s.flags(__os.flags());
      __s.imbue(__os.getloc());
      __s.precision(__os.precision());
      __s << '(' << __x.real() << ',' << __x.imag() << ')';
      return __os << __s.str();
    }
# 540 "/usr/include/c++/4.5.3/complex" 3
  template<typename _Tp>
    inline _Tp&
    real(complex<_Tp>& __z)
    { return __z.real(); }

  template<typename _Tp>
    inline const _Tp&
    real(const complex<_Tp>& __z)
    { return __z.real(); }

  template<typename _Tp>
    inline _Tp&
    imag(complex<_Tp>& __z)
    { return __z.imag(); }

  template<typename _Tp>
    inline const _Tp&
    imag(const complex<_Tp>& __z)
    { return __z.imag(); }



  template<typename _Tp>
    inline _Tp
    __complex_abs(const complex<_Tp>& __z)
    {
      _Tp __x = __z.real();
      _Tp __y = __z.imag();
      const _Tp __s = std::max(abs(__x), abs(__y));
      if (__s == _Tp())
        return __s;
      __x /= __s;
      __y /= __s;
      return __s * sqrt(__x * __x + __y * __y);
    }


  inline float
  __complex_abs(__complex__ float __z) { return __builtin_cabsf(__z); }

  inline double
  __complex_abs(__complex__ double __z) { return __builtin_cabs(__z); }

  inline long double
  __complex_abs(const __complex__ long double& __z)
  { return __builtin_cabsl(__z); }

  template<typename _Tp>
    inline _Tp
    abs(const complex<_Tp>& __z) { return __complex_abs(__z.__rep()); }
# 598 "/usr/include/c++/4.5.3/complex" 3
  template<typename _Tp>
    inline _Tp
    __complex_arg(const complex<_Tp>& __z)
    { return atan2(__z.imag(), __z.real()); }


  inline float
  __complex_arg(__complex__ float __z) { return __builtin_cargf(__z); }

  inline double
  __complex_arg(__complex__ double __z) { return __builtin_carg(__z); }

  inline long double
  __complex_arg(const __complex__ long double& __z)
  { return __builtin_cargl(__z); }

  template<typename _Tp>
    inline _Tp
    arg(const complex<_Tp>& __z) { return __complex_arg(__z.__rep()); }
# 628 "/usr/include/c++/4.5.3/complex" 3
  template<bool>
    struct _Norm_helper
    {
      template<typename _Tp>
        static inline _Tp _S_do_it(const complex<_Tp>& __z)
        {
          const _Tp __x = __z.real();
          const _Tp __y = __z.imag();
          return __x * __x + __y * __y;
        }
    };

  template<>
    struct _Norm_helper<true>
    {
      template<typename _Tp>
        static inline _Tp _S_do_it(const complex<_Tp>& __z)
        {
          _Tp __res = std::abs(__z);
          return __res * __res;
        }
    };

  template<typename _Tp>
    inline _Tp
    norm(const complex<_Tp>& __z)
    {
      return _Norm_helper<__is_floating<_Tp>::__value
 && !0>::_S_do_it(__z);
    }

  template<typename _Tp>
    inline complex<_Tp>
    polar(const _Tp& __rho, const _Tp& __theta)
    { return complex<_Tp>(__rho * cos(__theta), __rho * sin(__theta)); }

  template<typename _Tp>
    inline complex<_Tp>
    conj(const complex<_Tp>& __z)
    { return complex<_Tp>(__z.real(), -__z.imag()); }




  template<typename _Tp>
    inline complex<_Tp>
    __complex_cos(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(cos(__x) * cosh(__y), -sin(__x) * sinh(__y));
    }


  inline __complex__ float
  __complex_cos(__complex__ float __z) { return __builtin_ccosf(__z); }

  inline __complex__ double
  __complex_cos(__complex__ double __z) { return __builtin_ccos(__z); }

  inline __complex__ long double
  __complex_cos(const __complex__ long double& __z)
  { return __builtin_ccosl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    cos(const complex<_Tp>& __z) { return __complex_cos(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_cosh(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(cosh(__x) * cos(__y), sinh(__x) * sin(__y));
    }


  inline __complex__ float
  __complex_cosh(__complex__ float __z) { return __builtin_ccoshf(__z); }

  inline __complex__ double
  __complex_cosh(__complex__ double __z) { return __builtin_ccosh(__z); }

  inline __complex__ long double
  __complex_cosh(const __complex__ long double& __z)
  { return __builtin_ccoshl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    cosh(const complex<_Tp>& __z) { return __complex_cosh(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_exp(const complex<_Tp>& __z)
    { return std::polar(exp(__z.real()), __z.imag()); }


  inline __complex__ float
  __complex_exp(__complex__ float __z) { return __builtin_cexpf(__z); }

  inline __complex__ double
  __complex_exp(__complex__ double __z) { return __builtin_cexp(__z); }

  inline __complex__ long double
  __complex_exp(const __complex__ long double& __z)
  { return __builtin_cexpl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    exp(const complex<_Tp>& __z) { return __complex_exp(__z.__rep()); }
# 759 "/usr/include/c++/4.5.3/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_log(const complex<_Tp>& __z)
    { return complex<_Tp>(log(std::abs(__z)), std::arg(__z)); }


  inline __complex__ float
  __complex_log(__complex__ float __z) { return __builtin_clogf(__z); }

  inline __complex__ double
  __complex_log(__complex__ double __z) { return __builtin_clog(__z); }

  inline __complex__ long double
  __complex_log(const __complex__ long double& __z)
  { return __builtin_clogl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    log(const complex<_Tp>& __z) { return __complex_log(__z.__rep()); }






  template<typename _Tp>
    inline complex<_Tp>
    log10(const complex<_Tp>& __z)
    { return std::log(__z) / log(_Tp(10.0)); }


  template<typename _Tp>
    inline complex<_Tp>
    __complex_sin(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(sin(__x) * cosh(__y), cos(__x) * sinh(__y));
    }


  inline __complex__ float
  __complex_sin(__complex__ float __z) { return __builtin_csinf(__z); }

  inline __complex__ double
  __complex_sin(__complex__ double __z) { return __builtin_csin(__z); }

  inline __complex__ long double
  __complex_sin(const __complex__ long double& __z)
  { return __builtin_csinl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sin(const complex<_Tp>& __z) { return __complex_sin(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_sinh(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(sinh(__x) * cos(__y), cosh(__x) * sin(__y));
    }


  inline __complex__ float
  __complex_sinh(__complex__ float __z) { return __builtin_csinhf(__z); }

  inline __complex__ double
  __complex_sinh(__complex__ double __z) { return __builtin_csinh(__z); }

  inline __complex__ long double
  __complex_sinh(const __complex__ long double& __z)
  { return __builtin_csinhl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sinh(const complex<_Tp>& __z) { return __complex_sinh(__z.__rep()); }
# 851 "/usr/include/c++/4.5.3/complex" 3
  template<typename _Tp>
    complex<_Tp>
    __complex_sqrt(const complex<_Tp>& __z)
    {
      _Tp __x = __z.real();
      _Tp __y = __z.imag();

      if (__x == _Tp())
        {
          _Tp __t = sqrt(abs(__y) / 2);
          return complex<_Tp>(__t, __y < _Tp() ? -__t : __t);
        }
      else
        {
          _Tp __t = sqrt(2 * (std::abs(__z) + abs(__x)));
          _Tp __u = __t / 2;
          return __x > _Tp()
            ? complex<_Tp>(__u, __y / __t)
            : complex<_Tp>(abs(__y) / __t, __y < _Tp() ? -__u : __u);
        }
    }


  inline __complex__ float
  __complex_sqrt(__complex__ float __z) { return __builtin_csqrtf(__z); }

  inline __complex__ double
  __complex_sqrt(__complex__ double __z) { return __builtin_csqrt(__z); }

  inline __complex__ long double
  __complex_sqrt(const __complex__ long double& __z)
  { return __builtin_csqrtl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sqrt(const complex<_Tp>& __z) { return __complex_sqrt(__z.__rep()); }
# 895 "/usr/include/c++/4.5.3/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_tan(const complex<_Tp>& __z)
    { return std::sin(__z) / std::cos(__z); }


  inline __complex__ float
  __complex_tan(__complex__ float __z) { return __builtin_ctanf(__z); }

  inline __complex__ double
  __complex_tan(__complex__ double __z) { return __builtin_ctan(__z); }

  inline __complex__ long double
  __complex_tan(const __complex__ long double& __z)
  { return __builtin_ctanl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    tan(const complex<_Tp>& __z) { return __complex_tan(__z.__rep()); }
# 923 "/usr/include/c++/4.5.3/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_tanh(const complex<_Tp>& __z)
    { return std::sinh(__z) / std::cosh(__z); }


  inline __complex__ float
  __complex_tanh(__complex__ float __z) { return __builtin_ctanhf(__z); }

  inline __complex__ double
  __complex_tanh(__complex__ double __z) { return __builtin_ctanh(__z); }

  inline __complex__ long double
  __complex_tanh(const __complex__ long double& __z)
  { return __builtin_ctanhl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    tanh(const complex<_Tp>& __z) { return __complex_tanh(__z.__rep()); }
# 955 "/usr/include/c++/4.5.3/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    pow(const complex<_Tp>& __z, int __n)
    { return std::__pow_helper(__z, __n); }


  template<typename _Tp>
    complex<_Tp>
    pow(const complex<_Tp>& __x, const _Tp& __y)
    {




      if (__x.imag() == _Tp() && __x.real() > _Tp())
        return pow(__x.real(), __y);

      complex<_Tp> __t = std::log(__x);
      return std::polar(exp(__y * __t.real()), __y * __t.imag());
    }

  template<typename _Tp>
    inline complex<_Tp>
    __complex_pow(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x == _Tp() ? _Tp() : std::exp(__y * std::log(__x)); }


  inline __complex__ float
  __complex_pow(__complex__ float __x, __complex__ float __y)
  { return __builtin_cpowf(__x, __y); }

  inline __complex__ double
  __complex_pow(__complex__ double __x, __complex__ double __y)
  { return __builtin_cpow(__x, __y); }

  inline __complex__ long double
  __complex_pow(const __complex__ long double& __x,
  const __complex__ long double& __y)
  { return __builtin_cpowl(__x, __y); }

  template<typename _Tp>
    inline complex<_Tp>
    pow(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __complex_pow(__x.__rep(), __y.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    pow(const _Tp& __x, const complex<_Tp>& __y)
    {
      return __x > _Tp() ? std::polar(pow(__x, __y.real()),
          __y.imag() * log(__x))
                  : std::pow(complex<_Tp>(__x), __y);
    }



  template<>
    struct complex<float>
    {
      typedef float value_type;
      typedef __complex__ float _ComplexT;

      complex(_ComplexT __z) : _M_value(__z) { }

      complex(float __r = 0.0f, float __i = 0.0f)
      {
 __real__ _M_value = __r;
 __imag__ _M_value = __i;
      }

      explicit complex(const complex<double>&);
      explicit complex(const complex<long double>&);
# 1043 "/usr/include/c++/4.5.3/complex" 3
      float& real()
      { return __real__ _M_value; }

      const float& real() const
      { return __real__ _M_value; }

      float& imag()
      { return __imag__ _M_value; }

      const float& imag() const
      { return __imag__ _M_value; }




      void real(float __val)
      { __real__ _M_value = __val; }

      void imag(float __val)
      { __imag__ _M_value = __val; }

      complex<float>&
      operator=(float __f)
      {
 __real__ _M_value = __f;
 __imag__ _M_value = 0.0f;
 return *this;
      }

      complex<float>&
      operator+=(float __f)
      {
 __real__ _M_value += __f;
 return *this;
      }

      complex<float>&
      operator-=(float __f)
      {
 __real__ _M_value -= __f;
 return *this;
      }

      complex<float>&
      operator*=(float __f)
      {
 _M_value *= __f;
 return *this;
      }

      complex<float>&
      operator/=(float __f)
      {
 _M_value /= __f;
 return *this;
      }





      template<typename _Tp>
        complex<float>&
        operator=(const complex<_Tp>& __z)
 {
   __real__ _M_value = __z.real();
   __imag__ _M_value = __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex<float>&
        operator+=(const complex<_Tp>& __z)
 {
   __real__ _M_value += __z.real();
   __imag__ _M_value += __z.imag();
   return *this;
 }

      template<class _Tp>
        complex<float>&
        operator-=(const complex<_Tp>& __z)
 {
   __real__ _M_value -= __z.real();
   __imag__ _M_value -= __z.imag();
   return *this;
 }

      template<class _Tp>
        complex<float>&
        operator*=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value *= __t;
   return *this;
 }

      template<class _Tp>
        complex<float>&
        operator/=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value /= __t;
   return *this;
 }

      const _ComplexT& __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  template<>
    struct complex<double>
    {
      typedef double value_type;
      typedef __complex__ double _ComplexT;

      complex(_ComplexT __z) : _M_value(__z) { }

      complex(double __r = 0.0, double __i = 0.0)
      {
 __real__ _M_value = __r;
 __imag__ _M_value = __i;
      }

      complex(const complex<float>& __z)
      : _M_value(__z.__rep()) { }

      explicit complex(const complex<long double>&);
# 1189 "/usr/include/c++/4.5.3/complex" 3
      double& real()
      { return __real__ _M_value; }

      const double& real() const
      { return __real__ _M_value; }

      double& imag()
      { return __imag__ _M_value; }

      const double& imag() const
      { return __imag__ _M_value; }




      void real(double __val)
      { __real__ _M_value = __val; }

      void imag(double __val)
      { __imag__ _M_value = __val; }

      complex<double>&
      operator=(double __d)
      {
 __real__ _M_value = __d;
 __imag__ _M_value = 0.0;
 return *this;
      }

      complex<double>&
      operator+=(double __d)
      {
 __real__ _M_value += __d;
 return *this;
      }

      complex<double>&
      operator-=(double __d)
      {
 __real__ _M_value -= __d;
 return *this;
      }

      complex<double>&
      operator*=(double __d)
      {
 _M_value *= __d;
 return *this;
      }

      complex<double>&
      operator/=(double __d)
      {
 _M_value /= __d;
 return *this;
      }




      template<typename _Tp>
        complex<double>&
        operator=(const complex<_Tp>& __z)
 {
   __real__ _M_value = __z.real();
   __imag__ _M_value = __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex<double>&
        operator+=(const complex<_Tp>& __z)
 {
   __real__ _M_value += __z.real();
   __imag__ _M_value += __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex<double>&
        operator-=(const complex<_Tp>& __z)
 {
   __real__ _M_value -= __z.real();
   __imag__ _M_value -= __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex<double>&
        operator*=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value *= __t;
   return *this;
 }

      template<typename _Tp>
        complex<double>&
        operator/=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value /= __t;
   return *this;
 }

      const _ComplexT& __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  template<>
    struct complex<long double>
    {
      typedef long double value_type;
      typedef __complex__ long double _ComplexT;

      complex(_ComplexT __z) : _M_value(__z) { }

      complex(long double __r = 0.0L, long double __i = 0.0L)
      {
 __real__ _M_value = __r;
 __imag__ _M_value = __i;
      }

      complex(const complex<float>& __z)
      : _M_value(__z.__rep()) { }

      complex(const complex<double>& __z)
      : _M_value(__z.__rep()) { }
# 1335 "/usr/include/c++/4.5.3/complex" 3
      long double& real()
      { return __real__ _M_value; }

      const long double& real() const
      { return __real__ _M_value; }

      long double& imag()
      { return __imag__ _M_value; }

      const long double& imag() const
      { return __imag__ _M_value; }




      void real(long double __val)
      { __real__ _M_value = __val; }

      void imag(long double __val)
      { __imag__ _M_value = __val; }

      complex<long double>&
      operator=(long double __r)
      {
 __real__ _M_value = __r;
 __imag__ _M_value = 0.0L;
 return *this;
      }

      complex<long double>&
      operator+=(long double __r)
      {
 __real__ _M_value += __r;
 return *this;
      }

      complex<long double>&
      operator-=(long double __r)
      {
 __real__ _M_value -= __r;
 return *this;
      }

      complex<long double>&
      operator*=(long double __r)
      {
 _M_value *= __r;
 return *this;
      }

      complex<long double>&
      operator/=(long double __r)
      {
 _M_value /= __r;
 return *this;
      }




      template<typename _Tp>
        complex<long double>&
        operator=(const complex<_Tp>& __z)
 {
   __real__ _M_value = __z.real();
   __imag__ _M_value = __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex<long double>&
 operator+=(const complex<_Tp>& __z)
 {
   __real__ _M_value += __z.real();
   __imag__ _M_value += __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex<long double>&
 operator-=(const complex<_Tp>& __z)
 {
   __real__ _M_value -= __z.real();
   __imag__ _M_value -= __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex<long double>&
 operator*=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value *= __t;
   return *this;
 }

      template<typename _Tp>
        complex<long double>&
 operator/=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value /= __t;
   return *this;
 }

      const _ComplexT& __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  inline
  complex<float>::complex(const complex<double>& __z)
  : _M_value(__z.__rep()) { }

  inline
  complex<float>::complex(const complex<long double>& __z)
  : _M_value(__z.__rep()) { }

  inline
  complex<double>::complex(const complex<long double>& __z)
  : _M_value(__z.__rep()) { }





  extern template istream& operator>>(istream&, complex<float>&);
  extern template ostream& operator<<(ostream&, const complex<float>&);
  extern template istream& operator>>(istream&, complex<double>&);
  extern template ostream& operator<<(ostream&, const complex<double>&);
  extern template istream& operator>>(istream&, complex<long double>&);
  extern template ostream& operator<<(ostream&, const complex<long double>&);


  extern template wistream& operator>>(wistream&, complex<float>&);
  extern template wostream& operator<<(wostream&, const complex<float>&);
  extern template wistream& operator>>(wistream&, complex<double>&);
  extern template wostream& operator<<(wostream&, const complex<double>&);
  extern template wistream& operator>>(wistream&, complex<long double>&);
  extern template wostream& operator<<(wostream&, const complex<long double>&);





}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {


  template<typename _Tp, typename _Up>
    struct __promote_2<std::complex<_Tp>, _Up>
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };

  template<typename _Tp, typename _Up>
    struct __promote_2<_Tp, std::complex<_Up> >
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };

  template<typename _Tp, typename _Up>
    struct __promote_2<std::complex<_Tp>, std::complex<_Up> >
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };

}
# 37 "/home/pipping/Downloads/eigen-eigen-3.0.3/test/main.h" 2
# 1 "/usr/include/c++/4.5.3/deque" 1 3
# 59 "/usr/include/c++/4.5.3/deque" 3
# 59 "/usr/include/c++/4.5.3/deque" 3





# 1 "/usr/include/c++/4.5.3/bits/stl_deque.h" 1 3
# 65 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 85 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
  inline size_t
  __deque_buf_size(size_t __size)
  { return (__size < 512
     ? size_t(512 / __size) : size_t(1)); }
# 102 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator
    {
      typedef _Deque_iterator<_Tp, _Tp&, _Tp*> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;

      static size_t _S_buffer_size()
      { return __deque_buf_size(sizeof(_Tp)); }

      typedef std::random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Ptr pointer;
      typedef _Ref reference;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp** _Map_pointer;
      typedef _Deque_iterator _Self;

      _Tp* _M_cur;
      _Tp* _M_first;
      _Tp* _M_last;
      _Map_pointer _M_node;

      _Deque_iterator(_Tp* __x, _Map_pointer __y)
      : _M_cur(__x), _M_first(*__y),
        _M_last(*__y + _S_buffer_size()), _M_node(__y) { }

      _Deque_iterator()
      : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) { }

      _Deque_iterator(const iterator& __x)
      : _M_cur(__x._M_cur), _M_first(__x._M_first),
        _M_last(__x._M_last), _M_node(__x._M_node) { }

      reference
      operator*() const
      { return *_M_cur; }

      pointer
      operator->() const
      { return _M_cur; }

      _Self&
      operator++()
      {
 ++_M_cur;
 if (_M_cur == _M_last)
   {
     _M_set_node(_M_node + 1);
     _M_cur = _M_first;
   }
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 ++*this;
 return __tmp;
      }

      _Self&
      operator--()
      {
 if (_M_cur == _M_first)
   {
     _M_set_node(_M_node - 1);
     _M_cur = _M_last;
   }
 --_M_cur;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 --*this;
 return __tmp;
      }

      _Self&
      operator+=(difference_type __n)
      {
 const difference_type __offset = __n + (_M_cur - _M_first);
 if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
   _M_cur += __n;
 else
   {
     const difference_type __node_offset =
       __offset > 0 ? __offset / difference_type(_S_buffer_size())
                    : -difference_type((-__offset - 1)
           / _S_buffer_size()) - 1;
     _M_set_node(_M_node + __node_offset);
     _M_cur = _M_first + (__offset - __node_offset
     * difference_type(_S_buffer_size()));
   }
 return *this;
      }

      _Self
      operator+(difference_type __n) const
      {
 _Self __tmp = *this;
 return __tmp += __n;
      }

      _Self&
      operator-=(difference_type __n)
      { return *this += -__n; }

      _Self
      operator-(difference_type __n) const
      {
 _Self __tmp = *this;
 return __tmp -= __n;
      }

      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }






      void
      _M_set_node(_Map_pointer __new_node)
      {
 _M_node = __new_node;
 _M_first = *__new_node;
 _M_last = _M_first + difference_type(_S_buffer_size());
      }
    };




  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__x == __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__x == __y); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                          : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                   : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return __y < __x; }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return __y < __x; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__x < __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__x < __y); }





  template<typename _Tp, typename _Ref, typename _Ptr>
    inline typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
    operator-(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    {
      return typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
 (_Deque_iterator<_Tp, _Ref, _Ptr>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
    operator-(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    {
      return typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
 (_Deque_iterator<_Tp, _RefL, _PtrL>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline _Deque_iterator<_Tp, _Ref, _Ptr>
    operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)
    { return __x + __n; }

  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>&,
  const _Deque_iterator<_Tp, _Tp&, _Tp*>&, const _Tp&);

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
  _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
  _Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>(__first),
         _Deque_iterator<_Tp, const _Tp&, const _Tp*>(__last),
         __result); }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
    _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
    _Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::copy_backward(_Deque_iterator<_Tp,
    const _Tp&, const _Tp*>(__first),
    _Deque_iterator<_Tp,
    const _Tp&, const _Tp*>(__last),
    __result); }
# 435 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    class _Deque_base
    {
    public:
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Tp_allocator()); }

      typedef _Deque_iterator<_Tp, _Tp&, _Tp*> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;

      _Deque_base()
      : _M_impl()
      { _M_initialize_map(0); }

      _Deque_base(const allocator_type& __a, size_t __num_elements)
      : _M_impl(__a)
      { _M_initialize_map(__num_elements); }

      _Deque_base(const allocator_type& __a)
      : _M_impl(__a)
      { }
# 475 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      ~_Deque_base();

    protected:



      typedef typename _Alloc::template rebind<_Tp*>::other _Map_alloc_type;

      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _Deque_impl
      : public _Tp_alloc_type
      {
 _Tp** _M_map;
 size_t _M_map_size;
 iterator _M_start;
 iterator _M_finish;

 _Deque_impl()
 : _Tp_alloc_type(), _M_map(0), _M_map_size(0),
   _M_start(), _M_finish()
 { }

 _Deque_impl(const _Tp_alloc_type& __a)
 : _Tp_alloc_type(__a), _M_map(0), _M_map_size(0),
   _M_start(), _M_finish()
 { }
      };

      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      _Map_alloc_type
      _M_get_map_allocator() const
      { return _Map_alloc_type(_M_get_Tp_allocator()); }

      _Tp*
      _M_allocate_node()
      {
 return _M_impl._Tp_alloc_type::allocate(__deque_buf_size(sizeof(_Tp)));
      }

      void
      _M_deallocate_node(_Tp* __p)
      {
 _M_impl._Tp_alloc_type::deallocate(__p, __deque_buf_size(sizeof(_Tp)));
      }

      _Tp**
      _M_allocate_map(size_t __n)
      { return _M_get_map_allocator().allocate(__n); }

      void
      _M_deallocate_map(_Tp** __p, size_t __n)
      { _M_get_map_allocator().deallocate(__p, __n); }

    protected:
      void _M_initialize_map(size_t);
      void _M_create_nodes(_Tp** __nstart, _Tp** __nfinish);
      void _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish);
      enum { _S_initial_map_size = 8 };

      _Deque_impl _M_impl;
    };

  template<typename _Tp, typename _Alloc>
    _Deque_base<_Tp, _Alloc>::
    ~_Deque_base()
    {
      if (this->_M_impl._M_map)
 {
   _M_destroy_nodes(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
 }
    }
# 565 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_initialize_map(size_t __num_elements)
    {
      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
      + 1);

      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
        size_t(__num_nodes + 2));
      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);






      _Tp** __nstart = (this->_M_impl._M_map
   + (this->_M_impl._M_map_size - __num_nodes) / 2);
      _Tp** __nfinish = __nstart + __num_nodes;

      try
 { _M_create_nodes(__nstart, __nfinish); }
      catch(...)
 {
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
   this->_M_impl._M_map = 0;
   this->_M_impl._M_map_size = 0;
   throw;
 }

      this->_M_impl._M_start._M_set_node(__nstart);
      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
     + __num_elements
     % __deque_buf_size(sizeof(_Tp)));
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_create_nodes(_Tp** __nstart, _Tp** __nfinish)
    {
      _Tp** __cur;
      try
 {
   for (__cur = __nstart; __cur < __nfinish; ++__cur)
     *__cur = this->_M_allocate_node();
 }
      catch(...)
 {
   _M_destroy_nodes(__nstart, __cur);
   throw;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)
    {
      for (_Tp** __n = __nstart; __n < __nfinish; ++__n)
 _M_deallocate_node(*__n);
    }
# 712 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class deque : protected _Deque_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;



      typedef _Deque_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef typename _Base::iterator iterator;
      typedef typename _Base::const_iterator const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      typedef pointer* _Map_pointer;

      static size_t _S_buffer_size()
      { return __deque_buf_size(sizeof(_Tp)); }


      using _Base::_M_initialize_map;
      using _Base::_M_create_nodes;
      using _Base::_M_destroy_nodes;
      using _Base::_M_allocate_node;
      using _Base::_M_deallocate_node;
      using _Base::_M_allocate_map;
      using _Base::_M_deallocate_map;
      using _Base::_M_get_Tp_allocator;





      using _Base::_M_impl;

    public:





      deque()
      : _Base() { }





      explicit
      deque(const allocator_type& __a)
      : _Base(__a, 0) { }
# 784 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      explicit
      deque(size_type __n, const value_type& __value = value_type(),
     const allocator_type& __a = allocator_type())
      : _Base(__a, __n)
      { _M_fill_initialize(__value); }
# 797 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      deque(const deque& __x)
      : _Base(__x._M_get_Tp_allocator(), __x.size())
      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
        this->_M_impl._M_start,
        _M_get_Tp_allocator()); }
# 849 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      template<typename _InputIterator>
        deque(_InputIterator __first, _InputIterator __last,
       const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }






      ~deque()
      { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }
# 874 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      deque&
      operator=(const deque& __x);
# 924 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 940 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }
# 966 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }






      iterator
      begin()
      { return this->_M_impl._M_start; }





      const_iterator
      begin() const
      { return this->_M_impl._M_start; }






      iterator
      end()
      { return this->_M_impl._M_finish; }






      const_iterator
      end() const
      { return this->_M_impl._M_finish; }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->_M_impl._M_start); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->_M_impl._M_start); }
# 1080 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      size_type
      size() const
      { return this->_M_impl._M_finish - this->_M_impl._M_start; }


      size_type
      max_size() const
      { return _M_get_Tp_allocator().max_size(); }
# 1100 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
 const size_type __len = size();
 if (__new_size < __len)
   _M_erase_at_end(this->_M_impl._M_start + difference_type(__new_size));
 else
   insert(this->_M_impl._M_finish, __new_size - __len, __x);
      }
# 1121 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      bool
      empty() const
      { return this->_M_impl._M_finish == this->_M_impl._M_start; }
# 1137 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      reference
      operator[](size_type __n)
      { return this->_M_impl._M_start[difference_type(__n)]; }
# 1152 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      const_reference
      operator[](size_type __n) const
      { return this->_M_impl._M_start[difference_type(__n)]; }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("deque::_M_range_check"));
      }

    public:
# 1177 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 1195 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
# 1252 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      void
      push_front(const value_type& __x)
      {
 if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
   {
     this->_M_impl.construct(this->_M_impl._M_start._M_cur - 1, __x);
     --this->_M_impl._M_start._M_cur;
   }
 else
   _M_push_front_aux(__x);
      }
# 1283 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_last - 1)
   {
     this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __x);
     ++this->_M_impl._M_finish._M_cur;
   }
 else
   _M_push_back_aux(__x);
      }
# 1314 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      void
      pop_front()
      {
 if (this->_M_impl._M_start._M_cur
     != this->_M_impl._M_start._M_last - 1)
   {
     this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
     ++this->_M_impl._M_start._M_cur;
   }
 else
   _M_pop_front_aux();
      }
# 1335 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      void
      pop_back()
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_first)
   {
     --this->_M_impl._M_finish._M_cur;
     this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
   }
 else
   _M_pop_back_aux();
      }
# 1372 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 1412 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 1426 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 1449 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      iterator
      erase(iterator __position);
# 1468 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 1480 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      void
      swap(deque& __x)
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_map, __x._M_impl._M_map);
 std::swap(this->_M_impl._M_map_size, __x._M_impl._M_map_size);



 std::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
          __x._M_get_Tp_allocator());
      }







      void
      clear()
      { _M_erase_at_end(begin()); }

    protected:






      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        {
   _M_initialize_map(static_cast<size_type>(__n));
   _M_fill_initialize(__x);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }
# 1542 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag);
# 1564 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      void
      _M_fill_initialize(const value_type& __value);
# 1574 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag)
        {
   const size_type __len = std::distance(__first, __last);
   if (__len > size())
     {
       _ForwardIterator __mid = __first;
       std::advance(__mid, size());
       std::copy(__first, __mid, begin());
       insert(end(), __mid, __last);
     }
   else
     _M_erase_at_end(std::copy(__first, __last, begin()));
 }



      void
      _M_fill_assign(size_type __n, const value_type& __val)
      {
 if (__n > size())
   {
     std::fill(begin(), end(), __val);
     insert(end(), __n - size(), __val);
   }
 else
   {
     _M_erase_at_end(begin() + difference_type(__n));
     std::fill(begin(), end(), __val);
   }
      }




      void _M_push_back_aux(const value_type&);

      void _M_push_front_aux(const value_type&);
# 1645 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      void _M_pop_back_aux();

      void _M_pop_front_aux();
# 1657 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos,
      _Integer __n, _Integer __x, __true_type)
        { _M_fill_insert(__pos, __n, __x); }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos,
      _InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
          _M_range_insert_aux(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert_aux(iterator __pos, _InputIterator __first,
       _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert_aux(iterator __pos, _ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag);




      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);



      iterator
      _M_insert_aux(iterator __pos, const value_type& __x);







      void
      _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);


      template<typename _ForwardIterator>
        void
        _M_insert_aux(iterator __pos,
        _ForwardIterator __first, _ForwardIterator __last,
        size_type __n);




      void
      _M_destroy_data_aux(iterator __first, iterator __last);



      template<typename _Alloc1>
        void
        _M_destroy_data(iterator __first, iterator __last, const _Alloc1&)
        { _M_destroy_data_aux(__first, __last); }

      void
      _M_destroy_data(iterator __first, iterator __last,
        const std::allocator<_Tp>&)
      {
 if (!__has_trivial_destructor(value_type))
   _M_destroy_data_aux(__first, __last);
      }


      void
      _M_erase_at_begin(iterator __pos)
      {
 _M_destroy_data(begin(), __pos, _M_get_Tp_allocator());
 _M_destroy_nodes(this->_M_impl._M_start._M_node, __pos._M_node);
 this->_M_impl._M_start = __pos;
      }



      void
      _M_erase_at_end(iterator __pos)
      {
 _M_destroy_data(__pos, end(), _M_get_Tp_allocator());
 _M_destroy_nodes(__pos._M_node + 1,
    this->_M_impl._M_finish._M_node + 1);
 this->_M_impl._M_finish = __pos;
      }



      iterator
      _M_reserve_elements_at_front(size_type __n)
      {
 const size_type __vacancies = this->_M_impl._M_start._M_cur
                               - this->_M_impl._M_start._M_first;
 if (__n > __vacancies)
   _M_new_elements_at_front(__n - __vacancies);
 return this->_M_impl._M_start - difference_type(__n);
      }

      iterator
      _M_reserve_elements_at_back(size_type __n)
      {
 const size_type __vacancies = (this->_M_impl._M_finish._M_last
           - this->_M_impl._M_finish._M_cur) - 1;
 if (__n > __vacancies)
   _M_new_elements_at_back(__n - __vacancies);
 return this->_M_impl._M_finish + difference_type(__n);
      }

      void
      _M_new_elements_at_front(size_type __new_elements);

      void
      _M_new_elements_at_back(size_type __new_elements);
# 1793 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
      void
      _M_reserve_map_at_back(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add + 1 > this->_M_impl._M_map_size
     - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, false);
      }

      void
      _M_reserve_map_at_front(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add > size_type(this->_M_impl._M_start._M_node
           - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, true);
      }

      void
      _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);

    };
# 1825 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const deque<_Tp, _Alloc>& __x,
                         const deque<_Tp, _Alloc>& __y)
    { return __x.size() == __y.size()
             && std::equal(__x.begin(), __x.end(), __y.begin()); }
# 1843 "/usr/include/c++/4.5.3/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)
    { __x.swap(__y); }



}
# 65 "/usr/include/c++/4.5.3/deque" 2 3


# 1 "/usr/include/c++/4.5.3/bits/deque.tcc" 1 3
# 60 "/usr/include/c++/4.5.3/bits/deque.tcc" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template <typename _Tp, typename _Alloc>
    deque<_Tp, _Alloc>&
    deque<_Tp, _Alloc>::
    operator=(const deque& __x)
    {
      const size_type __len = size();
      if (&__x != this)
 {
   if (__len >= __x.size())
     _M_erase_at_end(std::copy(__x.begin(), __x.end(),
          this->_M_impl._M_start));
   else
     {
       const_iterator __mid = __x.begin() + difference_type(__len);
       std::copy(__x.begin(), __mid, this->_M_impl._M_start);
       insert(this->_M_impl._M_finish, __mid, __x.end());
     }
 }
      return *this;
    }
# 118 "/usr/include/c++/4.5.3/bits/deque.tcc" 3
  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      if (__position._M_cur == this->_M_impl._M_start._M_cur)
 {
   push_front(__x);
   return this->_M_impl._M_start;
 }
      else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
 {
   push_back(__x);
   iterator __tmp = this->_M_impl._M_finish;
   --__tmp;
   return __tmp;
 }
      else
        return _M_insert_aux(__position, __x);
    }
# 163 "/usr/include/c++/4.5.3/bits/deque.tcc" 3
  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    erase(iterator __position)
    {
      iterator __next = __position;
      ++__next;
      const difference_type __index = __position - begin();
      if (static_cast<size_type>(__index) < (size() >> 1))
 {
   if (__position != begin())
     std::copy_backward(begin(), __position, __next);
   pop_front();
 }
      else
 {
   if (__next != end())
     std::copy(__next, end(), __position);
   pop_back();
 }
      return begin() + __index;
    }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first == begin() && __last == end())
 {
   clear();
   return end();
 }
      else
 {
   const difference_type __n = __last - __first;
   const difference_type __elems_before = __first - begin();
   if (static_cast<size_type>(__elems_before) <= (size() - __n) / 2)
     {
       if (__first != begin())
  std::copy_backward(begin(), __first, __last);
       _M_erase_at_begin(begin() + __n);
     }
   else
     {
       if (__last != end())
  std::copy(__last, end(), __first);
       _M_erase_at_end(end() - __n);
     }
   return begin() + __elems_before;
 }
    }

  template <typename _Tp, class _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
        iterator __cur = begin();
        for (; __first != __last && __cur != end(); ++__cur, ++__first)
          *__cur = *__first;
        if (__first == __last)
          _M_erase_at_end(__cur);
        else
          insert(end(), __first, __last);
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)
    {
      if (__pos._M_cur == this->_M_impl._M_start._M_cur)
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   try
     {
       std::__uninitialized_fill_a(__new_start, this->_M_impl._M_start,
       __x, _M_get_Tp_allocator());
       this->_M_impl._M_start = __new_start;
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   try
     {
       std::__uninitialized_fill_a(this->_M_impl._M_finish,
       __new_finish, __x,
       _M_get_Tp_allocator());
       this->_M_impl._M_finish = __new_finish;
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
      else
        _M_insert_aux(__pos, __n, __x);
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_initialize(const value_type& __value)
    {
      _Map_pointer __cur;
      try
        {
          for (__cur = this->_M_impl._M_start._M_node;
        __cur < this->_M_impl._M_finish._M_node;
        ++__cur)
            std::__uninitialized_fill_a(*__cur, *__cur + _S_buffer_size(),
     __value, _M_get_Tp_allocator());
          std::__uninitialized_fill_a(this->_M_impl._M_finish._M_first,
          this->_M_impl._M_finish._M_cur,
          __value, _M_get_Tp_allocator());
        }
      catch(...)
        {
          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
   _M_get_Tp_allocator());
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      {
        this->_M_initialize_map(0);
        try
          {
            for (; __first != __last; ++__first)
              push_back(*__first);
          }
        catch(...)
          {
            clear();
            throw;
          }
      }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        this->_M_initialize_map(__n);

        _Map_pointer __cur_node;
        try
          {
            for (__cur_node = this->_M_impl._M_start._M_node;
                 __cur_node < this->_M_impl._M_finish._M_node;
                 ++__cur_node)
       {
  _ForwardIterator __mid = __first;
  std::advance(__mid, _S_buffer_size());
  std::__uninitialized_copy_a(__first, __mid, *__cur_node,
         _M_get_Tp_allocator());
  __first = __mid;
       }
            std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_finish._M_first,
     _M_get_Tp_allocator());
          }
        catch(...)
          {
            std::_Destroy(this->_M_impl._M_start,
     iterator(*__cur_node, __cur_node),
     _M_get_Tp_allocator());
            throw;
          }
      }


  template<typename _Tp, typename _Alloc>






      void
      deque<_Tp, _Alloc>::
      _M_push_back_aux(const value_type& __t)

      {
 _M_reserve_map_at_back();
 *(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();
 try
   {




     this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __t);

     this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node
      + 1);
     this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
   }
 catch(...)
   {
     _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
     throw;
   }
      }


  template<typename _Tp, typename _Alloc>






      void
      deque<_Tp, _Alloc>::
      _M_push_front_aux(const value_type& __t)

      {
 _M_reserve_map_at_front();
 *(this->_M_impl._M_start._M_node - 1) = this->_M_allocate_node();
 try
   {
     this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node
            - 1);
     this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_last - 1;




     this->_M_impl.construct(this->_M_impl._M_start._M_cur, __t);

   }
 catch(...)
   {
     ++this->_M_impl._M_start;
     _M_deallocate_node(*(this->_M_impl._M_start._M_node - 1));
     throw;
   }
      }


  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_back_aux()
    {
      _M_deallocate_node(this->_M_impl._M_finish._M_first);
      this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);
      this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_last - 1;
      this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
    }






  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_front_aux()
    {
      this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
      _M_deallocate_node(this->_M_impl._M_start._M_first);
      this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);
      this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      { std::copy(__first, __last, std::inserter(*this, __pos)); }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        if (__pos._M_cur == this->_M_impl._M_start._M_cur)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last, __new_start,
         _M_get_Tp_allocator());
  this->_M_impl._M_start = __new_start;
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
   {
     iterator __new_finish = _M_reserve_elements_at_back(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last,
         this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  this->_M_impl._M_finish = __new_finish;
       }
     catch(...)
       {
  _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
     __new_finish._M_node + 1);
  throw;
       }
   }
        else
          _M_insert_aux(__pos, __first, __last, __n);
      }

  template<typename _Tp, typename _Alloc>
# 514 "/usr/include/c++/4.5.3/bits/deque.tcc" 3
    typename deque<_Tp, _Alloc>::iterator
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos, const value_type& __x)
      {
 value_type __x_copy = __x;

 difference_type __index = __pos - this->_M_impl._M_start;
 if (static_cast<size_type>(__index) < size() / 2)
   {
     push_front((front()));
     iterator __front1 = this->_M_impl._M_start;
     ++__front1;
     iterator __front2 = __front1;
     ++__front2;
     __pos = this->_M_impl._M_start + __index;
     iterator __pos1 = __pos;
     ++__pos1;
     std::copy(__front2, __pos1, __front1);
   }
 else
   {
     push_back((back()));
     iterator __back1 = this->_M_impl._M_finish;
     --__back1;
     iterator __back2 = __back1;
     --__back2;
     __pos = this->_M_impl._M_start + __index;
     std::copy_backward(__pos, __back2, __back1);
   }
 *__pos = (__x_copy);
 return __pos;
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)
    {
      const difference_type __elems_before = __pos - this->_M_impl._M_start;
      const size_type __length = this->size();
      value_type __x_copy = __x;
      if (__elems_before < difference_type(__length / 2))
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   iterator __old_start = this->_M_impl._M_start;
   __pos = this->_M_impl._M_start + __elems_before;
   try
     {
       if (__elems_before >= difference_type(__n))
  {
    iterator __start_n = (this->_M_impl._M_start
     + difference_type(__n));
    std::__uninitialized_move_a(this->_M_impl._M_start,
           __start_n, __new_start,
           _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::copy(__start_n, __pos, __old_start);
    std::fill(__pos - difference_type(__n), __pos, __x_copy);
  }
       else
  {
    std::__uninitialized_move_fill(this->_M_impl._M_start,
       __pos, __new_start,
       this->_M_impl._M_start,
       __x_copy,
       _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::fill(__old_start, __pos, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   iterator __old_finish = this->_M_impl._M_finish;
   const difference_type __elems_after =
     difference_type(__length) - __elems_before;
   __pos = this->_M_impl._M_finish - __elems_after;
   try
     {
       if (__elems_after > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_move_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy_backward(__pos, __finish_n, __old_finish);
    std::fill(__pos, __pos + difference_type(__n), __x_copy);
  }
       else
  {
    std::__uninitialized_fill_move(this->_M_impl._M_finish,
       __pos + difference_type(__n),
       __x_copy, __pos,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::fill(__pos, __old_finish, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos,
                    _ForwardIterator __first, _ForwardIterator __last,
                    size_type __n)
      {
        const difference_type __elemsbefore = __pos - this->_M_impl._M_start;
        const size_type __length = size();
        if (static_cast<size_type>(__elemsbefore) < __length / 2)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     iterator __old_start = this->_M_impl._M_start;
     __pos = this->_M_impl._M_start + __elemsbefore;
     try
       {
  if (__elemsbefore >= difference_type(__n))
    {
      iterator __start_n = (this->_M_impl._M_start
       + difference_type(__n));
      std::__uninitialized_move_a(this->_M_impl._M_start,
      __start_n, __new_start,
      _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::copy(__start_n, __pos, __old_start);
      std::copy(__first, __last, __pos - difference_type(__n));
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, difference_type(__n) - __elemsbefore);
      std::__uninitialized_move_copy(this->_M_impl._M_start,
         __pos, __first, __mid,
         __new_start,
         _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::copy(__mid, __last, __old_start);
    }
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else
        {
          iterator __new_finish = _M_reserve_elements_at_back(__n);
          iterator __old_finish = this->_M_impl._M_finish;
          const difference_type __elemsafter =
            difference_type(__length) - __elemsbefore;
          __pos = this->_M_impl._M_finish - __elemsafter;
          try
            {
              if (__elemsafter > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_move_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy_backward(__pos, __finish_n, __old_finish);
    std::copy(__first, __last, __pos);
  }
              else
  {
    _ForwardIterator __mid = __first;
    std::advance(__mid, __elemsafter);
    std::__uninitialized_copy_move(__mid, __last, __pos,
       this->_M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy(__first, __mid, __pos);
  }
            }
          catch(...)
            {
              _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
              throw;
            }
        }
      }

   template<typename _Tp, typename _Alloc>
     void
     deque<_Tp, _Alloc>::
     _M_destroy_data_aux(iterator __first, iterator __last)
     {
       for (_Map_pointer __node = __first._M_node + 1;
     __node < __last._M_node; ++__node)
  std::_Destroy(*__node, *__node + _S_buffer_size(),
         _M_get_Tp_allocator());

       if (__first._M_node != __last._M_node)
  {
    std::_Destroy(__first._M_cur, __first._M_last,
    _M_get_Tp_allocator());
    std::_Destroy(__last._M_first, __last._M_cur,
    _M_get_Tp_allocator());
  }
       else
  std::_Destroy(__first._M_cur, __last._M_cur,
         _M_get_Tp_allocator());
     }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_front(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_front"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_front(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_start._M_node - __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_start._M_node - __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_back(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_back"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_back(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_finish._M_node + __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_finish._M_node + __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
    {
      const size_type __old_num_nodes
 = this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;

      _Map_pointer __new_nstart;
      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
 {
   __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
      - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   if (__new_nstart < this->_M_impl._M_start._M_node)
     std::copy(this->_M_impl._M_start._M_node,
        this->_M_impl._M_finish._M_node + 1,
        __new_nstart);
   else
     std::copy_backward(this->_M_impl._M_start._M_node,
          this->_M_impl._M_finish._M_node + 1,
          __new_nstart + __old_num_nodes);
 }
      else
 {
   size_type __new_map_size = this->_M_impl._M_map_size
                              + std::max(this->_M_impl._M_map_size,
      __nodes_to_add) + 2;

   _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
   __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   std::copy(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1,
      __new_nstart);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);

   this->_M_impl._M_map = __new_map;
   this->_M_impl._M_map_size = __new_map_size;
 }

      this->_M_impl._M_start._M_set_node(__new_nstart);
      this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
    }



  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>& __first,
  const _Deque_iterator<_Tp, _Tp&, _Tp*>& __last, const _Tp& __value)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;

      for (typename _Self::_Map_pointer __node = __first._M_node + 1;
           __node < __last._M_node; ++__node)
 std::fill(*__node, *__node + _Self::_S_buffer_size(), __value);

      if (__first._M_node != __last._M_node)
 {
   std::fill(__first._M_cur, __first._M_last, __value);
   std::fill(__last._M_first, __last._M_cur, __value);
 }
      else
 std::fill(__first._M_cur, __last._M_cur, __value);
    }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
  _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
 {
   const difference_type __clen
     = std::min(__len, std::min(__first._M_last - __first._M_cur,
           __result._M_last - __result._M_cur));
   std::copy(__first._M_cur, __first._M_cur + __clen, __result._M_cur);
   __first += __clen;
   __result += __clen;
   __len -= __clen;
 }
      return __result;
    }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
    _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
 {
   difference_type __llen = __last._M_cur - __last._M_first;
   _Tp* __lend = __last._M_cur;

   difference_type __rlen = __result._M_cur - __result._M_first;
   _Tp* __rend = __result._M_cur;

   if (!__llen)
     {
       __llen = _Self::_S_buffer_size();
       __lend = *(__last._M_node - 1) + __llen;
     }
   if (!__rlen)
     {
       __rlen = _Self::_S_buffer_size();
       __rend = *(__result._M_node - 1) + __rlen;
     }

   const difference_type __clen = std::min(__len,
        std::min(__llen, __rlen));
   std::copy_backward(__lend - __clen, __lend, __rend);
   __last -= __clen;
   __result -= __clen;
   __len -= __clen;
 }
      return __result;
    }
# 987 "/usr/include/c++/4.5.3/bits/deque.tcc" 3
}
# 68 "/usr/include/c++/4.5.3/deque" 2 3
# 38 "/home/pipping/Downloads/eigen-eigen-3.0.3/test/main.h" 2
# 1 "/usr/include/c++/4.5.3/queue" 1 3
# 59 "/usr/include/c++/4.5.3/queue" 3
# 59 "/usr/include/c++/4.5.3/queue" 3





# 1 "/usr/include/c++/4.5.3/bits/stl_queue.h" 1 3
# 63 "/usr/include/c++/4.5.3/bits/stl_queue.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 88 "/usr/include/c++/4.5.3/bits/stl_queue.h" 3
  template<typename _Tp, typename _Sequence = deque<_Tp> >
    class queue
    {

      typedef typename _Sequence::value_type _Sequence_value_type;





      template<typename _Tp1, typename _Seq1>
        friend bool
        operator==(const queue<_Tp1, _Seq1>&, const queue<_Tp1, _Seq1>&);

      template<typename _Tp1, typename _Seq1>
        friend bool
        operator<(const queue<_Tp1, _Seq1>&, const queue<_Tp1, _Seq1>&);

    public:
      typedef typename _Sequence::value_type value_type;
      typedef typename _Sequence::reference reference;
      typedef typename _Sequence::const_reference const_reference;
      typedef typename _Sequence::size_type size_type;
      typedef _Sequence container_type;

    protected:
# 122 "/usr/include/c++/4.5.3/bits/stl_queue.h" 3
      _Sequence c;

    public:




      explicit
      queue(const _Sequence& __c = _Sequence())
      : c(__c) { }
# 155 "/usr/include/c++/4.5.3/bits/stl_queue.h" 3
      bool
      empty() const
      { return c.empty(); }


      size_type
      size() const
      { return c.size(); }





      reference
      front()
      {
                              ;
 return c.front();
      }





      const_reference
      front() const
      {
                              ;
 return c.front();
      }





      reference
      back()
      {
                              ;
 return c.back();
      }





      const_reference
      back() const
      {
                              ;
 return c.back();
      }
# 217 "/usr/include/c++/4.5.3/bits/stl_queue.h" 3
      void
      push(const value_type& __x)
      { c.push_back(__x); }
# 243 "/usr/include/c++/4.5.3/bits/stl_queue.h" 3
      void
      pop()
      {
                              ;
 c.pop_front();
      }






    };
# 268 "/usr/include/c++/4.5.3/bits/stl_queue.h" 3
  template<typename _Tp, typename _Seq>
    inline bool
    operator==(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return __x.c == __y.c; }
# 286 "/usr/include/c++/4.5.3/bits/stl_queue.h" 3
  template<typename _Tp, typename _Seq>
    inline bool
    operator<(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return __x.c < __y.c; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator!=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator<=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return !(__x < __y); }
# 357 "/usr/include/c++/4.5.3/bits/stl_queue.h" 3
  template<typename _Tp, typename _Sequence = vector<_Tp>,
    typename _Compare = less<typename _Sequence::value_type> >
    class priority_queue
    {

      typedef typename _Sequence::value_type _Sequence_value_type;







    public:
      typedef typename _Sequence::value_type value_type;
      typedef typename _Sequence::reference reference;
      typedef typename _Sequence::const_reference const_reference;
      typedef typename _Sequence::size_type size_type;
      typedef _Sequence container_type;

    protected:

      _Sequence c;
      _Compare comp;

    public:




      explicit
      priority_queue(const _Compare& __x = _Compare(),
       const _Sequence& __s = _Sequence())
      : c(__s), comp(__x)
      { std::make_heap(c.begin(), c.end(), comp); }
# 422 "/usr/include/c++/4.5.3/bits/stl_queue.h" 3
      template<typename _InputIterator>
        priority_queue(_InputIterator __first, _InputIterator __last,
         const _Compare& __x = _Compare(),
         const _Sequence& __s = _Sequence())
 : c(__s), comp(__x)
        {
                                                  ;
   c.insert(c.end(), __first, __last);
   std::make_heap(c.begin(), c.end(), comp);
 }
# 470 "/usr/include/c++/4.5.3/bits/stl_queue.h" 3
      bool
      empty() const
      { return c.empty(); }


      size_type
      size() const
      { return c.size(); }





      const_reference
      top() const
      {
                              ;
 return c.front();
      }
# 498 "/usr/include/c++/4.5.3/bits/stl_queue.h" 3
      void
      push(const value_type& __x)
      {
 c.push_back(__x);
 std::push_heap(c.begin(), c.end(), comp);
      }
# 533 "/usr/include/c++/4.5.3/bits/stl_queue.h" 3
      void
      pop()
      {
                              ;
 std::pop_heap(c.begin(), c.end(), comp);
 c.pop_back();
      }
# 550 "/usr/include/c++/4.5.3/bits/stl_queue.h" 3
    };
# 562 "/usr/include/c++/4.5.3/bits/stl_queue.h" 3
}
# 65 "/usr/include/c++/4.5.3/queue" 2 3
# 39 "/home/pipping/Downloads/eigen-eigen-3.0.3/test/main.h" 2
# 63 "/home/pipping/Downloads/eigen-eigen-3.0.3/test/main.h"
namespace Eigen
{
  static std::vector<std::string> g_test_stack;
  static int g_repeat;
  static unsigned int g_seed;
  static bool g_has_set_repeat, g_has_set_seed;
}
# 78 "/home/pipping/Downloads/eigen-eigen-3.0.3/test/main.h"
  namespace Eigen
  {
    static const bool should_raise_an_assert = false;




    static bool no_more_assert = false;
    static bool report_on_cerr_on_assert_failure = true;

    struct eigen_assert_exception
    {
      eigen_assert_exception(void) {}
      ~eigen_assert_exception() { Eigen::no_more_assert = false; }
    };
  }
# 177 "/home/pipping/Downloads/eigen-eigen-3.0.3/test/main.h"
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/QR" 1



# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 1
# 30 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core"
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/DisableStupidWarnings.h" 1
# 39 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/DisableStupidWarnings.h"
#pragma clang diagnostic ignored "-Wconstant-logical-operand"
# 31 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2




# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Macros.h" 1
# 192 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Macros.h"
# 1 "/usr/include/c++/4.5.3/cstdlib" 1 3
# 41 "/usr/include/c++/4.5.3/cstdlib" 3
# 41 "/usr/include/c++/4.5.3/cstdlib" 3


# 1 "/usr/include/c++/4.5.3/cstddef" 1 3
# 41 "/usr/include/c++/4.5.3/cstddef" 3
# 41 "/usr/include/c++/4.5.3/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.5.3/cstddef" 2 3
# 44 "/usr/include/c++/4.5.3/cstdlib" 2 3
# 193 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Macros.h" 2


    namespace Eigen {
    namespace internal {


    namespace {
    __attribute__((noinline)) bool copy_bool(bool b) { return b; }
    }
    inline void assert_fail(const char *condition, const char *function, const char *file, int line)
    {
      std::cerr << "assertion failed: " << condition << " in function " << function << " at " << file << ":" << line << std::endl;
      abort();
    }
    }
    }
# 36 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 98 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core"
    extern "C" {

# 1 "/usr/bin/../lib/clang/3.0/include/emmintrin.h" 1 3 4
# 31 "/usr/bin/../lib/clang/3.0/include/emmintrin.h" 3 4
# 1 "/usr/bin/../lib/clang/3.0/include/xmmintrin.h" 1 3 4
# 31 "/usr/bin/../lib/clang/3.0/include/xmmintrin.h" 3 4
# 1 "/usr/bin/../lib/clang/3.0/include/mmintrin.h" 1 3 4
# 31 "/usr/bin/../lib/clang/3.0/include/mmintrin.h" 3 4
typedef long long __m64 __attribute__((__vector_size__(8)));

typedef int __v2si __attribute__((__vector_size__(8)));
typedef short __v4hi __attribute__((__vector_size__(8)));
typedef char __v8qi __attribute__((__vector_size__(8)));

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_empty(void)
{
    __builtin_ia32_emms();
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi32_si64(int __i)
{
    return (__m64)__builtin_ia32_vec_init_v2si(__i, 0);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_si32(__m64 __m)
{
    return __builtin_ia32_vec_ext_v2si((__v2si)__m, 0);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_m64(long long __i)
{
    return (__m64)__i;
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvtm64_si64(__m64 __m)
{
    return (long long)__m;
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_packs_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packsswb((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_packs_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packssdw((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_packs_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packuswb((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhbw((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhwd((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhdq((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpcklbw((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpcklwd((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckldq((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_add_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_add_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_add_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddd((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_adds_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddsb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_adds_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddsw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_adds_pu8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddusb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_adds_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddusw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sub_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sub_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sub_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubd((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_subs_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubsb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_subs_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubsw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_subs_pu8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubusb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_subs_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubusw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_madd_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmaddwd((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_mulhi_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmulhw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_mullo_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmullw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sll_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psllw((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_slli_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psllwi((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sll_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_pslld((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_slli_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_pslldi((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sll_si64(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psllq(__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_slli_si64(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psllqi(__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sra_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psraw((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srai_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrawi((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sra_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrad((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srai_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psradi((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srl_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrlw((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srli_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrlwi((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srl_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrld((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srli_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrldi((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srl_si64(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrlq(__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srli_si64(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrlqi(__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_and_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pand(__m1, __m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_andnot_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pandn(__m1, __m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_or_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_por(__m1, __m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_xor_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pxor(__m1, __m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqd((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtd((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_setzero_si64(void)
{
    return (__m64){ 0LL };
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set_pi32(int __i1, int __i0)
{
    return (__m64)__builtin_ia32_vec_init_v2si(__i0, __i1);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set_pi16(short __s3, short __s2, short __s1, short __s0)
{
    return (__m64)__builtin_ia32_vec_init_v4hi(__s0, __s1, __s2, __s3);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set_pi8(char __b7, char __b6, char __b5, char __b4, char __b3, char __b2,
            char __b1, char __b0)
{
    return (__m64)__builtin_ia32_vec_init_v8qi(__b0, __b1, __b2, __b3,
                                               __b4, __b5, __b6, __b7);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set1_pi32(int __i)
{
    return _mm_set_pi32(__i, __i);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set1_pi16(short __w)
{
    return _mm_set_pi16(__w, __w, __w, __w);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set1_pi8(char __b)
{
    return _mm_set_pi8(__b, __b, __b, __b, __b, __b, __b, __b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_setr_pi32(int __i0, int __i1)
{
    return _mm_set_pi32(__i1, __i0);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_setr_pi16(short __w0, short __w1, short __w2, short __w3)
{
    return _mm_set_pi16(__w3, __w2, __w1, __w0);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_setr_pi8(char __b0, char __b1, char __b2, char __b3, char __b4, char __b5,
             char __b6, char __b7)
{
    return _mm_set_pi8(__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
}
# 32 "/usr/bin/../lib/clang/3.0/include/xmmintrin.h" 2 3 4

typedef int __v4si __attribute__((__vector_size__(16)));
typedef float __v4sf __attribute__((__vector_size__(16)));
typedef float __m128 __attribute__((__vector_size__(16)));





# 1 "/usr/bin/../lib/clang/3.0/include/mm_malloc.h" 1 3 4
# 39 "/usr/bin/../lib/clang/3.0/include/mm_malloc.h" 3 4
extern "C" int posix_memalign(void **memptr, size_t alignment, size_t size);




static __inline__ void *__attribute__((__always_inline__, __nodebug__,
                                       __malloc__))
_mm_malloc(size_t size, size_t align)
{
  if (align == 1) {
    return malloc(size);
  }

  if (!(align & (align - 1)) && align < sizeof(void *))
    align = sizeof(void *);

  void *mallocedMemory;





  if (posix_memalign(&mallocedMemory, align, size))
    return 0;


  return mallocedMemory;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_free(void *p)
{
  free(p);
}
# 41 "/usr/bin/../lib/clang/3.0/include/xmmintrin.h" 2 3 4


static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_add_ss(__m128 a, __m128 b)
{
  a[0] += b[0];
  return a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_add_ps(__m128 a, __m128 b)
{
  return a + b;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_sub_ss(__m128 a, __m128 b)
{
  a[0] -= b[0];
  return a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_sub_ps(__m128 a, __m128 b)
{
  return a - b;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_mul_ss(__m128 a, __m128 b)
{
  a[0] *= b[0];
  return a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_mul_ps(__m128 a, __m128 b)
{
  return a * b;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_div_ss(__m128 a, __m128 b)
{
  a[0] /= b[0];
  return a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_div_ps(__m128 a, __m128 b)
{
  return a / b;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_sqrt_ss(__m128 a)
{
  return __builtin_ia32_sqrtss(a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_sqrt_ps(__m128 a)
{
  return __builtin_ia32_sqrtps(a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_rcp_ss(__m128 a)
{
  return __builtin_ia32_rcpss(a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_rcp_ps(__m128 a)
{
  return __builtin_ia32_rcpps(a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_rsqrt_ss(__m128 a)
{
  return __builtin_ia32_rsqrtss(a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_rsqrt_ps(__m128 a)
{
  return __builtin_ia32_rsqrtps(a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_min_ss(__m128 a, __m128 b)
{
  return __builtin_ia32_minss(a, b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_min_ps(__m128 a, __m128 b)
{
  return __builtin_ia32_minps(a, b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_max_ss(__m128 a, __m128 b)
{
  return __builtin_ia32_maxss(a, b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_max_ps(__m128 a, __m128 b)
{
  return __builtin_ia32_maxps(a, b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_and_ps(__m128 a, __m128 b)
{
  return (__m128)((__v4si)a & (__v4si)b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_andnot_ps(__m128 a, __m128 b)
{
  return (__m128)(~(__v4si)a & (__v4si)b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_or_ps(__m128 a, __m128 b)
{
  return (__m128)((__v4si)a | (__v4si)b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_xor_ps(__m128 a, __m128 b)
{
  return (__m128)((__v4si)a ^ (__v4si)b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_ss(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpss(a, b, 0);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_ps(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpps(a, b, 0);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_ss(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpss(a, b, 1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_ps(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpps(a, b, 1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmple_ss(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpss(a, b, 2);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmple_ps(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpps(a, b, 2);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_ss(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpss(b, a, 1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_ps(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpps(b, a, 1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpge_ss(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpss(b, a, 2);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpge_ps(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpps(b, a, 2);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpneq_ss(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpss(a, b, 4);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpneq_ps(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpps(a, b, 4);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnlt_ss(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpss(a, b, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnlt_ps(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpps(a, b, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnle_ss(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpss(a, b, 6);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnle_ps(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpps(a, b, 6);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpngt_ss(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpss(b, a, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpngt_ps(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpps(b, a, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnge_ss(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpss(b, a, 6);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnge_ps(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpps(b, a, 6);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpord_ss(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpss(a, b, 7);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpord_ps(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpps(a, b, 7);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpunord_ss(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpss(a, b, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpunord_ps(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpps(a, b, 3);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comieq_ss(__m128 a, __m128 b)
{
  return __builtin_ia32_comieq(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comilt_ss(__m128 a, __m128 b)
{
  return __builtin_ia32_comilt(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comile_ss(__m128 a, __m128 b)
{
  return __builtin_ia32_comile(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comigt_ss(__m128 a, __m128 b)
{
  return __builtin_ia32_comigt(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comige_ss(__m128 a, __m128 b)
{
  return __builtin_ia32_comige(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comineq_ss(__m128 a, __m128 b)
{
  return __builtin_ia32_comineq(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomieq_ss(__m128 a, __m128 b)
{
  return __builtin_ia32_ucomieq(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomilt_ss(__m128 a, __m128 b)
{
  return __builtin_ia32_ucomilt(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomile_ss(__m128 a, __m128 b)
{
  return __builtin_ia32_ucomile(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomigt_ss(__m128 a, __m128 b)
{
  return __builtin_ia32_ucomigt(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomige_ss(__m128 a, __m128 b)
{
  return __builtin_ia32_ucomige(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomineq_ss(__m128 a, __m128 b)
{
  return __builtin_ia32_ucomineq(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtss_si32(__m128 a)
{
  return __builtin_ia32_cvtss2si(a);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvt_ss2si(__m128 a)
{
  return _mm_cvtss_si32(a);
}



static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvtss_si64(__m128 a)
{
  return __builtin_ia32_cvtss2si64(a);
}



static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_pi32(__m128 a)
{
  return (__m64)__builtin_ia32_cvtps2pi(a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvt_ps2pi(__m128 a)
{
  return _mm_cvtps_pi32(a);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvttss_si32(__m128 a)
{
  return a[0];
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtt_ss2si(__m128 a)
{
  return _mm_cvttss_si32(a);
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvttss_si64(__m128 a)
{
  return a[0];
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvttps_pi32(__m128 a)
{
  return (__m64)__builtin_ia32_cvttps2pi(a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtt_ps2pi(__m128 a)
{
  return _mm_cvttps_pi32(a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi32_ss(__m128 a, int b)
{
  a[0] = b;
  return a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvt_si2ss(__m128 a, int b)
{
  return _mm_cvtsi32_ss(a, b);
}



static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_ss(__m128 a, long long b)
{
  a[0] = b;
  return a;
}



static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi32_ps(__m128 a, __m64 b)
{
  return __builtin_ia32_cvtpi2ps(a, (__v2si)b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvt_pi2ps(__m128 a, __m64 b)
{
  return _mm_cvtpi32_ps(a, b);
}

static __inline__ float __attribute__((__always_inline__, __nodebug__))
_mm_cvtss_f32(__m128 a)
{
  return a[0];
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_loadh_pi(__m128 a, const __m64 *p)
{
  typedef float __mm_loadh_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_loadh_pi_struct {
    __mm_loadh_pi_v2f32 u;
  } __attribute__((__packed__, __may_alias__));
  __mm_loadh_pi_v2f32 b = ((struct __mm_loadh_pi_struct*)p)->u;
  __m128 bb = __builtin_shufflevector(b, b, 0, 1, 0, 1);
  return __builtin_shufflevector(a, bb, 0, 1, 4, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_loadl_pi(__m128 a, const __m64 *p)
{
  typedef float __mm_loadl_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_loadl_pi_struct {
    __mm_loadl_pi_v2f32 u;
  } __attribute__((__packed__, __may_alias__));
  __mm_loadl_pi_v2f32 b = ((struct __mm_loadl_pi_struct*)p)->u;
  __m128 bb = __builtin_shufflevector(b, b, 0, 1, 0, 1);
  return __builtin_shufflevector(a, bb, 4, 5, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_load_ss(const float *p)
{
  struct __mm_load_ss_struct {
    float u;
  } __attribute__((__packed__, __may_alias__));
  float u = ((struct __mm_load_ss_struct*)p)->u;
  return (__m128){ u, 0, 0, 0 };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_load1_ps(const float *p)
{
  struct __mm_load1_ps_struct {
    float u;
  } __attribute__((__packed__, __may_alias__));
  float u = ((struct __mm_load1_ps_struct*)p)->u;
  return (__m128){ u, u, u, u };
}



static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_load_ps(const float *p)
{
  return *(__m128*)p;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_loadu_ps(const float *p)
{
  struct __loadu_ps {
    __m128 v;
  } __attribute__((__packed__, __may_alias__));
  return ((struct __loadu_ps*)p)->v;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_loadr_ps(const float *p)
{
  __m128 a = _mm_load_ps(p);
  return __builtin_shufflevector(a, a, 3, 2, 1, 0);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_set_ss(float w)
{
  return (__m128){ w, 0, 0, 0 };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_set1_ps(float w)
{
  return (__m128){ w, w, w, w };
}


static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_set_ps1(float w)
{
    return _mm_set1_ps(w);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_set_ps(float z, float y, float x, float w)
{
  return (__m128){ w, x, y, z };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_setr_ps(float z, float y, float x, float w)
{
  return (__m128){ z, y, x, w };
}

static __inline__ __m128 __attribute__((__always_inline__))
_mm_setzero_ps(void)
{
  return (__m128){ 0, 0, 0, 0 };
}

static __inline__ void __attribute__((__always_inline__))
_mm_storeh_pi(__m64 *p, __m128 a)
{
  __builtin_ia32_storehps((__v2si *)p, a);
}

static __inline__ void __attribute__((__always_inline__))
_mm_storel_pi(__m64 *p, __m128 a)
{
  __builtin_ia32_storelps((__v2si *)p, a);
}

static __inline__ void __attribute__((__always_inline__))
_mm_store_ss(float *p, __m128 a)
{
  struct __mm_store_ss_struct {
    float u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store_ss_struct*)p)->u = a[0];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storeu_ps(float *p, __m128 a)
{
  __builtin_ia32_storeups(p, a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store1_ps(float *p, __m128 a)
{
  a = __builtin_shufflevector(a, a, 0, 0, 0, 0);
  _mm_storeu_ps(p, a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_ps1(float *p, __m128 a)
{
    return _mm_store1_ps(p, a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_ps(float *p, __m128 a)
{
  *(__m128 *)p = a;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storer_ps(float *p, __m128 a)
{
  a = __builtin_shufflevector(a, a, 3, 2, 1, 0);
  _mm_store_ps(p, a);
}
# 669 "/usr/bin/../lib/clang/3.0/include/xmmintrin.h" 3 4
static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_pi(__m64 *p, __m64 a)
{
  __builtin_ia32_movntq(p, a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_ps(float *p, __m128 a)
{
  __builtin_ia32_movntps(p, a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_sfence(void)
{
  __builtin_ia32_sfence();
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_extract_pi16(__m64 a, int n)
{
  __v4hi b = (__v4hi)a;
  return (unsigned short)b[n & 3];
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_insert_pi16(__m64 a, int d, int n)
{
   __v4hi b = (__v4hi)a;
   b[n & 3] = d;
   return (__m64)b;
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_max_pi16(__m64 a, __m64 b)
{
  return (__m64)__builtin_ia32_pmaxsw((__v4hi)a, (__v4hi)b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_max_pu8(__m64 a, __m64 b)
{
  return (__m64)__builtin_ia32_pmaxub((__v8qi)a, (__v8qi)b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_min_pi16(__m64 a, __m64 b)
{
  return (__m64)__builtin_ia32_pminsw((__v4hi)a, (__v4hi)b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_min_pu8(__m64 a, __m64 b)
{
  return (__m64)__builtin_ia32_pminub((__v8qi)a, (__v8qi)b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_movemask_pi8(__m64 a)
{
  return __builtin_ia32_pmovmskb((__v8qi)a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_mulhi_pu16(__m64 a, __m64 b)
{
  return (__m64)__builtin_ia32_pmulhuw((__v4hi)a, (__v4hi)b);
}




static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_maskmove_si64(__m64 d, __m64 n, char *p)
{
  __builtin_ia32_maskmovq((__v8qi)d, (__v8qi)n, p);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_avg_pu8(__m64 a, __m64 b)
{
  return (__m64)__builtin_ia32_pavgb((__v8qi)a, (__v8qi)b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_avg_pu16(__m64 a, __m64 b)
{
  return (__m64)__builtin_ia32_pavgw((__v4hi)a, (__v4hi)b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sad_pu8(__m64 a, __m64 b)
{
  return (__m64)__builtin_ia32_psadbw((__v8qi)a, (__v8qi)b);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__))
_mm_getcsr(void)
{
  return __builtin_ia32_stmxcsr();
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_setcsr(unsigned int i)
{
  __builtin_ia32_ldmxcsr(i);
}







static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_ps(__m128 a, __m128 b)
{
  return __builtin_shufflevector(a, b, 2, 6, 3, 7);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_ps(__m128 a, __m128 b)
{
  return __builtin_shufflevector(a, b, 0, 4, 1, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_move_ss(__m128 a, __m128 b)
{
  return __builtin_shufflevector(a, b, 4, 1, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_movehl_ps(__m128 a, __m128 b)
{
  return __builtin_shufflevector(a, b, 6, 7, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_movelh_ps(__m128 a, __m128 b)
{
  return __builtin_shufflevector(a, b, 0, 1, 4, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi16_ps(__m64 a)
{
  __m64 b, c;
  __m128 r;

  b = _mm_setzero_si64();
  b = _mm_cmpgt_pi16(b, a);
  c = _mm_unpackhi_pi16(a, b);
  r = _mm_setzero_ps();
  r = _mm_cvtpi32_ps(r, c);
  r = _mm_movelh_ps(r, r);
  c = _mm_unpacklo_pi16(a, b);
  r = _mm_cvtpi32_ps(r, c);

  return r;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpu16_ps(__m64 a)
{
  __m64 b, c;
  __m128 r;

  b = _mm_setzero_si64();
  c = _mm_unpackhi_pi16(a, b);
  r = _mm_setzero_ps();
  r = _mm_cvtpi32_ps(r, c);
  r = _mm_movelh_ps(r, r);
  c = _mm_unpacklo_pi16(a, b);
  r = _mm_cvtpi32_ps(r, c);

  return r;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi8_ps(__m64 a)
{
  __m64 b;

  b = _mm_setzero_si64();
  b = _mm_cmpgt_pi8(b, a);
  b = _mm_unpacklo_pi8(a, b);

  return _mm_cvtpi16_ps(b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpu8_ps(__m64 a)
{
  __m64 b;

  b = _mm_setzero_si64();
  b = _mm_unpacklo_pi8(a, b);

  return _mm_cvtpi16_ps(b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi32x2_ps(__m64 a, __m64 b)
{
  __m128 c;

  c = _mm_setzero_ps();
  c = _mm_cvtpi32_ps(c, b);
  c = _mm_movelh_ps(c, c);

  return _mm_cvtpi32_ps(c, a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_pi16(__m128 a)
{
  __m64 b, c;

  b = _mm_cvtps_pi32(a);
  a = _mm_movehl_ps(a, a);
  c = _mm_cvtps_pi32(a);

  return _mm_packs_pi16(b, c);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_pi8(__m128 a)
{
  __m64 b, c;

  b = _mm_cvtps_pi16(a);
  c = _mm_setzero_si64();

  return _mm_packs_pi16(b, c);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_movemask_ps(__m128 a)
{
  return __builtin_ia32_movmskps(a);
}
# 982 "/usr/bin/../lib/clang/3.0/include/xmmintrin.h" 3 4
# 1 "/usr/bin/../lib/clang/3.0/include/emmintrin.h" 1 3 4
# 983 "/usr/bin/../lib/clang/3.0/include/xmmintrin.h" 2 3 4
# 32 "/usr/bin/../lib/clang/3.0/include/emmintrin.h" 2 3 4

typedef double __m128d __attribute__((__vector_size__(16)));
typedef long long __m128i __attribute__((__vector_size__(16)));


typedef double __v2df __attribute__ ((__vector_size__ (16)));
typedef long long __v2di __attribute__ ((__vector_size__ (16)));
typedef short __v8hi __attribute__((__vector_size__(16)));
typedef char __v16qi __attribute__((__vector_size__(16)));

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_add_sd(__m128d a, __m128d b)
{
  a[0] += b[0];
  return a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_add_pd(__m128d a, __m128d b)
{
  return a + b;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_sub_sd(__m128d a, __m128d b)
{
  a[0] -= b[0];
  return a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_sub_pd(__m128d a, __m128d b)
{
  return a - b;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_mul_sd(__m128d a, __m128d b)
{
  a[0] *= b[0];
  return a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_mul_pd(__m128d a, __m128d b)
{
  return a * b;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_div_sd(__m128d a, __m128d b)
{
  a[0] /= b[0];
  return a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_div_pd(__m128d a, __m128d b)
{
  return a / b;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_sqrt_sd(__m128d a, __m128d b)
{
  __m128d c = __builtin_ia32_sqrtsd(b);
  return (__m128d) { c[0], a[1] };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_sqrt_pd(__m128d a)
{
  return __builtin_ia32_sqrtpd(a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_min_sd(__m128d a, __m128d b)
{
  return __builtin_ia32_minsd(a, b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_min_pd(__m128d a, __m128d b)
{
  return __builtin_ia32_minpd(a, b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_max_sd(__m128d a, __m128d b)
{
  return __builtin_ia32_maxsd(a, b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_max_pd(__m128d a, __m128d b)
{
  return __builtin_ia32_maxpd(a, b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_and_pd(__m128d a, __m128d b)
{
  return (__m128d)((__v4si)a & (__v4si)b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_andnot_pd(__m128d a, __m128d b)
{
  return (__m128d)(~(__v4si)a & (__v4si)b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_or_pd(__m128d a, __m128d b)
{
  return (__m128d)((__v4si)a | (__v4si)b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_xor_pd(__m128d a, __m128d b)
{
  return (__m128d)((__v4si)a ^ (__v4si)b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_pd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmppd(a, b, 0);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_pd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmppd(a, b, 1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmple_pd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmppd(a, b, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_pd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmppd(b, a, 1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpge_pd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmppd(b, a, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpord_pd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmppd(a, b, 7);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpunord_pd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmppd(a, b, 3);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpneq_pd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmppd(a, b, 4);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnlt_pd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmppd(a, b, 5);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnle_pd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmppd(a, b, 6);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpngt_pd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmppd(b, a, 5);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnge_pd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmppd(b, a, 6);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_sd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmpsd(a, b, 0);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_sd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmpsd(a, b, 1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmple_sd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmpsd(a, b, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_sd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmpsd(b, a, 1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpge_sd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmpsd(b, a, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpord_sd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmpsd(a, b, 7);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpunord_sd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmpsd(a, b, 3);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpneq_sd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmpsd(a, b, 4);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnlt_sd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmpsd(a, b, 5);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnle_sd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmpsd(a, b, 6);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpngt_sd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmpsd(b, a, 5);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnge_sd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmpsd(b, a, 6);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comieq_sd(__m128d a, __m128d b)
{
  return __builtin_ia32_comisdeq(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comilt_sd(__m128d a, __m128d b)
{
  return __builtin_ia32_comisdlt(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comile_sd(__m128d a, __m128d b)
{
  return __builtin_ia32_comisdle(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comigt_sd(__m128d a, __m128d b)
{
  return __builtin_ia32_comisdgt(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comige_sd(__m128d a, __m128d b)
{
  return __builtin_ia32_comisdge(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comineq_sd(__m128d a, __m128d b)
{
  return __builtin_ia32_comisdneq(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomieq_sd(__m128d a, __m128d b)
{
  return __builtin_ia32_ucomisdeq(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomilt_sd(__m128d a, __m128d b)
{
  return __builtin_ia32_ucomisdlt(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomile_sd(__m128d a, __m128d b)
{
  return __builtin_ia32_ucomisdle(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomigt_sd(__m128d a, __m128d b)
{
  return __builtin_ia32_ucomisdgt(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomige_sd(__m128d a, __m128d b)
{
  return __builtin_ia32_ucomisdge(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomineq_sd(__m128d a, __m128d b)
{
  return __builtin_ia32_ucomisdneq(a, b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpd_ps(__m128d a)
{
  return __builtin_ia32_cvtpd2ps(a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_pd(__m128 a)
{
  return __builtin_ia32_cvtps2pd(a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtepi32_pd(__m128i a)
{
  return __builtin_ia32_cvtdq2pd((__v4si)a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtpd_epi32(__m128d a)
{
  return __builtin_ia32_cvtpd2dq(a);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtsd_si32(__m128d a)
{
  return __builtin_ia32_cvtsd2si(a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsd_ss(__m128 a, __m128d b)
{
  a[0] = b[0];
  return a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi32_sd(__m128d a, int b)
{
  a[0] = b;
  return a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtss_sd(__m128d a, __m128 b)
{
  a[0] = b[0];
  return a;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvttpd_epi32(__m128d a)
{
  return (__m128i)__builtin_ia32_cvttpd2dq(a);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvttsd_si32(__m128d a)
{
  return a[0];
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpd_pi32(__m128d a)
{
  return (__m64)__builtin_ia32_cvtpd2pi(a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvttpd_pi32(__m128d a)
{
  return (__m64)__builtin_ia32_cvttpd2pi(a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi32_pd(__m64 a)
{
  return __builtin_ia32_cvtpi2pd((__v2si)a);
}

static __inline__ double __attribute__((__always_inline__, __nodebug__))
_mm_cvtsd_f64(__m128d a)
{
  return a[0];
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_load_pd(double const *dp)
{
  return *(__m128d*)dp;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_load1_pd(double const *dp)
{
  struct __mm_load1_pd_struct {
    double u;
  } __attribute__((__packed__, __may_alias__));
  double u = ((struct __mm_load1_pd_struct*)dp)->u;
  return (__m128d){ u, u };
}



static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_loadr_pd(double const *dp)
{
  __m128d u = *(__m128d*)dp;
  return __builtin_shufflevector(u, u, 1, 0);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_loadu_pd(double const *dp)
{
  struct __loadu_pd {
    __m128d v;
  } __attribute__((packed, may_alias));
  return ((struct __loadu_pd*)dp)->v;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_load_sd(double const *dp)
{
  struct __mm_load_sd_struct {
    double u;
  } __attribute__((__packed__, __may_alias__));
  double u = ((struct __mm_load_sd_struct*)dp)->u;
  return (__m128d){ u, 0 };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_loadh_pd(__m128d a, double const *dp)
{
  struct __mm_loadh_pd_struct {
    double u;
  } __attribute__((__packed__, __may_alias__));
  double u = ((struct __mm_loadh_pd_struct*)dp)->u;
  return (__m128d){ a[0], u };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_loadl_pd(__m128d a, double const *dp)
{
  struct __mm_loadl_pd_struct {
    double u;
  } __attribute__((__packed__, __may_alias__));
  double u = ((struct __mm_loadl_pd_struct*)dp)->u;
  return (__m128d){ u, a[1] };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_set_sd(double w)
{
  return (__m128d){ w, 0 };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_set1_pd(double w)
{
  return (__m128d){ w, w };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_set_pd(double w, double x)
{
  return (__m128d){ x, w };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_setr_pd(double w, double x)
{
  return (__m128d){ w, x };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_setzero_pd(void)
{
  return (__m128d){ 0, 0 };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_move_sd(__m128d a, __m128d b)
{
  return (__m128d){ b[0], a[1] };
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_sd(double *dp, __m128d a)
{
  struct __mm_store_sd_struct {
    double u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store_sd_struct*)dp)->u = a[0];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store1_pd(double *dp, __m128d a)
{
  struct __mm_store1_pd_struct {
    double u[2];
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store1_pd_struct*)dp)->u[0] = a[0];
  ((struct __mm_store1_pd_struct*)dp)->u[1] = a[0];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_pd(double *dp, __m128d a)
{
  *(__m128d *)dp = a;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storeu_pd(double *dp, __m128d a)
{
  __builtin_ia32_storeupd(dp, a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storer_pd(double *dp, __m128d a)
{
  a = __builtin_shufflevector(a, a, 1, 0);
  *(__m128d *)dp = a;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storeh_pd(double *dp, __m128d a)
{
  struct __mm_storeh_pd_struct {
    double u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pd_struct*)dp)->u = a[1];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storel_pd(double *dp, __m128d a)
{
  struct __mm_storeh_pd_struct {
    double u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pd_struct*)dp)->u = a[0];
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_add_epi8(__m128i a, __m128i b)
{
  return (__m128i)((__v16qi)a + (__v16qi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_add_epi16(__m128i a, __m128i b)
{
  return (__m128i)((__v8hi)a + (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_add_epi32(__m128i a, __m128i b)
{
  return (__m128i)((__v4si)a + (__v4si)b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_add_si64(__m64 a, __m64 b)
{
  return a + b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_add_epi64(__m128i a, __m128i b)
{
  return a + b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_adds_epi8(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_paddsb128((__v16qi)a, (__v16qi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_adds_epi16(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_paddsw128((__v8hi)a, (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_adds_epu8(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_paddusb128((__v16qi)a, (__v16qi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_adds_epu16(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_paddusw128((__v8hi)a, (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_avg_epu8(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_pavgb128((__v16qi)a, (__v16qi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_avg_epu16(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_pavgw128((__v8hi)a, (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_madd_epi16(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_pmaddwd128((__v8hi)a, (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_max_epi16(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_pmaxsw128((__v8hi)a, (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_max_epu8(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_pmaxub128((__v16qi)a, (__v16qi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_min_epi16(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_pminsw128((__v8hi)a, (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_min_epu8(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_pminub128((__v16qi)a, (__v16qi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mulhi_epi16(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_pmulhw128((__v8hi)a, (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mulhi_epu16(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_pmulhuw128((__v8hi)a, (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mullo_epi16(__m128i a, __m128i b)
{
  return (__m128i)((__v8hi)a * (__v8hi)b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_mul_su32(__m64 a, __m64 b)
{
  return __builtin_ia32_pmuludq((__v2si)a, (__v2si)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mul_epu32(__m128i a, __m128i b)
{
  return __builtin_ia32_pmuludq128((__v4si)a, (__v4si)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sad_epu8(__m128i a, __m128i b)
{
  return __builtin_ia32_psadbw128((__v16qi)a, (__v16qi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sub_epi8(__m128i a, __m128i b)
{
  return (__m128i)((__v16qi)a - (__v16qi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sub_epi16(__m128i a, __m128i b)
{
  return (__m128i)((__v8hi)a - (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sub_epi32(__m128i a, __m128i b)
{
  return (__m128i)((__v4si)a - (__v4si)b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sub_si64(__m64 a, __m64 b)
{
  return a - b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sub_epi64(__m128i a, __m128i b)
{
  return a - b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_subs_epi8(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_psubsb128((__v16qi)a, (__v16qi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_subs_epi16(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_psubsw128((__v8hi)a, (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_subs_epu8(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_psubusb128((__v16qi)a, (__v16qi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_subs_epu16(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_psubusw128((__v8hi)a, (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_and_si128(__m128i a, __m128i b)
{
  return a & b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_andnot_si128(__m128i a, __m128i b)
{
  return ~a & b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_or_si128(__m128i a, __m128i b)
{
  return a | b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_xor_si128(__m128i a, __m128i b)
{
  return a ^ b;
}




static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_slli_epi16(__m128i a, int count)
{
  return (__m128i)__builtin_ia32_psllwi128((__v8hi)a, count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sll_epi16(__m128i a, __m128i count)
{
  return (__m128i)__builtin_ia32_psllw128((__v8hi)a, (__v8hi)count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_slli_epi32(__m128i a, int count)
{
  return (__m128i)__builtin_ia32_pslldi128((__v4si)a, count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sll_epi32(__m128i a, __m128i count)
{
  return (__m128i)__builtin_ia32_pslld128((__v4si)a, (__v4si)count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_slli_epi64(__m128i a, int count)
{
  return __builtin_ia32_psllqi128(a, count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sll_epi64(__m128i a, __m128i count)
{
  return __builtin_ia32_psllq128(a, count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srai_epi16(__m128i a, int count)
{
  return (__m128i)__builtin_ia32_psrawi128((__v8hi)a, count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sra_epi16(__m128i a, __m128i count)
{
  return (__m128i)__builtin_ia32_psraw128((__v8hi)a, (__v8hi)count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srai_epi32(__m128i a, int count)
{
  return (__m128i)__builtin_ia32_psradi128((__v4si)a, count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sra_epi32(__m128i a, __m128i count)
{
  return (__m128i)__builtin_ia32_psrad128((__v4si)a, (__v4si)count);
}





static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srli_epi16(__m128i a, int count)
{
  return (__m128i)__builtin_ia32_psrlwi128((__v8hi)a, count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srl_epi16(__m128i a, __m128i count)
{
  return (__m128i)__builtin_ia32_psrlw128((__v8hi)a, (__v8hi)count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srli_epi32(__m128i a, int count)
{
  return (__m128i)__builtin_ia32_psrldi128((__v4si)a, count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srl_epi32(__m128i a, __m128i count)
{
  return (__m128i)__builtin_ia32_psrld128((__v4si)a, (__v4si)count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srli_epi64(__m128i a, int count)
{
  return __builtin_ia32_psrlqi128(a, count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srl_epi64(__m128i a, __m128i count)
{
  return __builtin_ia32_psrlq128(a, count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_epi8(__m128i a, __m128i b)
{
  return (__m128i)((__v16qi)a == (__v16qi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_epi16(__m128i a, __m128i b)
{
  return (__m128i)((__v8hi)a == (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_epi32(__m128i a, __m128i b)
{
  return (__m128i)((__v4si)a == (__v4si)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_epi8(__m128i a, __m128i b)
{
  return (__m128i)((__v16qi)a > (__v16qi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_epi16(__m128i a, __m128i b)
{
  return (__m128i)((__v8hi)a > (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_epi32(__m128i a, __m128i b)
{
  return (__m128i)((__v4si)a > (__v4si)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_epi8(__m128i a, __m128i b)
{
  return _mm_cmpgt_epi8(b,a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_epi16(__m128i a, __m128i b)
{
  return _mm_cmpgt_epi16(b,a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_epi32(__m128i a, __m128i b)
{
  return _mm_cmpgt_epi32(b,a);
}


static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_sd(__m128d a, long long b)
{
  a[0] = b;
  return a;
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvtsd_si64(__m128d a)
{
  return __builtin_ia32_cvtsd2si64(a);
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvttsd_si64(__m128d a)
{
  return a[0];
}


static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtepi32_ps(__m128i a)
{
  return __builtin_ia32_cvtdq2ps((__v4si)a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_epi32(__m128 a)
{
  return (__m128i)__builtin_ia32_cvtps2dq(a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvttps_epi32(__m128 a)
{
  return (__m128i)__builtin_ia32_cvttps2dq(a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi32_si128(int a)
{
  return (__m128i)(__v4si){ a, 0, 0, 0 };
}


static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_si128(long long a)
{
  return (__m128i){ a, 0 };
}


static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi128_si32(__m128i a)
{
  __v4si b = (__v4si)a;
  return b[0];
}


static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi128_si64(__m128i a)
{
  return a[0];
}


static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_load_si128(__m128i const *p)
{
  return *p;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_loadu_si128(__m128i const *p)
{
  struct __loadu_si128 {
    __m128i v;
  } __attribute__((packed, may_alias));
  return ((struct __loadu_si128*)p)->v;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_loadl_epi64(__m128i const *p)
{
  struct __mm_loadl_epi64_struct {
    long long u;
  } __attribute__((__packed__, __may_alias__));
  return (__m128i) { ((struct __mm_loadl_epi64_struct*)p)->u, 0};
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi64x(long long q1, long long q0)
{
  return (__m128i){ q0, q1 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi64(__m64 q1, __m64 q0)
{
  return (__m128i){ (long long)q0, (long long)q1 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi32(int i3, int i2, int i1, int i0)
{
  return (__m128i)(__v4si){ i0, i1, i2, i3};
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi16(short w7, short w6, short w5, short w4, short w3, short w2, short w1, short w0)
{
  return (__m128i)(__v8hi){ w0, w1, w2, w3, w4, w5, w6, w7 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi8(char b15, char b14, char b13, char b12, char b11, char b10, char b9, char b8, char b7, char b6, char b5, char b4, char b3, char b2, char b1, char b0)
{
  return (__m128i)(__v16qi){ b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi64x(long long q)
{
  return (__m128i){ q, q };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi64(__m64 q)
{
  return (__m128i){ (long long)q, (long long)q };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi32(int i)
{
  return (__m128i)(__v4si){ i, i, i, i };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi16(short w)
{
  return (__m128i)(__v8hi){ w, w, w, w, w, w, w, w };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi8(char b)
{
  return (__m128i)(__v16qi){ b, b, b, b, b, b, b, b, b, b, b, b, b, b, b, b };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setr_epi64(__m64 q0, __m64 q1)
{
  return (__m128i){ (long long)q0, (long long)q1 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setr_epi32(int i0, int i1, int i2, int i3)
{
  return (__m128i)(__v4si){ i0, i1, i2, i3};
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setr_epi16(short w0, short w1, short w2, short w3, short w4, short w5, short w6, short w7)
{
  return (__m128i)(__v8hi){ w0, w1, w2, w3, w4, w5, w6, w7 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setr_epi8(char b0, char b1, char b2, char b3, char b4, char b5, char b6, char b7, char b8, char b9, char b10, char b11, char b12, char b13, char b14, char b15)
{
  return (__m128i)(__v16qi){ b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setzero_si128(void)
{
  return (__m128i){ 0LL, 0LL };
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_si128(__m128i *p, __m128i b)
{
  *p = b;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storeu_si128(__m128i *p, __m128i b)
{
  __builtin_ia32_storedqu((char *)p, (__v16qi)b);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_maskmoveu_si128(__m128i d, __m128i n, char *p)
{
  __builtin_ia32_maskmovdqu((__v16qi)d, (__v16qi)n, p);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storel_epi64(__m128i *p, __m128i a)
{
  __builtin_ia32_storelv4si((__v2si *)p, a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_pd(double *p, __m128d a)
{
  __builtin_ia32_movntpd(p, a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_si128(__m128i *p, __m128i a)
{
  __builtin_ia32_movntdq(p, a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_si32(int *p, int a)
{
  __builtin_ia32_movnti(p, a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_clflush(void const *p)
{
  __builtin_ia32_clflush(p);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_lfence(void)
{
  __builtin_ia32_lfence();
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_mfence(void)
{
  __builtin_ia32_mfence();
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_packs_epi16(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_packsswb128((__v8hi)a, (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_packs_epi32(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_packssdw128((__v4si)a, (__v4si)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_packus_epi16(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_packuswb128((__v8hi)a, (__v8hi)b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_extract_epi16(__m128i a, int imm)
{
  __v8hi b = (__v8hi)a;
  return (unsigned short)b[imm];
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_insert_epi16(__m128i a, int b, int imm)
{
  __v8hi c = (__v8hi)a;
  c[imm & 7] = b;
  return (__m128i)c;
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_movemask_epi8(__m128i a)
{
  return __builtin_ia32_pmovmskb128((__v16qi)a);
}
# 1280 "/usr/bin/../lib/clang/3.0/include/emmintrin.h" 3 4
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_epi8(__m128i a, __m128i b)
{
  return (__m128i)__builtin_shufflevector((__v16qi)a, (__v16qi)b, 8, 16+8, 9, 16+9, 10, 16+10, 11, 16+11, 12, 16+12, 13, 16+13, 14, 16+14, 15, 16+15);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_epi16(__m128i a, __m128i b)
{
  return (__m128i)__builtin_shufflevector((__v8hi)a, (__v8hi)b, 4, 8+4, 5, 8+5, 6, 8+6, 7, 8+7);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_epi32(__m128i a, __m128i b)
{
  return (__m128i)__builtin_shufflevector((__v4si)a, (__v4si)b, 2, 4+2, 3, 4+3);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_epi64(__m128i a, __m128i b)
{
  return (__m128i)__builtin_shufflevector(a, b, 1, 2+1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_epi8(__m128i a, __m128i b)
{
  return (__m128i)__builtin_shufflevector((__v16qi)a, (__v16qi)b, 0, 16+0, 1, 16+1, 2, 16+2, 3, 16+3, 4, 16+4, 5, 16+5, 6, 16+6, 7, 16+7);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_epi16(__m128i a, __m128i b)
{
  return (__m128i)__builtin_shufflevector((__v8hi)a, (__v8hi)b, 0, 8+0, 1, 8+1, 2, 8+2, 3, 8+3);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_epi32(__m128i a, __m128i b)
{
  return (__m128i)__builtin_shufflevector((__v4si)a, (__v4si)b, 0, 4+0, 1, 4+1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_epi64(__m128i a, __m128i b)
{
  return (__m128i)__builtin_shufflevector(a, b, 0, 2+0);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_movepi64_pi64(__m128i a)
{
  return (__m64)a[0];
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_movpi64_pi64(__m64 a)
{
  return (__m128i){ (long long)a, 0 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_move_epi64(__m128i a)
{
  return __builtin_shufflevector(a, (__m128i){ 0 }, 0, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_pd(__m128d a, __m128d b)
{
  return __builtin_shufflevector(a, b, 1, 2+1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_pd(__m128d a, __m128d b)
{
  return __builtin_shufflevector(a, b, 0, 2+0);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_movemask_pd(__m128d a)
{
  return __builtin_ia32_movmskpd(a);
}





static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_castpd_ps(__m128d in)
{
  return (__m128)in;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_castpd_si128(__m128d in)
{
  return (__m128i)in;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_castps_pd(__m128 in)
{
  return (__m128d)in;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_castps_si128(__m128 in)
{
  return (__m128i)in;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_castsi128_ps(__m128i in)
{
  return (__m128)in;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_castsi128_pd(__m128i in)
{
  return (__m128d)in;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_pause(void)
{
  __asm__ volatile ("pause");
}
# 100 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 113 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core"
    }
# 144 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core"
# 1 "/usr/include/c++/4.5.3/cerrno" 1 3
# 41 "/usr/include/c++/4.5.3/cerrno" 3
# 41 "/usr/include/c++/4.5.3/cerrno" 3

# 1 "/usr/include/errno.h" 1 3 4
# 43 "/usr/include/c++/4.5.3/cerrno" 2 3
# 145 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2

# 1 "/usr/include/c++/4.5.3/cstddef" 1 3
# 41 "/usr/include/c++/4.5.3/cstddef" 3
# 41 "/usr/include/c++/4.5.3/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.5.3/cstddef" 2 3
# 147 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/usr/include/c++/4.5.3/cstdlib" 1 3
# 41 "/usr/include/c++/4.5.3/cstdlib" 3
# 41 "/usr/include/c++/4.5.3/cstdlib" 3


# 1 "/usr/include/c++/4.5.3/cstddef" 1 3
# 41 "/usr/include/c++/4.5.3/cstddef" 3
# 41 "/usr/include/c++/4.5.3/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.5.3/cstddef" 2 3
# 44 "/usr/include/c++/4.5.3/cstdlib" 2 3
# 148 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/usr/include/c++/4.5.3/cmath" 1 3
# 41 "/usr/include/c++/4.5.3/cmath" 3
# 41 "/usr/include/c++/4.5.3/cmath" 3
# 149 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2

# 1 "/usr/include/c++/4.5.3/cassert" 1 3
# 43 "/usr/include/c++/4.5.3/cassert" 3
# 43 "/usr/include/c++/4.5.3/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 66 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
             __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
             __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
             __attribute__ ((__noreturn__));


}
# 45 "/usr/include/c++/4.5.3/cassert" 2 3
# 151 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/usr/include/c++/4.5.3/functional" 1 3
# 47 "/usr/include/c++/4.5.3/functional" 3
# 47 "/usr/include/c++/4.5.3/functional" 3
# 152 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2

# 1 "/usr/include/c++/4.5.3/cstring" 1 3
# 41 "/usr/include/c++/4.5.3/cstring" 3
# 41 "/usr/include/c++/4.5.3/cstring" 3


# 1 "/usr/include/c++/4.5.3/cstddef" 1 3
# 41 "/usr/include/c++/4.5.3/cstddef" 3
# 41 "/usr/include/c++/4.5.3/cstddef" 3


# 1 "/usr/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.5.3/cstddef" 2 3
# 44 "/usr/include/c++/4.5.3/cstring" 2 3
# 1 "/usr/include/string.h" 1 3 4
# 29 "/usr/include/string.h" 3 4
extern "C" {





# 1 "/usr/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 35 "/usr/include/string.h" 2 3 4
# 44 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest,
       __const void *__restrict __src, size_t __n)
             __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, __const void *__src, size_t __n)
             __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
        int __c, size_t __n)
             __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nonnull__ (1)));


extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 95 "/usr/include/string.h" 3 4
extern void *memchr (__const void *__s, int __c, size_t __n)
              __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 109 "/usr/include/string.h" 3 4
extern void *rawmemchr (__const void *__s, int __c)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 120 "/usr/include/string.h" 3 4
extern void *memrchr (__const void *__s, int __c, size_t __n)
              __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
             __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
             __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
             __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
        size_t __n) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (__const char *__s1, __const char *__s2)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (__const char *__s1, __const char *__s2)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         __const char *__restrict __src, size_t __n)
             __attribute__ ((__nonnull__ (2)));
# 165 "/usr/include/string.h" 3 4
extern int strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
    __locale_t __l) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (__const char *__s)
             __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (__const char *__string, size_t __n)
             __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 235 "/usr/include/string.h" 3 4
extern char *strchr (__const char *__s, int __c)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 262 "/usr/include/string.h" 3 4
extern char *strrchr (__const char *__s, int __c)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 276 "/usr/include/string.h" 3 4
extern char *strchrnul (__const char *__s, int __c)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern size_t strcspn (__const char *__s, __const char *__reject)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (__const char *__s, __const char *__accept)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 314 "/usr/include/string.h" 3 4
extern char *strpbrk (__const char *__s, __const char *__accept)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 342 "/usr/include/string.h" 3 4
extern char *strstr (__const char *__haystack, __const char *__needle)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
             __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    __const char *__restrict __delim,
    char **__restrict __save_ptr)
             __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
         char **__restrict __save_ptr)
             __attribute__ ((__nonnull__ (2, 3)));
# 373 "/usr/include/string.h" 3 4
extern char *strcasestr (__const char *__haystack, __const char *__needle)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));







extern void *memmem (__const void *__haystack, size_t __haystacklen,
       __const void *__needle, size_t __needlelen)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   __const void *__restrict __src, size_t __n)
             __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        __const void *__restrict __src, size_t __n)
             __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (__const char *__s)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (__const char *__string, size_t __maxlen)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) ;
# 438 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
             __attribute__ ((__nonnull__ (2)));





extern char *strerror_l (int __errnum, __locale_t __l) ;





extern void __bzero (void *__s, size_t __n) __attribute__ ((__nonnull__ (1)));



extern void bcopy (__const void *__src, void *__dest, size_t __n)
             __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nonnull__ (1)));


extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 489 "/usr/include/string.h" 3 4
extern char *index (__const char *__s, int __c)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 517 "/usr/include/string.h" 3 4
extern char *rindex (__const char *__s, int __c)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern int ffs (int __i) __attribute__ ((__const__));




extern int ffsl (long int __l) __attribute__ ((__const__));

__extension__ extern int ffsll (long long int __ll)
             __attribute__ ((__const__));




extern int strcasecmp (__const char *__s1, __const char *__s2)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (__const char *__s1, __const char *__s2,
    __locale_t __loc)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (__const char *__s1, __const char *__s2,
     size_t __n, __locale_t __loc)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       __const char *__restrict __delim)
             __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) ;


extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
             __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
             __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   __const char *__restrict __src, size_t __n)
             __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
             __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (__const char *__s1, __const char *__s2)
             __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nonnull__ (1)));
# 606 "/usr/include/string.h" 3 4
extern char *basename (__const char *__filename) __attribute__ ((__nonnull__ (1)));
# 646 "/usr/include/string.h" 3 4
}
# 45 "/usr/include/c++/4.5.3/cstring" 2 3
# 73 "/usr/include/c++/4.5.3/cstring" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;


  inline void*
  memchr(void* __s, int __c, size_t __n)
  { return __builtin_memchr(__s, __c, __n); }

  inline char*
  strchr(char* __s, int __n)
  { return __builtin_strchr(__s, __n); }

  inline char*
  strpbrk(char* __s1, const char* __s2)
  { return __builtin_strpbrk(__s1, __s2); }

  inline char*
  strrchr(char* __s, int __n)
  { return __builtin_strrchr(__s, __n); }

  inline char*
  strstr(char* __s1, const char* __s2)
  { return __builtin_strstr(__s1, __s2); }


}
# 154 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2


# 1 "/usr/include/c++/4.5.3/climits" 1 3
# 41 "/usr/include/c++/4.5.3/climits" 3
# 41 "/usr/include/c++/4.5.3/climits" 3

# 1 "/usr/bin/../lib/clang/3.0/include/limits.h" 1 3 4
# 38 "/usr/bin/../lib/clang/3.0/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 145 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
# 157 "/usr/include/bits/posix1_lim.h" 3 4
# 1 "/usr/include/bits/local_lim.h" 1 3 4
# 39 "/usr/include/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 40 "/usr/include/bits/local_lim.h" 2 3 4
# 158 "/usr/include/bits/posix1_lim.h" 2 3 4
# 146 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/posix2_lim.h" 1 3 4
# 150 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/xopen_lim.h" 1 3 4
# 34 "/usr/include/bits/xopen_lim.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 35 "/usr/include/bits/xopen_lim.h" 2 3 4
# 154 "/usr/include/limits.h" 2 3 4
# 39 "/usr/bin/../lib/clang/3.0/include/limits.h" 2 3 4
# 43 "/usr/include/c++/4.5.3/climits" 2 3
# 157 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 182 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core"
namespace Eigen {

inline static const char *SimdInstructionSetsInUse(void) {
# 194 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core"
  return "SSE, SSE2";







}
# 236 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core"
using std::size_t;

using std::ptrdiff_t;
# 250 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core"
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Constants.h" 1
# 34 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Constants.h"
const int Dynamic = -1;




const int Infinity = -1;
# 61 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Constants.h"
const unsigned int RowMajorBit = 0x1;




const unsigned int EvalBeforeNestingBit = 0x2;




const unsigned int EvalBeforeAssigningBit = 0x4;
# 89 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Constants.h"
const unsigned int PacketAccessBit = 0x8;
# 100 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Constants.h"
const unsigned int ActualPacketAccessBit = PacketAccessBit;
# 125 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Constants.h"
const unsigned int LinearAccessBit = 0x10;
# 139 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Constants.h"
const unsigned int LvalueBit = 0x20;
# 150 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Constants.h"
const unsigned int DirectAccessBit = 0x40;




const unsigned int AlignedBit = 0x80;

const unsigned int NestByRefBit = 0x100;


const unsigned int HereditaryBits = RowMajorBit
                                  | EvalBeforeNestingBit
                                  | EvalBeforeAssigningBit;
# 173 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Constants.h"
enum {

  Lower=0x1,

  Upper=0x2,

  UnitDiag=0x4,

  ZeroDiag=0x8,

  UnitLower=UnitDiag|Lower,

  UnitUpper=UnitDiag|Upper,

  StrictlyLower=ZeroDiag|Lower,

  StrictlyUpper=ZeroDiag|Upper,

  SelfAdjoint=0x10
};



enum {

  Unaligned=0,

  Aligned=1
};

enum { ConditionalJumpCost = 5 };





enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };




enum DirectionType {


  Vertical,


  Horizontal,


  BothDirections
};

enum ProductEvaluationMode { NormalProduct, CacheFriendlyProduct };



enum {

  DefaultTraversal,

  LinearTraversal,


  InnerVectorizedTraversal,


  LinearVectorizedTraversal,


  SliceVectorizedTraversal,

  InvalidTraversal
};



enum {

  NoUnrolling,

  InnerUnrolling,


  CompleteUnrolling
};




enum {

  ColMajor = 0,

  RowMajor = 0x1,

  AutoAlign = 0,

  DontAlign = 0x2
};



enum {

  OnTheLeft = 1,

  OnTheRight = 2
};







struct NoChange_t {};
namespace {
  __attribute__((unused)) NoChange_t NoChange;
}

struct Sequential_t {};
namespace {
  __attribute__((unused)) Sequential_t Sequential;
}

struct Default_t {};
namespace {
  __attribute__((unused)) Default_t Default;
}



enum {
  IsDense = 0,
  IsSparse
};




enum AccessorLevels {

  ReadOnlyAccessors,

  WriteAccessors,

  DirectAccessors,

  DirectWriteAccessors
};



enum DecompositionOptions {

  Pivoting = 0x01,

  NoPivoting = 0x02,

  ComputeFullU = 0x04,

  ComputeThinU = 0x08,

  ComputeFullV = 0x10,

  ComputeThinV = 0x20,


  EigenvaluesOnly = 0x40,


  ComputeEigenvectors = 0x80,

  EigVecMask = EigenvaluesOnly | ComputeEigenvectors,


  Ax_lBx = 0x100,


  ABx_lx = 0x200,


  BAx_lx = 0x400,

  GenEigMask = Ax_lBx | ABx_lx | BAx_lx
};



enum QRPreconditioners {

  NoQRPreconditioner,

  HouseholderQRPreconditioner,

  ColPivHouseholderQRPreconditioner,

  FullPivHouseholderQRPreconditioner
};







enum ComputationInfo {

  Success = 0,

  NumericalIssue = 1,

  NoConvergence = 2
};




enum TransformTraits {

  Isometry = 0x1,


  Affine = 0x2,

  AffineCompact = 0x10 | Affine,

  Projective = 0x20
};



namespace Architecture
{
  enum Type {
    Generic = 0x0,
    SSE = 0x1,
    AltiVec = 0x2,

    Target = SSE





  };
}



enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };



enum Action {GetAction, SetAction};


struct Dense {};


struct MatrixXpr {};


struct ArrayXpr {};
# 251 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/ForwardDeclarations.h" 1
# 29 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/ForwardDeclarations.h"
namespace internal {

template<typename T> struct traits;





template<typename T> struct traits<const T> : traits<T> {};

template<typename Derived> struct has_direct_access
{
  enum { ret = (traits<Derived>::Flags & DirectAccessBit) ? 1 : 0 };
};

template<typename Derived> struct accessors_level
{
  enum { has_direct_access = (traits<Derived>::Flags & DirectAccessBit) ? 1 : 0,
         has_write_access = (traits<Derived>::Flags & LvalueBit) ? 1 : 0,
         value = has_direct_access ? (has_write_access ? DirectWriteAccessors : DirectAccessors)
                                   : (has_write_access ? WriteAccessors : ReadOnlyAccessors)
  };
};

}

template<typename T> struct NumTraits;

template<typename Derived> struct EigenBase;
template<typename Derived> class DenseBase;
template<typename Derived> class PlainObjectBase;


template<typename Derived,
         int Level = internal::accessors_level<Derived>::value >
class DenseCoeffsBase;

template<typename _Scalar, int _Rows, int _Cols,
         int _Options = AutoAlign |
# 78 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/ForwardDeclarations.h"
                          ( (_Rows==1 && _Cols!=1) ? RowMajor
                          : (_Cols==1 && _Rows!=1) ? ColMajor
                          : ColMajor ),

         int _MaxRows = _Rows,
         int _MaxCols = _Cols
> class Matrix;

template<typename Derived> class MatrixBase;
template<typename Derived> class ArrayBase;

template<typename ExpressionType, unsigned int Added, unsigned int Removed> class Flagged;
template<typename ExpressionType, template <typename> class StorageBase > class NoAlias;
template<typename ExpressionType> class NestByValue;
template<typename ExpressionType> class ForceAlignedAccess;
template<typename ExpressionType> class SwapWrapper;

template<typename XprType, int BlockRows=Dynamic, int BlockCols=Dynamic, bool InnerPanel = false,
         bool HasDirectAccess = internal::has_direct_access<XprType>::ret> class Block;

template<typename MatrixType, int Size=Dynamic> class VectorBlock;
template<typename MatrixType> class Transpose;
template<typename MatrixType> class Conjugate;
template<typename NullaryOp, typename MatrixType> class CwiseNullaryOp;
template<typename UnaryOp, typename MatrixType> class CwiseUnaryOp;
template<typename ViewOp, typename MatrixType> class CwiseUnaryView;
template<typename BinaryOp, typename Lhs, typename Rhs> class CwiseBinaryOp;
template<typename BinOp, typename Lhs, typename Rhs> class SelfCwiseBinaryOp;
template<typename Derived, typename Lhs, typename Rhs> class ProductBase;
template<typename Lhs, typename Rhs, int Mode> class GeneralProduct;
template<typename Lhs, typename Rhs, int NestingFlags> class CoeffBasedProduct;

template<typename Derived> class DiagonalBase;
template<typename _DiagonalVectorType> class DiagonalWrapper;
template<typename _Scalar, int SizeAtCompileTime, int MaxSizeAtCompileTime=SizeAtCompileTime> class DiagonalMatrix;
template<typename MatrixType, typename DiagonalType, int ProductOrder> class DiagonalProduct;
template<typename MatrixType, int Index = 0> class Diagonal;
template<int SizeAtCompileTime, int MaxSizeAtCompileTime = SizeAtCompileTime, typename IndexType=int> class PermutationMatrix;
template<int SizeAtCompileTime, int MaxSizeAtCompileTime = SizeAtCompileTime, typename IndexType=int> class Transpositions;
template<typename Derived> class PermutationBase;
template<typename Derived> class TranspositionsBase;
template<typename _IndicesType> class PermutationWrapper;
template<typename _IndicesType> class TranspositionsWrapper;

template<typename Derived,
         int Level = internal::accessors_level<Derived>::has_write_access ? WriteAccessors : ReadOnlyAccessors
> class MapBase;
template<int InnerStrideAtCompileTime, int OuterStrideAtCompileTime> class Stride;
template<typename MatrixType, int MapOptions=Unaligned, typename StrideType = Stride<0,0> > class Map;

template<typename Derived> class TriangularBase;
template<typename MatrixType, unsigned int Mode> class TriangularView;
template<typename MatrixType, unsigned int Mode> class SelfAdjointView;
template<typename MatrixType> class SparseView;
template<typename ExpressionType> class WithFormat;
template<typename MatrixType> struct CommaInitializer;
template<typename Derived> class ReturnByValue;
template<typename ExpressionType> class ArrayWrapper;

namespace internal {
template<typename DecompositionType, typename Rhs> struct solve_retval_base;
template<typename DecompositionType, typename Rhs> struct solve_retval;
template<typename DecompositionType> struct kernel_retval_base;
template<typename DecompositionType> struct kernel_retval;
template<typename DecompositionType> struct image_retval_base;
template<typename DecompositionType> struct image_retval;
}

namespace internal {
template<typename _Scalar, int Rows=Dynamic, int Cols=Dynamic, int Supers=Dynamic, int Subs=Dynamic, int Options=0> class BandMatrix;
}

namespace internal {
template<typename Lhs, typename Rhs> struct product_type;
}

template<typename Lhs, typename Rhs,
         int ProductType = internal::product_type<Lhs,Rhs>::value>
struct ProductReturnType;


template<typename Lhs, typename Rhs> struct LazyProductReturnType;

namespace internal {



template<typename LhsScalar, typename RhsScalar, bool ConjLhs=false, bool ConjRhs=false> struct conj_helper;

template<typename Scalar> struct scalar_sum_op;
template<typename Scalar> struct scalar_difference_op;
template<typename LhsScalar,typename RhsScalar> struct scalar_conj_product_op;
template<typename Scalar> struct scalar_quotient_op;
template<typename Scalar> struct scalar_opposite_op;
template<typename Scalar> struct scalar_conjugate_op;
template<typename Scalar> struct scalar_real_op;
template<typename Scalar> struct scalar_imag_op;
template<typename Scalar> struct scalar_abs_op;
template<typename Scalar> struct scalar_abs2_op;
template<typename Scalar> struct scalar_sqrt_op;
template<typename Scalar> struct scalar_exp_op;
template<typename Scalar> struct scalar_log_op;
template<typename Scalar> struct scalar_cos_op;
template<typename Scalar> struct scalar_sin_op;
template<typename Scalar> struct scalar_acos_op;
template<typename Scalar> struct scalar_asin_op;
template<typename Scalar> struct scalar_tan_op;
template<typename Scalar> struct scalar_pow_op;
template<typename Scalar> struct scalar_inverse_op;
template<typename Scalar> struct scalar_square_op;
template<typename Scalar> struct scalar_cube_op;
template<typename Scalar, typename NewType> struct scalar_cast_op;
template<typename Scalar> struct scalar_multiple_op;
template<typename Scalar> struct scalar_quotient1_op;
template<typename Scalar> struct scalar_min_op;
template<typename Scalar> struct scalar_max_op;
template<typename Scalar> struct scalar_random_op;
template<typename Scalar> struct scalar_add_op;
template<typename Scalar> struct scalar_constant_op;
template<typename Scalar> struct scalar_identity_op;

template<typename LhsScalar,typename RhsScalar=LhsScalar> struct scalar_product_op;
template<typename LhsScalar,typename RhsScalar> struct scalar_multiple2_op;

}

struct IOFormat;


template<typename _Scalar, int _Rows, int _Cols,
         int _Options = AutoAlign |
# 219 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/ForwardDeclarations.h"
                          ( (_Rows==1 && _Cols!=1) ? RowMajor
                          : (_Cols==1 && _Rows!=1) ? ColMajor
                          : ColMajor ),

         int _MaxRows = _Rows, int _MaxCols = _Cols> class Array;
template<typename ConditionMatrixType, typename ThenMatrixType, typename ElseMatrixType> class Select;
template<typename MatrixType, typename BinaryOp, int Direction> class PartialReduxExpr;
template<typename ExpressionType, int Direction> class VectorwiseOp;
template<typename MatrixType,int RowFactor,int ColFactor> class Replicate;
template<typename MatrixType, int Direction = BothDirections> class Reverse;

template<typename MatrixType> class FullPivLU;
template<typename MatrixType> class PartialPivLU;
namespace internal {
template<typename MatrixType> struct inverse_impl;
}
template<typename MatrixType> class HouseholderQR;
template<typename MatrixType> class ColPivHouseholderQR;
template<typename MatrixType> class FullPivHouseholderQR;
template<typename MatrixType, int QRPreconditioner = ColPivHouseholderQRPreconditioner> class JacobiSVD;
template<typename MatrixType, int UpLo = Lower> class LLT;
template<typename MatrixType, int UpLo = Lower> class LDLT;
template<typename VectorsType, typename CoeffsType, int Side=OnTheLeft> class HouseholderSequence;
template<typename Scalar> class JacobiRotation;


template<typename Derived, int _Dim> class RotationBase;
template<typename Lhs, typename Rhs> class Cross;
template<typename Derived> class QuaternionBase;
template<typename Scalar> class Rotation2D;
template<typename Scalar> class AngleAxis;
template<typename Scalar,int Dim> class Translation;
# 274 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/ForwardDeclarations.h"
template<typename Scalar, int Options = AutoAlign> class Quaternion;
template<typename Scalar,int Dim,int Mode,int _Options=AutoAlign> class Transform;
template <typename _Scalar, int _AmbientDim, int Options=AutoAlign> class ParametrizedLine;
template <typename _Scalar, int _AmbientDim, int Options=AutoAlign> class Hyperplane;
template<typename Scalar> class UniformScaling;
template<typename MatrixType,int Direction> class Homogeneous;



template<typename Derived> struct MatrixExponentialReturnValue;
template<typename Derived> class MatrixFunctionReturnValue;

namespace internal {
template <typename Scalar>
struct stem_function
{
  typedef std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;
  typedef ComplexScalar type(ComplexScalar, int);
};
}
# 252 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Meta.h" 1
# 29 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Meta.h"
namespace internal {
# 38 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Meta.h"
struct true_type { enum { value = 1 }; };
struct false_type { enum { value = 0 }; };

template<bool Condition, typename Then, typename Else>
struct conditional { typedef Then type; };

template<typename Then, typename Else>
struct conditional <false, Then, Else> { typedef Else type; };

template<typename T, typename U> struct is_same { enum { value = 0 }; };
template<typename T> struct is_same<T,T> { enum { value = 1 }; };

template<typename T> struct remove_reference { typedef T type; };
template<typename T> struct remove_reference<T&> { typedef T type; };

template<typename T> struct remove_pointer { typedef T type; };
template<typename T> struct remove_pointer<T*> { typedef T type; };
template<typename T> struct remove_pointer<T*const> { typedef T type; };

template <class T> struct remove_const { typedef T type; };
template <class T> struct remove_const<const T> { typedef T type; };
template <class T> struct remove_const<const T[]> { typedef T type[]; };
template <class T, unsigned int Size> struct remove_const<const T[Size]> { typedef T type[Size]; };

template<typename T> struct remove_all { typedef T type; };
template<typename T> struct remove_all<const T> { typedef typename remove_all<T>::type type; };
template<typename T> struct remove_all<T const&> { typedef typename remove_all<T>::type type; };
template<typename T> struct remove_all<T&> { typedef typename remove_all<T>::type type; };
template<typename T> struct remove_all<T const*> { typedef typename remove_all<T>::type type; };
template<typename T> struct remove_all<T*> { typedef typename remove_all<T>::type type; };

template<typename T> struct is_arithmetic { enum { value = false }; };
template<> struct is_arithmetic<float> { enum { value = true }; };
template<> struct is_arithmetic<double> { enum { value = true }; };
template<> struct is_arithmetic<long double> { enum { value = true }; };
template<> struct is_arithmetic<bool> { enum { value = true }; };
template<> struct is_arithmetic<char> { enum { value = true }; };
template<> struct is_arithmetic<signed char> { enum { value = true }; };
template<> struct is_arithmetic<unsigned char> { enum { value = true }; };
template<> struct is_arithmetic<signed short> { enum { value = true }; };
template<> struct is_arithmetic<unsigned short>{ enum { value = true }; };
template<> struct is_arithmetic<signed int> { enum { value = true }; };
template<> struct is_arithmetic<unsigned int> { enum { value = true }; };
template<> struct is_arithmetic<signed long> { enum { value = true }; };
template<> struct is_arithmetic<unsigned long> { enum { value = true }; };
template<> struct is_arithmetic<signed long long> { enum { value = true }; };
template<> struct is_arithmetic<unsigned long long> { enum { value = true }; };

template <typename T> struct add_const { typedef const T type; };
template <typename T> struct add_const<T&> { typedef T& type; };

template <typename T> struct is_const { enum { value = 0 }; };
template <typename T> struct is_const<T const> { enum { value = 1 }; };

template<typename T> struct add_const_on_value_type { typedef const T type; };
template<typename T> struct add_const_on_value_type<T&> { typedef T const& type; };
template<typename T> struct add_const_on_value_type<T*> { typedef T const* type; };
template<typename T> struct add_const_on_value_type<T* const> { typedef T const* const type; };
template<typename T> struct add_const_on_value_type<T const* const> { typedef T const* const type; };




template<bool Condition, typename T> struct enable_if;

template<typename T> struct enable_if<true,T>
{ typedef T type; };
# 113 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Meta.h"
template<typename T> struct result_of {};

struct has_none {int a[1];};
struct has_std_result_type {int a[2];};
struct has_tr1_result {int a[3];};

template<typename Func, typename ArgType, int SizeOf=sizeof(has_none)>
struct unary_result_of_select {typedef ArgType type;};

template<typename Func, typename ArgType>
struct unary_result_of_select<Func, ArgType, sizeof(has_std_result_type)> {typedef typename Func::result_type type;};

template<typename Func, typename ArgType>
struct unary_result_of_select<Func, ArgType, sizeof(has_tr1_result)> {typedef typename Func::template result<Func(ArgType)>::type type;};

template<typename Func, typename ArgType>
struct result_of<Func(ArgType)> {
    template<typename T>
    static has_std_result_type testFunctor(T const *, typename T::result_type const * = 0);
    template<typename T>
    static has_tr1_result testFunctor(T const *, typename T::template result<T(ArgType)>::type const * = 0);
    static has_none testFunctor(...);


    enum {FunctorType = sizeof(testFunctor(static_cast<Func*>(0)))};
    typedef typename unary_result_of_select<Func, ArgType, FunctorType>::type type;
};

template<typename Func, typename ArgType0, typename ArgType1, int SizeOf=sizeof(has_none)>
struct binary_result_of_select {typedef ArgType0 type;};

template<typename Func, typename ArgType0, typename ArgType1>
struct binary_result_of_select<Func, ArgType0, ArgType1, sizeof(has_std_result_type)>
{typedef typename Func::result_type type;};

template<typename Func, typename ArgType0, typename ArgType1>
struct binary_result_of_select<Func, ArgType0, ArgType1, sizeof(has_tr1_result)>
{typedef typename Func::template result<Func(ArgType0,ArgType1)>::type type;};

template<typename Func, typename ArgType0, typename ArgType1>
struct result_of<Func(ArgType0,ArgType1)> {
    template<typename T>
    static has_std_result_type testFunctor(T const *, typename T::result_type const * = 0);
    template<typename T>
    static has_tr1_result testFunctor(T const *, typename T::template result<T(ArgType0,ArgType1)>::type const * = 0);
    static has_none testFunctor(...);


    enum {FunctorType = sizeof(testFunctor(static_cast<Func*>(0)))};
    typedef typename binary_result_of_select<Func, ArgType0, ArgType1, FunctorType>::type type;
};




template<int Y,
         int InfX = 0,
         int SupX = ((Y==1) ? 1 : Y/2),
         bool Done = ((SupX-InfX)<=1 ? true : ((SupX*SupX <= Y) && ((SupX+1)*(SupX+1) > Y))) >

class meta_sqrt
{
    enum {
      MidX = (InfX+SupX)/2,
      TakeInf = MidX*MidX > Y ? 1 : 0,
      NewInf = int(TakeInf) ? InfX : int(MidX),
      NewSup = int(TakeInf) ? int(MidX) : SupX
    };
  public:
    enum { ret = meta_sqrt<Y,NewInf,NewSup>::ret };
};

template<int Y, int InfX, int SupX>
class meta_sqrt<Y, InfX, SupX, true> { public: enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };


template<typename T, typename U> struct scalar_product_traits;

template<typename T> struct scalar_product_traits<T,T>
{

  typedef T ReturnType;
};

template<typename T> struct scalar_product_traits<T,std::complex<T> >
{

  typedef std::complex<T> ReturnType;
};

template<typename T> struct scalar_product_traits<std::complex<T>, T>
{

  typedef std::complex<T> ReturnType;
};







template<typename T> struct is_diagonal
{ enum { ret = false }; };

template<typename T> struct is_diagonal<DiagonalBase<T> >
{ enum { ret = true }; };

template<typename T> struct is_diagonal<DiagonalWrapper<T> >
{ enum { ret = true }; };

template<typename T, int S> struct is_diagonal<DiagonalMatrix<T,S> >
{ enum { ret = true }; };

}
# 253 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/XprHelper.h" 1
# 40 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/XprHelper.h"
typedef std::ptrdiff_t DenseIndex;

namespace internal {


class no_assignment_operator
{
  private:
    no_assignment_operator& operator=(const no_assignment_operator&);
};


template<typename I1, typename I2>
struct promote_index_type
{
  typedef typename conditional<(sizeof(I1)<sizeof(I2)), I2, I1>::type type;
};





template<typename T, int Value> class variable_if_dynamic
{
  public:
    inline variable_if_dynamic() {} inline variable_if_dynamic(const variable_if_dynamic& ) {}
    explicit variable_if_dynamic(T v) { ; ((v == T(Value)) ? static_cast<void> (0) : __assert_fail ("v == T(Value)", "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/XprHelper.h", 66, __PRETTY_FUNCTION__)); }
    static T value() { return T(Value); }
    void setValue(T) {}
};

template<typename T> class variable_if_dynamic<T, Dynamic>
{
    T m_value;
    variable_if_dynamic() { ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/XprHelper.h", 74, __PRETTY_FUNCTION__)); }
  public:
    explicit variable_if_dynamic(T value) : m_value(value) {}
    T value() const { return m_value; }
    void setValue(T value) { m_value = value; }
};

template<typename T> struct functor_traits
{
  enum
  {
    Cost = 10,
    PacketAccess = false
  };
};

template<typename T> struct packet_traits;

template<typename T> struct unpacket_traits
{
  typedef T type;
  enum {size=1};
};

template<typename _Scalar, int _Rows, int _Cols,
         int _Options = AutoAlign |
                          ( (_Rows==1 && _Cols!=1) ? RowMajor
                          : (_Cols==1 && _Rows!=1) ? ColMajor
                          : ColMajor ),
         int _MaxRows = _Rows,
         int _MaxCols = _Cols
> class make_proper_matrix_type
{
    enum {
      IsColVector = _Cols==1 && _Rows!=1,
      IsRowVector = _Rows==1 && _Cols!=1,
      Options = IsColVector ? (_Options | ColMajor) & ~RowMajor
              : IsRowVector ? (_Options | RowMajor) & ~ColMajor
              : _Options
    };
  public:
    typedef Matrix<_Scalar, _Rows, _Cols, Options, _MaxRows, _MaxCols> type;
};

template<typename Scalar, int Rows, int Cols, int Options, int MaxRows, int MaxCols>
class compute_matrix_flags
{
    enum {
      row_major_bit = Options&RowMajor ? RowMajorBit : 0,
      is_dynamic_size_storage = MaxRows==Dynamic || MaxCols==Dynamic,

      aligned_bit =
      (
            ((Options&DontAlign)==0)
        && packet_traits<Scalar>::Vectorizable
        && (

             ((!is_dynamic_size_storage) && (((MaxCols*MaxRows) % packet_traits<Scalar>::size) == 0))




          ||


             is_dynamic_size_storage




          )
      ) ? AlignedBit : 0,
      packet_access_bit = packet_traits<Scalar>::Vectorizable && aligned_bit ? PacketAccessBit : 0
    };

  public:
    enum { ret = LinearAccessBit | LvalueBit | DirectAccessBit | NestByRefBit | packet_access_bit | row_major_bit | aligned_bit };
};

template<int _Rows, int _Cols> struct size_at_compile_time
{
  enum { ret = (_Rows==Dynamic || _Cols==Dynamic) ? Dynamic : _Rows * _Cols };
};





template<typename T, typename StorageKind = typename traits<T>::StorageKind> struct plain_matrix_type;
template<typename T, typename BaseClassType> struct plain_matrix_type_dense;
template<typename T> struct plain_matrix_type<T,Dense>
{
  typedef typename plain_matrix_type_dense<T,typename traits<T>::XprKind>::type type;
};

template<typename T> struct plain_matrix_type_dense<T,MatrixXpr>
{
  typedef Matrix<typename traits<T>::Scalar,
                traits<T>::RowsAtCompileTime,
                traits<T>::ColsAtCompileTime,
                AutoAlign | (traits<T>::Flags&RowMajorBit ? RowMajor : ColMajor),
                traits<T>::MaxRowsAtCompileTime,
                traits<T>::MaxColsAtCompileTime
          > type;
};

template<typename T> struct plain_matrix_type_dense<T,ArrayXpr>
{
  typedef Array<typename traits<T>::Scalar,
                traits<T>::RowsAtCompileTime,
                traits<T>::ColsAtCompileTime,
                AutoAlign | (traits<T>::Flags&RowMajorBit ? RowMajor : ColMajor),
                traits<T>::MaxRowsAtCompileTime,
                traits<T>::MaxColsAtCompileTime
          > type;
};





template<typename T, typename StorageKind = typename traits<T>::StorageKind> struct eval;

template<typename T> struct eval<T,Dense>
{
  typedef typename plain_matrix_type<T>::type type;
# 208 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/XprHelper.h"
};


template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
struct eval<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>, Dense>
{
  typedef const Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& type;
};

template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
struct eval<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>, Dense>
{
  typedef const Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>& type;
};





template<typename T> struct plain_matrix_type_column_major
{
  enum { Rows = traits<T>::RowsAtCompileTime,
         Cols = traits<T>::ColsAtCompileTime,
         MaxRows = traits<T>::MaxRowsAtCompileTime,
         MaxCols = traits<T>::MaxColsAtCompileTime
  };
  typedef Matrix<typename traits<T>::Scalar,
                Rows,
                Cols,
                (MaxRows==1&&MaxCols!=1) ? RowMajor : ColMajor,
                MaxRows,
                MaxCols
          > type;
};



template<typename T> struct plain_matrix_type_row_major
{
  enum { Rows = traits<T>::RowsAtCompileTime,
         Cols = traits<T>::ColsAtCompileTime,
         MaxRows = traits<T>::MaxRowsAtCompileTime,
         MaxCols = traits<T>::MaxColsAtCompileTime
  };
  typedef Matrix<typename traits<T>::Scalar,
                Rows,
                Cols,
                (MaxCols==1&&MaxRows!=1) ? RowMajor : ColMajor,
                MaxRows,
                MaxCols
          > type;
};


template<typename T> struct must_nest_by_value { enum { ret = false }; };

template<class T>
struct is_reference
{
  enum { ret = false };
};

template<class T>
struct is_reference<T&>
{
  enum { ret = true };
};






template <typename T>
struct ref_selector
{
  typedef typename conditional<
    bool(traits<T>::Flags & NestByRefBit),
    T const&,
    T
  >::type type;
};
# 309 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/XprHelper.h"
template<typename T, int n=1, typename PlainObject = typename eval<T>::type> struct nested
{
  enum {





    DynamicAsInteger = 10000,
    ScalarReadCost = NumTraits<typename traits<T>::Scalar>::ReadCost,
    ScalarReadCostAsInteger = ScalarReadCost == Dynamic ? DynamicAsInteger : ScalarReadCost,
    CoeffReadCost = traits<T>::CoeffReadCost,
    CoeffReadCostAsInteger = CoeffReadCost == Dynamic ? DynamicAsInteger : CoeffReadCost,
    NAsInteger = n == Dynamic ? int(DynamicAsInteger) : n,
    CostEvalAsInteger = (NAsInteger+1) * ScalarReadCostAsInteger + CoeffReadCostAsInteger,
    CostNoEvalAsInteger = NAsInteger * CoeffReadCostAsInteger
  };

  typedef typename conditional<
      ( (int(traits<T>::Flags) & EvalBeforeNestingBit) ||
        int(CostEvalAsInteger) < int(CostNoEvalAsInteger)
      ),
      PlainObject,
      typename ref_selector<T>::type
  >::type type;
};

template<typename T>
T* const_cast_ptr(const T* ptr)
{
  return const_cast<T*>(ptr);
}

template<typename Derived, typename XprKind = typename traits<Derived>::XprKind>
struct dense_xpr_base
{

};

template<typename Derived>
struct dense_xpr_base<Derived, MatrixXpr>
{
  typedef MatrixBase<Derived> type;
};

template<typename Derived>
struct dense_xpr_base<Derived, ArrayXpr>
{
  typedef ArrayBase<Derived> type;
};



template<typename Derived,typename Scalar,typename OtherScalar,
         bool EnableIt = !is_same<Scalar,OtherScalar>::value >
struct special_scalar_op_base : public DenseCoeffsBase<Derived>
{


  void operator*() const;
};

template<typename Derived,typename Scalar,typename OtherScalar>
struct special_scalar_op_base<Derived,Scalar,OtherScalar,true> : public DenseCoeffsBase<Derived>
{
  const CwiseUnaryOp<scalar_multiple2_op<Scalar,OtherScalar>, Derived>
  operator*(const OtherScalar& scalar) const
  {
    return CwiseUnaryOp<scalar_multiple2_op<Scalar,OtherScalar>, Derived>
      (*static_cast<const Derived*>(this), scalar_multiple2_op<Scalar,OtherScalar>(scalar));
  }

  inline friend const CwiseUnaryOp<scalar_multiple2_op<Scalar,OtherScalar>, Derived>
  operator*(const OtherScalar& scalar, const Derived& matrix)
  { return static_cast<const special_scalar_op_base&>(matrix).operator*(scalar); }
};

template<typename XprType, typename CastType> struct cast_return_type
{
  typedef typename XprType::Scalar CurrentScalarType;
  typedef typename remove_all<CastType>::type _CastType;
  typedef typename _CastType::Scalar NewScalarType;
  typedef typename conditional<is_same<CurrentScalarType,NewScalarType>::value,
                              const XprType&,CastType>::type type;
};

template <typename A, typename B> struct promote_storage_type;

template <typename A> struct promote_storage_type<A,A>
{
  typedef A ret;
};




template<typename ExpressionType, typename Scalar = typename ExpressionType::Scalar>
struct plain_row_type
{
  typedef Matrix<Scalar, 1, ExpressionType::ColsAtCompileTime,
                 ExpressionType::PlainObject::Options | RowMajor, 1, ExpressionType::MaxColsAtCompileTime> MatrixRowType;
  typedef Array<Scalar, 1, ExpressionType::ColsAtCompileTime,
                 ExpressionType::PlainObject::Options | RowMajor, 1, ExpressionType::MaxColsAtCompileTime> ArrayRowType;

  typedef typename conditional<
    is_same< typename traits<ExpressionType>::XprKind, MatrixXpr >::value,
    MatrixRowType,
    ArrayRowType
  >::type type;
};

template<typename ExpressionType, typename Scalar = typename ExpressionType::Scalar>
struct plain_col_type
{
  typedef Matrix<Scalar, ExpressionType::RowsAtCompileTime, 1,
                 ExpressionType::PlainObject::Options & ~RowMajor, ExpressionType::MaxRowsAtCompileTime, 1> MatrixColType;
  typedef Array<Scalar, ExpressionType::RowsAtCompileTime, 1,
                 ExpressionType::PlainObject::Options & ~RowMajor, ExpressionType::MaxRowsAtCompileTime, 1> ArrayColType;

  typedef typename conditional<
    is_same< typename traits<ExpressionType>::XprKind, MatrixXpr >::value,
    MatrixColType,
    ArrayColType
  >::type type;
};

template<typename ExpressionType, typename Scalar = typename ExpressionType::Scalar>
struct plain_diag_type
{
  enum { diag_size = (((int)ExpressionType::RowsAtCompileTime == 0 || (int)ExpressionType::ColsAtCompileTime == 0) ? 0 : ((int)ExpressionType::RowsAtCompileTime == 1 || (int)ExpressionType::ColsAtCompileTime == 1) ? 1 : ((int)ExpressionType::RowsAtCompileTime == Dynamic || (int)ExpressionType::ColsAtCompileTime == Dynamic) ? Dynamic : ((int)ExpressionType::RowsAtCompileTime <= (int)ExpressionType::ColsAtCompileTime) ? (int)ExpressionType::RowsAtCompileTime : (int)ExpressionType::ColsAtCompileTime),
         max_diag_size = (((int)ExpressionType::MaxRowsAtCompileTime == 0 || (int)ExpressionType::MaxColsAtCompileTime == 0) ? 0 : ((int)ExpressionType::MaxRowsAtCompileTime == 1 || (int)ExpressionType::MaxColsAtCompileTime == 1) ? 1 : ((int)ExpressionType::MaxRowsAtCompileTime == Dynamic && (int)ExpressionType::MaxColsAtCompileTime == Dynamic) ? Dynamic : ((int)ExpressionType::MaxRowsAtCompileTime == Dynamic) ? (int)ExpressionType::MaxColsAtCompileTime : ((int)ExpressionType::MaxColsAtCompileTime == Dynamic) ? (int)ExpressionType::MaxRowsAtCompileTime : ((int)ExpressionType::MaxRowsAtCompileTime <= (int)ExpressionType::MaxColsAtCompileTime) ? (int)ExpressionType::MaxRowsAtCompileTime : (int)ExpressionType::MaxColsAtCompileTime)
  };
  typedef Matrix<Scalar, diag_size, 1, ExpressionType::PlainObject::Options & ~RowMajor, max_diag_size, 1> MatrixDiagType;
  typedef Array<Scalar, diag_size, 1, ExpressionType::PlainObject::Options & ~RowMajor, max_diag_size, 1> ArrayDiagType;

  typedef typename conditional<
    is_same< typename traits<ExpressionType>::XprKind, MatrixXpr >::value,
    MatrixDiagType,
    ArrayDiagType
  >::type type;
};

template<typename ExpressionType>
struct is_lvalue
{
  enum { value = !bool(is_const<ExpressionType>::value) &&
                 bool(traits<ExpressionType>::Flags & LvalueBit) };
};

}
# 254 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/StaticAssert.h" 1
# 51 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/StaticAssert.h"
    namespace internal {

    template<bool condition>
    struct static_assertion {};

    template<>
    struct static_assertion<true>
    {
      enum {
        YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX,
        YOU_MIXED_VECTORS_OF_DIFFERENT_SIZES,
        YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES,
        THIS_METHOD_IS_ONLY_FOR_VECTORS_OF_A_SPECIFIC_SIZE,
        THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE,
        THIS_METHOD_IS_ONLY_FOR_OBJECTS_OF_A_SPECIFIC_SIZE,
        YOU_MADE_A_PROGRAMMING_MISTAKE,
        EIGEN_INTERNAL_ERROR_PLEASE_FILE_A_BUG_REPORT,
        EIGEN_INTERNAL_COMPILATION_ERROR_OR_YOU_MADE_A_PROGRAMMING_MISTAKE,
        YOU_CALLED_A_FIXED_SIZE_METHOD_ON_A_DYNAMIC_SIZE_MATRIX_OR_VECTOR,
        YOU_CALLED_A_DYNAMIC_SIZE_METHOD_ON_A_FIXED_SIZE_MATRIX_OR_VECTOR,
        UNALIGNED_LOAD_AND_STORE_OPERATIONS_UNIMPLEMENTED_ON_ALTIVEC,
        THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES,
        NUMERIC_TYPE_MUST_BE_REAL,
        COEFFICIENT_WRITE_ACCESS_TO_SELFADJOINT_NOT_SUPPORTED,
        WRITING_TO_TRIANGULAR_PART_WITH_UNIT_DIAGONAL_IS_NOT_SUPPORTED,
        THIS_METHOD_IS_ONLY_FOR_FIXED_SIZE,
        INVALID_MATRIX_PRODUCT,
        INVALID_VECTOR_VECTOR_PRODUCT__IF_YOU_WANTED_A_DOT_OR_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTIONS,
        INVALID_MATRIX_PRODUCT__IF_YOU_WANTED_A_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTION,
        YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY,
        THIS_METHOD_IS_ONLY_FOR_COLUMN_MAJOR_MATRICES,
        THIS_METHOD_IS_ONLY_FOR_ROW_MAJOR_MATRICES,
        INVALID_MATRIX_TEMPLATE_PARAMETERS,
        INVALID_MATRIXBASE_TEMPLATE_PARAMETERS,
        BOTH_MATRICES_MUST_HAVE_THE_SAME_STORAGE_ORDER,
        THIS_METHOD_IS_ONLY_FOR_DIAGONAL_MATRIX,
        THE_MATRIX_OR_EXPRESSION_THAT_YOU_PASSED_DOES_NOT_HAVE_THE_EXPECTED_TYPE,
        THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_WITH_DIRECT_MEMORY_ACCESS_SUCH_AS_MAP_OR_PLAIN_MATRICES,
        YOU_ALREADY_SPECIFIED_THIS_STRIDE,
        INVALID_STORAGE_ORDER_FOR_THIS_VECTOR_EXPRESSION,
        THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD,
        PACKET_ACCESS_REQUIRES_TO_HAVE_INNER_STRIDE_FIXED_TO_1,
        THIS_METHOD_IS_ONLY_FOR_SPECIFIC_TRANSFORMATIONS,
        YOU_CANNOT_MIX_ARRAYS_AND_MATRICES,
        YOU_PERFORMED_AN_INVALID_TRANSFORMATION_CONVERSION,
        THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY,
        YOU_ARE_TRYING_TO_USE_AN_INDEX_BASED_ACCESSOR_ON_AN_EXPRESSION_THAT_DOES_NOT_SUPPORT_THAT,
        THIS_METHOD_IS_ONLY_FOR_1x1_EXPRESSIONS
      };
    };

    }
# 255 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Memory.h" 1
# 83 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Memory.h"
namespace internal {
# 94 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Memory.h"
inline void* handmade_aligned_malloc(size_t size)
{
  void *original = std::malloc(size+16);
  if (original == 0) return 0;
  void *aligned = reinterpret_cast<void*>((reinterpret_cast<size_t>(original) & ~(size_t(15))) + 16);
  *(reinterpret_cast<void**>(aligned) - 1) = original;
  return aligned;
}


inline void handmade_aligned_free(void *ptr)
{
  if (ptr) std::free(*(reinterpret_cast<void**>(ptr) - 1));
}






inline void* handmade_aligned_realloc(void* ptr, size_t size, size_t = 0)
{
  if (ptr == 0) return handmade_aligned_malloc(size);
  void *original = *(reinterpret_cast<void**>(ptr) - 1);
  original = std::realloc(original,size+16);
  if (original == 0) return 0;
  void *aligned = reinterpret_cast<void*>((reinterpret_cast<size_t>(original) & ~(size_t(15))) + 16);
  *(reinterpret_cast<void**>(aligned) - 1) = original;
  return aligned;
}





void* aligned_malloc(size_t size);
void aligned_free(void *ptr);






inline void* generic_aligned_realloc(void* ptr, size_t size, size_t old_size)
{
  if (ptr==0)
    return aligned_malloc(size);

  if (size==0)
  {
    aligned_free(ptr);
    return 0;
  }

  void* newptr = aligned_malloc(size);
  if (newptr == 0)
  {

    (*__errno_location ()) = 12;

    return 0;
  }

  if (ptr != 0)
  {
    std::memcpy(newptr, ptr, (std::min)(size,old_size));
    aligned_free(ptr);
  }

  return newptr;
}






inline void check_that_malloc_is_allowed()
{
  if( (!Eigen::internal::copy_bool(false && "heap allocation is forbidden (EIGEN_NO_MALLOC is defined)")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(false && "heap allocation is forbidden (EIGEN_NO_MALLOC is defined)")) Eigen::internal::assert_fail("false && \"heap allocation is forbidden (EIGEN_NO_MALLOC is defined)\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Memory.h", 173); } while(false); else throw Eigen::eigen_assert_exception(); };
}
# 197 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Memory.h"
inline void* aligned_malloc(size_t size)
{
  check_that_malloc_is_allowed();

  void *result;



    result = std::malloc(size);
# 217 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Memory.h"
    if(result == 0)
      throw std::bad_alloc();

  return result;
}


inline void aligned_free(void *ptr)
{



    std::free(ptr);
# 239 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Memory.h"
}






inline void* aligned_realloc(void *ptr, size_t new_size, size_t old_size)
{
  (void)old_size;;

  void *result;



  result = std::realloc(ptr,new_size);
# 273 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Memory.h"
  if (result==0 && new_size!=0)
    throw std::bad_alloc();

  return result;
}
# 286 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Memory.h"
template<bool Align> inline void* conditional_aligned_malloc(size_t size)
{
  return aligned_malloc(size);
}

template<> inline void* conditional_aligned_malloc<false>(size_t size)
{
  check_that_malloc_is_allowed();

  void *result = std::malloc(size);

    if(!result) throw std::bad_alloc();

  return result;
}


template<bool Align> inline void conditional_aligned_free(void *ptr)
{
  aligned_free(ptr);
}

template<> inline void conditional_aligned_free<false>(void *ptr)
{
  std::free(ptr);
}

template<bool Align> inline void* conditional_aligned_realloc(void* ptr, size_t new_size, size_t old_size)
{
  return aligned_realloc(ptr, new_size, old_size);
}

template<> inline void* conditional_aligned_realloc<false>(void* ptr, size_t new_size, size_t)
{
  return std::realloc(ptr, new_size);
}
# 330 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Memory.h"
template<typename T> inline T* construct_elements_of_array(T *ptr, size_t size)
{
  for (size_t i=0; i < size; ++i) ::new (ptr + i) T;
  return ptr;
}




template<typename T> inline void destruct_elements_of_array(T *ptr, size_t size)
{

  if(ptr)
    while(size) ptr[--size].~T();
}
# 354 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Memory.h"
template<typename T> inline T* aligned_new(size_t size)
{
  T *result = reinterpret_cast<T*>(aligned_malloc(sizeof(T)*size));
  return construct_elements_of_array(result, size);
}

template<typename T, bool Align> inline T* conditional_aligned_new(size_t size)
{
  T *result = reinterpret_cast<T*>(conditional_aligned_malloc<Align>(sizeof(T)*size));
  return construct_elements_of_array(result, size);
}




template<typename T> inline void aligned_delete(T *ptr, size_t size)
{
  destruct_elements_of_array<T>(ptr, size);
  aligned_free(ptr);
}




template<typename T, bool Align> inline void conditional_aligned_delete(T *ptr, size_t size)
{
  destruct_elements_of_array<T>(ptr, size);
  conditional_aligned_free<Align>(ptr);
}

template<typename T, bool Align> inline T* conditional_aligned_realloc_new(T* pts, size_t new_size, size_t old_size)
{
  if(new_size < old_size)
    destruct_elements_of_array(pts+new_size, old_size-new_size);
  T *result = reinterpret_cast<T*>(conditional_aligned_realloc<Align>(reinterpret_cast<void*>(pts), sizeof(T)*new_size, sizeof(T)*old_size));
  if(new_size > old_size)
    construct_elements_of_array(result+old_size, new_size-old_size);
  return result;
}


template<typename T, bool Align> inline T* conditional_aligned_new_auto(size_t size)
{
  T *result = reinterpret_cast<T*>(conditional_aligned_malloc<Align>(sizeof(T)*size));
  if(NumTraits<T>::RequireInitialization)
    construct_elements_of_array(result, size);
  return result;
}

template<typename T, bool Align> inline T* conditional_aligned_realloc_new_auto(T* pts, size_t new_size, size_t old_size)
{
  if(NumTraits<T>::RequireInitialization && (new_size < old_size))
    destruct_elements_of_array(pts+new_size, old_size-new_size);
  T *result = reinterpret_cast<T*>(conditional_aligned_realloc<Align>(reinterpret_cast<void*>(pts), sizeof(T)*new_size, sizeof(T)*old_size));
  if(NumTraits<T>::RequireInitialization && (new_size > old_size))
    construct_elements_of_array(result+old_size, new_size-old_size);
  return result;
}

template<typename T, bool Align> inline void conditional_aligned_delete_auto(T *ptr, size_t size)
{
  if(NumTraits<T>::RequireInitialization)
    destruct_elements_of_array<T>(ptr, size);
  conditional_aligned_free<Align>(ptr);
}
# 438 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Memory.h"
template<typename Scalar, typename Index>
inline static Index first_aligned(const Scalar* array, Index size)
{
  typedef typename packet_traits<Scalar>::type Packet;
  enum { PacketSize = packet_traits<Scalar>::size,
         PacketAlignedMask = PacketSize-1
  };

  if(PacketSize==1)
  {


    return 0;
  }
  else if(size_t(array) & (sizeof(Scalar)-1))
  {


    return size;
  }
  else
  {
    return std::min<Index>( (PacketSize - (Index((size_t(array)/sizeof(Scalar))) & PacketAlignedMask))
                           & PacketAlignedMask, size);
  }
}

}
# 481 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Memory.h"
namespace internal {



template<typename T> class aligned_stack_memory_handler
{
  public:






    aligned_stack_memory_handler(T* ptr, size_t size, bool dealloc)
      : m_ptr(ptr), m_size(size), m_deallocate(dealloc)
    {
      if(NumTraits<T>::RequireInitialization && m_ptr)
        Eigen::internal::construct_elements_of_array(m_ptr, size);
    }
    ~aligned_stack_memory_handler()
    {
      if(NumTraits<T>::RequireInitialization && m_ptr)
        Eigen::internal::destruct_elements_of_array<T>(m_ptr, m_size);
      if(m_deallocate)
        Eigen::internal::aligned_free(m_ptr);
    }
  protected:
    T* m_ptr;
    size_t m_size;
    bool m_deallocate;
};

}
# 619 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Memory.h"
template<class T>
class aligned_allocator
{
public:
    typedef size_t size_type;
    typedef std::ptrdiff_t difference_type;
    typedef T* pointer;
    typedef const T* const_pointer;
    typedef T& reference;
    typedef const T& const_reference;
    typedef T value_type;

    template<class U>
    struct rebind
    {
        typedef aligned_allocator<U> other;
    };

    pointer address( reference value ) const
    {
        return &value;
    }

    const_pointer address( const_reference value ) const
    {
        return &value;
    }

    aligned_allocator()
    {
    }

    aligned_allocator( const aligned_allocator& )
    {
    }

    template<class U>
    aligned_allocator( const aligned_allocator<U>& )
    {
    }

    ~aligned_allocator()
    {
    }

    size_type max_size() const
    {
        return (std::numeric_limits<size_type>::max)();
    }

    pointer allocate( size_type num, const void* hint = 0 )
    {
        (void)hint;;
        return static_cast<pointer>( internal::aligned_malloc( num * sizeof(T) ) );
    }

    void construct( pointer p, const T& value )
    {
        ::new( p ) T( value );
    }

    void destroy( pointer p )
    {
        p->~T();
    }

    void deallocate( pointer p, size_type )
    {
        internal::aligned_free( p );
    }

    bool operator!=(const aligned_allocator<T>& ) const
    { return false; }

    bool operator==(const aligned_allocator<T>& ) const
    { return true; }
};
# 715 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Memory.h"
namespace internal {



inline bool cpuid_is_vendor(int abcd[4], const char* vendor)
{
  return abcd[1]==((int*)(vendor))[0] && abcd[3]==((int*)(vendor))[1] && abcd[2]==((int*)(vendor))[2];
}

inline void queryCacheSizes_intel_direct(int& l1, int& l2, int& l3)
{
  int abcd[4];
  l1 = l2 = l3 = 0;
  int cache_id = 0;
  int cache_type = 0;
  do {
    abcd[0] = abcd[1] = abcd[2] = abcd[3] = 0;
    __asm__ __volatile__ ("cpuid": "=a" (abcd[0]), "=b" (abcd[1]), "=c" (abcd[2]), "=d" (abcd[3]) : "a" (0x4), "c" (cache_id) );;
    cache_type = (abcd[0] & 0x0F) >> 0;
    if(cache_type==1||cache_type==3)
    {
      int cache_level = (abcd[0] & 0xE0) >> 5;
      int ways = (abcd[1] & 0xFFC00000) >> 22;
      int partitions = (abcd[1] & 0x003FF000) >> 12;
      int line_size = (abcd[1] & 0x00000FFF) >> 0;
      int sets = (abcd[2]);

      int cache_size = (ways+1) * (partitions+1) * (line_size+1) * (sets+1);

      switch(cache_level)
      {
        case 1: l1 = cache_size; break;
        case 2: l2 = cache_size; break;
        case 3: l3 = cache_size; break;
        default: break;
      }
    }
    cache_id++;
  } while(cache_type>0 && cache_id<16);
}

inline void queryCacheSizes_intel_codes(int& l1, int& l2, int& l3)
{
  int abcd[4];
  abcd[0] = abcd[1] = abcd[2] = abcd[3] = 0;
  l1 = l2 = l3 = 0;
  __asm__ __volatile__ ("cpuid": "=a" (abcd[0]), "=b" (abcd[1]), "=c" (abcd[2]), "=d" (abcd[3]) : "a" (0x00000002), "c" (0) );;
  unsigned char * bytes = reinterpret_cast<unsigned char *>(abcd)+2;
  bool check_for_p2_core2 = false;
  for(int i=0; i<14; ++i)
  {
    switch(bytes[i])
    {
      case 0x0A: l1 = 8; break;
      case 0x0C: l1 = 16; break;
      case 0x0E: l1 = 24; break;
      case 0x10: l1 = 16; break;
      case 0x15: l1 = 16; break;
      case 0x2C: l1 = 32; break;
      case 0x30: l1 = 32; break;
      case 0x60: l1 = 16; break;
      case 0x66: l1 = 8; break;
      case 0x67: l1 = 16; break;
      case 0x68: l1 = 32; break;
      case 0x1A: l2 = 96; break;
      case 0x22: l3 = 512; break;
      case 0x23: l3 = 1024; break;
      case 0x25: l3 = 2048; break;
      case 0x29: l3 = 4096; break;
      case 0x39: l2 = 128; break;
      case 0x3A: l2 = 192; break;
      case 0x3B: l2 = 128; break;
      case 0x3C: l2 = 256; break;
      case 0x3D: l2 = 384; break;
      case 0x3E: l2 = 512; break;
      case 0x40: l2 = 0; break;
      case 0x41: l2 = 128; break;
      case 0x42: l2 = 256; break;
      case 0x43: l2 = 512; break;
      case 0x44: l2 = 1024; break;
      case 0x45: l2 = 2048; break;
      case 0x46: l3 = 4096; break;
      case 0x47: l3 = 8192; break;
      case 0x48: l2 = 3072; break;
      case 0x49: if(l2!=0) l3 = 4096; else {check_for_p2_core2=true; l3 = l2 = 4096;} break;
      case 0x4A: l3 = 6144; break;
      case 0x4B: l3 = 8192; break;
      case 0x4C: l3 = 12288; break;
      case 0x4D: l3 = 16384; break;
      case 0x4E: l2 = 6144; break;
      case 0x78: l2 = 1024; break;
      case 0x79: l2 = 128; break;
      case 0x7A: l2 = 256; break;
      case 0x7B: l2 = 512; break;
      case 0x7C: l2 = 1024; break;
      case 0x7D: l2 = 2048; break;
      case 0x7E: l2 = 256; break;
      case 0x7F: l2 = 512; break;
      case 0x80: l2 = 512; break;
      case 0x81: l2 = 128; break;
      case 0x82: l2 = 256; break;
      case 0x83: l2 = 512; break;
      case 0x84: l2 = 1024; break;
      case 0x85: l2 = 2048; break;
      case 0x86: l2 = 512; break;
      case 0x87: l2 = 1024; break;
      case 0x88: l3 = 2048; break;
      case 0x89: l3 = 4096; break;
      case 0x8A: l3 = 8192; break;
      case 0x8D: l3 = 3072; break;

      default: break;
    }
  }
  if(check_for_p2_core2 && l2 == l3)
    l3 = 0;
  l1 *= 1024;
  l2 *= 1024;
  l3 *= 1024;
}

inline void queryCacheSizes_intel(int& l1, int& l2, int& l3, int max_std_funcs)
{
  if(max_std_funcs>=4)
    queryCacheSizes_intel_direct(l1,l2,l3);
  else
    queryCacheSizes_intel_codes(l1,l2,l3);
}

inline void queryCacheSizes_amd(int& l1, int& l2, int& l3)
{
  int abcd[4];
  abcd[0] = abcd[1] = abcd[2] = abcd[3] = 0;
  __asm__ __volatile__ ("cpuid": "=a" (abcd[0]), "=b" (abcd[1]), "=c" (abcd[2]), "=d" (abcd[3]) : "a" (0x80000005), "c" (0) );;
  l1 = (abcd[2] >> 24) * 1024;
  abcd[0] = abcd[1] = abcd[2] = abcd[3] = 0;
  __asm__ __volatile__ ("cpuid": "=a" (abcd[0]), "=b" (abcd[1]), "=c" (abcd[2]), "=d" (abcd[3]) : "a" (0x80000006), "c" (0) );;
  l2 = (abcd[2] >> 16) * 1024;
  l3 = ((abcd[3] & 0xFFFC000) >> 18) * 512 * 1024;
}




inline void queryCacheSizes(int& l1, int& l2, int& l3)
{

  int abcd[4];


  __asm__ __volatile__ ("cpuid": "=a" (abcd[0]), "=b" (abcd[1]), "=c" (abcd[2]), "=d" (abcd[3]) : "a" (0x0), "c" (0) );;
  int max_std_funcs = abcd[1];
  if(cpuid_is_vendor(abcd,"GenuineIntel"))
    queryCacheSizes_intel(l1,l2,l3,max_std_funcs);
  else if(cpuid_is_vendor(abcd,"AuthenticAMD") || cpuid_is_vendor(abcd,"AMDisbetter!"))
    queryCacheSizes_amd(l1,l2,l3);
  else

    queryCacheSizes_intel(l1,l2,l3,max_std_funcs);
# 889 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/Memory.h"
}



inline int queryL1CacheSize()
{
  int l1(-1), l2, l3;
  queryCacheSizes(l1,l2,l3);
  return l1;
}



inline int queryTopLevelCacheSize()
{
  int l1, l2(-1), l3(-1);
  queryCacheSizes(l1,l2,l3);
  return (std::max)(l2,l3);
}

}
# 256 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2

# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/NumTraits.h" 1
# 64 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/NumTraits.h"
template<typename T> struct GenericNumTraits
{
  enum {
    IsInteger = std::numeric_limits<T>::is_integer,
    IsSigned = std::numeric_limits<T>::is_signed,
    IsComplex = 0,
    RequireInitialization = internal::is_arithmetic<T>::value ? 0 : 1,
    ReadCost = 1,
    AddCost = 1,
    MulCost = 1
  };

  typedef T Real;
  typedef typename internal::conditional<
                     IsInteger,
                     typename internal::conditional<sizeof(T)<=2, float, double>::type,
                     T
                   >::type NonInteger;
  typedef T Nested;

  inline static Real epsilon() { return std::numeric_limits<T>::epsilon(); }
  inline static Real dummy_precision()
  {

    return Real(0);
  }
  inline static T highest() { return (std::numeric_limits<T>::max)(); }
  inline static T lowest() { return IsInteger ? (std::numeric_limits<T>::min)() : (-(std::numeric_limits<T>::max)()); }







};

template<typename T> struct NumTraits : GenericNumTraits<T>
{};

template<> struct NumTraits<float>
  : GenericNumTraits<float>
{
  inline static float dummy_precision() { return 1e-5f; }
};

template<> struct NumTraits<double> : GenericNumTraits<double>
{
  inline static double dummy_precision() { return 1e-12; }
};

template<> struct NumTraits<long double>
  : GenericNumTraits<long double>
{
  static inline long double dummy_precision() { return 1e-15l; }
};

template<typename _Real> struct NumTraits<std::complex<_Real> >
  : GenericNumTraits<std::complex<_Real> >
{
  typedef _Real Real;
  enum {
    IsComplex = 1,
    RequireInitialization = NumTraits<_Real>::RequireInitialization,
    ReadCost = 2 * NumTraits<_Real>::ReadCost,
    AddCost = 2 * NumTraits<Real>::AddCost,
    MulCost = 4 * NumTraits<Real>::MulCost + 2 * NumTraits<Real>::AddCost
  };

  inline static Real epsilon() { return NumTraits<Real>::epsilon(); }
  inline static Real dummy_precision() { return NumTraits<Real>::dummy_precision(); }
};

template<typename Scalar, int Rows, int Cols, int Options, int MaxRows, int MaxCols>
struct NumTraits<Array<Scalar, Rows, Cols, Options, MaxRows, MaxCols> >
{
  typedef Array<Scalar, Rows, Cols, Options, MaxRows, MaxCols> ArrayType;
  typedef typename NumTraits<Scalar>::Real RealScalar;
  typedef Array<RealScalar, Rows, Cols, Options, MaxRows, MaxCols> Real;
  typedef typename NumTraits<Scalar>::NonInteger NonIntegerScalar;
  typedef Array<NonIntegerScalar, Rows, Cols, Options, MaxRows, MaxCols> NonInteger;
  typedef ArrayType & Nested;

  enum {
    IsComplex = NumTraits<Scalar>::IsComplex,
    IsInteger = NumTraits<Scalar>::IsInteger,
    IsSigned = NumTraits<Scalar>::IsSigned,
    RequireInitialization = 1,
    ReadCost = ArrayType::SizeAtCompileTime==Dynamic ? Dynamic : ArrayType::SizeAtCompileTime * NumTraits<Scalar>::ReadCost,
    AddCost = ArrayType::SizeAtCompileTime==Dynamic ? Dynamic : ArrayType::SizeAtCompileTime * NumTraits<Scalar>::AddCost,
    MulCost = ArrayType::SizeAtCompileTime==Dynamic ? Dynamic : ArrayType::SizeAtCompileTime * NumTraits<Scalar>::MulCost
  };
};
# 258 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/MathFunctions.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/MathFunctions.h"
namespace internal {
# 50 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/MathFunctions.h"
template<typename T, typename dummy = void>
struct global_math_functions_filtering_base
{
  typedef T type;
};

template<typename T> struct always_void { typedef void type; };

template<typename T>
struct global_math_functions_filtering_base
  <T,
   typename always_void<typename T::Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl>::type
  >
{
  typedef typename T::Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl type;
};
# 75 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/MathFunctions.h"
template<typename Scalar>
struct real_impl
{
  typedef typename NumTraits<Scalar>::Real RealScalar;
  static inline RealScalar run(const Scalar& x)
  {
    return x;
  }
};

template<typename RealScalar>
struct real_impl<std::complex<RealScalar> >
{
  static inline RealScalar run(const std::complex<RealScalar>& x)
  {
    using std::real;
    return real(x);
  }
};

template<typename Scalar>
struct real_retval
{
  typedef typename NumTraits<Scalar>::Real type;
};

template<typename Scalar>
inline typename real_retval<typename global_math_functions_filtering_base<Scalar>::type>::type real(const Scalar& x)
{
  return real_impl<typename global_math_functions_filtering_base<Scalar>::type>::run(x);
}





template<typename Scalar>
struct imag_impl
{
  typedef typename NumTraits<Scalar>::Real RealScalar;
  static inline RealScalar run(const Scalar&)
  {
    return RealScalar(0);
  }
};

template<typename RealScalar>
struct imag_impl<std::complex<RealScalar> >
{
  static inline RealScalar run(const std::complex<RealScalar>& x)
  {
    using std::imag;
    return imag(x);
  }
};

template<typename Scalar>
struct imag_retval
{
  typedef typename NumTraits<Scalar>::Real type;
};

template<typename Scalar>
inline typename imag_retval<typename global_math_functions_filtering_base<Scalar>::type>::type imag(const Scalar& x)
{
  return imag_impl<typename global_math_functions_filtering_base<Scalar>::type>::run(x);
}





template<typename Scalar>
struct real_ref_impl
{
  typedef typename NumTraits<Scalar>::Real RealScalar;
  static inline RealScalar& run(Scalar& x)
  {
    return reinterpret_cast<RealScalar*>(&x)[0];
  }
  static inline const RealScalar& run(const Scalar& x)
  {
    return reinterpret_cast<const RealScalar*>(&x)[0];
  }
};

template<typename Scalar>
struct real_ref_retval
{
  typedef typename NumTraits<Scalar>::Real & type;
};

template<typename Scalar>
inline typename add_const_on_value_type< typename real_ref_retval<typename global_math_functions_filtering_base<Scalar>::type>::type >::type real_ref(const Scalar& x)
{
  return real_ref_impl<Scalar>::run(x);
}

template<typename Scalar>
inline typename real_ref_retval<typename global_math_functions_filtering_base<Scalar>::type>::type real_ref(Scalar& x)
{
  return real_ref_impl<typename global_math_functions_filtering_base<Scalar>::type>::run(x);
}





template<typename Scalar, bool IsComplex>
struct imag_ref_default_impl
{
  typedef typename NumTraits<Scalar>::Real RealScalar;
  static inline RealScalar& run(Scalar& x)
  {
    return reinterpret_cast<RealScalar*>(&x)[1];
  }
  static inline const RealScalar& run(const Scalar& x)
  {
    return reinterpret_cast<RealScalar*>(&x)[1];
  }
};

template<typename Scalar>
struct imag_ref_default_impl<Scalar, false>
{
  static inline Scalar run(Scalar&)
  {
    return Scalar(0);
  }
  static inline const Scalar run(const Scalar&)
  {
    return Scalar(0);
  }
};

template<typename Scalar>
struct imag_ref_impl : imag_ref_default_impl<Scalar, NumTraits<Scalar>::IsComplex> {};

template<typename Scalar>
struct imag_ref_retval
{
  typedef typename NumTraits<Scalar>::Real & type;
};

template<typename Scalar>
inline typename add_const_on_value_type< typename imag_ref_retval<typename global_math_functions_filtering_base<Scalar>::type>::type >::type imag_ref(const Scalar& x)
{
  return imag_ref_impl<Scalar>::run(x);
}

template<typename Scalar>
inline typename imag_ref_retval<typename global_math_functions_filtering_base<Scalar>::type>::type imag_ref(Scalar& x)
{
  return imag_ref_impl<typename global_math_functions_filtering_base<Scalar>::type>::run(x);
}





template<typename Scalar>
struct conj_impl
{
  static inline Scalar run(const Scalar& x)
  {
    return x;
  }
};

template<typename RealScalar>
struct conj_impl<std::complex<RealScalar> >
{
  static inline std::complex<RealScalar> run(const std::complex<RealScalar>& x)
  {
    using std::conj;
    return conj(x);
  }
};

template<typename Scalar>
struct conj_retval
{
  typedef Scalar type;
};

template<typename Scalar>
inline typename conj_retval<typename global_math_functions_filtering_base<Scalar>::type>::type conj(const Scalar& x)
{
  return conj_impl<typename global_math_functions_filtering_base<Scalar>::type>::run(x);
}





template<typename Scalar>
struct abs_impl
{
  typedef typename NumTraits<Scalar>::Real RealScalar;
  static inline RealScalar run(const Scalar& x)
  {
    using std::abs;
    return abs(x);
  }
};

template<typename Scalar>
struct abs_retval
{
  typedef typename NumTraits<Scalar>::Real type;
};

template<typename Scalar>
inline typename abs_retval<typename global_math_functions_filtering_base<Scalar>::type>::type abs(const Scalar& x)
{
  return abs_impl<typename global_math_functions_filtering_base<Scalar>::type>::run(x);
}





template<typename Scalar>
struct abs2_impl
{
  typedef typename NumTraits<Scalar>::Real RealScalar;
  static inline RealScalar run(const Scalar& x)
  {
    return x*x;
  }
};

template<typename RealScalar>
struct abs2_impl<std::complex<RealScalar> >
{
  static inline RealScalar run(const std::complex<RealScalar>& x)
  {
    using std::norm;
    return norm(x);
  }
};

template<typename Scalar>
struct abs2_retval
{
  typedef typename NumTraits<Scalar>::Real type;
};

template<typename Scalar>
inline typename abs2_retval<typename global_math_functions_filtering_base<Scalar>::type>::type abs2(const Scalar& x)
{
  return abs2_impl<typename global_math_functions_filtering_base<Scalar>::type>::run(x);
}





template<typename Scalar, bool IsComplex>
struct norm1_default_impl
{
  typedef typename NumTraits<Scalar>::Real RealScalar;
  static inline RealScalar run(const Scalar& x)
  {
    return abs(real(x)) + abs(imag(x));
  }
};

template<typename Scalar>
struct norm1_default_impl<Scalar, false>
{
  static inline Scalar run(const Scalar& x)
  {
    return abs(x);
  }
};

template<typename Scalar>
struct norm1_impl : norm1_default_impl<Scalar, NumTraits<Scalar>::IsComplex> {};

template<typename Scalar>
struct norm1_retval
{
  typedef typename NumTraits<Scalar>::Real type;
};

template<typename Scalar>
inline typename norm1_retval<typename global_math_functions_filtering_base<Scalar>::type>::type norm1(const Scalar& x)
{
  return norm1_impl<typename global_math_functions_filtering_base<Scalar>::type>::run(x);
}





template<typename Scalar>
struct hypot_impl
{
  typedef typename NumTraits<Scalar>::Real RealScalar;
  static inline RealScalar run(const Scalar& x, const Scalar& y)
  {
    using std::max;
    using std::min;
    RealScalar _x = abs(x);
    RealScalar _y = abs(y);
    RealScalar p = (max)(_x, _y);
    RealScalar q = (min)(_x, _y);
    RealScalar qp = q/p;
    return p * sqrt(RealScalar(1) + qp*qp);
  }
};

template<typename Scalar>
struct hypot_retval
{
  typedef typename NumTraits<Scalar>::Real type;
};

template<typename Scalar>
inline typename hypot_retval<typename global_math_functions_filtering_base<Scalar>::type>::type hypot(const Scalar& x, const Scalar& y)
{
  return hypot_impl<typename global_math_functions_filtering_base<Scalar>::type>::run(x, y);
}





template<typename OldType, typename NewType>
struct cast_impl
{
  static inline NewType run(const OldType& x)
  {
    return static_cast<NewType>(x);
  }
};



template<typename OldType, typename NewType>
inline NewType cast(const OldType& x)
{
  return cast_impl<OldType, NewType>::run(x);
}





template<typename Scalar, bool IsInteger>
struct sqrt_default_impl
{
  static inline Scalar run(const Scalar& x)
  {
    using std::sqrt;
    return sqrt(x);
  }
};

template<typename Scalar>
struct sqrt_default_impl<Scalar, true>
{
  static inline Scalar run(const Scalar&)
  {



    if (Eigen::internal::static_assertion<bool(!NumTraits<Scalar>::IsInteger)>::THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES) {}

    return Scalar(0);
  }
};

template<typename Scalar>
struct sqrt_impl : sqrt_default_impl<Scalar, NumTraits<Scalar>::IsInteger> {};

template<typename Scalar>
struct sqrt_retval
{
  typedef Scalar type;
};

template<typename Scalar>
inline typename sqrt_retval<typename global_math_functions_filtering_base<Scalar>::type>::type sqrt(const Scalar& x)
{
  return sqrt_impl<typename global_math_functions_filtering_base<Scalar>::type>::run(x);
}
# 488 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/MathFunctions.h"
template<typename Scalar, bool IsInteger> struct exp_default_impl { static inline Scalar run(const Scalar& x) { using std::exp; return exp(x); } }; template<typename Scalar> struct exp_default_impl<Scalar, true> { static inline Scalar run(const Scalar&) { if (Eigen::internal::static_assertion<bool(!NumTraits<Scalar>::IsInteger)>::THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES) {} return Scalar(0); } }; template<typename Scalar> struct exp_impl : exp_default_impl<Scalar, NumTraits<Scalar>::IsInteger> {}; template<typename Scalar> struct exp_retval { typedef Scalar type; }; template<typename Scalar> inline typename exp_retval<typename global_math_functions_filtering_base<Scalar>::type>::type exp(const Scalar& x) { return exp_impl<typename global_math_functions_filtering_base<Scalar>::type>::run(x); }
template<typename Scalar, bool IsInteger> struct log_default_impl { static inline Scalar run(const Scalar& x) { using std::log; return log(x); } }; template<typename Scalar> struct log_default_impl<Scalar, true> { static inline Scalar run(const Scalar&) { if (Eigen::internal::static_assertion<bool(!NumTraits<Scalar>::IsInteger)>::THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES) {} return Scalar(0); } }; template<typename Scalar> struct log_impl : log_default_impl<Scalar, NumTraits<Scalar>::IsInteger> {}; template<typename Scalar> struct log_retval { typedef Scalar type; }; template<typename Scalar> inline typename log_retval<typename global_math_functions_filtering_base<Scalar>::type>::type log(const Scalar& x) { return log_impl<typename global_math_functions_filtering_base<Scalar>::type>::run(x); }
template<typename Scalar, bool IsInteger> struct sin_default_impl { static inline Scalar run(const Scalar& x) { using std::sin; return sin(x); } }; template<typename Scalar> struct sin_default_impl<Scalar, true> { static inline Scalar run(const Scalar&) { if (Eigen::internal::static_assertion<bool(!NumTraits<Scalar>::IsInteger)>::THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES) {} return Scalar(0); } }; template<typename Scalar> struct sin_impl : sin_default_impl<Scalar, NumTraits<Scalar>::IsInteger> {}; template<typename Scalar> struct sin_retval { typedef Scalar type; }; template<typename Scalar> inline typename sin_retval<typename global_math_functions_filtering_base<Scalar>::type>::type sin(const Scalar& x) { return sin_impl<typename global_math_functions_filtering_base<Scalar>::type>::run(x); }
template<typename Scalar, bool IsInteger> struct cos_default_impl { static inline Scalar run(const Scalar& x) { using std::cos; return cos(x); } }; template<typename Scalar> struct cos_default_impl<Scalar, true> { static inline Scalar run(const Scalar&) { if (Eigen::internal::static_assertion<bool(!NumTraits<Scalar>::IsInteger)>::THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES) {} return Scalar(0); } }; template<typename Scalar> struct cos_impl : cos_default_impl<Scalar, NumTraits<Scalar>::IsInteger> {}; template<typename Scalar> struct cos_retval { typedef Scalar type; }; template<typename Scalar> inline typename cos_retval<typename global_math_functions_filtering_base<Scalar>::type>::type cos(const Scalar& x) { return cos_impl<typename global_math_functions_filtering_base<Scalar>::type>::run(x); }
template<typename Scalar, bool IsInteger> struct tan_default_impl { static inline Scalar run(const Scalar& x) { using std::tan; return tan(x); } }; template<typename Scalar> struct tan_default_impl<Scalar, true> { static inline Scalar run(const Scalar&) { if (Eigen::internal::static_assertion<bool(!NumTraits<Scalar>::IsInteger)>::THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES) {} return Scalar(0); } }; template<typename Scalar> struct tan_impl : tan_default_impl<Scalar, NumTraits<Scalar>::IsInteger> {}; template<typename Scalar> struct tan_retval { typedef Scalar type; }; template<typename Scalar> inline typename tan_retval<typename global_math_functions_filtering_base<Scalar>::type>::type tan(const Scalar& x) { return tan_impl<typename global_math_functions_filtering_base<Scalar>::type>::run(x); }
template<typename Scalar, bool IsInteger> struct asin_default_impl { static inline Scalar run(const Scalar& x) { using std::asin; return asin(x); } }; template<typename Scalar> struct asin_default_impl<Scalar, true> { static inline Scalar run(const Scalar&) { if (Eigen::internal::static_assertion<bool(!NumTraits<Scalar>::IsInteger)>::THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES) {} return Scalar(0); } }; template<typename Scalar> struct asin_impl : asin_default_impl<Scalar, NumTraits<Scalar>::IsInteger> {}; template<typename Scalar> struct asin_retval { typedef Scalar type; }; template<typename Scalar> inline typename asin_retval<typename global_math_functions_filtering_base<Scalar>::type>::type asin(const Scalar& x) { return asin_impl<typename global_math_functions_filtering_base<Scalar>::type>::run(x); }
template<typename Scalar, bool IsInteger> struct acos_default_impl { static inline Scalar run(const Scalar& x) { using std::acos; return acos(x); } }; template<typename Scalar> struct acos_default_impl<Scalar, true> { static inline Scalar run(const Scalar&) { if (Eigen::internal::static_assertion<bool(!NumTraits<Scalar>::IsInteger)>::THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES) {} return Scalar(0); } }; template<typename Scalar> struct acos_impl : acos_default_impl<Scalar, NumTraits<Scalar>::IsInteger> {}; template<typename Scalar> struct acos_retval { typedef Scalar type; }; template<typename Scalar> inline typename acos_retval<typename global_math_functions_filtering_base<Scalar>::type>::type acos(const Scalar& x) { return acos_impl<typename global_math_functions_filtering_base<Scalar>::type>::run(x); }





template<typename Scalar, bool IsInteger>
struct atan2_default_impl
{
  typedef Scalar retval;
  static inline Scalar run(const Scalar& x, const Scalar& y)
  {
    using std::atan2;
    return atan2(x, y);
  }
};

template<typename Scalar>
struct atan2_default_impl<Scalar, true>
{
  static inline Scalar run(const Scalar&, const Scalar&)
  {
    if (Eigen::internal::static_assertion<bool(!NumTraits<Scalar>::IsInteger)>::THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES) {}
    return Scalar(0);
  }
};

template<typename Scalar>
struct atan2_impl : atan2_default_impl<Scalar, NumTraits<Scalar>::IsInteger> {};

template<typename Scalar>
struct atan2_retval
{
  typedef Scalar type;
};

template<typename Scalar>
inline typename atan2_retval<typename global_math_functions_filtering_base<Scalar>::type>::type atan2(const Scalar& x, const Scalar& y)
{
  return atan2_impl<typename global_math_functions_filtering_base<Scalar>::type>::run(x, y);
}





template<typename Scalar, bool IsInteger>
struct pow_default_impl
{
  typedef Scalar retval;
  static inline Scalar run(const Scalar& x, const Scalar& y)
  {
    using std::pow;
    return pow(x, y);
  }
};

template<typename Scalar>
struct pow_default_impl<Scalar, true>
{
  static inline Scalar run(Scalar x, Scalar y)
  {
    Scalar res = 1;
    if( (!Eigen::internal::copy_bool(!NumTraits<Scalar>::IsSigned || y >= 0)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(!NumTraits<Scalar>::IsSigned || y >= 0)) Eigen::internal::assert_fail("!NumTraits<Scalar>::IsSigned || y >= 0", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/MathFunctions.h", 557); } while(false); else throw Eigen::eigen_assert_exception(); };
    if(y & 1) res *= x;
    y >>= 1;
    while(y)
    {
      x *= x;
      if(y&1) res *= x;
      y >>= 1;
    }
    return res;
  }
};

template<typename Scalar>
struct pow_impl : pow_default_impl<Scalar, NumTraits<Scalar>::IsInteger> {};

template<typename Scalar>
struct pow_retval
{
  typedef Scalar type;
};

template<typename Scalar>
inline typename pow_retval<typename global_math_functions_filtering_base<Scalar>::type>::type pow(const Scalar& x, const Scalar& y)
{
  return pow_impl<typename global_math_functions_filtering_base<Scalar>::type>::run(x, y);
}





template<typename Scalar,
         bool IsComplex,
         bool IsInteger>
struct random_default_impl {};

template<typename Scalar>
struct random_impl : random_default_impl<Scalar, NumTraits<Scalar>::IsComplex, NumTraits<Scalar>::IsInteger> {};

template<typename Scalar>
struct random_retval
{
  typedef Scalar type;
};

template<typename Scalar> inline typename random_retval<typename global_math_functions_filtering_base<Scalar>::type>::type random(const Scalar& x, const Scalar& y);
template<typename Scalar> inline typename random_retval<typename global_math_functions_filtering_base<Scalar>::type>::type random();

template<typename Scalar>
struct random_default_impl<Scalar, false, false>
{
  static inline Scalar run(const Scalar& x, const Scalar& y)
  {
    return x + (y-x) * Scalar(std::rand()) / Scalar(2147483647);
  }
  static inline Scalar run()
  {
    return run(Scalar(NumTraits<Scalar>::IsSigned ? -1 : 0), Scalar(1));
  }
};

enum {
  floor_log2_terminate,
  floor_log2_move_up,
  floor_log2_move_down,
  floor_log2_bogus
};

template<unsigned int n, int lower, int upper> struct floor_log2_selector
{
  enum { middle = (lower + upper) / 2,
         value = (upper <= lower + 1) ? int(floor_log2_terminate)
               : (n < (1 << middle)) ? int(floor_log2_move_down)
               : (n==0) ? int(floor_log2_bogus)
               : int(floor_log2_move_up)
  };
};

template<unsigned int n,
         int lower = 0,
         int upper = sizeof(unsigned int) * 8 - 1,
         int selector = floor_log2_selector<n, lower, upper>::value>
struct floor_log2 {};

template<unsigned int n, int lower, int upper>
struct floor_log2<n, lower, upper, floor_log2_move_down>
{
  enum { value = floor_log2<n, lower, floor_log2_selector<n, lower, upper>::middle>::value };
};

template<unsigned int n, int lower, int upper>
struct floor_log2<n, lower, upper, floor_log2_move_up>
{
  enum { value = floor_log2<n, floor_log2_selector<n, lower, upper>::middle, upper>::value };
};

template<unsigned int n, int lower, int upper>
struct floor_log2<n, lower, upper, floor_log2_terminate>
{
  enum { value = (n >= ((unsigned int)(1) << (lower+1))) ? lower+1 : lower };
};

template<unsigned int n, int lower, int upper>
struct floor_log2<n, lower, upper, floor_log2_bogus>
{

};

template<typename Scalar>
struct random_default_impl<Scalar, false, true>
{
  typedef typename NumTraits<Scalar>::NonInteger NonInteger;

  static inline Scalar run(const Scalar& x, const Scalar& y)
  {
    return x + Scalar((NonInteger(y)-x+1) * std::rand() / (2147483647 + NonInteger(1)));
  }

  static inline Scalar run()
  {



    enum { rand_bits = floor_log2<(unsigned int)(2147483647)+1>::value,
           scalar_bits = sizeof(Scalar) * 8,
           shift = (((int)0 >= (int)int(rand_bits) - int(scalar_bits)) ? (int)0 : (int)int(rand_bits) - int(scalar_bits))
    };
    Scalar x = Scalar(std::rand() >> shift);
    Scalar offset = NumTraits<Scalar>::IsSigned ? Scalar(1 << (rand_bits-1)) : Scalar(0);
    return x - offset;

  }
};

template<typename Scalar>
struct random_default_impl<Scalar, true, false>
{
  static inline Scalar run(const Scalar& x, const Scalar& y)
  {
    return Scalar(random(real(x), real(y)),
                  random(imag(x), imag(y)));
  }
  static inline Scalar run()
  {
    typedef typename NumTraits<Scalar>::Real RealScalar;
    return Scalar(random<RealScalar>(), random<RealScalar>());
  }
};

template<typename Scalar>
inline typename random_retval<typename global_math_functions_filtering_base<Scalar>::type>::type random(const Scalar& x, const Scalar& y)
{
  return random_impl<typename global_math_functions_filtering_base<Scalar>::type>::run(x, y);
}

template<typename Scalar>
inline typename random_retval<typename global_math_functions_filtering_base<Scalar>::type>::type random()
{
  return random_impl<typename global_math_functions_filtering_base<Scalar>::type>::run();
}





template<typename Scalar,
         bool IsComplex,
         bool IsInteger>
struct scalar_fuzzy_default_impl {};

template<typename Scalar>
struct scalar_fuzzy_default_impl<Scalar, false, false>
{
  typedef typename NumTraits<Scalar>::Real RealScalar;
  template<typename OtherScalar>
  static inline bool isMuchSmallerThan(const Scalar& x, const OtherScalar& y, const RealScalar& prec)
  {
    return abs(x) <= abs(y) * prec;
  }
  static inline bool isApprox(const Scalar& x, const Scalar& y, const RealScalar& prec)
  {
    using std::min;
    return abs(x - y) <= (min)(abs(x), abs(y)) * prec;
  }
  static inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y, const RealScalar& prec)
  {
    return x <= y || isApprox(x, y, prec);
  }
};

template<typename Scalar>
struct scalar_fuzzy_default_impl<Scalar, false, true>
{
  typedef typename NumTraits<Scalar>::Real RealScalar;
  template<typename OtherScalar>
  static inline bool isMuchSmallerThan(const Scalar& x, const Scalar&, const RealScalar&)
  {
    return x == Scalar(0);
  }
  static inline bool isApprox(const Scalar& x, const Scalar& y, const RealScalar&)
  {
    return x == y;
  }
  static inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y, const RealScalar&)
  {
    return x <= y;
  }
};

template<typename Scalar>
struct scalar_fuzzy_default_impl<Scalar, true, false>
{
  typedef typename NumTraits<Scalar>::Real RealScalar;
  template<typename OtherScalar>
  static inline bool isMuchSmallerThan(const Scalar& x, const OtherScalar& y, const RealScalar& prec)
  {
    return abs2(x) <= abs2(y) * prec * prec;
  }
  static inline bool isApprox(const Scalar& x, const Scalar& y, const RealScalar& prec)
  {
    using std::min;
    return abs2(x - y) <= (min)(abs2(x), abs2(y)) * prec * prec;
  }
};

template<typename Scalar>
struct scalar_fuzzy_impl : scalar_fuzzy_default_impl<Scalar, NumTraits<Scalar>::IsComplex, NumTraits<Scalar>::IsInteger> {};

template<typename Scalar, typename OtherScalar>
inline bool isMuchSmallerThan(const Scalar& x, const OtherScalar& y,
                                   typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision())
{
  return scalar_fuzzy_impl<Scalar>::template isMuchSmallerThan<OtherScalar>(x, y, precision);
}

template<typename Scalar>
inline bool isApprox(const Scalar& x, const Scalar& y,
                          typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision())
{
  return scalar_fuzzy_impl<Scalar>::isApprox(x, y, precision);
}

template<typename Scalar>
inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y,
                                    typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision())
{
  return scalar_fuzzy_impl<Scalar>::isApproxOrLessThan(x, y, precision);
}





template<> struct random_impl<bool>
{
  static inline bool run()
  {
    return random<int>(0,1)==0 ? false : true;
  }
};

template<> struct scalar_fuzzy_impl<bool>
{
  typedef bool RealScalar;

  template<typename OtherScalar>
  static inline bool isMuchSmallerThan(const bool& x, const bool&, const bool&)
  {
    return !x;
  }

  static inline bool isApprox(bool x, bool y, bool)
  {
    return x == y;
  }

  static inline bool isApproxOrLessThan(const bool& x, const bool& y, const bool&)
  {
    return (!x) || y;
  }

};

}
# 259 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/GenericPacketMath.h" 1
# 29 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/GenericPacketMath.h"
namespace internal {
# 55 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/GenericPacketMath.h"
struct default_packet_traits
{
  enum {
    HasAdd = 1,
    HasSub = 1,
    HasMul = 1,
    HasNegate = 1,
    HasAbs = 1,
    HasAbs2 = 1,
    HasMin = 1,
    HasMax = 1,
    HasConj = 1,
    HasSetLinear = 1,

    HasDiv = 0,
    HasSqrt = 0,
    HasExp = 0,
    HasLog = 0,
    HasPow = 0,

    HasSin = 0,
    HasCos = 0,
    HasTan = 0,
    HasASin = 0,
    HasACos = 0,
    HasATan = 0
  };
};

template<typename T> struct packet_traits : default_packet_traits
{
  typedef T type;
  enum {
    Vectorizable = 0,
    size = 1,
    AlignedOnScalar = 0
  };
  enum {
    HasAdd = 0,
    HasSub = 0,
    HasMul = 0,
    HasNegate = 0,
    HasAbs = 0,
    HasAbs2 = 0,
    HasMin = 0,
    HasMax = 0,
    HasConj = 0,
    HasSetLinear = 0
  };
};


template<typename Packet> inline Packet
padd(const Packet& a,
        const Packet& b) { return a+b; }


template<typename Packet> inline Packet
psub(const Packet& a,
        const Packet& b) { return a-b; }


template<typename Packet> inline Packet
pnegate(const Packet& a) { return -a; }


template<typename Packet> inline Packet
pconj(const Packet& a) { return conj(a); }


template<typename Packet> inline Packet
pmul(const Packet& a,
        const Packet& b) { return a*b; }


template<typename Packet> inline Packet
pdiv(const Packet& a,
        const Packet& b) { return a/b; }


template<typename Packet> inline Packet
pmin(const Packet& a,
        const Packet& b) { using std::min; return (min)(a, b); }


template<typename Packet> inline Packet
pmax(const Packet& a,
        const Packet& b) { using std::max; return (max)(a, b); }


template<typename Packet> inline Packet
pabs(const Packet& a) { return abs(a); }


template<typename Packet> inline Packet
pand(const Packet& a, const Packet& b) { return a & b; }


template<typename Packet> inline Packet
por(const Packet& a, const Packet& b) { return a | b; }


template<typename Packet> inline Packet
pxor(const Packet& a, const Packet& b) { return a ^ b; }


template<typename Packet> inline Packet
pandnot(const Packet& a, const Packet& b) { return a & (!b); }


template<typename Packet> inline Packet
pload(const typename unpacket_traits<Packet>::type* from) { return *from; }


template<typename Packet> inline Packet
ploadu(const typename unpacket_traits<Packet>::type* from) { return *from; }


template<typename Packet> inline Packet
ploaddup(const typename unpacket_traits<Packet>::type* from) { return *from; }


template<typename Packet> inline Packet
pset1(const typename unpacket_traits<Packet>::type& a) { return a; }


template<typename Scalar> inline typename packet_traits<Scalar>::type
plset(const Scalar& a) { return a; }


template<typename Scalar, typename Packet> inline void pstore(Scalar* to, const Packet& from)
{ (*to) = from; }


template<typename Scalar, typename Packet> inline void pstoreu(Scalar* to, const Packet& from)
{ (*to) = from; }


template<typename Scalar> inline void prefetch(const Scalar* addr)
{

__builtin_prefetch(addr);

}


template<typename Packet> inline typename unpacket_traits<Packet>::type pfirst(const Packet& a)
{ return a; }


template<typename Packet> inline Packet
preduxp(const Packet* vecs) { return vecs[0]; }


template<typename Packet> inline typename unpacket_traits<Packet>::type predux(const Packet& a)
{ return a; }


template<typename Packet> inline typename unpacket_traits<Packet>::type predux_mul(const Packet& a)
{ return a; }


template<typename Packet> inline typename unpacket_traits<Packet>::type predux_min(const Packet& a)
{ return a; }


template<typename Packet> inline typename unpacket_traits<Packet>::type predux_max(const Packet& a)
{ return a; }


template<typename Packet> inline Packet preverse(const Packet& a)
{ return a; }



template<typename Packet> inline Packet pcplxflip(const Packet& a)
{ return Packet(imag(a),real(a)); }






template<typename Packet>
Packet psin(const Packet& a) { return sin(a); }


template<typename Packet>
Packet pcos(const Packet& a) { return cos(a); }


template<typename Packet>
Packet ptan(const Packet& a) { return tan(a); }


template<typename Packet>
Packet pasin(const Packet& a) { return asin(a); }


template<typename Packet>
Packet pacos(const Packet& a) { return acos(a); }


template<typename Packet>
Packet pexp(const Packet& a) { return exp(a); }


template<typename Packet>
Packet plog(const Packet& a) { return log(a); }


template<typename Packet>
Packet psqrt(const Packet& a) { return sqrt(a); }







template<typename Packet>
inline void pstore1(typename unpacket_traits<Packet>::type* to, const typename unpacket_traits<Packet>::type& a)
{
  pstore(to, pset1<Packet>(a));
}


template<typename Packet> inline Packet
pmadd(const Packet& a,
         const Packet& b,
         const Packet& c)
{ return padd(pmul(a, b),c); }



template<typename Packet, int LoadMode>
inline Packet ploadt(const typename unpacket_traits<Packet>::type* from)
{
  if(LoadMode == Aligned)
    return pload<Packet>(from);
  else
    return ploadu<Packet>(from);
}



template<typename Scalar, typename Packet, int LoadMode>
inline void pstoret(Scalar* to, const Packet& from)
{
  if(LoadMode == Aligned)
    pstore(to, from);
  else
    pstoreu(to, from);
}


template<int Offset,typename PacketType>
struct palign_impl
{

  inline static void run(PacketType&, const PacketType&) {}
};



template<int Offset,typename PacketType>
inline void palign(PacketType& first, const PacketType& second)
{
  palign_impl<Offset,PacketType>::run(first,second);
}





template<> inline std::complex<float> pmul(const std::complex<float>& a, const std::complex<float>& b)
{ return std::complex<float>(real(a)*real(b) - imag(a)*imag(b), imag(a)*real(b) + real(a)*imag(b)); }

template<> inline std::complex<double> pmul(const std::complex<double>& a, const std::complex<double>& b)
{ return std::complex<double>(real(a)*real(b) - imag(a)*imag(b), imag(a)*real(b) + real(a)*imag(b)); }

}
# 260 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2


# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/arch/SSE/PacketMath.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/arch/SSE/PacketMath.h"
namespace internal {
# 38 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/arch/SSE/PacketMath.h"
typedef __m128 Packet4f;
typedef __m128i Packet4i;
typedef __m128d Packet2d;

template<> struct is_arithmetic<__m128> { enum { value = true }; };
template<> struct is_arithmetic<__m128i> { enum { value = true }; };
template<> struct is_arithmetic<__m128d> { enum { value = true }; };
# 71 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/arch/SSE/PacketMath.h"
template<> struct packet_traits<float> : default_packet_traits
{
  typedef Packet4f type;
  enum {
    Vectorizable = 1,
    AlignedOnScalar = 1,
    size=4,

    HasDiv = 1,
    HasSin = 1,
    HasCos = 1,
    HasLog = 1,
    HasExp = 1,
    HasSqrt = 1
  };
};
template<> struct packet_traits<double> : default_packet_traits
{
  typedef Packet2d type;
  enum {
    Vectorizable = 1,
    AlignedOnScalar = 1,
    size=2,

    HasDiv = 1
  };
};
template<> struct packet_traits<int> : default_packet_traits
{
  typedef Packet4i type;
  enum {

    Vectorizable = 1,
    AlignedOnScalar = 1,
    size=4
  };
};

template<> struct unpacket_traits<Packet4f> { typedef float type; enum {size=4}; };
template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2}; };
template<> struct unpacket_traits<Packet4i> { typedef int type; enum {size=4}; };

template<> inline Packet4f pset1<Packet4f>(const float& from) { return _mm_set1_ps(from); }
template<> inline Packet2d pset1<Packet2d>(const double& from) { return _mm_set1_pd(from); }
template<> inline Packet4i pset1<Packet4i>(const int& from) { return _mm_set1_epi32(from); }

template<> inline Packet4f plset<float>(const float& a) { return _mm_add_ps(pset1<Packet4f>(a), _mm_set_ps(3,2,1,0)); }
template<> inline Packet2d plset<double>(const double& a) { return _mm_add_pd(pset1<Packet2d>(a),_mm_set_pd(1,0)); }
template<> inline Packet4i plset<int>(const int& a) { return _mm_add_epi32(pset1<Packet4i>(a),_mm_set_epi32(3,2,1,0)); }

template<> inline Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_add_ps(a,b); }
template<> inline Packet2d padd<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_add_pd(a,b); }
template<> inline Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_add_epi32(a,b); }

template<> inline Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_sub_ps(a,b); }
template<> inline Packet2d psub<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_sub_pd(a,b); }
template<> inline Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_sub_epi32(a,b); }

template<> inline Packet4f pnegate(const Packet4f& a)
{
  const Packet4f mask = _mm_castsi128_ps(_mm_setr_epi32(0x80000000,0x80000000,0x80000000,0x80000000));
  return _mm_xor_ps(a,mask);
}
template<> inline Packet2d pnegate(const Packet2d& a)
{
  const Packet2d mask = _mm_castsi128_pd(_mm_setr_epi32(0x0,0x80000000,0x0,0x80000000));
  return _mm_xor_pd(a,mask);
}
template<> inline Packet4i pnegate(const Packet4i& a)
{
  return psub(_mm_setr_epi32(0,0,0,0), a);
}

template<> inline Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_mul_ps(a,b); }
template<> inline Packet2d pmul<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_mul_pd(a,b); }
template<> inline Packet4i pmul<Packet4i>(const Packet4i& a, const Packet4i& b)
{




  return (((__m128i)__builtin_shufflevector((__v4si)((_mm_castps_si128( ((__builtin_shufflevector((__v4sf)(_mm_castsi128_ps(_mm_mul_epu32(a,b))), (__v4sf)(_mm_castsi128_ps(_mm_mul_epu32((((__m128i)__builtin_shufflevector((__v4si)(a), (__v4si) _mm_set1_epi32(0), (((2)<<6|(3)<<4|(0)<<2|(1))) & 0x3, ((((2)<<6|(3)<<4|(0)<<2|(1))) & 0xc) >> 2, ((((2)<<6|(3)<<4|(0)<<2|(1))) & 0x30) >> 4, ((((2)<<6|(3)<<4|(0)<<2|(1))) & 0xc0) >> 6))), (((__m128i)__builtin_shufflevector((__v4si)(b), (__v4si) _mm_set1_epi32(0), (((2)<<6|(3)<<4|(0)<<2|(1))) & 0x3, ((((2)<<6|(3)<<4|(0)<<2|(1))) & 0xc) >> 2, ((((2)<<6|(3)<<4|(0)<<2|(1))) & 0x30) >> 4, ((((2)<<6|(3)<<4|(0)<<2|(1))) & 0xc0) >> 6)))))), (((2)<<6|(0)<<4|(2)<<2|(0))) & 0x3, ((((2)<<6|(0)<<4|(2)<<2|(0))) & 0xc) >> 2, (((((2)<<6|(0)<<4|(2)<<2|(0))) & 0x30) >> 4) + 4, (((((2)<<6|(0)<<4|(2)<<2|(0))) & 0xc0) >> 6) + 4)))))), (__v4si) _mm_set1_epi32(0), (((3)<<6|(1)<<4|(2)<<2|(0))) & 0x3, ((((3)<<6|(1)<<4|(2)<<2|(0))) & 0xc) >> 2, ((((3)<<6|(1)<<4|(2)<<2|(0))) & 0x30) >> 4, ((((3)<<6|(1)<<4|(2)<<2|(0))) & 0xc0) >> 6)));







}

template<> inline Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_div_ps(a,b); }
template<> inline Packet2d pdiv<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_div_pd(a,b); }
template<> inline Packet4i pdiv<Packet4i>(const Packet4i& , const Packet4i& )
{ if( (!Eigen::internal::copy_bool(false && "packet integer division are not supported by SSE")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(false && "packet integer division are not supported by SSE")) Eigen::internal::assert_fail("false && \"packet integer division are not supported by SSE\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/arch/SSE/PacketMath.h", 165); } while(false); else throw Eigen::eigen_assert_exception(); };
  return pset1<Packet4i>(0);
}


template<> inline Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return padd(pmul(a,b), c); }

template<> inline Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_min_ps(a,b); }
template<> inline Packet2d pmin<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_min_pd(a,b); }
template<> inline Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b)
{

  Packet4i mask = _mm_cmplt_epi32(a,b);
  return _mm_or_si128(_mm_and_si128(mask,a),_mm_andnot_si128(mask,b));
}

template<> inline Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_max_ps(a,b); }
template<> inline Packet2d pmax<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_max_pd(a,b); }
template<> inline Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b)
{

  Packet4i mask = _mm_cmpgt_epi32(a,b);
  return _mm_or_si128(_mm_and_si128(mask,a),_mm_andnot_si128(mask,b));
}

template<> inline Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_and_ps(a,b); }
template<> inline Packet2d pand<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_and_pd(a,b); }
template<> inline Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_and_si128(a,b); }

template<> inline Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_or_ps(a,b); }
template<> inline Packet2d por<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_or_pd(a,b); }
template<> inline Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_or_si128(a,b); }

template<> inline Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_xor_ps(a,b); }
template<> inline Packet2d pxor<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_xor_pd(a,b); }
template<> inline Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_xor_si128(a,b); }

template<> inline Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_andnot_ps(a,b); }
template<> inline Packet2d pandnot<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_andnot_pd(a,b); }
template<> inline Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_andnot_si128(a,b); }

template<> inline Packet4f pload<Packet4f>(const float* from) { return _mm_load_ps(from); }
template<> inline Packet2d pload<Packet2d>(const double* from) { return _mm_load_pd(from); }
template<> inline Packet4i pload<Packet4i>(const int* from) { return _mm_load_si128(reinterpret_cast<const Packet4i*>(from)); }
# 245 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/arch/SSE/PacketMath.h"
template<> inline Packet4f ploadu<Packet4f>(const float* from)
{


  return _mm_loadu_ps(from);






}
template<> inline Packet2d ploadu<Packet2d>(const double* from)
{


  return _mm_loadu_pd(from);






}
template<> inline Packet4i ploadu<Packet4i>(const int* from)
{


  return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from));






}


template<> inline Packet4f ploaddup<Packet4f>(const float* from)
{
  return (_mm_castsi128_ps(((__m128i)__builtin_shufflevector((__v4si)(_mm_castps_si128(_mm_castpd_ps(_mm_load_sd((const double*)from)))), (__v4si) _mm_set1_epi32(0), (((1)<<6|(1)<<4|(0)<<2|(0))) & 0x3, ((((1)<<6|(1)<<4|(0)<<2|(0))) & 0xc) >> 2, ((((1)<<6|(1)<<4|(0)<<2|(0))) & 0x30) >> 4, ((((1)<<6|(1)<<4|(0)<<2|(0))) & 0xc0) >> 6))));
}
template<> inline Packet2d ploaddup<Packet2d>(const double* from)
{ return pset1<Packet2d>(from[0]); }
template<> inline Packet4i ploaddup<Packet4i>(const int* from)
{
  Packet4i tmp;
  tmp = _mm_loadl_epi64(reinterpret_cast<const Packet4i*>(from));
  return (((__m128i)__builtin_shufflevector((__v4si)(tmp), (__v4si) _mm_set1_epi32(0), (((1)<<6|(1)<<4|(0)<<2|(0))) & 0x3, ((((1)<<6|(1)<<4|(0)<<2|(0))) & 0xc) >> 2, ((((1)<<6|(1)<<4|(0)<<2|(0))) & 0x30) >> 4, ((((1)<<6|(1)<<4|(0)<<2|(0))) & 0xc0) >> 6)));
}

template<> inline void pstore<float>(float* to, const Packet4f& from) { _mm_store_ps(to, from); }
template<> inline void pstore<double>(double* to, const Packet2d& from) { _mm_store_pd(to, from); }
template<> inline void pstore<int>(int* to, const Packet4i& from) { _mm_store_si128(reinterpret_cast<Packet4i*>(to), from); }

template<> inline void pstoreu<double>(double* to, const Packet2d& from) {

  _mm_storel_pd((to), from);
  _mm_storeh_pd((to+1), from);
}
template<> inline void pstoreu<float>(float* to, const Packet4f& from) { pstoreu((double*)to, _mm_castps_pd(from)); }
template<> inline void pstoreu<int>(int* to, const Packet4i& from) { pstoreu((double*)to, _mm_castsi128_pd(from)); }


template<> inline void pstore1<Packet4f>(float* to, const float& a)
{
  Packet4f pa = _mm_set_ss(a);
  pstore(to, (_mm_castsi128_ps(((__m128i)__builtin_shufflevector((__v4si)(_mm_castps_si128(pa)), (__v4si) _mm_set1_epi32(0), (((0)<<6|(0)<<4|(0)<<2|(0))) & 0x3, ((((0)<<6|(0)<<4|(0)<<2|(0))) & 0xc) >> 2, ((((0)<<6|(0)<<4|(0)<<2|(0))) & 0x30) >> 4, ((((0)<<6|(0)<<4|(0)<<2|(0))) & 0xc0) >> 6)))));
}

template<> inline void pstore1<Packet2d>(double* to, const double& a)
{
  Packet2d pa = _mm_set_sd(a);
  pstore(to, (_mm_castsi128_pd(((__m128i)__builtin_shufflevector((__v4si)(_mm_castpd_si128(pa)), (__v4si) _mm_set1_epi32(0), (((0*2 +1)<<6|(0*2)<<4|(0*2 +1)<<2|(0*2))) & 0x3, ((((0*2 +1)<<6|(0*2)<<4|(0*2 +1)<<2|(0*2))) & 0xc) >> 2, ((((0*2 +1)<<6|(0*2)<<4|(0*2 +1)<<2|(0*2))) & 0x30) >> 4, ((((0*2 +1)<<6|(0*2)<<4|(0*2 +1)<<2|(0*2))) & 0xc0) >> 6)))));
}

template<> inline void prefetch<float>(const float* addr) { (__builtin_prefetch((void *)((const char*)(addr)), 0, 3)); }
template<> inline void prefetch<double>(const double* addr) { (__builtin_prefetch((void *)((const char*)(addr)), 0, 3)); }
template<> inline void prefetch<int>(const int* addr) { (__builtin_prefetch((void *)((const char*)(addr)), 0, 3)); }
# 337 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/arch/SSE/PacketMath.h"
template<> inline float pfirst<Packet4f>(const Packet4f& a) { return _mm_cvtss_f32(a); }
template<> inline double pfirst<Packet2d>(const Packet2d& a) { return _mm_cvtsd_f64(a); }
template<> inline int pfirst<Packet4i>(const Packet4i& a) { return _mm_cvtsi128_si32(a); }


template<> inline Packet4f preverse(const Packet4f& a)
{ return (__builtin_shufflevector((__v4sf)(a), (__v4sf)(a), (0x1B) & 0x3, ((0x1B) & 0xc) >> 2, (((0x1B) & 0x30) >> 4) + 4, (((0x1B) & 0xc0) >> 6) + 4)); }
template<> inline Packet2d preverse(const Packet2d& a)
{ return (__builtin_shufflevector((__m128d)(a), (__m128d)(a), (0x1) & 1, (((0x1) & 2) >> 1) + 2)); }
template<> inline Packet4i preverse(const Packet4i& a)
{ return ((__m128i)__builtin_shufflevector((__v4si)(a), (__v4si) _mm_set1_epi32(0), (0x1B) & 0x3, ((0x1B) & 0xc) >> 2, ((0x1B) & 0x30) >> 4, ((0x1B) & 0xc0) >> 6)); }


template<> inline Packet4f pabs(const Packet4f& a)
{
  const Packet4f mask = _mm_castsi128_ps(_mm_setr_epi32(0x7FFFFFFF,0x7FFFFFFF,0x7FFFFFFF,0x7FFFFFFF));
  return _mm_and_ps(a,mask);
}
template<> inline Packet2d pabs(const Packet2d& a)
{
  const Packet2d mask = _mm_castsi128_pd(_mm_setr_epi32(0xFFFFFFFF,0x7FFFFFFF,0xFFFFFFFF,0x7FFFFFFF));
  return _mm_and_pd(a,mask);
}
template<> inline Packet4i pabs(const Packet4i& a)
{



  Packet4i aux = _mm_srai_epi32(a,31);
  return _mm_sub_epi32(_mm_xor_si128(a,aux),aux);

}

inline void punpackp(Packet4f* vecs)
{
  vecs[1] = _mm_castsi128_ps(((__m128i)__builtin_shufflevector((__v4si)(_mm_castps_si128(vecs[0])), (__v4si) _mm_set1_epi32(0), (0x55) & 0x3, ((0x55) & 0xc) >> 2, ((0x55) & 0x30) >> 4, ((0x55) & 0xc0) >> 6)));
  vecs[2] = _mm_castsi128_ps(((__m128i)__builtin_shufflevector((__v4si)(_mm_castps_si128(vecs[0])), (__v4si) _mm_set1_epi32(0), (0xAA) & 0x3, ((0xAA) & 0xc) >> 2, ((0xAA) & 0x30) >> 4, ((0xAA) & 0xc0) >> 6)));
  vecs[3] = _mm_castsi128_ps(((__m128i)__builtin_shufflevector((__v4si)(_mm_castps_si128(vecs[0])), (__v4si) _mm_set1_epi32(0), (0xFF) & 0x3, ((0xFF) & 0xc) >> 2, ((0xFF) & 0x30) >> 4, ((0xFF) & 0xc0) >> 6)));
  vecs[0] = _mm_castsi128_ps(((__m128i)__builtin_shufflevector((__v4si)(_mm_castps_si128(vecs[0])), (__v4si) _mm_set1_epi32(0), (0x00) & 0x3, ((0x00) & 0xc) >> 2, ((0x00) & 0x30) >> 4, ((0x00) & 0xc0) >> 6)));
}
# 410 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/arch/SSE/PacketMath.h"
template<> inline float predux<Packet4f>(const Packet4f& a)
{
  Packet4f tmp = _mm_add_ps(a, _mm_movehl_ps(a,a));
  return pfirst(_mm_add_ss(tmp, (__builtin_shufflevector((__v4sf)(tmp), (__v4sf)(tmp), (1) & 0x3, ((1) & 0xc) >> 2, (((1) & 0x30) >> 4) + 4, (((1) & 0xc0) >> 6) + 4))));
}
template<> inline double predux<Packet2d>(const Packet2d& a)
{
  return pfirst(_mm_add_sd(a, _mm_unpackhi_pd(a,a)));
}

template<> inline Packet4f preduxp<Packet4f>(const Packet4f* vecs)
{
  Packet4f tmp0, tmp1, tmp2;
  tmp0 = _mm_unpacklo_ps(vecs[0], vecs[1]);
  tmp1 = _mm_unpackhi_ps(vecs[0], vecs[1]);
  tmp2 = _mm_unpackhi_ps(vecs[2], vecs[3]);
  tmp0 = _mm_add_ps(tmp0, tmp1);
  tmp1 = _mm_unpacklo_ps(vecs[2], vecs[3]);
  tmp1 = _mm_add_ps(tmp1, tmp2);
  tmp2 = _mm_movehl_ps(tmp1, tmp0);
  tmp0 = _mm_movelh_ps(tmp0, tmp1);
  return _mm_add_ps(tmp0, tmp2);
}

template<> inline Packet2d preduxp<Packet2d>(const Packet2d* vecs)
{
  return _mm_add_pd(_mm_unpacklo_pd(vecs[0], vecs[1]), _mm_unpackhi_pd(vecs[0], vecs[1]));
}


template<> inline int predux<Packet4i>(const Packet4i& a)
{
  Packet4i tmp = _mm_add_epi32(a, _mm_unpackhi_epi64(a,a));
  return pfirst(tmp) + pfirst(((__m128i)__builtin_shufflevector((__v4si)(tmp), (__v4si) _mm_set1_epi32(0), (1) & 0x3, ((1) & 0xc) >> 2, ((1) & 0x30) >> 4, ((1) & 0xc0) >> 6)));
}

template<> inline Packet4i preduxp<Packet4i>(const Packet4i* vecs)
{
  Packet4i tmp0, tmp1, tmp2;
  tmp0 = _mm_unpacklo_epi32(vecs[0], vecs[1]);
  tmp1 = _mm_unpackhi_epi32(vecs[0], vecs[1]);
  tmp2 = _mm_unpackhi_epi32(vecs[2], vecs[3]);
  tmp0 = _mm_add_epi32(tmp0, tmp1);
  tmp1 = _mm_unpacklo_epi32(vecs[2], vecs[3]);
  tmp1 = _mm_add_epi32(tmp1, tmp2);
  tmp2 = _mm_unpacklo_epi64(tmp0, tmp1);
  tmp0 = _mm_unpackhi_epi64(tmp0, tmp1);
  return _mm_add_epi32(tmp0, tmp2);
}




template<> inline float predux_mul<Packet4f>(const Packet4f& a)
{
  Packet4f tmp = _mm_mul_ps(a, _mm_movehl_ps(a,a));
  return pfirst(_mm_mul_ss(tmp, (__builtin_shufflevector((__v4sf)(tmp), (__v4sf)(tmp), (1) & 0x3, ((1) & 0xc) >> 2, (((1) & 0x30) >> 4) + 4, (((1) & 0xc0) >> 6) + 4))));
}
template<> inline double predux_mul<Packet2d>(const Packet2d& a)
{
  return pfirst(_mm_mul_sd(a, _mm_unpackhi_pd(a,a)));
}
template<> inline int predux_mul<Packet4i>(const Packet4i& a)
{



  __attribute__((aligned(16))) int aux[4];
  pstore(aux, a);
  return (aux[0] * aux[1]) * (aux[2] * aux[3]);;
}


template<> inline float predux_min<Packet4f>(const Packet4f& a)
{
  Packet4f tmp = _mm_min_ps(a, _mm_movehl_ps(a,a));
  return pfirst(_mm_min_ss(tmp, (__builtin_shufflevector((__v4sf)(tmp), (__v4sf)(tmp), (1) & 0x3, ((1) & 0xc) >> 2, (((1) & 0x30) >> 4) + 4, (((1) & 0xc0) >> 6) + 4))));
}
template<> inline double predux_min<Packet2d>(const Packet2d& a)
{
  return pfirst(_mm_min_sd(a, _mm_unpackhi_pd(a,a)));
}
template<> inline int predux_min<Packet4i>(const Packet4i& a)
{


  __attribute__((aligned(16))) int aux[4];
  pstore(aux, a);
  register int aux0 = aux[0]<aux[1] ? aux[0] : aux[1];
  register int aux2 = aux[2]<aux[3] ? aux[2] : aux[3];
  return aux0<aux2 ? aux0 : aux2;
}


template<> inline float predux_max<Packet4f>(const Packet4f& a)
{
  Packet4f tmp = _mm_max_ps(a, _mm_movehl_ps(a,a));
  return pfirst(_mm_max_ss(tmp, (__builtin_shufflevector((__v4sf)(tmp), (__v4sf)(tmp), (1) & 0x3, ((1) & 0xc) >> 2, (((1) & 0x30) >> 4) + 4, (((1) & 0xc0) >> 6) + 4))));
}
template<> inline double predux_max<Packet2d>(const Packet2d& a)
{
  return pfirst(_mm_max_sd(a, _mm_unpackhi_pd(a,a)));
}
template<> inline int predux_max<Packet4i>(const Packet4i& a)
{


  __attribute__((aligned(16))) int aux[4];
  pstore(aux, a);
  register int aux0 = aux[0]>aux[1] ? aux[0] : aux[1];
  register int aux2 = aux[2]>aux[3] ? aux[2] : aux[3];
  return aux0>aux2 ? aux0 : aux2;
}
# 572 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/arch/SSE/PacketMath.h"
template<int Offset>
struct palign_impl<Offset,Packet4f>
{
  inline static void run(Packet4f& first, const Packet4f& second)
  {
    if (Offset==1)
    {
      first = _mm_move_ss(first,second);
      first = _mm_castsi128_ps(((__m128i)__builtin_shufflevector((__v4si)(_mm_castps_si128(first)), (__v4si) _mm_set1_epi32(0), (0x39) & 0x3, ((0x39) & 0xc) >> 2, ((0x39) & 0x30) >> 4, ((0x39) & 0xc0) >> 6)));
    }
    else if (Offset==2)
    {
      first = _mm_movehl_ps(first,first);
      first = _mm_movelh_ps(first,second);
    }
    else if (Offset==3)
    {
      first = _mm_move_ss(first,second);
      first = (__builtin_shufflevector((__v4sf)(first), (__v4sf)(second), (0x93) & 0x3, ((0x93) & 0xc) >> 2, (((0x93) & 0x30) >> 4) + 4, (((0x93) & 0xc0) >> 6) + 4));
    }
  }
};

template<int Offset>
struct palign_impl<Offset,Packet4i>
{
  inline static void run(Packet4i& first, const Packet4i& second)
  {
    if (Offset==1)
    {
      first = _mm_castps_si128(_mm_move_ss(_mm_castsi128_ps(first),_mm_castsi128_ps(second)));
      first = ((__m128i)__builtin_shufflevector((__v4si)(first), (__v4si) _mm_set1_epi32(0), (0x39) & 0x3, ((0x39) & 0xc) >> 2, ((0x39) & 0x30) >> 4, ((0x39) & 0xc0) >> 6));
    }
    else if (Offset==2)
    {
      first = _mm_castps_si128(_mm_movehl_ps(_mm_castsi128_ps(first),_mm_castsi128_ps(first)));
      first = _mm_castps_si128(_mm_movelh_ps(_mm_castsi128_ps(first),_mm_castsi128_ps(second)));
    }
    else if (Offset==3)
    {
      first = _mm_castps_si128(_mm_move_ss(_mm_castsi128_ps(first),_mm_castsi128_ps(second)));
      first = _mm_castps_si128((__builtin_shufflevector((__v4sf)(_mm_castsi128_ps(first)), (__v4sf)(_mm_castsi128_ps(second)), (0x93) & 0x3, ((0x93) & 0xc) >> 2, (((0x93) & 0x30) >> 4) + 4, (((0x93) & 0xc0) >> 6) + 4)));
    }
  }
};

template<int Offset>
struct palign_impl<Offset,Packet2d>
{
  inline static void run(Packet2d& first, const Packet2d& second)
  {
    if (Offset==1)
    {
      first = _mm_castps_pd(_mm_movehl_ps(_mm_castpd_ps(first),_mm_castpd_ps(first)));
      first = _mm_castps_pd(_mm_movelh_ps(_mm_castpd_ps(first),_mm_castpd_ps(second)));
    }
  }
};


}
# 263 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/arch/SSE/MathFunctions.h" 1
# 33 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/arch/SSE/MathFunctions.h"
namespace internal {

template<> inline __attribute__((unused))
Packet4f plog<Packet4f>(const Packet4f& _x)
{
  Packet4f x = _x;
  const Packet4f p4f_1 = pset1<Packet4f>(1.0f);
  const Packet4f p4f_half = pset1<Packet4f>(0.5f);
  const Packet4i p4i_0x7f = pset1<Packet4i>(0x7f);

  const Packet4f p4f_inv_mant_mask = _mm_castsi128_ps(pset1<Packet4i>(~0x7f800000));


  const Packet4f p4f_min_norm_pos = _mm_castsi128_ps(pset1<Packet4i>(0x00800000));




  const Packet4f p4f_cephes_SQRTHF = pset1<Packet4f>(0.707106781186547524f);
  const Packet4f p4f_cephes_log_p0 = pset1<Packet4f>(7.0376836292E-2f);
  const Packet4f p4f_cephes_log_p1 = pset1<Packet4f>(- 1.1514610310E-1f);
  const Packet4f p4f_cephes_log_p2 = pset1<Packet4f>(1.1676998740E-1f);
  const Packet4f p4f_cephes_log_p3 = pset1<Packet4f>(- 1.2420140846E-1f);
  const Packet4f p4f_cephes_log_p4 = pset1<Packet4f>(+ 1.4249322787E-1f);
  const Packet4f p4f_cephes_log_p5 = pset1<Packet4f>(- 1.6668057665E-1f);
  const Packet4f p4f_cephes_log_p6 = pset1<Packet4f>(+ 2.0000714765E-1f);
  const Packet4f p4f_cephes_log_p7 = pset1<Packet4f>(- 2.4999993993E-1f);
  const Packet4f p4f_cephes_log_p8 = pset1<Packet4f>(+ 3.3333331174E-1f);
  const Packet4f p4f_cephes_log_q1 = pset1<Packet4f>(-2.12194440e-4f);
  const Packet4f p4f_cephes_log_q2 = pset1<Packet4f>(0.693359375f);


  Packet4i emm0;

  Packet4f invalid_mask = _mm_cmple_ps(x, _mm_setzero_ps());

  x = pmax(x, p4f_min_norm_pos);
  emm0 = _mm_srli_epi32(_mm_castps_si128(x), 23);


  x = _mm_and_ps(x, p4f_inv_mant_mask);
  x = _mm_or_ps(x, p4f_half);

  emm0 = _mm_sub_epi32(emm0, p4i_0x7f);
  Packet4f e = padd(_mm_cvtepi32_ps(emm0), p4f_1);







  Packet4f mask = _mm_cmplt_ps(x, p4f_cephes_SQRTHF);
  Packet4f tmp = _mm_and_ps(x, mask);
  x = psub(x, p4f_1);
  e = psub(e, _mm_and_ps(p4f_1, mask));
  x = padd(x, tmp);

  Packet4f x2 = pmul(x,x);
  Packet4f x3 = pmul(x2,x);

  Packet4f y, y1, y2;
  y = pmadd(p4f_cephes_log_p0, x, p4f_cephes_log_p1);
  y1 = pmadd(p4f_cephes_log_p3, x, p4f_cephes_log_p4);
  y2 = pmadd(p4f_cephes_log_p6, x, p4f_cephes_log_p7);
  y = pmadd(y , x, p4f_cephes_log_p2);
  y1 = pmadd(y1, x, p4f_cephes_log_p5);
  y2 = pmadd(y2, x, p4f_cephes_log_p8);
  y = pmadd(y, x3, y1);
  y = pmadd(y, x3, y2);
  y = pmul(y, x3);

  y1 = pmul(e, p4f_cephes_log_q1);
  tmp = pmul(x2, p4f_half);
  y = padd(y, y1);
  x = psub(x, tmp);
  y2 = pmul(e, p4f_cephes_log_q2);
  x = padd(x, y);
  x = padd(x, y2);
  return _mm_or_ps(x, invalid_mask);
}

template<> inline __attribute__((unused))
Packet4f pexp<Packet4f>(const Packet4f& _x)
{
  Packet4f x = _x;
  const Packet4f p4f_1 = pset1<Packet4f>(1.0f);
  const Packet4f p4f_half = pset1<Packet4f>(0.5f);
  const Packet4i p4i_0x7f = pset1<Packet4i>(0x7f);


  const Packet4f p4f_exp_hi = pset1<Packet4f>(88.3762626647949f);
  const Packet4f p4f_exp_lo = pset1<Packet4f>(-88.3762626647949f);

  const Packet4f p4f_cephes_LOG2EF = pset1<Packet4f>(1.44269504088896341f);
  const Packet4f p4f_cephes_exp_C1 = pset1<Packet4f>(0.693359375f);
  const Packet4f p4f_cephes_exp_C2 = pset1<Packet4f>(-2.12194440e-4f);

  const Packet4f p4f_cephes_exp_p0 = pset1<Packet4f>(1.9875691500E-4f);
  const Packet4f p4f_cephes_exp_p1 = pset1<Packet4f>(1.3981999507E-3f);
  const Packet4f p4f_cephes_exp_p2 = pset1<Packet4f>(8.3334519073E-3f);
  const Packet4f p4f_cephes_exp_p3 = pset1<Packet4f>(4.1665795894E-2f);
  const Packet4f p4f_cephes_exp_p4 = pset1<Packet4f>(1.6666665459E-1f);
  const Packet4f p4f_cephes_exp_p5 = pset1<Packet4f>(5.0000001201E-1f);

  Packet4f tmp = _mm_setzero_ps(), fx;
  Packet4i emm0;


  x = pmax(pmin(x, p4f_exp_hi), p4f_exp_lo);


  fx = pmadd(x, p4f_cephes_LOG2EF, p4f_half);


  emm0 = _mm_cvttps_epi32(fx);
  tmp = _mm_cvtepi32_ps(emm0);

  Packet4f mask = _mm_cmpgt_ps(tmp, fx);
  mask = _mm_and_ps(mask, p4f_1);
  fx = psub(tmp, mask);

  tmp = pmul(fx, p4f_cephes_exp_C1);
  Packet4f z = pmul(fx, p4f_cephes_exp_C2);
  x = psub(x, tmp);
  x = psub(x, z);

  z = pmul(x,x);

  Packet4f y = p4f_cephes_exp_p0;
  y = pmadd(y, x, p4f_cephes_exp_p1);
  y = pmadd(y, x, p4f_cephes_exp_p2);
  y = pmadd(y, x, p4f_cephes_exp_p3);
  y = pmadd(y, x, p4f_cephes_exp_p4);
  y = pmadd(y, x, p4f_cephes_exp_p5);
  y = pmadd(y, z, x);
  y = padd(y, p4f_1);


  emm0 = _mm_cvttps_epi32(fx);
  emm0 = _mm_add_epi32(emm0, p4i_0x7f);
  emm0 = _mm_slli_epi32(emm0, 23);
  return pmul(y, _mm_castsi128_ps(emm0));
}
# 190 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/arch/SSE/MathFunctions.h"
template<> inline __attribute__((unused))
Packet4f psin<Packet4f>(const Packet4f& _x)
{
  Packet4f x = _x;
  const Packet4f p4f_1 = pset1<Packet4f>(1.0f);
  const Packet4f p4f_half = pset1<Packet4f>(0.5f);

  const Packet4i p4i_1 = pset1<Packet4i>(1);
  const Packet4i p4i_not1 = pset1<Packet4i>(~1);
  const Packet4i p4i_2 = pset1<Packet4i>(2);
  const Packet4i p4i_4 = pset1<Packet4i>(4);

  const Packet4f p4f_sign_mask = _mm_castsi128_ps(pset1<Packet4i>(0x80000000));

  const Packet4f p4f_minus_cephes_DP1 = pset1<Packet4f>(-0.78515625f);
  const Packet4f p4f_minus_cephes_DP2 = pset1<Packet4f>(-2.4187564849853515625e-4f);
  const Packet4f p4f_minus_cephes_DP3 = pset1<Packet4f>(-3.77489497744594108e-8f);
  const Packet4f p4f_sincof_p0 = pset1<Packet4f>(-1.9515295891E-4f);
  const Packet4f p4f_sincof_p1 = pset1<Packet4f>(8.3321608736E-3f);
  const Packet4f p4f_sincof_p2 = pset1<Packet4f>(-1.6666654611E-1f);
  const Packet4f p4f_coscof_p0 = pset1<Packet4f>(2.443315711809948E-005f);
  const Packet4f p4f_coscof_p1 = pset1<Packet4f>(-1.388731625493765E-003f);
  const Packet4f p4f_coscof_p2 = pset1<Packet4f>(4.166664568298827E-002f);
  const Packet4f p4f_cephes_FOPI = pset1<Packet4f>(1.27323954473516f);

  Packet4f xmm1, xmm2 = _mm_setzero_ps(), xmm3, sign_bit, y;

  Packet4i emm0, emm2;
  sign_bit = x;

  x = pabs(x);




  sign_bit = _mm_and_ps(sign_bit, p4f_sign_mask);


  y = pmul(x, p4f_cephes_FOPI);


  emm2 = _mm_cvttps_epi32(y);

  emm2 = _mm_add_epi32(emm2, p4i_1);
  emm2 = _mm_and_si128(emm2, p4i_not1);
  y = _mm_cvtepi32_ps(emm2);

  emm0 = _mm_and_si128(emm2, p4i_4);
  emm0 = _mm_slli_epi32(emm0, 29);






  emm2 = _mm_and_si128(emm2, p4i_2);
  emm2 = _mm_cmpeq_epi32(emm2, _mm_setzero_si128());

  Packet4f swap_sign_bit = _mm_castsi128_ps(emm0);
  Packet4f poly_mask = _mm_castsi128_ps(emm2);
  sign_bit = _mm_xor_ps(sign_bit, swap_sign_bit);



  xmm1 = pmul(y, p4f_minus_cephes_DP1);
  xmm2 = pmul(y, p4f_minus_cephes_DP2);
  xmm3 = pmul(y, p4f_minus_cephes_DP3);
  x = padd(x, xmm1);
  x = padd(x, xmm2);
  x = padd(x, xmm3);


  y = p4f_coscof_p0;
  Packet4f z = _mm_mul_ps(x,x);

  y = pmadd(y, z, p4f_coscof_p1);
  y = pmadd(y, z, p4f_coscof_p2);
  y = pmul(y, z);
  y = pmul(y, z);
  Packet4f tmp = pmul(z, p4f_half);
  y = psub(y, tmp);
  y = padd(y, p4f_1);



  Packet4f y2 = p4f_sincof_p0;
  y2 = pmadd(y2, z, p4f_sincof_p1);
  y2 = pmadd(y2, z, p4f_sincof_p2);
  y2 = pmul(y2, z);
  y2 = pmul(y2, x);
  y2 = padd(y2, x);


  y2 = _mm_and_ps(poly_mask, y2);
  y = _mm_andnot_ps(poly_mask, y);
  y = _mm_or_ps(y,y2);

  return _mm_xor_ps(y, sign_bit);
}


template<> inline __attribute__((unused))
Packet4f pcos<Packet4f>(const Packet4f& _x)
{
  Packet4f x = _x;
  const Packet4f p4f_1 = pset1<Packet4f>(1.0f);
  const Packet4f p4f_half = pset1<Packet4f>(0.5f);

  const Packet4i p4i_1 = pset1<Packet4i>(1);
  const Packet4i p4i_not1 = pset1<Packet4i>(~1);
  const Packet4i p4i_2 = pset1<Packet4i>(2);
  const Packet4i p4i_4 = pset1<Packet4i>(4);

  const Packet4f p4f_minus_cephes_DP1 = pset1<Packet4f>(-0.78515625f);
  const Packet4f p4f_minus_cephes_DP2 = pset1<Packet4f>(-2.4187564849853515625e-4f);
  const Packet4f p4f_minus_cephes_DP3 = pset1<Packet4f>(-3.77489497744594108e-8f);
  const Packet4f p4f_sincof_p0 = pset1<Packet4f>(-1.9515295891E-4f);
  const Packet4f p4f_sincof_p1 = pset1<Packet4f>(8.3321608736E-3f);
  const Packet4f p4f_sincof_p2 = pset1<Packet4f>(-1.6666654611E-1f);
  const Packet4f p4f_coscof_p0 = pset1<Packet4f>(2.443315711809948E-005f);
  const Packet4f p4f_coscof_p1 = pset1<Packet4f>(-1.388731625493765E-003f);
  const Packet4f p4f_coscof_p2 = pset1<Packet4f>(4.166664568298827E-002f);
  const Packet4f p4f_cephes_FOPI = pset1<Packet4f>(1.27323954473516f);

  Packet4f xmm1, xmm2 = _mm_setzero_ps(), xmm3, y;
  Packet4i emm0, emm2;

  x = pabs(x);


  y = pmul(x, p4f_cephes_FOPI);


  emm2 = _mm_cvttps_epi32(y);

  emm2 = _mm_add_epi32(emm2, p4i_1);
  emm2 = _mm_and_si128(emm2, p4i_not1);
  y = _mm_cvtepi32_ps(emm2);

  emm2 = _mm_sub_epi32(emm2, p4i_2);


  emm0 = _mm_andnot_si128(emm2, p4i_4);
  emm0 = _mm_slli_epi32(emm0, 29);

  emm2 = _mm_and_si128(emm2, p4i_2);
  emm2 = _mm_cmpeq_epi32(emm2, _mm_setzero_si128());

  Packet4f sign_bit = _mm_castsi128_ps(emm0);
  Packet4f poly_mask = _mm_castsi128_ps(emm2);



  xmm1 = pmul(y, p4f_minus_cephes_DP1);
  xmm2 = pmul(y, p4f_minus_cephes_DP2);
  xmm3 = pmul(y, p4f_minus_cephes_DP3);
  x = padd(x, xmm1);
  x = padd(x, xmm2);
  x = padd(x, xmm3);


  y = p4f_coscof_p0;
  Packet4f z = pmul(x,x);

  y = pmadd(y,z,p4f_coscof_p1);
  y = pmadd(y,z,p4f_coscof_p2);
  y = pmul(y, z);
  y = pmul(y, z);
  Packet4f tmp = _mm_mul_ps(z, p4f_half);
  y = psub(y, tmp);
  y = padd(y, p4f_1);


  Packet4f y2 = p4f_sincof_p0;
  y2 = pmadd(y2, z, p4f_sincof_p1);
  y2 = pmadd(y2, z, p4f_sincof_p2);
  y2 = pmul(y2, z);
  y2 = pmadd(y2, x, x);


  y2 = _mm_and_ps(poly_mask, y2);
  y = _mm_andnot_ps(poly_mask, y);
  y = _mm_or_ps(y,y2);


  return _mm_xor_ps(y, sign_bit);
}



template<> inline __attribute__((unused))
Packet4f psqrt<Packet4f>(const Packet4f& _x)
{
  Packet4f half = pmul(_x, pset1<Packet4f>(.5f));


  Packet4f non_zero_mask = _mm_cmpgt_ps(_x, pset1<Packet4f>(std::numeric_limits<float>::epsilon()));
  Packet4f x = _mm_and_ps(non_zero_mask, _mm_rsqrt_ps(_x));

  x = pmul(x, psub(pset1<Packet4f>(1.5f), pmul(half, pmul(x,x))));
  return pmul(_x,x);
}

}
# 264 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/arch/SSE/Complex.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/arch/SSE/Complex.h"
namespace internal {


struct Packet2cf
{
  inline Packet2cf() {}
  inline explicit Packet2cf(const __m128& a) : v(a) {}
  __m128 v;
};

template<> struct packet_traits<std::complex<float> > : default_packet_traits
{
  typedef Packet2cf type;
  enum {
    Vectorizable = 1,
    AlignedOnScalar = 1,
    size = 2,

    HasAdd = 1,
    HasSub = 1,
    HasMul = 1,
    HasDiv = 1,
    HasNegate = 1,
    HasAbs = 0,
    HasAbs2 = 0,
    HasMin = 0,
    HasMax = 0,
    HasSetLinear = 0
  };
};

template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };

template<> inline Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_add_ps(a.v,b.v)); }
template<> inline Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_sub_ps(a.v,b.v)); }
template<> inline Packet2cf pnegate(const Packet2cf& a)
{
  const __m128 mask = _mm_castsi128_ps(_mm_setr_epi32(0x80000000,0x80000000,0x80000000,0x80000000));
  return Packet2cf(_mm_xor_ps(a.v,mask));
}
template<> inline Packet2cf pconj(const Packet2cf& a)
{
  const __m128 mask = _mm_castsi128_ps(_mm_setr_epi32(0x00000000,0x80000000,0x00000000,0x80000000));
  return Packet2cf(_mm_xor_ps(a.v,mask));
}

template<> inline Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)
{
# 85 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/arch/SSE/Complex.h"
  const __m128 mask = _mm_castsi128_ps(_mm_setr_epi32(0x80000000,0x00000000,0x80000000,0x00000000));
  return Packet2cf(_mm_add_ps(_mm_mul_ps((_mm_castsi128_ps(((__m128i)__builtin_shufflevector((__v4si)(_mm_castps_si128(a.v)), (__v4si) _mm_set1_epi32(0), (((2)<<6|(2)<<4|(0)<<2|(0))) & 0x3, ((((2)<<6|(2)<<4|(0)<<2|(0))) & 0xc) >> 2, ((((2)<<6|(2)<<4|(0)<<2|(0))) & 0x30) >> 4, ((((2)<<6|(2)<<4|(0)<<2|(0))) & 0xc0) >> 6)))), b.v),
                              _mm_xor_ps(_mm_mul_ps((_mm_castsi128_ps(((__m128i)__builtin_shufflevector((__v4si)(_mm_castps_si128(a.v)), (__v4si) _mm_set1_epi32(0), (((3)<<6|(3)<<4|(1)<<2|(1))) & 0x3, ((((3)<<6|(3)<<4|(1)<<2|(1))) & 0xc) >> 2, ((((3)<<6|(3)<<4|(1)<<2|(1))) & 0x30) >> 4, ((((3)<<6|(3)<<4|(1)<<2|(1))) & 0xc0) >> 6)))),
                                                    (_mm_castsi128_ps(((__m128i)__builtin_shufflevector((__v4si)(_mm_castps_si128(b.v)), (__v4si) _mm_set1_epi32(0), (((2)<<6|(3)<<4|(0)<<2|(1))) & 0x3, ((((2)<<6|(3)<<4|(0)<<2|(1))) & 0xc) >> 2, ((((2)<<6|(3)<<4|(0)<<2|(1))) & 0x30) >> 4, ((((2)<<6|(3)<<4|(0)<<2|(1))) & 0xc0) >> 6))))), mask)));

}

template<> inline Packet2cf pand <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_and_ps(a.v,b.v)); }
template<> inline Packet2cf por <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_or_ps(a.v,b.v)); }
template<> inline Packet2cf pxor <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_xor_ps(a.v,b.v)); }
template<> inline Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_andnot_ps(a.v,b.v)); }

template<> inline Packet2cf pload <Packet2cf>(const std::complex<float>* from) { return Packet2cf(pload<Packet4f>(&real_ref(*from))); }
template<> inline Packet2cf ploadu<Packet2cf>(const std::complex<float>* from) { return Packet2cf(ploadu<Packet4f>(&real_ref(*from))); }

template<> inline Packet2cf pset1<Packet2cf>(const std::complex<float>& from)
{
  Packet2cf res;


  res.v = _mm_loadl_pi(_mm_set1_ps(0.0f), (const __m64*)&from);



  return Packet2cf(_mm_movelh_ps(res.v,res.v));
}

template<> inline Packet2cf ploaddup<Packet2cf>(const std::complex<float>* from) { return pset1<Packet2cf>(*from); }

template<> inline void pstore <std::complex<float> >(std::complex<float> * to, const Packet2cf& from) { pstore(&real_ref(*to), from.v); }
template<> inline void pstoreu<std::complex<float> >(std::complex<float> * to, const Packet2cf& from) { pstoreu(&real_ref(*to), from.v); }

template<> inline void prefetch<std::complex<float> >(const std::complex<float> * addr) { (__builtin_prefetch((void *)((const char*)(addr)), 0, 3)); }

template<> inline std::complex<float> pfirst<Packet2cf>(const Packet2cf& a)
{



  __attribute__((aligned(16))) std::complex<float> res[2];
  _mm_store_ps((float*)res, a.v);
  return res[0];





}

template<> inline Packet2cf preverse(const Packet2cf& a) { return Packet2cf(_mm_castpd_ps(preverse(_mm_castps_pd(a.v)))); }

template<> inline std::complex<float> predux<Packet2cf>(const Packet2cf& a)
{
  return pfirst(Packet2cf(_mm_add_ps(a.v, _mm_movehl_ps(a.v,a.v))));
}

template<> inline Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)
{
  return Packet2cf(_mm_add_ps(_mm_movelh_ps(vecs[0].v,vecs[1].v), _mm_movehl_ps(vecs[1].v,vecs[0].v)));
}

template<> inline std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)
{
  return pfirst(pmul(a, Packet2cf(_mm_movehl_ps(a.v,a.v))));
}

template<int Offset>
struct palign_impl<Offset,Packet2cf>
{
  inline static void run(Packet2cf& first, const Packet2cf& second)
  {
    if (Offset==1)
    {
      first.v = _mm_movehl_ps(first.v, first.v);
      first.v = _mm_movelh_ps(first.v, second.v);
    }
  }
};

template<> struct conj_helper<Packet2cf, Packet2cf, false,true>
{
  inline Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const
  { return padd(pmul(x,y),c); }

  inline Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const
  {



    const __m128 mask = _mm_castsi128_ps(_mm_setr_epi32(0x00000000,0x80000000,0x00000000,0x80000000));
    return Packet2cf(_mm_add_ps(_mm_xor_ps(_mm_mul_ps((_mm_castsi128_ps(((__m128i)__builtin_shufflevector((__v4si)(_mm_castps_si128(a.v)), (__v4si) _mm_set1_epi32(0), (((2)<<6|(2)<<4|(0)<<2|(0))) & 0x3, ((((2)<<6|(2)<<4|(0)<<2|(0))) & 0xc) >> 2, ((((2)<<6|(2)<<4|(0)<<2|(0))) & 0x30) >> 4, ((((2)<<6|(2)<<4|(0)<<2|(0))) & 0xc0) >> 6)))), b.v), mask),
                                _mm_mul_ps((_mm_castsi128_ps(((__m128i)__builtin_shufflevector((__v4si)(_mm_castps_si128(a.v)), (__v4si) _mm_set1_epi32(0), (((3)<<6|(3)<<4|(1)<<2|(1))) & 0x3, ((((3)<<6|(3)<<4|(1)<<2|(1))) & 0xc) >> 2, ((((3)<<6|(3)<<4|(1)<<2|(1))) & 0x30) >> 4, ((((3)<<6|(3)<<4|(1)<<2|(1))) & 0xc0) >> 6)))),
                                           (_mm_castsi128_ps(((__m128i)__builtin_shufflevector((__v4si)(_mm_castps_si128(b.v)), (__v4si) _mm_set1_epi32(0), (((2)<<6|(3)<<4|(0)<<2|(1))) & 0x3, ((((2)<<6|(3)<<4|(0)<<2|(1))) & 0xc) >> 2, ((((2)<<6|(3)<<4|(0)<<2|(1))) & 0x30) >> 4, ((((2)<<6|(3)<<4|(0)<<2|(1))) & 0xc0) >> 6)))))));

  }
};

template<> struct conj_helper<Packet2cf, Packet2cf, true,false>
{
  inline Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const
  { return padd(pmul(x,y),c); }

  inline Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const
  {



    const __m128 mask = _mm_castsi128_ps(_mm_setr_epi32(0x00000000,0x80000000,0x00000000,0x80000000));
    return Packet2cf(_mm_add_ps(_mm_mul_ps((_mm_castsi128_ps(((__m128i)__builtin_shufflevector((__v4si)(_mm_castps_si128(a.v)), (__v4si) _mm_set1_epi32(0), (((2)<<6|(2)<<4|(0)<<2|(0))) & 0x3, ((((2)<<6|(2)<<4|(0)<<2|(0))) & 0xc) >> 2, ((((2)<<6|(2)<<4|(0)<<2|(0))) & 0x30) >> 4, ((((2)<<6|(2)<<4|(0)<<2|(0))) & 0xc0) >> 6)))), b.v),
                                _mm_xor_ps(_mm_mul_ps((_mm_castsi128_ps(((__m128i)__builtin_shufflevector((__v4si)(_mm_castps_si128(a.v)), (__v4si) _mm_set1_epi32(0), (((3)<<6|(3)<<4|(1)<<2|(1))) & 0x3, ((((3)<<6|(3)<<4|(1)<<2|(1))) & 0xc) >> 2, ((((3)<<6|(3)<<4|(1)<<2|(1))) & 0x30) >> 4, ((((3)<<6|(3)<<4|(1)<<2|(1))) & 0xc0) >> 6)))),
                                                      (_mm_castsi128_ps(((__m128i)__builtin_shufflevector((__v4si)(_mm_castps_si128(b.v)), (__v4si) _mm_set1_epi32(0), (((2)<<6|(3)<<4|(0)<<2|(1))) & 0x3, ((((2)<<6|(3)<<4|(0)<<2|(1))) & 0xc) >> 2, ((((2)<<6|(3)<<4|(0)<<2|(1))) & 0x30) >> 4, ((((2)<<6|(3)<<4|(0)<<2|(1))) & 0xc0) >> 6))))), mask)));

  }
};

template<> struct conj_helper<Packet2cf, Packet2cf, true,true>
{
  inline Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const
  { return padd(pmul(x,y),c); }

  inline Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const
  {



    const __m128 mask = _mm_castsi128_ps(_mm_setr_epi32(0x00000000,0x80000000,0x00000000,0x80000000));
    return Packet2cf(_mm_sub_ps(_mm_xor_ps(_mm_mul_ps((_mm_castsi128_ps(((__m128i)__builtin_shufflevector((__v4si)(_mm_castps_si128(a.v)), (__v4si) _mm_set1_epi32(0), (((2)<<6|(2)<<4|(0)<<2|(0))) & 0x3, ((((2)<<6|(2)<<4|(0)<<2|(0))) & 0xc) >> 2, ((((2)<<6|(2)<<4|(0)<<2|(0))) & 0x30) >> 4, ((((2)<<6|(2)<<4|(0)<<2|(0))) & 0xc0) >> 6)))), b.v), mask),
                                _mm_mul_ps((_mm_castsi128_ps(((__m128i)__builtin_shufflevector((__v4si)(_mm_castps_si128(a.v)), (__v4si) _mm_set1_epi32(0), (((3)<<6|(3)<<4|(1)<<2|(1))) & 0x3, ((((3)<<6|(3)<<4|(1)<<2|(1))) & 0xc) >> 2, ((((3)<<6|(3)<<4|(1)<<2|(1))) & 0x30) >> 4, ((((3)<<6|(3)<<4|(1)<<2|(1))) & 0xc0) >> 6)))),
                                           (_mm_castsi128_ps(((__m128i)__builtin_shufflevector((__v4si)(_mm_castps_si128(b.v)), (__v4si) _mm_set1_epi32(0), (((2)<<6|(3)<<4|(0)<<2|(1))) & 0x3, ((((2)<<6|(3)<<4|(0)<<2|(1))) & 0xc) >> 2, ((((2)<<6|(3)<<4|(0)<<2|(1))) & 0x30) >> 4, ((((2)<<6|(3)<<4|(0)<<2|(1))) & 0xc0) >> 6)))))));

  }
};

template<> struct conj_helper<Packet4f, Packet2cf, false,false>
{
  inline Packet2cf pmadd(const Packet4f& x, const Packet2cf& y, const Packet2cf& c) const
  { return padd(c, pmul(x,y)); }

  inline Packet2cf pmul(const Packet4f& x, const Packet2cf& y) const
  { return Packet2cf(Eigen::internal::pmul(x, y.v)); }
};

template<> struct conj_helper<Packet2cf, Packet4f, false,false>
{
  inline Packet2cf pmadd(const Packet2cf& x, const Packet4f& y, const Packet2cf& c) const
  { return padd(c, pmul(x,y)); }

  inline Packet2cf pmul(const Packet2cf& x, const Packet4f& y) const
  { return Packet2cf(Eigen::internal::pmul(x.v, y)); }
};

template<> inline Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)
{

  Packet2cf res = conj_helper<Packet2cf,Packet2cf,false,true>().pmul(a,b);
  __m128 s = _mm_mul_ps(b.v,b.v);
  return Packet2cf(_mm_div_ps(res.v,_mm_add_ps(s,_mm_castsi128_ps(((__m128i)__builtin_shufflevector((__v4si)(_mm_castps_si128(s)), (__v4si) _mm_set1_epi32(0), (0xb1) & 0x3, ((0xb1) & 0xc) >> 2, ((0xb1) & 0x30) >> 4, ((0xb1) & 0xc0) >> 6))))));
}

inline Packet2cf pcplxflip (const Packet2cf& x)
{
  return Packet2cf((_mm_castsi128_ps(((__m128i)__builtin_shufflevector((__v4si)(_mm_castps_si128(x.v)), (__v4si) _mm_set1_epi32(0), (((2)<<6|(3)<<4|(0)<<2|(1))) & 0x3, ((((2)<<6|(3)<<4|(0)<<2|(1))) & 0xc) >> 2, ((((2)<<6|(3)<<4|(0)<<2|(1))) & 0x30) >> 4, ((((2)<<6|(3)<<4|(0)<<2|(1))) & 0xc0) >> 6)))));
}



struct Packet1cd
{
  inline Packet1cd() {}
  inline explicit Packet1cd(const __m128d& a) : v(a) {}
  __m128d v;
};

template<> struct packet_traits<std::complex<double> > : default_packet_traits
{
  typedef Packet1cd type;
  enum {
    Vectorizable = 1,
    AlignedOnScalar = 0,
    size = 1,

    HasAdd = 1,
    HasSub = 1,
    HasMul = 1,
    HasDiv = 1,
    HasNegate = 1,
    HasAbs = 0,
    HasAbs2 = 0,
    HasMin = 0,
    HasMax = 0,
    HasSetLinear = 0
  };
};

template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1}; };

template<> inline Packet1cd padd<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_add_pd(a.v,b.v)); }
template<> inline Packet1cd psub<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_sub_pd(a.v,b.v)); }
template<> inline Packet1cd pnegate(const Packet1cd& a) { return Packet1cd(pnegate(a.v)); }
template<> inline Packet1cd pconj(const Packet1cd& a)
{
  const __m128d mask = _mm_castsi128_pd(_mm_set_epi32(0x80000000,0x0,0x0,0x0));
  return Packet1cd(_mm_xor_pd(a.v,mask));
}

template<> inline Packet1cd pmul<Packet1cd>(const Packet1cd& a, const Packet1cd& b)
{






  const __m128d mask = _mm_castsi128_pd(_mm_set_epi32(0x0,0x0,0x80000000,0x0));
  return Packet1cd(_mm_add_pd(_mm_mul_pd((_mm_castsi128_pd(((__m128i)__builtin_shufflevector((__v4si)(_mm_castpd_si128(a.v)), (__v4si) _mm_set1_epi32(0), (((0*2 +1)<<6|(0*2)<<4|(0*2 +1)<<2|(0*2))) & 0x3, ((((0*2 +1)<<6|(0*2)<<4|(0*2 +1)<<2|(0*2))) & 0xc) >> 2, ((((0*2 +1)<<6|(0*2)<<4|(0*2 +1)<<2|(0*2))) & 0x30) >> 4, ((((0*2 +1)<<6|(0*2)<<4|(0*2 +1)<<2|(0*2))) & 0xc0) >> 6)))), b.v),
                              _mm_xor_pd(_mm_mul_pd((_mm_castsi128_pd(((__m128i)__builtin_shufflevector((__v4si)(_mm_castpd_si128(a.v)), (__v4si) _mm_set1_epi32(0), (((1*2 +1)<<6|(1*2)<<4|(1*2 +1)<<2|(1*2))) & 0x3, ((((1*2 +1)<<6|(1*2)<<4|(1*2 +1)<<2|(1*2))) & 0xc) >> 2, ((((1*2 +1)<<6|(1*2)<<4|(1*2 +1)<<2|(1*2))) & 0x30) >> 4, ((((1*2 +1)<<6|(1*2)<<4|(1*2 +1)<<2|(1*2))) & 0xc0) >> 6)))),
                                                    (_mm_castsi128_pd(((__m128i)__builtin_shufflevector((__v4si)(_mm_castpd_si128(b.v)), (__v4si) _mm_set1_epi32(0), (((0*2 +1)<<6|(0*2)<<4|(1*2 +1)<<2|(1*2))) & 0x3, ((((0*2 +1)<<6|(0*2)<<4|(1*2 +1)<<2|(1*2))) & 0xc) >> 2, ((((0*2 +1)<<6|(0*2)<<4|(1*2 +1)<<2|(1*2))) & 0x30) >> 4, ((((0*2 +1)<<6|(0*2)<<4|(1*2 +1)<<2|(1*2))) & 0xc0) >> 6))))), mask)));

}

template<> inline Packet1cd pand <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_and_pd(a.v,b.v)); }
template<> inline Packet1cd por <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_or_pd(a.v,b.v)); }
template<> inline Packet1cd pxor <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_xor_pd(a.v,b.v)); }
template<> inline Packet1cd pandnot<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_andnot_pd(a.v,b.v)); }


template<> inline Packet1cd pload <Packet1cd>(const std::complex<double>* from)
{ return Packet1cd(pload<Packet2d>((const double*)from)); }
template<> inline Packet1cd ploadu<Packet1cd>(const std::complex<double>* from)
{ return Packet1cd(ploadu<Packet2d>((const double*)from)); }
template<> inline Packet1cd pset1<Packet1cd>(const std::complex<double>& from)
{ return ploadu<Packet1cd>(&from); }

template<> inline Packet1cd ploaddup<Packet1cd>(const std::complex<double>* from) { return pset1<Packet1cd>(*from); }


template<> inline void pstore <std::complex<double> >(std::complex<double> * to, const Packet1cd& from) { pstore((double*)to, from.v); }
template<> inline void pstoreu<std::complex<double> >(std::complex<double> * to, const Packet1cd& from) { pstoreu((double*)to, from.v); }

template<> inline void prefetch<std::complex<double> >(const std::complex<double> * addr) { (__builtin_prefetch((void *)((const char*)(addr)), 0, 3)); }

template<> inline std::complex<double> pfirst<Packet1cd>(const Packet1cd& a)
{
  __attribute__((aligned(16))) double res[2];
  _mm_store_pd(res, a.v);
  return std::complex<double>(res[0],res[1]);
}

template<> inline Packet1cd preverse(const Packet1cd& a) { return a; }

template<> inline std::complex<double> predux<Packet1cd>(const Packet1cd& a)
{
  return pfirst(a);
}

template<> inline Packet1cd preduxp<Packet1cd>(const Packet1cd* vecs)
{
  return vecs[0];
}

template<> inline std::complex<double> predux_mul<Packet1cd>(const Packet1cd& a)
{
  return pfirst(a);
}

template<int Offset>
struct palign_impl<Offset,Packet1cd>
{
  inline static void run(Packet1cd& , const Packet1cd& )
  {


  }
};

template<> struct conj_helper<Packet1cd, Packet1cd, false,true>
{
  inline Packet1cd pmadd(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const
  { return padd(pmul(x,y),c); }

  inline Packet1cd pmul(const Packet1cd& a, const Packet1cd& b) const
  {



    const __m128d mask = _mm_castsi128_pd(_mm_set_epi32(0x80000000,0x0,0x0,0x0));
    return Packet1cd(_mm_add_pd(_mm_xor_pd(_mm_mul_pd((_mm_castsi128_pd(((__m128i)__builtin_shufflevector((__v4si)(_mm_castpd_si128(a.v)), (__v4si) _mm_set1_epi32(0), (((0*2 +1)<<6|(0*2)<<4|(0*2 +1)<<2|(0*2))) & 0x3, ((((0*2 +1)<<6|(0*2)<<4|(0*2 +1)<<2|(0*2))) & 0xc) >> 2, ((((0*2 +1)<<6|(0*2)<<4|(0*2 +1)<<2|(0*2))) & 0x30) >> 4, ((((0*2 +1)<<6|(0*2)<<4|(0*2 +1)<<2|(0*2))) & 0xc0) >> 6)))), b.v), mask),
                                _mm_mul_pd((_mm_castsi128_pd(((__m128i)__builtin_shufflevector((__v4si)(_mm_castpd_si128(a.v)), (__v4si) _mm_set1_epi32(0), (((1*2 +1)<<6|(1*2)<<4|(1*2 +1)<<2|(1*2))) & 0x3, ((((1*2 +1)<<6|(1*2)<<4|(1*2 +1)<<2|(1*2))) & 0xc) >> 2, ((((1*2 +1)<<6|(1*2)<<4|(1*2 +1)<<2|(1*2))) & 0x30) >> 4, ((((1*2 +1)<<6|(1*2)<<4|(1*2 +1)<<2|(1*2))) & 0xc0) >> 6)))),
                                           (_mm_castsi128_pd(((__m128i)__builtin_shufflevector((__v4si)(_mm_castpd_si128(b.v)), (__v4si) _mm_set1_epi32(0), (((0*2 +1)<<6|(0*2)<<4|(1*2 +1)<<2|(1*2))) & 0x3, ((((0*2 +1)<<6|(0*2)<<4|(1*2 +1)<<2|(1*2))) & 0xc) >> 2, ((((0*2 +1)<<6|(0*2)<<4|(1*2 +1)<<2|(1*2))) & 0x30) >> 4, ((((0*2 +1)<<6|(0*2)<<4|(1*2 +1)<<2|(1*2))) & 0xc0) >> 6)))))));

  }
};

template<> struct conj_helper<Packet1cd, Packet1cd, true,false>
{
  inline Packet1cd pmadd(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const
  { return padd(pmul(x,y),c); }

  inline Packet1cd pmul(const Packet1cd& a, const Packet1cd& b) const
  {



    const __m128d mask = _mm_castsi128_pd(_mm_set_epi32(0x80000000,0x0,0x0,0x0));
    return Packet1cd(_mm_add_pd(_mm_mul_pd((_mm_castsi128_pd(((__m128i)__builtin_shufflevector((__v4si)(_mm_castpd_si128(a.v)), (__v4si) _mm_set1_epi32(0), (((0*2 +1)<<6|(0*2)<<4|(0*2 +1)<<2|(0*2))) & 0x3, ((((0*2 +1)<<6|(0*2)<<4|(0*2 +1)<<2|(0*2))) & 0xc) >> 2, ((((0*2 +1)<<6|(0*2)<<4|(0*2 +1)<<2|(0*2))) & 0x30) >> 4, ((((0*2 +1)<<6|(0*2)<<4|(0*2 +1)<<2|(0*2))) & 0xc0) >> 6)))), b.v),
                                _mm_xor_pd(_mm_mul_pd((_mm_castsi128_pd(((__m128i)__builtin_shufflevector((__v4si)(_mm_castpd_si128(a.v)), (__v4si) _mm_set1_epi32(0), (((1*2 +1)<<6|(1*2)<<4|(1*2 +1)<<2|(1*2))) & 0x3, ((((1*2 +1)<<6|(1*2)<<4|(1*2 +1)<<2|(1*2))) & 0xc) >> 2, ((((1*2 +1)<<6|(1*2)<<4|(1*2 +1)<<2|(1*2))) & 0x30) >> 4, ((((1*2 +1)<<6|(1*2)<<4|(1*2 +1)<<2|(1*2))) & 0xc0) >> 6)))),
                                                      (_mm_castsi128_pd(((__m128i)__builtin_shufflevector((__v4si)(_mm_castpd_si128(b.v)), (__v4si) _mm_set1_epi32(0), (((0*2 +1)<<6|(0*2)<<4|(1*2 +1)<<2|(1*2))) & 0x3, ((((0*2 +1)<<6|(0*2)<<4|(1*2 +1)<<2|(1*2))) & 0xc) >> 2, ((((0*2 +1)<<6|(0*2)<<4|(1*2 +1)<<2|(1*2))) & 0x30) >> 4, ((((0*2 +1)<<6|(0*2)<<4|(1*2 +1)<<2|(1*2))) & 0xc0) >> 6))))), mask)));

  }
};

template<> struct conj_helper<Packet1cd, Packet1cd, true,true>
{
  inline Packet1cd pmadd(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const
  { return padd(pmul(x,y),c); }

  inline Packet1cd pmul(const Packet1cd& a, const Packet1cd& b) const
  {



    const __m128d mask = _mm_castsi128_pd(_mm_set_epi32(0x80000000,0x0,0x0,0x0));
    return Packet1cd(_mm_sub_pd(_mm_xor_pd(_mm_mul_pd((_mm_castsi128_pd(((__m128i)__builtin_shufflevector((__v4si)(_mm_castpd_si128(a.v)), (__v4si) _mm_set1_epi32(0), (((0*2 +1)<<6|(0*2)<<4|(0*2 +1)<<2|(0*2))) & 0x3, ((((0*2 +1)<<6|(0*2)<<4|(0*2 +1)<<2|(0*2))) & 0xc) >> 2, ((((0*2 +1)<<6|(0*2)<<4|(0*2 +1)<<2|(0*2))) & 0x30) >> 4, ((((0*2 +1)<<6|(0*2)<<4|(0*2 +1)<<2|(0*2))) & 0xc0) >> 6)))), b.v), mask),
                                _mm_mul_pd((_mm_castsi128_pd(((__m128i)__builtin_shufflevector((__v4si)(_mm_castpd_si128(a.v)), (__v4si) _mm_set1_epi32(0), (((1*2 +1)<<6|(1*2)<<4|(1*2 +1)<<2|(1*2))) & 0x3, ((((1*2 +1)<<6|(1*2)<<4|(1*2 +1)<<2|(1*2))) & 0xc) >> 2, ((((1*2 +1)<<6|(1*2)<<4|(1*2 +1)<<2|(1*2))) & 0x30) >> 4, ((((1*2 +1)<<6|(1*2)<<4|(1*2 +1)<<2|(1*2))) & 0xc0) >> 6)))),
                                           (_mm_castsi128_pd(((__m128i)__builtin_shufflevector((__v4si)(_mm_castpd_si128(b.v)), (__v4si) _mm_set1_epi32(0), (((0*2 +1)<<6|(0*2)<<4|(1*2 +1)<<2|(1*2))) & 0x3, ((((0*2 +1)<<6|(0*2)<<4|(1*2 +1)<<2|(1*2))) & 0xc) >> 2, ((((0*2 +1)<<6|(0*2)<<4|(1*2 +1)<<2|(1*2))) & 0x30) >> 4, ((((0*2 +1)<<6|(0*2)<<4|(1*2 +1)<<2|(1*2))) & 0xc0) >> 6)))))));

  }
};

template<> struct conj_helper<Packet2d, Packet1cd, false,false>
{
  inline Packet1cd pmadd(const Packet2d& x, const Packet1cd& y, const Packet1cd& c) const
  { return padd(c, pmul(x,y)); }

  inline Packet1cd pmul(const Packet2d& x, const Packet1cd& y) const
  { return Packet1cd(Eigen::internal::pmul(x, y.v)); }
};

template<> struct conj_helper<Packet1cd, Packet2d, false,false>
{
  inline Packet1cd pmadd(const Packet1cd& x, const Packet2d& y, const Packet1cd& c) const
  { return padd(c, pmul(x,y)); }

  inline Packet1cd pmul(const Packet1cd& x, const Packet2d& y) const
  { return Packet1cd(Eigen::internal::pmul(x.v, y)); }
};

template<> inline Packet1cd pdiv<Packet1cd>(const Packet1cd& a, const Packet1cd& b)
{

  Packet1cd res = conj_helper<Packet1cd,Packet1cd,false,true>().pmul(a,b);
  __m128d s = _mm_mul_pd(b.v,b.v);
  return Packet1cd(_mm_div_pd(res.v, _mm_add_pd(s,(__builtin_shufflevector((__m128d)(s), (__m128d)(s), (0x1) & 1, (((0x1) & 2) >> 1) + 2)))));
}

inline Packet1cd pcplxflip (const Packet1cd& x)
{
  return Packet1cd(preverse(x.v));
}

}
# 265 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2








# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/arch/Default/Settings.h" 1
# 274 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2

# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Functors.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Functors.h"
namespace internal {
# 37 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Functors.h"
template<typename Scalar> struct scalar_sum_op {
  inline scalar_sum_op() {} inline scalar_sum_op(const scalar_sum_op& ) {}
  inline const Scalar operator() (const Scalar& a, const Scalar& b) const { return a + b; }
  template<typename Packet>
  inline const Packet packetOp(const Packet& a, const Packet& b) const
  { return internal::padd(a,b); }
  template<typename Packet>
  inline const Scalar predux(const Packet& a) const
  { return internal::predux(a); }
};
template<typename Scalar>
struct functor_traits<scalar_sum_op<Scalar> > {
  enum {
    Cost = NumTraits<Scalar>::AddCost,
    PacketAccess = packet_traits<Scalar>::HasAdd
  };
};






template<typename LhsScalar,typename RhsScalar> struct scalar_product_op {
  enum {

    Vectorizable = is_same<LhsScalar,RhsScalar>::value && packet_traits<LhsScalar>::HasMul && packet_traits<RhsScalar>::HasMul
  };
  typedef typename scalar_product_traits<LhsScalar,RhsScalar>::ReturnType result_type;
  inline scalar_product_op() {} inline scalar_product_op(const scalar_product_op& ) {}
  inline const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return a * b; }
  template<typename Packet>
  inline const Packet packetOp(const Packet& a, const Packet& b) const
  { return internal::pmul(a,b); }
  template<typename Packet>
  inline const result_type predux(const Packet& a) const
  { return internal::predux_mul(a); }
};
template<typename LhsScalar,typename RhsScalar>
struct functor_traits<scalar_product_op<LhsScalar,RhsScalar> > {
  enum {
    Cost = (NumTraits<LhsScalar>::MulCost + NumTraits<RhsScalar>::MulCost)/2,
    PacketAccess = scalar_product_op<LhsScalar,RhsScalar>::Vectorizable
  };
};






template<typename LhsScalar,typename RhsScalar> struct scalar_conj_product_op {

  enum {
    Conj = NumTraits<LhsScalar>::IsComplex
  };

  typedef typename scalar_product_traits<LhsScalar,RhsScalar>::ReturnType result_type;

  inline scalar_conj_product_op() {} inline scalar_conj_product_op(const scalar_conj_product_op& ) {}
  inline const result_type operator() (const LhsScalar& a, const RhsScalar& b) const
  { return conj_helper<LhsScalar,RhsScalar,Conj,false>().pmul(a,b); }

  template<typename Packet>
  inline const Packet packetOp(const Packet& a, const Packet& b) const
  { return conj_helper<Packet,Packet,Conj,false>().pmul(a,b); }
};
template<typename LhsScalar,typename RhsScalar>
struct functor_traits<scalar_conj_product_op<LhsScalar,RhsScalar> > {
  enum {
    Cost = NumTraits<LhsScalar>::MulCost,
    PacketAccess = internal::is_same<LhsScalar, RhsScalar>::value && packet_traits<LhsScalar>::HasMul
  };
};






template<typename Scalar> struct scalar_min_op {
  inline scalar_min_op() {} inline scalar_min_op(const scalar_min_op& ) {}
  inline const Scalar operator() (const Scalar& a, const Scalar& b) const { using std::min; return (min)(a, b); }
  template<typename Packet>
  inline const Packet packetOp(const Packet& a, const Packet& b) const
  { return internal::pmin(a,b); }
  template<typename Packet>
  inline const Scalar predux(const Packet& a) const
  { return internal::predux_min(a); }
};
template<typename Scalar>
struct functor_traits<scalar_min_op<Scalar> > {
  enum {
    Cost = NumTraits<Scalar>::AddCost,
    PacketAccess = packet_traits<Scalar>::HasMin
  };
};






template<typename Scalar> struct scalar_max_op {
  inline scalar_max_op() {} inline scalar_max_op(const scalar_max_op& ) {}
  inline const Scalar operator() (const Scalar& a, const Scalar& b) const { using std::max; return (max)(a, b); }
  template<typename Packet>
  inline const Packet packetOp(const Packet& a, const Packet& b) const
  { return internal::pmax(a,b); }
  template<typename Packet>
  inline const Scalar predux(const Packet& a) const
  { return internal::predux_max(a); }
};
template<typename Scalar>
struct functor_traits<scalar_max_op<Scalar> > {
  enum {
    Cost = NumTraits<Scalar>::AddCost,
    PacketAccess = packet_traits<Scalar>::HasMax
  };
};






template<typename Scalar> struct scalar_hypot_op {
  inline scalar_hypot_op() {} inline scalar_hypot_op(const scalar_hypot_op& ) {}

  inline const Scalar operator() (const Scalar& _x, const Scalar& _y) const
  {
    using std::max;
    using std::min;
    Scalar p = (max)(_x, _y);
    Scalar q = (min)(_x, _y);
    Scalar qp = q/p;
    return p * sqrt(Scalar(1) + qp*qp);
  }
};
template<typename Scalar>
struct functor_traits<scalar_hypot_op<Scalar> > {
  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess=0 };
};
# 188 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Functors.h"
template<typename Scalar> struct scalar_difference_op {
  inline scalar_difference_op() {} inline scalar_difference_op(const scalar_difference_op& ) {}
  inline const Scalar operator() (const Scalar& a, const Scalar& b) const { return a - b; }
  template<typename Packet>
  inline const Packet packetOp(const Packet& a, const Packet& b) const
  { return internal::psub(a,b); }
};
template<typename Scalar>
struct functor_traits<scalar_difference_op<Scalar> > {
  enum {
    Cost = NumTraits<Scalar>::AddCost,
    PacketAccess = packet_traits<Scalar>::HasSub
  };
};






template<typename Scalar> struct scalar_quotient_op {
  inline scalar_quotient_op() {} inline scalar_quotient_op(const scalar_quotient_op& ) {}
  inline const Scalar operator() (const Scalar& a, const Scalar& b) const { return a / b; }
  template<typename Packet>
  inline const Packet packetOp(const Packet& a, const Packet& b) const
  { return internal::pdiv(a,b); }
};
template<typename Scalar>
struct functor_traits<scalar_quotient_op<Scalar> > {
  enum {
    Cost = 2 * NumTraits<Scalar>::MulCost,
    PacketAccess = packet_traits<Scalar>::HasDiv
  };
};
# 230 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Functors.h"
template<typename Scalar> struct scalar_opposite_op {
  inline scalar_opposite_op() {} inline scalar_opposite_op(const scalar_opposite_op& ) {}
  inline const Scalar operator() (const Scalar& a) const { return -a; }
  template<typename Packet>
  inline const Packet packetOp(const Packet& a) const
  { return internal::pnegate(a); }
};
template<typename Scalar>
struct functor_traits<scalar_opposite_op<Scalar> >
{ enum {
    Cost = NumTraits<Scalar>::AddCost,
    PacketAccess = packet_traits<Scalar>::HasNegate };
};






template<typename Scalar> struct scalar_abs_op {
  inline scalar_abs_op() {} inline scalar_abs_op(const scalar_abs_op& ) {}
  typedef typename NumTraits<Scalar>::Real result_type;
  inline const result_type operator() (const Scalar& a) const { return abs(a); }
  template<typename Packet>
  inline const Packet packetOp(const Packet& a) const
  { return internal::pabs(a); }
};
template<typename Scalar>
struct functor_traits<scalar_abs_op<Scalar> >
{
  enum {
    Cost = NumTraits<Scalar>::AddCost,
    PacketAccess = packet_traits<Scalar>::HasAbs
  };
};






template<typename Scalar> struct scalar_abs2_op {
  inline scalar_abs2_op() {} inline scalar_abs2_op(const scalar_abs2_op& ) {}
  typedef typename NumTraits<Scalar>::Real result_type;
  inline const result_type operator() (const Scalar& a) const { return abs2(a); }
  template<typename Packet>
  inline const Packet packetOp(const Packet& a) const
  { return internal::pmul(a,a); }
};
template<typename Scalar>
struct functor_traits<scalar_abs2_op<Scalar> >
{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasAbs2 }; };






template<typename Scalar> struct scalar_conjugate_op {
  inline scalar_conjugate_op() {} inline scalar_conjugate_op(const scalar_conjugate_op& ) {}
  inline const Scalar operator() (const Scalar& a) const { return conj(a); }
  template<typename Packet>
  inline const Packet packetOp(const Packet& a) const { return internal::pconj(a); }
};
template<typename Scalar>
struct functor_traits<scalar_conjugate_op<Scalar> >
{
  enum {
    Cost = NumTraits<Scalar>::IsComplex ? NumTraits<Scalar>::AddCost : 0,
    PacketAccess = packet_traits<Scalar>::HasConj
  };
};






template<typename Scalar, typename NewType>
struct scalar_cast_op {
  inline scalar_cast_op() {} inline scalar_cast_op(const scalar_cast_op& ) {}
  typedef NewType result_type;
  inline const NewType operator() (const Scalar& a) const { return cast<Scalar, NewType>(a); }
};
template<typename Scalar, typename NewType>
struct functor_traits<scalar_cast_op<Scalar,NewType> >
{ enum { Cost = is_same<Scalar, NewType>::value ? 0 : NumTraits<NewType>::AddCost, PacketAccess = false }; };






template<typename Scalar>
struct scalar_real_op {
  inline scalar_real_op() {} inline scalar_real_op(const scalar_real_op& ) {}
  typedef typename NumTraits<Scalar>::Real result_type;
  inline result_type operator() (const Scalar& a) const { return real(a); }
};
template<typename Scalar>
struct functor_traits<scalar_real_op<Scalar> >
{ enum { Cost = 0, PacketAccess = false }; };






template<typename Scalar>
struct scalar_imag_op {
  inline scalar_imag_op() {} inline scalar_imag_op(const scalar_imag_op& ) {}
  typedef typename NumTraits<Scalar>::Real result_type;
  inline result_type operator() (const Scalar& a) const { return imag(a); }
};
template<typename Scalar>
struct functor_traits<scalar_imag_op<Scalar> >
{ enum { Cost = 0, PacketAccess = false }; };






template<typename Scalar>
struct scalar_real_ref_op {
  inline scalar_real_ref_op() {} inline scalar_real_ref_op(const scalar_real_ref_op& ) {}
  typedef typename NumTraits<Scalar>::Real result_type;
  inline result_type& operator() (const Scalar& a) const { return real_ref(*const_cast<Scalar*>(&a)); }
};
template<typename Scalar>
struct functor_traits<scalar_real_ref_op<Scalar> >
{ enum { Cost = 0, PacketAccess = false }; };






template<typename Scalar>
struct scalar_imag_ref_op {
  inline scalar_imag_ref_op() {} inline scalar_imag_ref_op(const scalar_imag_ref_op& ) {}
  typedef typename NumTraits<Scalar>::Real result_type;
  inline result_type& operator() (const Scalar& a) const { return imag_ref(*const_cast<Scalar*>(&a)); }
};
template<typename Scalar>
struct functor_traits<scalar_imag_ref_op<Scalar> >
{ enum { Cost = 0, PacketAccess = false }; };







template<typename Scalar> struct scalar_exp_op {
  inline scalar_exp_op() {} inline scalar_exp_op(const scalar_exp_op& ) {}
  inline const Scalar operator() (const Scalar& a) const { return exp(a); }
  typedef typename packet_traits<Scalar>::type Packet;
  inline Packet packetOp(const Packet& a) const { return internal::pexp(a); }
};
template<typename Scalar>
struct functor_traits<scalar_exp_op<Scalar> >
{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasExp }; };







template<typename Scalar> struct scalar_log_op {
  inline scalar_log_op() {} inline scalar_log_op(const scalar_log_op& ) {}
  inline const Scalar operator() (const Scalar& a) const { return log(a); }
  typedef typename packet_traits<Scalar>::type Packet;
  inline Packet packetOp(const Packet& a) const { return internal::plog(a); }
};
template<typename Scalar>
struct functor_traits<scalar_log_op<Scalar> >
{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasLog }; };
# 423 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Functors.h"
template<typename Scalar>
struct scalar_multiple_op {
  typedef typename packet_traits<Scalar>::type Packet;

  inline scalar_multiple_op(const scalar_multiple_op& other) : m_other(other.m_other) { }
  inline scalar_multiple_op(const Scalar& other) : m_other(other) { }
  inline Scalar operator() (const Scalar& a) const { return a * m_other; }
  inline const Packet packetOp(const Packet& a) const
  { return internal::pmul(a, pset1<Packet>(m_other)); }
  typename add_const_on_value_type<typename NumTraits<Scalar>::Nested>::type m_other;
};
template<typename Scalar>
struct functor_traits<scalar_multiple_op<Scalar> >
{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };

template<typename Scalar1, typename Scalar2>
struct scalar_multiple2_op {
  typedef typename scalar_product_traits<Scalar1,Scalar2>::ReturnType result_type;
  inline scalar_multiple2_op(const scalar_multiple2_op& other) : m_other(other.m_other) { }
  inline scalar_multiple2_op(const Scalar2& other) : m_other(other) { }
  inline result_type operator() (const Scalar1& a) const { return a * m_other; }
  typename add_const_on_value_type<typename NumTraits<Scalar2>::Nested>::type m_other;
};
template<typename Scalar1,typename Scalar2>
struct functor_traits<scalar_multiple2_op<Scalar1,Scalar2> >
{ enum { Cost = NumTraits<Scalar1>::MulCost, PacketAccess = false }; };

template<typename Scalar, bool IsInteger>
struct scalar_quotient1_impl {
  typedef typename packet_traits<Scalar>::type Packet;

  inline scalar_quotient1_impl(const scalar_quotient1_impl& other) : m_other(other.m_other) { }
  inline scalar_quotient1_impl(const Scalar& other) : m_other(static_cast<Scalar>(1) / other) {}
  inline Scalar operator() (const Scalar& a) const { return a * m_other; }
  inline const Packet packetOp(const Packet& a) const
  { return internal::pmul(a, pset1<Packet>(m_other)); }
  const Scalar m_other;
};
template<typename Scalar>
struct functor_traits<scalar_quotient1_impl<Scalar,false> >
{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };

template<typename Scalar>
struct scalar_quotient1_impl<Scalar,true> {

  inline scalar_quotient1_impl(const scalar_quotient1_impl& other) : m_other(other.m_other) { }
  inline scalar_quotient1_impl(const Scalar& other) : m_other(other) {}
  inline Scalar operator() (const Scalar& a) const { return a / m_other; }
  typename add_const_on_value_type<typename NumTraits<Scalar>::Nested>::type m_other;
};
template<typename Scalar>
struct functor_traits<scalar_quotient1_impl<Scalar,true> >
{ enum { Cost = 2 * NumTraits<Scalar>::MulCost, PacketAccess = false }; };
# 485 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Functors.h"
template<typename Scalar>
struct scalar_quotient1_op : scalar_quotient1_impl<Scalar, NumTraits<Scalar>::IsInteger > {
  inline scalar_quotient1_op(const Scalar& other)
    : scalar_quotient1_impl<Scalar, NumTraits<Scalar>::IsInteger >(other) {}
};
template<typename Scalar>
struct functor_traits<scalar_quotient1_op<Scalar> >
: functor_traits<scalar_quotient1_impl<Scalar, NumTraits<Scalar>::IsInteger> >
{};



template<typename Scalar>
struct scalar_constant_op {
  typedef typename packet_traits<Scalar>::type Packet;
  inline scalar_constant_op(const scalar_constant_op& other) : m_other(other.m_other) { }
  inline scalar_constant_op(const Scalar& other) : m_other(other) { }
  template<typename Index>
  inline const Scalar operator() (Index, Index = 0) const { return m_other; }
  template<typename Index>
  inline const Packet packetOp(Index, Index = 0) const { return internal::pset1<Packet>(m_other); }
  const Scalar m_other;
};
template<typename Scalar>
struct functor_traits<scalar_constant_op<Scalar> >

{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::Vectorizable, IsRepeatable = true }; };

template<typename Scalar> struct scalar_identity_op {
  inline scalar_identity_op() {} inline scalar_identity_op(const scalar_identity_op& ) {}
  template<typename Index>
  inline const Scalar operator() (Index row, Index col) const { return row==col ? Scalar(1) : Scalar(0); }
};
template<typename Scalar>
struct functor_traits<scalar_identity_op<Scalar> >
{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = false, IsRepeatable = true }; };

template <typename Scalar, bool RandomAccess> struct linspaced_op_impl;






template <typename Scalar>
struct linspaced_op_impl<Scalar,false>
{
  typedef typename packet_traits<Scalar>::type Packet;

  linspaced_op_impl(Scalar low, Scalar step) :
  m_low(low), m_step(step),
  m_packetStep(pset1<Packet>(packet_traits<Scalar>::size*step)),
  m_base(padd(pset1<Packet>(low),pmul(pset1<Packet>(step),plset<Scalar>(-packet_traits<Scalar>::size)))) {}

  template<typename Index>
  inline const Scalar operator() (Index i) const { return m_low+i*m_step; }
  template<typename Index>
  inline const Packet packetOp(Index) const { return m_base = padd(m_base,m_packetStep); }

  const Scalar m_low;
  const Scalar m_step;
  const Packet m_packetStep;
  mutable Packet m_base;
};




template <typename Scalar>
struct linspaced_op_impl<Scalar,true>
{
  typedef typename packet_traits<Scalar>::type Packet;

  linspaced_op_impl(Scalar low, Scalar step) :
  m_low(low), m_step(step),
  m_lowPacket(pset1<Packet>(m_low)), m_stepPacket(pset1<Packet>(m_step)), m_interPacket(plset<Scalar>(0)) {}

  template<typename Index>
  inline const Scalar operator() (Index i) const { return m_low+i*m_step; }

  template<typename Index>
  inline const Packet packetOp(Index i) const
  { return internal::padd(m_lowPacket, pmul(m_stepPacket, padd(pset1<Packet>(i),m_interPacket))); }

  const Scalar m_low;
  const Scalar m_step;
  const Packet m_lowPacket;
  const Packet m_stepPacket;
  const Packet m_interPacket;
};






template <typename Scalar, bool RandomAccess = true> struct linspaced_op;
template <typename Scalar, bool RandomAccess> struct functor_traits< linspaced_op<Scalar,RandomAccess> >
{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::HasSetLinear, IsRepeatable = true }; };
template <typename Scalar, bool RandomAccess> struct linspaced_op
{
  typedef typename packet_traits<Scalar>::type Packet;
  linspaced_op(Scalar low, Scalar high, int num_steps) : impl(low, (high-low)/(num_steps-1)) {}

  template<typename Index>
  inline const Scalar operator() (Index i) const { return impl(i); }



  template<typename Index>
  inline const Scalar operator() (Index row, Index col) const
  {
    if( (!Eigen::internal::copy_bool(col==0 || row==0)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(col==0 || row==0)) Eigen::internal::assert_fail("col==0 || row==0", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Functors.h", 597); } while(false); else throw Eigen::eigen_assert_exception(); };
    return impl(col + row);
  }

  template<typename Index>
  inline const Packet packetOp(Index i) const { return impl.packetOp(i); }



  template<typename Index>
  inline const Packet packetOp(Index row, Index col) const
  {
    if( (!Eigen::internal::copy_bool(col==0 || row==0)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(col==0 || row==0)) Eigen::internal::assert_fail("col==0 || row==0", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Functors.h", 609); } while(false); else throw Eigen::eigen_assert_exception(); };
    return impl.packetOp(col + row);
  }




  const linspaced_op_impl<Scalar,RandomAccess> impl;
};





template<typename Functor> struct functor_has_linear_access { enum { ret = 1 }; };
template<typename Scalar> struct functor_has_linear_access<scalar_identity_op<Scalar> > { enum { ret = 0 }; };




template<typename Functor> struct functor_allows_mixing_real_and_complex { enum { ret = 0 }; };
template<typename LhsScalar,typename RhsScalar> struct functor_allows_mixing_real_and_complex<scalar_product_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };
template<typename LhsScalar,typename RhsScalar> struct functor_allows_mixing_real_and_complex<scalar_conj_product_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };







template<typename Scalar>
struct scalar_add_op {
  typedef typename packet_traits<Scalar>::type Packet;

  inline scalar_add_op(const scalar_add_op& other) : m_other(other.m_other) { }
  inline scalar_add_op(const Scalar& other) : m_other(other) { }
  inline Scalar operator() (const Scalar& a) const { return a + m_other; }
  inline const Packet packetOp(const Packet& a) const
  { return internal::padd(a, pset1<Packet>(m_other)); }
  const Scalar m_other;
};
template<typename Scalar>
struct functor_traits<scalar_add_op<Scalar> >
{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = packet_traits<Scalar>::HasAdd }; };





template<typename Scalar> struct scalar_sqrt_op {
  inline scalar_sqrt_op() {} inline scalar_sqrt_op(const scalar_sqrt_op& ) {}
  inline const Scalar operator() (const Scalar& a) const { return sqrt(a); }
  typedef typename packet_traits<Scalar>::type Packet;
  inline Packet packetOp(const Packet& a) const { return internal::psqrt(a); }
};
template<typename Scalar>
struct functor_traits<scalar_sqrt_op<Scalar> >
{ enum {
    Cost = 5 * NumTraits<Scalar>::MulCost,
    PacketAccess = packet_traits<Scalar>::HasSqrt
  };
};





template<typename Scalar> struct scalar_cos_op {
  inline scalar_cos_op() {} inline scalar_cos_op(const scalar_cos_op& ) {}
  inline Scalar operator() (const Scalar& a) const { return cos(a); }
  typedef typename packet_traits<Scalar>::type Packet;
  inline Packet packetOp(const Packet& a) const { return internal::pcos(a); }
};
template<typename Scalar>
struct functor_traits<scalar_cos_op<Scalar> >
{
  enum {
    Cost = 5 * NumTraits<Scalar>::MulCost,
    PacketAccess = packet_traits<Scalar>::HasCos
  };
};





template<typename Scalar> struct scalar_sin_op {
  inline scalar_sin_op() {} inline scalar_sin_op(const scalar_sin_op& ) {}
  inline const Scalar operator() (const Scalar& a) const { return sin(a); }
  typedef typename packet_traits<Scalar>::type Packet;
  inline Packet packetOp(const Packet& a) const { return internal::psin(a); }
};
template<typename Scalar>
struct functor_traits<scalar_sin_op<Scalar> >
{
  enum {
    Cost = 5 * NumTraits<Scalar>::MulCost,
    PacketAccess = packet_traits<Scalar>::HasSin
  };
};






template<typename Scalar> struct scalar_tan_op {
  inline scalar_tan_op() {} inline scalar_tan_op(const scalar_tan_op& ) {}
  inline const Scalar operator() (const Scalar& a) const { return tan(a); }
  typedef typename packet_traits<Scalar>::type Packet;
  inline Packet packetOp(const Packet& a) const { return internal::ptan(a); }
};
template<typename Scalar>
struct functor_traits<scalar_tan_op<Scalar> >
{
  enum {
    Cost = 5 * NumTraits<Scalar>::MulCost,
    PacketAccess = packet_traits<Scalar>::HasTan
  };
};





template<typename Scalar> struct scalar_acos_op {
  inline scalar_acos_op() {} inline scalar_acos_op(const scalar_acos_op& ) {}
  inline const Scalar operator() (const Scalar& a) const { return acos(a); }
  typedef typename packet_traits<Scalar>::type Packet;
  inline Packet packetOp(const Packet& a) const { return internal::pacos(a); }
};
template<typename Scalar>
struct functor_traits<scalar_acos_op<Scalar> >
{
  enum {
    Cost = 5 * NumTraits<Scalar>::MulCost,
    PacketAccess = packet_traits<Scalar>::HasACos
  };
};





template<typename Scalar> struct scalar_asin_op {
  inline scalar_asin_op() {} inline scalar_asin_op(const scalar_asin_op& ) {}
  inline const Scalar operator() (const Scalar& a) const { return asin(a); }
  typedef typename packet_traits<Scalar>::type Packet;
  inline Packet packetOp(const Packet& a) const { return internal::pasin(a); }
};
template<typename Scalar>
struct functor_traits<scalar_asin_op<Scalar> >
{
  enum {
    Cost = 5 * NumTraits<Scalar>::MulCost,
    PacketAccess = packet_traits<Scalar>::HasASin
  };
};





template<typename Scalar>
struct scalar_pow_op {

  inline scalar_pow_op(const scalar_pow_op& other) : m_exponent(other.m_exponent) { }
  inline scalar_pow_op(const Scalar& exponent) : m_exponent(exponent) {}
  inline Scalar operator() (const Scalar& a) const { return internal::pow(a, m_exponent); }
  const Scalar m_exponent;
};
template<typename Scalar>
struct functor_traits<scalar_pow_op<Scalar> >
{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false }; };





template<typename Scalar>
struct scalar_inverse_op {
  inline scalar_inverse_op() {} inline scalar_inverse_op(const scalar_inverse_op& ) {}
  inline Scalar operator() (const Scalar& a) const { return Scalar(1)/a; }
  template<typename Packet>
  inline const Packet packetOp(const Packet& a) const
  { return internal::pdiv(pset1<Packet>(Scalar(1)),a); }
};
template<typename Scalar>
struct functor_traits<scalar_inverse_op<Scalar> >
{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasDiv }; };





template<typename Scalar>
struct scalar_square_op {
  inline scalar_square_op() {} inline scalar_square_op(const scalar_square_op& ) {}
  inline Scalar operator() (const Scalar& a) const { return a*a; }
  template<typename Packet>
  inline const Packet packetOp(const Packet& a) const
  { return internal::pmul(a,a); }
};
template<typename Scalar>
struct functor_traits<scalar_square_op<Scalar> >
{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };





template<typename Scalar>
struct scalar_cube_op {
  inline scalar_cube_op() {} inline scalar_cube_op(const scalar_cube_op& ) {}
  inline Scalar operator() (const Scalar& a) const { return a*a*a; }
  template<typename Packet>
  inline const Packet packetOp(const Packet& a) const
  { return internal::pmul(a,pmul(a,a)); }
};
template<typename Scalar>
struct functor_traits<scalar_cube_op<Scalar> >
{ enum { Cost = 2*NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };



template<typename T>
struct functor_traits<std::multiplies<T> >
{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };

template<typename T>
struct functor_traits<std::divides<T> >
{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };

template<typename T>
struct functor_traits<std::plus<T> >
{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };

template<typename T>
struct functor_traits<std::minus<T> >
{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };

template<typename T>
struct functor_traits<std::negate<T> >
{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };

template<typename T>
struct functor_traits<std::logical_or<T> >
{ enum { Cost = 1, PacketAccess = false }; };

template<typename T>
struct functor_traits<std::logical_and<T> >
{ enum { Cost = 1, PacketAccess = false }; };

template<typename T>
struct functor_traits<std::logical_not<T> >
{ enum { Cost = 1, PacketAccess = false }; };

template<typename T>
struct functor_traits<std::greater<T> >
{ enum { Cost = 1, PacketAccess = false }; };

template<typename T>
struct functor_traits<std::less<T> >
{ enum { Cost = 1, PacketAccess = false }; };

template<typename T>
struct functor_traits<std::greater_equal<T> >
{ enum { Cost = 1, PacketAccess = false }; };

template<typename T>
struct functor_traits<std::less_equal<T> >
{ enum { Cost = 1, PacketAccess = false }; };

template<typename T>
struct functor_traits<std::equal_to<T> >
{ enum { Cost = 1, PacketAccess = false }; };

template<typename T>
struct functor_traits<std::not_equal_to<T> >
{ enum { Cost = 1, PacketAccess = false }; };

template<typename T>
struct functor_traits<std::binder2nd<T> >
{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };

template<typename T>
struct functor_traits<std::binder1st<T> >
{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };

template<typename T>
struct functor_traits<std::unary_negate<T> >
{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };

template<typename T>
struct functor_traits<std::binary_negate<T> >
{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };
# 940 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Functors.h"
}
# 276 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h"
namespace internal {
template<typename T> struct add_const_on_value_type_if_arithmetic
{
  typedef typename conditional<is_arithmetic<T>::value, T, typename add_const_on_value_type<T>::type>::type type;
};
}
# 46 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h"
template<typename Derived>
class DenseCoeffsBase<Derived,ReadOnlyAccessors> : public EigenBase<Derived>
{
  public:
    typedef typename internal::traits<Derived>::StorageKind StorageKind;
    typedef typename internal::traits<Derived>::Index Index;
    typedef typename internal::traits<Derived>::Scalar Scalar;
    typedef typename internal::packet_traits<Scalar>::type PacketScalar;
# 62 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h"
    typedef typename internal::conditional<bool(internal::traits<Derived>::Flags&LvalueBit),
                         const Scalar&,
                         typename internal::conditional<internal::is_arithmetic<Scalar>::value, Scalar, const Scalar>::type
                     >::type CoeffReturnType;

    typedef typename internal::add_const_on_value_type_if_arithmetic<
                         typename internal::packet_traits<Scalar>::type
                     >::type PacketReturnType;

    typedef EigenBase<Derived> Base;
    using Base::rows;
    using Base::cols;
    using Base::size;
    using Base::derived;

    inline Index rowIndexByOuterInner(Index outer, Index inner) const
    {
      return int(Derived::RowsAtCompileTime) == 1 ? 0
          : int(Derived::ColsAtCompileTime) == 1 ? inner
          : int(Derived::Flags)&RowMajorBit ? outer
          : inner;
    }

    inline Index colIndexByOuterInner(Index outer, Index inner) const
    {
      return int(Derived::ColsAtCompileTime) == 1 ? 0
          : int(Derived::RowsAtCompileTime) == 1 ? inner
          : int(Derived::Flags)&RowMajorBit ? inner
          : outer;
    }
# 107 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h"
    inline CoeffReturnType coeff(Index row, Index col) const
    {
      if( (!Eigen::internal::copy_bool(row >= 0 && row < rows() && col >= 0 && col < cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(row >= 0 && row < rows() && col >= 0 && col < cols())) Eigen::internal::assert_fail("row >= 0 && row < rows() && col >= 0 && col < cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h", 110); } while(false); else throw Eigen::eigen_assert_exception(); };

      return derived().coeff(row, col);
    }

    inline CoeffReturnType coeffByOuterInner(Index outer, Index inner) const
    {
      return coeff(rowIndexByOuterInner(outer, inner),
                   colIndexByOuterInner(outer, inner));
    }





    inline CoeffReturnType operator()(Index row, Index col) const
    {
      if( (!Eigen::internal::copy_bool(row >= 0 && row < rows() && col >= 0 && col < cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(row >= 0 && row < rows() && col >= 0 && col < cols())) Eigen::internal::assert_fail("row >= 0 && row < rows() && col >= 0 && col < cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h", 127); } while(false); else throw Eigen::eigen_assert_exception(); };

      return derived().coeff(row, col);
    }
# 146 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h"
    inline CoeffReturnType
    coeff(Index index) const
    {
      if( (!Eigen::internal::copy_bool(index >= 0 && index < size())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(index >= 0 && index < size())) Eigen::internal::assert_fail("index >= 0 && index < size()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h", 149); } while(false); else throw Eigen::eigen_assert_exception(); };
      return derived().coeff(index);
    }
# 162 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h"
    inline CoeffReturnType
    operator[](Index index) const
    {

      if (Eigen::internal::static_assertion<bool(Derived::IsVectorAtCompileTime)>::THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD) {}


      if( (!Eigen::internal::copy_bool(index >= 0 && index < size())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(index >= 0 && index < size())) Eigen::internal::assert_fail("index >= 0 && index < size()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h", 169); } while(false); else throw Eigen::eigen_assert_exception(); };
      return derived().coeff(index);
    }
# 183 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h"
    inline CoeffReturnType
    operator()(Index index) const
    {
      if( (!Eigen::internal::copy_bool(index >= 0 && index < size())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(index >= 0 && index < size())) Eigen::internal::assert_fail("index >= 0 && index < size()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h", 186); } while(false); else throw Eigen::eigen_assert_exception(); };
      return derived().coeff(index);
    }



    inline CoeffReturnType
    x() const { return (*this)[0]; }



    inline CoeffReturnType
    y() const { return (*this)[1]; }



    inline CoeffReturnType
    z() const { return (*this)[2]; }



    inline CoeffReturnType
    w() const { return (*this)[3]; }
# 220 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h"
    template<int LoadMode>
    inline PacketReturnType packet(Index row, Index col) const
    {
      if( (!Eigen::internal::copy_bool(row >= 0 && row < rows() && col >= 0 && col < cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(row >= 0 && row < rows() && col >= 0 && col < cols())) Eigen::internal::assert_fail("row >= 0 && row < rows() && col >= 0 && col < cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h", 224); } while(false); else throw Eigen::eigen_assert_exception(); };

      return derived().template packet<LoadMode>(row,col);
    }



    template<int LoadMode>
    inline PacketReturnType packetByOuterInner(Index outer, Index inner) const
    {
      return packet<LoadMode>(rowIndexByOuterInner(outer, inner),
                              colIndexByOuterInner(outer, inner));
    }
# 247 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h"
    template<int LoadMode>
    inline PacketReturnType packet(Index index) const
    {
      if( (!Eigen::internal::copy_bool(index >= 0 && index < size())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(index >= 0 && index < size())) Eigen::internal::assert_fail("index >= 0 && index < size()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h", 250); } while(false); else throw Eigen::eigen_assert_exception(); };
      return derived().template packet<LoadMode>(index);
    }

  protected:





    void coeffRef();
    void coeffRefByOuterInner();
    void writePacket();
    void writePacketByOuterInner();
    void copyCoeff();
    void copyCoeffByOuterInner();
    void copyPacket();
    void copyPacketByOuterInner();
    void stride();
    void innerStride();
    void outerStride();
    void rowStride();
    void colStride();
};
# 286 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h"
template<typename Derived>
class DenseCoeffsBase<Derived, WriteAccessors> : public DenseCoeffsBase<Derived, ReadOnlyAccessors>
{
  public:

    typedef DenseCoeffsBase<Derived, ReadOnlyAccessors> Base;

    typedef typename internal::traits<Derived>::StorageKind StorageKind;
    typedef typename internal::traits<Derived>::Index Index;
    typedef typename internal::traits<Derived>::Scalar Scalar;
    typedef typename internal::packet_traits<Scalar>::type PacketScalar;
    typedef typename NumTraits<Scalar>::Real RealScalar;

    using Base::coeff;
    using Base::rows;
    using Base::cols;
    using Base::size;
    using Base::derived;
    using Base::rowIndexByOuterInner;
    using Base::colIndexByOuterInner;
    using Base::operator[];
    using Base::operator();
    using Base::x;
    using Base::y;
    using Base::z;
    using Base::w;
# 327 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h"
    inline Scalar& coeffRef(Index row, Index col)
    {
      if( (!Eigen::internal::copy_bool(row >= 0 && row < rows() && col >= 0 && col < cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(row >= 0 && row < rows() && col >= 0 && col < cols())) Eigen::internal::assert_fail("row >= 0 && row < rows() && col >= 0 && col < cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h", 330); } while(false); else throw Eigen::eigen_assert_exception(); };

      return derived().coeffRef(row, col);
    }

    inline Scalar&
    coeffRefByOuterInner(Index outer, Index inner)
    {
      return coeffRef(rowIndexByOuterInner(outer, inner),
                      colIndexByOuterInner(outer, inner));
    }






    inline Scalar&
    operator()(Index row, Index col)
    {
      if( (!Eigen::internal::copy_bool(row >= 0 && row < rows() && col >= 0 && col < cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(row >= 0 && row < rows() && col >= 0 && col < cols())) Eigen::internal::assert_fail("row >= 0 && row < rows() && col >= 0 && col < cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h", 350); } while(false); else throw Eigen::eigen_assert_exception(); };

      return derived().coeffRef(row, col);
    }
# 370 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h"
    inline Scalar&
    coeffRef(Index index)
    {
      if( (!Eigen::internal::copy_bool(index >= 0 && index < size())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(index >= 0 && index < size())) Eigen::internal::assert_fail("index >= 0 && index < size()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h", 373); } while(false); else throw Eigen::eigen_assert_exception(); };
      return derived().coeffRef(index);
    }
# 384 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h"
    inline Scalar&
    operator[](Index index)
    {

      if (Eigen::internal::static_assertion<bool(Derived::IsVectorAtCompileTime)>::THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD) {}


      if( (!Eigen::internal::copy_bool(index >= 0 && index < size())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(index >= 0 && index < size())) Eigen::internal::assert_fail("index >= 0 && index < size()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h", 391); } while(false); else throw Eigen::eigen_assert_exception(); };
      return derived().coeffRef(index);
    }
# 404 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h"
    inline Scalar&
    operator()(Index index)
    {
      if( (!Eigen::internal::copy_bool(index >= 0 && index < size())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(index >= 0 && index < size())) Eigen::internal::assert_fail("index >= 0 && index < size()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h", 407); } while(false); else throw Eigen::eigen_assert_exception(); };
      return derived().coeffRef(index);
    }



    inline Scalar&
    x() { return (*this)[0]; }



    inline Scalar&
    y() { return (*this)[1]; }



    inline Scalar&
    z() { return (*this)[2]; }



    inline Scalar&
    w() { return (*this)[3]; }
# 441 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h"
    template<int StoreMode>
    inline void writePacket
    (Index row, Index col, const typename internal::packet_traits<Scalar>::type& x)
    {
      if( (!Eigen::internal::copy_bool(row >= 0 && row < rows() && col >= 0 && col < cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(row >= 0 && row < rows() && col >= 0 && col < cols())) Eigen::internal::assert_fail("row >= 0 && row < rows() && col >= 0 && col < cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h", 446); } while(false); else throw Eigen::eigen_assert_exception(); };

      derived().template writePacket<StoreMode>(row,col,x);
    }



    template<int StoreMode>
    inline void writePacketByOuterInner
    (Index outer, Index inner, const typename internal::packet_traits<Scalar>::type& x)
    {
      writePacket<StoreMode>(rowIndexByOuterInner(outer, inner),
                            colIndexByOuterInner(outer, inner),
                            x);
    }
# 470 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h"
    template<int StoreMode>
    inline void writePacket
    (Index index, const typename internal::packet_traits<Scalar>::type& x)
    {
      if( (!Eigen::internal::copy_bool(index >= 0 && index < size())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(index >= 0 && index < size())) Eigen::internal::assert_fail("index >= 0 && index < size()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h", 474); } while(false); else throw Eigen::eigen_assert_exception(); };
      derived().template writePacket<StoreMode>(index,x);
    }
# 488 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h"
    template<typename OtherDerived>
    inline void copyCoeff(Index row, Index col, const DenseBase<OtherDerived>& other)
    {
      if( (!Eigen::internal::copy_bool(row >= 0 && row < rows() && col >= 0 && col < cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(row >= 0 && row < rows() && col >= 0 && col < cols())) Eigen::internal::assert_fail("row >= 0 && row < rows() && col >= 0 && col < cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h", 492); } while(false); else throw Eigen::eigen_assert_exception(); };

      derived().coeffRef(row, col) = other.derived().coeff(row, col);
    }
# 504 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h"
    template<typename OtherDerived>
    inline void copyCoeff(Index index, const DenseBase<OtherDerived>& other)
    {
      if( (!Eigen::internal::copy_bool(index >= 0 && index < size())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(index >= 0 && index < size())) Eigen::internal::assert_fail("index >= 0 && index < size()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h", 507); } while(false); else throw Eigen::eigen_assert_exception(); };
      derived().coeffRef(index) = other.derived().coeff(index);
    }


    template<typename OtherDerived>
    inline void copyCoeffByOuterInner(Index outer, Index inner, const DenseBase<OtherDerived>& other)
    {
      const Index row = rowIndexByOuterInner(outer,inner);
      const Index col = colIndexByOuterInner(outer,inner);

      derived().copyCoeff(row, col, other);
    }
# 529 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h"
    template<typename OtherDerived, int StoreMode, int LoadMode>
    inline void copyPacket(Index row, Index col, const DenseBase<OtherDerived>& other)
    {
      if( (!Eigen::internal::copy_bool(row >= 0 && row < rows() && col >= 0 && col < cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(row >= 0 && row < rows() && col >= 0 && col < cols())) Eigen::internal::assert_fail("row >= 0 && row < rows() && col >= 0 && col < cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h", 533); } while(false); else throw Eigen::eigen_assert_exception(); };

      derived().template writePacket<StoreMode>(row, col,
        other.derived().template packet<LoadMode>(row, col));
    }
# 546 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h"
    template<typename OtherDerived, int StoreMode, int LoadMode>
    inline void copyPacket(Index index, const DenseBase<OtherDerived>& other)
    {
      if( (!Eigen::internal::copy_bool(index >= 0 && index < size())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(index >= 0 && index < size())) Eigen::internal::assert_fail("index >= 0 && index < size()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h", 549); } while(false); else throw Eigen::eigen_assert_exception(); };
      derived().template writePacket<StoreMode>(index,
        other.derived().template packet<LoadMode>(index));
    }


    template<typename OtherDerived, int StoreMode, int LoadMode>
    inline void copyPacketByOuterInner(Index outer, Index inner, const DenseBase<OtherDerived>& other)
    {
      const Index row = rowIndexByOuterInner(outer,inner);
      const Index col = colIndexByOuterInner(outer,inner);

      derived().template copyPacket< OtherDerived, StoreMode, LoadMode>(row, col, other);
    }


};
# 578 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h"
template<typename Derived>
class DenseCoeffsBase<Derived, DirectAccessors> : public DenseCoeffsBase<Derived, ReadOnlyAccessors>
{
  public:

    typedef DenseCoeffsBase<Derived, ReadOnlyAccessors> Base;
    typedef typename internal::traits<Derived>::Index Index;
    typedef typename internal::traits<Derived>::Scalar Scalar;
    typedef typename NumTraits<Scalar>::Real RealScalar;

    using Base::rows;
    using Base::cols;
    using Base::size;
    using Base::derived;





    inline Index innerStride() const
    {
      return derived().innerStride();
    }






    inline Index outerStride() const
    {
      return derived().outerStride();
    }


    inline Index stride() const
    {
      return Derived::IsVectorAtCompileTime ? innerStride() : outerStride();
    }





    inline Index rowStride() const
    {
      return Derived::IsRowMajor ? outerStride() : innerStride();
    }





    inline Index colStride() const
    {
      return Derived::IsRowMajor ? innerStride() : outerStride();
    }
};
# 648 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseCoeffsBase.h"
template<typename Derived>
class DenseCoeffsBase<Derived, DirectWriteAccessors>
  : public DenseCoeffsBase<Derived, WriteAccessors>
{
  public:

    typedef DenseCoeffsBase<Derived, WriteAccessors> Base;
    typedef typename internal::traits<Derived>::Index Index;
    typedef typename internal::traits<Derived>::Scalar Scalar;
    typedef typename NumTraits<Scalar>::Real RealScalar;

    using Base::rows;
    using Base::cols;
    using Base::size;
    using Base::derived;





    inline Index innerStride() const
    {
      return derived().innerStride();
    }






    inline Index outerStride() const
    {
      return derived().outerStride();
    }


    inline Index stride() const
    {
      return Derived::IsVectorAtCompileTime ? innerStride() : outerStride();
    }





    inline Index rowStride() const
    {
      return Derived::IsRowMajor ? outerStride() : innerStride();
    }





    inline Index colStride() const
    {
      return Derived::IsRowMajor ? innerStride() : outerStride();
    }
};

namespace internal {

template<typename Derived, bool JustReturnZero>
struct first_aligned_impl
{
  inline static typename Derived::Index run(const Derived&)
  { return 0; }
};

template<typename Derived>
struct first_aligned_impl<Derived, false>
{
  inline static typename Derived::Index run(const Derived& m)
  {
    return first_aligned(&m.const_cast_derived().coeffRef(0,0), m.size());
  }
};






template<typename Derived>
inline static typename Derived::Index first_aligned(const Derived& m)
{
  return first_aligned_impl
          <Derived, (Derived::Flags & AlignedBit) || !(Derived::Flags & DirectAccessBit)>
          ::run(m);
}

template<typename Derived, bool HasDirectAccess = has_direct_access<Derived>::ret>
struct inner_stride_at_compile_time
{
  enum { ret = traits<Derived>::InnerStrideAtCompileTime };
};

template<typename Derived>
struct inner_stride_at_compile_time<Derived, false>
{
  enum { ret = 0 };
};

template<typename Derived, bool HasDirectAccess = has_direct_access<Derived>::ret>
struct outer_stride_at_compile_time
{
  enum { ret = traits<Derived>::OuterStrideAtCompileTime };
};

template<typename Derived>
struct outer_stride_at_compile_time<Derived, false>
{
  enum { ret = 0 };
};

}
# 277 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseBase.h" 1
# 44 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseBase.h"
template<typename Derived> class DenseBase

  : public internal::special_scalar_op_base<Derived,typename internal::traits<Derived>::Scalar,
                                     typename NumTraits<typename internal::traits<Derived>::Scalar>::Real>



{
  public:
    using internal::special_scalar_op_base<Derived,typename internal::traits<Derived>::Scalar,
                typename NumTraits<typename internal::traits<Derived>::Scalar>::Real>::operator*;

    class InnerIterator;

    typedef typename internal::traits<Derived>::StorageKind StorageKind;





    typedef typename internal::traits<Derived>::Index Index;

    typedef typename internal::traits<Derived>::Scalar Scalar;
    typedef typename internal::packet_traits<Scalar>::type PacketScalar;
    typedef typename NumTraits<Scalar>::Real RealScalar;

    typedef DenseCoeffsBase<Derived> Base;
    using Base::derived;
    using Base::const_cast_derived;
    using Base::rows;
    using Base::cols;
    using Base::size;
    using Base::rowIndexByOuterInner;
    using Base::colIndexByOuterInner;
    using Base::coeff;
    using Base::coeffByOuterInner;
    using Base::packet;
    using Base::packetByOuterInner;
    using Base::writePacket;
    using Base::writePacketByOuterInner;
    using Base::coeffRef;
    using Base::coeffRefByOuterInner;
    using Base::copyCoeff;
    using Base::copyCoeffByOuterInner;
    using Base::copyPacket;
    using Base::copyPacketByOuterInner;
    using Base::operator();
    using Base::operator[];
    using Base::x;
    using Base::y;
    using Base::z;
    using Base::w;
    using Base::stride;
    using Base::innerStride;
    using Base::outerStride;
    using Base::rowStride;
    using Base::colStride;
    typedef typename Base::CoeffReturnType CoeffReturnType;

    enum {

      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,





      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,






      SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileTime,
                                                   internal::traits<Derived>::ColsAtCompileTime>::ret),




      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,
# 135 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseBase.h"
      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime,
# 146 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseBase.h"
      MaxSizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::MaxRowsAtCompileTime,
                                                      internal::traits<Derived>::MaxColsAtCompileTime>::ret),
# 158 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseBase.h"
      IsVectorAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime == 1
                           || internal::traits<Derived>::MaxColsAtCompileTime == 1,





      Flags = internal::traits<Derived>::Flags,




      IsRowMajor = int(Flags) & RowMajorBit,

      InnerSizeAtCompileTime = int(IsVectorAtCompileTime) ? SizeAtCompileTime
                             : int(IsRowMajor) ? ColsAtCompileTime : RowsAtCompileTime,

      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,




      InnerStrideAtCompileTime = internal::inner_stride_at_compile_time<Derived>::ret,
      OuterStrideAtCompileTime = internal::outer_stride_at_compile_time<Derived>::ret
    };

    enum { ThisConstantIsPrivateInPlainObjectBase };



    inline Index nonZeros() const { return size(); }
# 199 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseBase.h"
    Index outerSize() const
    {
      return IsVectorAtCompileTime ? 1
           : int(IsRowMajor) ? this->rows() : this->cols();
    }






    Index innerSize() const
    {
      return IsVectorAtCompileTime ? this->size()
           : int(IsRowMajor) ? this->cols() : this->rows();
    }





    void resize(Index size)
    {
                                     ;
      if( (!Eigen::internal::copy_bool(size == this->size() && "DenseBase::resize() does not actually allow to resize.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(size == this->size() && "DenseBase::resize() does not actually allow to resize.")) Eigen::internal::assert_fail("size == this->size() && \"DenseBase::resize() does not actually allow to resize.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseBase.h", 224); } while(false); else throw Eigen::eigen_assert_exception(); };

    }




    void resize(Index rows, Index cols)
    {
                                     ;
                                     ;
      if( (!Eigen::internal::copy_bool(rows == this->rows() && cols == this->cols() && "DenseBase::resize() does not actually allow to resize.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(rows == this->rows() && cols == this->cols() && "DenseBase::resize() does not actually allow to resize.")) Eigen::internal::assert_fail("rows == this->rows() && cols == this->cols() && \"DenseBase::resize() does not actually allow to resize.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseBase.h", 235); } while(false); else throw Eigen::eigen_assert_exception(); };

    }




    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Derived> ConstantReturnType;

    typedef CwiseNullaryOp<internal::linspaced_op<Scalar,false>,Derived> SequentialLinSpacedReturnType;

    typedef CwiseNullaryOp<internal::linspaced_op<Scalar,true>,Derived> RandomAccessLinSpacedReturnType;

    typedef Matrix<typename NumTraits<typename internal::traits<Derived>::Scalar>::Real, internal::traits<Derived>::ColsAtCompileTime, 1> EigenvaluesReturnType;




    template<typename OtherDerived>
    Derived& operator=(const DenseBase<OtherDerived>& other);




    Derived& operator=(const DenseBase& other);

    template<typename OtherDerived>
    Derived& operator=(const EigenBase<OtherDerived> &other);

    template<typename OtherDerived>
    Derived& operator+=(const EigenBase<OtherDerived> &other);

    template<typename OtherDerived>
    Derived& operator-=(const EigenBase<OtherDerived> &other);

    template<typename OtherDerived>
    Derived& operator=(const ReturnByValue<OtherDerived>& func);



    template<typename OtherDerived>
    Derived& lazyAssign(const DenseBase<OtherDerived>& other);


    CommaInitializer<Derived> operator<< (const Scalar& s);

    template<unsigned int Added,unsigned int Removed>
    const Flagged<Derived, Added, Removed> flagged() const;

    template<typename OtherDerived>
    CommaInitializer<Derived> operator<< (const DenseBase<OtherDerived>& other);

    Eigen::Transpose<Derived> transpose();
    typedef const Transpose<const Derived> ConstTransposeReturnType;
    ConstTransposeReturnType transpose() const;
    void transposeInPlace();

  protected:
    template<typename OtherDerived>
    void checkTransposeAliasing(const OtherDerived& other) const;
  public:


    typedef VectorBlock<Derived> SegmentReturnType;
    typedef const VectorBlock<const Derived> ConstSegmentReturnType;
    template<int Size> struct FixedSegmentReturnType { typedef VectorBlock<Derived, Size> Type; };
    template<int Size> struct ConstFixedSegmentReturnType { typedef const VectorBlock<const Derived, Size> Type; };


    SegmentReturnType segment(Index start, Index size);
    typename DenseBase::ConstSegmentReturnType segment(Index start, Index size) const;

    SegmentReturnType head(Index size);
    typename DenseBase::ConstSegmentReturnType head(Index size) const;

    SegmentReturnType tail(Index size);
    typename DenseBase::ConstSegmentReturnType tail(Index size) const;

    template<int Size> typename FixedSegmentReturnType<Size>::Type head();
    template<int Size> typename ConstFixedSegmentReturnType<Size>::Type head() const;

    template<int Size> typename FixedSegmentReturnType<Size>::Type tail();
    template<int Size> typename ConstFixedSegmentReturnType<Size>::Type tail() const;

    template<int Size> typename FixedSegmentReturnType<Size>::Type segment(Index start);
    template<int Size> typename ConstFixedSegmentReturnType<Size>::Type segment(Index start) const;

    static const ConstantReturnType
    Constant(Index rows, Index cols, const Scalar& value);
    static const ConstantReturnType
    Constant(Index size, const Scalar& value);
    static const ConstantReturnType
    Constant(const Scalar& value);

    static const SequentialLinSpacedReturnType
    LinSpaced(Sequential_t, Index size, const Scalar& low, const Scalar& high);
    static const RandomAccessLinSpacedReturnType
    LinSpaced(Index size, const Scalar& low, const Scalar& high);
    static const SequentialLinSpacedReturnType
    LinSpaced(Sequential_t, const Scalar& low, const Scalar& high);
    static const RandomAccessLinSpacedReturnType
    LinSpaced(const Scalar& low, const Scalar& high);

    template<typename CustomNullaryOp>
    static const CwiseNullaryOp<CustomNullaryOp, Derived>
    NullaryExpr(Index rows, Index cols, const CustomNullaryOp& func);
    template<typename CustomNullaryOp>
    static const CwiseNullaryOp<CustomNullaryOp, Derived>
    NullaryExpr(Index size, const CustomNullaryOp& func);
    template<typename CustomNullaryOp>
    static const CwiseNullaryOp<CustomNullaryOp, Derived>
    NullaryExpr(const CustomNullaryOp& func);

    static const ConstantReturnType Zero(Index rows, Index cols);
    static const ConstantReturnType Zero(Index size);
    static const ConstantReturnType Zero();
    static const ConstantReturnType Ones(Index rows, Index cols);
    static const ConstantReturnType Ones(Index size);
    static const ConstantReturnType Ones();

    void fill(const Scalar& value);
    Derived& setConstant(const Scalar& value);
    Derived& setLinSpaced(Index size, const Scalar& low, const Scalar& high);
    Derived& setLinSpaced(const Scalar& low, const Scalar& high);
    Derived& setZero();
    Derived& setOnes();
    Derived& setRandom();

    template<typename OtherDerived>
    bool isApprox(const DenseBase<OtherDerived>& other,
                  RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;
    bool isMuchSmallerThan(const RealScalar& other,
                           RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;
    template<typename OtherDerived>
    bool isMuchSmallerThan(const DenseBase<OtherDerived>& other,
                           RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;

    bool isApproxToConstant(const Scalar& value, RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;
    bool isConstant(const Scalar& value, RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;
    bool isZero(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;
    bool isOnes(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;

    inline Derived& operator*=(const Scalar& other);
    inline Derived& operator/=(const Scalar& other);






    inline const typename internal::eval<Derived>::type eval() const
    {



      return typename internal::eval<Derived>::type(derived());
    }




    template<typename OtherDerived>
    void swap(const DenseBase<OtherDerived>& other,
              int = OtherDerived::ThisConstantIsPrivateInPlainObjectBase)
    {
      SwapWrapper<Derived>(derived()).lazyAssign(other.derived());
    }




    template<typename OtherDerived>
    void swap(PlainObjectBase<OtherDerived>& other)
    {
      SwapWrapper<Derived>(derived()).lazyAssign(other.derived());
    }


    inline const NestByValue<Derived> nestByValue() const;
    inline const ForceAlignedAccess<Derived> forceAlignedAccess() const;
    inline ForceAlignedAccess<Derived> forceAlignedAccess();
    template<bool Enable> inline const typename internal::conditional<Enable,ForceAlignedAccess<Derived>,Derived&>::type forceAlignedAccessIf() const;
    template<bool Enable> inline typename internal::conditional<Enable,ForceAlignedAccess<Derived>,Derived&>::type forceAlignedAccessIf();

    Scalar sum() const;
    Scalar mean() const;
    Scalar trace() const;

    Scalar prod() const;

    typename internal::traits<Derived>::Scalar minCoeff() const;
    typename internal::traits<Derived>::Scalar maxCoeff() const;

    template<typename IndexType>
    typename internal::traits<Derived>::Scalar minCoeff(IndexType* row, IndexType* col) const;
    template<typename IndexType>
    typename internal::traits<Derived>::Scalar maxCoeff(IndexType* row, IndexType* col) const;
    template<typename IndexType>
    typename internal::traits<Derived>::Scalar minCoeff(IndexType* index) const;
    template<typename IndexType>
    typename internal::traits<Derived>::Scalar maxCoeff(IndexType* index) const;

    template<typename BinaryOp>
    typename internal::result_of<BinaryOp(typename internal::traits<Derived>::Scalar)>::type
    redux(const BinaryOp& func) const;

    template<typename Visitor>
    void visit(Visitor& func) const;

    inline const WithFormat<Derived> format(const IOFormat& fmt) const;


    CoeffReturnType value() const
    {
      if (Eigen::internal::static_assertion<bool((Derived::RowsAtCompileTime == 1 || Derived::RowsAtCompileTime == Dynamic) && (Derived::ColsAtCompileTime == 1 || Derived::ColsAtCompileTime == Dynamic))>::THIS_METHOD_IS_ONLY_FOR_1x1_EXPRESSIONS) {}
      if( (!Eigen::internal::copy_bool(this->rows() == 1 && this->cols() == 1)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(this->rows() == 1 && this->cols() == 1)) Eigen::internal::assert_fail("this->rows() == 1 && this->cols() == 1", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseBase.h", 449); } while(false); else throw Eigen::eigen_assert_exception(); };
      return derived().coeff(0,0);
    }



    bool all(void) const;
    bool any(void) const;
    Index count() const;

    typedef VectorwiseOp<Derived, Horizontal> RowwiseReturnType;
    typedef const VectorwiseOp<const Derived, Horizontal> ConstRowwiseReturnType;
    typedef VectorwiseOp<Derived, Vertical> ColwiseReturnType;
    typedef const VectorwiseOp<const Derived, Vertical> ConstColwiseReturnType;

    ConstRowwiseReturnType rowwise() const;
    RowwiseReturnType rowwise();
    ConstColwiseReturnType colwise() const;
    ColwiseReturnType colwise();

    static const CwiseNullaryOp<internal::scalar_random_op<Scalar>,Derived> Random(Index rows, Index cols);
    static const CwiseNullaryOp<internal::scalar_random_op<Scalar>,Derived> Random(Index size);
    static const CwiseNullaryOp<internal::scalar_random_op<Scalar>,Derived> Random();

    template<typename ThenDerived,typename ElseDerived>
    const Select<Derived,ThenDerived,ElseDerived>
    select(const DenseBase<ThenDerived>& thenMatrix,
           const DenseBase<ElseDerived>& elseMatrix) const;

    template<typename ThenDerived>
    inline const Select<Derived,ThenDerived, typename ThenDerived::ConstantReturnType>
    select(const DenseBase<ThenDerived>& thenMatrix, typename ThenDerived::Scalar elseScalar) const;

    template<typename ElseDerived>
    inline const Select<Derived, typename ElseDerived::ConstantReturnType, ElseDerived >
    select(typename ElseDerived::Scalar thenScalar, const DenseBase<ElseDerived>& elseMatrix) const;

    template<int p> RealScalar lpNorm() const;

    template<int RowFactor, int ColFactor>
    const Replicate<Derived,RowFactor,ColFactor> replicate() const;
    const Replicate<Derived,Dynamic,Dynamic> replicate(Index rowFacor,Index colFactor) const;

    typedef Reverse<Derived, BothDirections> ReverseReturnType;
    typedef const Reverse<const Derived, BothDirections> ConstReverseReturnType;
    ReverseReturnType reverse();
    ConstReverseReturnType reverse() const;
    void reverseInPlace();



# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/BlockMethods.h" 1
# 32 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/BlockMethods.h"
typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, 1, !IsRowMajor> ColXpr;
typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, 1, !IsRowMajor> ConstColXpr;

typedef Block<Derived, 1, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> RowXpr;
typedef const Block<const Derived, 1, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> ConstRowXpr;

typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, Dynamic, !IsRowMajor> ColsBlockXpr;
typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, Dynamic, !IsRowMajor> ConstColsBlockXpr;

typedef Block<Derived, Dynamic, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> RowsBlockXpr;
typedef const Block<const Derived, Dynamic, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> ConstRowsBlockXpr;

template<int N> struct NColsBlockXpr { typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };
template<int N> struct ConstNColsBlockXpr { typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };

template<int N> struct NRowsBlockXpr { typedef Block<Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };
template<int N> struct ConstNRowsBlockXpr { typedef const Block<const Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };
# 69 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/BlockMethods.h"
inline Block<Derived> block(Index startRow, Index startCol, Index blockRows, Index blockCols)
{
  return Block<Derived>(derived(), startRow, startCol, blockRows, blockCols);
}


inline const Block<const Derived> block(Index startRow, Index startCol, Index blockRows, Index blockCols) const
{
  return Block<const Derived>(derived(), startRow, startCol, blockRows, blockCols);
}
# 93 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/BlockMethods.h"
inline Block<Derived> topRightCorner(Index cRows, Index cCols)
{
  return Block<Derived>(derived(), 0, cols() - cCols, cRows, cCols);
}


inline const Block<const Derived> topRightCorner(Index cRows, Index cCols) const
{
  return Block<const Derived>(derived(), 0, cols() - cCols, cRows, cCols);
}
# 113 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/BlockMethods.h"
template<int CRows, int CCols>
inline Block<Derived, CRows, CCols> topRightCorner()
{
  return Block<Derived, CRows, CCols>(derived(), 0, cols() - CCols);
}


template<int CRows, int CCols>
inline const Block<const Derived, CRows, CCols> topRightCorner() const
{
  return Block<const Derived, CRows, CCols>(derived(), 0, cols() - CCols);
}
# 139 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/BlockMethods.h"
inline Block<Derived> topLeftCorner(Index cRows, Index cCols)
{
  return Block<Derived>(derived(), 0, 0, cRows, cCols);
}


inline const Block<const Derived> topLeftCorner(Index cRows, Index cCols) const
{
  return Block<const Derived>(derived(), 0, 0, cRows, cCols);
}
# 159 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/BlockMethods.h"
template<int CRows, int CCols>
inline Block<Derived, CRows, CCols> topLeftCorner()
{
  return Block<Derived, CRows, CCols>(derived(), 0, 0);
}


template<int CRows, int CCols>
inline const Block<const Derived, CRows, CCols> topLeftCorner() const
{
  return Block<const Derived, CRows, CCols>(derived(), 0, 0);
}
# 184 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/BlockMethods.h"
inline Block<Derived> bottomRightCorner(Index cRows, Index cCols)
{
  return Block<Derived>(derived(), rows() - cRows, cols() - cCols, cRows, cCols);
}


inline const Block<const Derived> bottomRightCorner(Index cRows, Index cCols) const
{
  return Block<const Derived>(derived(), rows() - cRows, cols() - cCols, cRows, cCols);
}
# 204 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/BlockMethods.h"
template<int CRows, int CCols>
inline Block<Derived, CRows, CCols> bottomRightCorner()
{
  return Block<Derived, CRows, CCols>(derived(), rows() - CRows, cols() - CCols);
}


template<int CRows, int CCols>
inline const Block<const Derived, CRows, CCols> bottomRightCorner() const
{
  return Block<const Derived, CRows, CCols>(derived(), rows() - CRows, cols() - CCols);
}
# 229 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/BlockMethods.h"
inline Block<Derived> bottomLeftCorner(Index cRows, Index cCols)
{
  return Block<Derived>(derived(), rows() - cRows, 0, cRows, cCols);
}


inline const Block<const Derived> bottomLeftCorner(Index cRows, Index cCols) const
{
  return Block<const Derived>(derived(), rows() - cRows, 0, cRows, cCols);
}
# 249 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/BlockMethods.h"
template<int CRows, int CCols>
inline Block<Derived, CRows, CCols> bottomLeftCorner()
{
  return Block<Derived, CRows, CCols>(derived(), rows() - CRows, 0);
}


template<int CRows, int CCols>
inline const Block<const Derived, CRows, CCols> bottomLeftCorner() const
{
  return Block<const Derived, CRows, CCols>(derived(), rows() - CRows, 0);
}
# 273 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/BlockMethods.h"
inline RowsBlockXpr topRows(Index n)
{
  return RowsBlockXpr(derived(), 0, 0, n, cols());
}


inline ConstRowsBlockXpr topRows(Index n) const
{
  return ConstRowsBlockXpr(derived(), 0, 0, n, cols());
}
# 293 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/BlockMethods.h"
template<int N>
inline typename NRowsBlockXpr<N>::Type topRows()
{
  return typename NRowsBlockXpr<N>::Type(derived(), 0, 0, N, cols());
}


template<int N>
inline typename ConstNRowsBlockXpr<N>::Type topRows() const
{
  return typename ConstNRowsBlockXpr<N>::Type(derived(), 0, 0, N, cols());
}
# 317 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/BlockMethods.h"
inline RowsBlockXpr bottomRows(Index n)
{
  return RowsBlockXpr(derived(), rows() - n, 0, n, cols());
}


inline ConstRowsBlockXpr bottomRows(Index n) const
{
  return ConstRowsBlockXpr(derived(), rows() - n, 0, n, cols());
}
# 337 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/BlockMethods.h"
template<int N>
inline typename NRowsBlockXpr<N>::Type bottomRows()
{
  return typename NRowsBlockXpr<N>::Type(derived(), rows() - N, 0, N, cols());
}


template<int N>
inline typename ConstNRowsBlockXpr<N>::Type bottomRows() const
{
  return typename ConstNRowsBlockXpr<N>::Type(derived(), rows() - N, 0, N, cols());
}
# 362 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/BlockMethods.h"
inline RowsBlockXpr middleRows(Index startRow, Index numRows)
{
  return RowsBlockXpr(derived(), startRow, 0, numRows, cols());
}


inline ConstRowsBlockXpr middleRows(Index startRow, Index numRows) const
{
  return ConstRowsBlockXpr(derived(), startRow, 0, numRows, cols());
}
# 383 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/BlockMethods.h"
template<int N>
inline typename NRowsBlockXpr<N>::Type middleRows(Index startRow)
{
  return typename NRowsBlockXpr<N>::Type(derived(), startRow, 0, N, cols());
}


template<int N>
inline typename ConstNRowsBlockXpr<N>::Type middleRows(Index startRow) const
{
  return typename ConstNRowsBlockXpr<N>::Type(derived(), startRow, 0, N, cols());
}
# 407 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/BlockMethods.h"
inline ColsBlockXpr leftCols(Index n)
{
  return ColsBlockXpr(derived(), 0, 0, rows(), n);
}


inline ConstColsBlockXpr leftCols(Index n) const
{
  return ConstColsBlockXpr(derived(), 0, 0, rows(), n);
}
# 427 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/BlockMethods.h"
template<int N>
inline typename NColsBlockXpr<N>::Type leftCols()
{
  return typename NColsBlockXpr<N>::Type(derived(), 0, 0, rows(), N);
}


template<int N>
inline typename ConstNColsBlockXpr<N>::Type leftCols() const
{
  return typename ConstNColsBlockXpr<N>::Type(derived(), 0, 0, rows(), N);
}
# 451 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/BlockMethods.h"
inline ColsBlockXpr rightCols(Index n)
{
  return ColsBlockXpr(derived(), 0, cols() - n, rows(), n);
}


inline ConstColsBlockXpr rightCols(Index n) const
{
  return ConstColsBlockXpr(derived(), 0, cols() - n, rows(), n);
}
# 471 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/BlockMethods.h"
template<int N>
inline typename NColsBlockXpr<N>::Type rightCols()
{
  return typename NColsBlockXpr<N>::Type(derived(), 0, cols() - N, rows(), N);
}


template<int N>
inline typename ConstNColsBlockXpr<N>::Type rightCols() const
{
  return typename ConstNColsBlockXpr<N>::Type(derived(), 0, cols() - N, rows(), N);
}
# 496 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/BlockMethods.h"
inline ColsBlockXpr middleCols(Index startCol, Index numCols)
{
  return ColsBlockXpr(derived(), 0, startCol, rows(), numCols);
}


inline ConstColsBlockXpr middleCols(Index startCol, Index numCols) const
{
  return ConstColsBlockXpr(derived(), 0, startCol, rows(), numCols);
}
# 517 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/BlockMethods.h"
template<int N>
inline typename NColsBlockXpr<N>::Type middleCols(Index startCol)
{
  return typename NColsBlockXpr<N>::Type(derived(), 0, startCol, rows(), N);
}


template<int N>
inline typename ConstNColsBlockXpr<N>::Type middleCols(Index startCol) const
{
  return typename ConstNColsBlockXpr<N>::Type(derived(), 0, startCol, rows(), N);
}
# 548 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/BlockMethods.h"
template<int BlockRows, int BlockCols>
inline Block<Derived, BlockRows, BlockCols> block(Index startRow, Index startCol)
{
  return Block<Derived, BlockRows, BlockCols>(derived(), startRow, startCol);
}


template<int BlockRows, int BlockCols>
inline const Block<const Derived, BlockRows, BlockCols> block(Index startRow, Index startCol) const
{
  return Block<const Derived, BlockRows, BlockCols>(derived(), startRow, startCol);
}







inline ColXpr col(Index i)
{
  return ColXpr(derived(), i);
}


inline ConstColXpr col(Index i) const
{
  return ConstColXpr(derived(), i);
}







inline RowXpr row(Index i)
{
  return RowXpr(derived(), i);
}


inline ConstRowXpr row(Index i) const
{
  return ConstRowXpr(derived(), i);
}
# 500 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseBase.h" 2
# 518 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseBase.h"
    template<typename Dest> inline void evalTo(Dest& ) const
    {
      if (Eigen::internal::static_assertion<bool((internal::is_same<Dest,void>::value))>::THE_EVAL_EVALTO_FUNCTION_SHOULD_NEVER_BE_CALLED_FOR_DENSE_OBJECTS) {};
    }

  protected:

    DenseBase()
    {




      if (Eigen::internal::static_assertion<bool(((!(MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1) || (int(IsRowMajor))) && (!(MaxColsAtCompileTime==1 && MaxRowsAtCompileTime!=1) || (int(!IsRowMajor)))))>::INVALID_STORAGE_ORDER_FOR_THIS_VECTOR_EXPRESSION) {}



    }

  private:
    explicit DenseBase(int);
    DenseBase(int,int);
    template<typename OtherDerived> explicit DenseBase(const DenseBase<OtherDerived>&);
};
# 278 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/MatrixBase.h" 1
# 61 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/MatrixBase.h"
template<typename Derived> class MatrixBase
  : public DenseBase<Derived>
{
  public:

    typedef MatrixBase StorageBaseType;
    typedef typename internal::traits<Derived>::StorageKind StorageKind;
    typedef typename internal::traits<Derived>::Index Index;
    typedef typename internal::traits<Derived>::Scalar Scalar;
    typedef typename internal::packet_traits<Scalar>::type PacketScalar;
    typedef typename NumTraits<Scalar>::Real RealScalar;

    typedef DenseBase<Derived> Base;
    using Base::RowsAtCompileTime;
    using Base::ColsAtCompileTime;
    using Base::SizeAtCompileTime;
    using Base::MaxRowsAtCompileTime;
    using Base::MaxColsAtCompileTime;
    using Base::MaxSizeAtCompileTime;
    using Base::IsVectorAtCompileTime;
    using Base::Flags;
    using Base::CoeffReadCost;

    using Base::derived;
    using Base::const_cast_derived;
    using Base::rows;
    using Base::cols;
    using Base::size;
    using Base::coeff;
    using Base::coeffRef;
    using Base::lazyAssign;
    using Base::eval;
    using Base::operator+=;
    using Base::operator-=;
    using Base::operator*=;
    using Base::operator/=;

    typedef typename Base::CoeffReturnType CoeffReturnType;
    typedef typename Base::ConstTransposeReturnType ConstTransposeReturnType;
    typedef typename Base::RowXpr RowXpr;
    typedef typename Base::ColXpr ColXpr;






    typedef Matrix<Scalar,(((int)RowsAtCompileTime == Dynamic || (int)ColsAtCompileTime == Dynamic) ? Dynamic : ((int)RowsAtCompileTime >= (int)ColsAtCompileTime) ? (int)RowsAtCompileTime : (int)ColsAtCompileTime),
                          (((int)RowsAtCompileTime == Dynamic || (int)ColsAtCompileTime == Dynamic) ? Dynamic : ((int)RowsAtCompileTime >= (int)ColsAtCompileTime) ? (int)RowsAtCompileTime : (int)ColsAtCompileTime)> SquareMatrixType;




    inline Index diagonalSize() const { return (std::min)(rows(),cols()); }







    typedef Matrix<typename internal::traits<Derived>::Scalar,
                internal::traits<Derived>::RowsAtCompileTime,
                internal::traits<Derived>::ColsAtCompileTime,
                AutoAlign | (internal::traits<Derived>::Flags&RowMajorBit ? RowMajor : ColMajor),
                internal::traits<Derived>::MaxRowsAtCompileTime,
                internal::traits<Derived>::MaxColsAtCompileTime
          > PlainObject;



    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Derived> ConstantReturnType;

    typedef typename internal::conditional<NumTraits<Scalar>::IsComplex,
                        CwiseUnaryOp<internal::scalar_conjugate_op<Scalar>, ConstTransposeReturnType>,
                        ConstTransposeReturnType
                     >::type AdjointReturnType;

    typedef Matrix<std::complex<RealScalar>, internal::traits<Derived>::ColsAtCompileTime, 1, ColMajor> EigenvaluesReturnType;

    typedef CwiseNullaryOp<internal::scalar_identity_op<Scalar>,Derived> IdentityReturnType;

    typedef Block<const CwiseNullaryOp<internal::scalar_identity_op<Scalar>, SquareMatrixType>,
                  internal::traits<Derived>::RowsAtCompileTime,
                  internal::traits<Derived>::ColsAtCompileTime> BasisReturnType;




# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/CommonCwiseUnaryOps.h" 1
# 31 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/CommonCwiseUnaryOps.h"
typedef CwiseUnaryOp<internal::scalar_multiple_op<Scalar>, const Derived> ScalarMultipleReturnType;

typedef CwiseUnaryOp<internal::scalar_quotient1_op<Scalar>, const Derived> ScalarQuotient1ReturnType;

typedef typename internal::conditional<NumTraits<Scalar>::IsComplex,
                    const CwiseUnaryOp<internal::scalar_conjugate_op<Scalar>, const Derived>,
                    const Derived&
                  >::type ConjugateReturnType;

typedef typename internal::conditional<NumTraits<Scalar>::IsComplex,
                    const CwiseUnaryOp<internal::scalar_real_op<Scalar>, const Derived>,
                    const Derived&
                  >::type RealReturnType;

typedef typename internal::conditional<NumTraits<Scalar>::IsComplex,
                    CwiseUnaryView<internal::scalar_real_ref_op<Scalar>, Derived>,
                    Derived&
                  >::type NonConstRealReturnType;

typedef CwiseUnaryOp<internal::scalar_imag_op<Scalar>, const Derived> ImagReturnType;

typedef CwiseUnaryView<internal::scalar_imag_ref_op<Scalar>, Derived> NonConstImagReturnType;





inline const CwiseUnaryOp<internal::scalar_opposite_op<typename internal::traits<Derived>::Scalar>, const Derived>
operator-() const { return derived(); }



inline const ScalarMultipleReturnType
operator*(const Scalar& scalar) const
{
  return CwiseUnaryOp<internal::scalar_multiple_op<Scalar>, const Derived>
    (derived(), internal::scalar_multiple_op<Scalar>(scalar));
}






inline const CwiseUnaryOp<internal::scalar_quotient1_op<typename internal::traits<Derived>::Scalar>, const Derived>
operator/(const Scalar& scalar) const
{
  return CwiseUnaryOp<internal::scalar_quotient1_op<Scalar>, const Derived>
    (derived(), internal::scalar_quotient1_op<Scalar>(scalar));
}


inline const CwiseUnaryOp<internal::scalar_multiple2_op<Scalar,std::complex<Scalar> >, const Derived>
operator*(const std::complex<Scalar>& scalar) const
{
  return CwiseUnaryOp<internal::scalar_multiple2_op<Scalar,std::complex<Scalar> >, const Derived>
    (*static_cast<const Derived*>(this), internal::scalar_multiple2_op<Scalar,std::complex<Scalar> >(scalar));
}

inline friend const ScalarMultipleReturnType
operator*(const Scalar& scalar, const StorageBaseType& matrix)
{ return matrix*scalar; }

inline friend const CwiseUnaryOp<internal::scalar_multiple2_op<Scalar,std::complex<Scalar> >, const Derived>
operator*(const std::complex<Scalar>& scalar, const StorageBaseType& matrix)
{ return matrix*scalar; }
# 105 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/CommonCwiseUnaryOps.h"
template<typename NewType>
typename internal::cast_return_type<Derived,const CwiseUnaryOp<internal::scalar_cast_op<typename internal::traits<Derived>::Scalar, NewType>, const Derived> >::type
cast() const
{
  return derived();
}




inline ConjugateReturnType
conjugate() const
{
  return ConjugateReturnType(derived());
}




inline RealReturnType
real() const { return derived(); }




inline const ImagReturnType
imag() const { return derived(); }
# 152 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/CommonCwiseUnaryOps.h"
template<typename CustomUnaryOp>
inline const CwiseUnaryOp<CustomUnaryOp, const Derived>
unaryExpr(const CustomUnaryOp& func = CustomUnaryOp()) const
{
  return CwiseUnaryOp<CustomUnaryOp, const Derived>(derived(), func);
}
# 170 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/CommonCwiseUnaryOps.h"
template<typename CustomViewOp>
inline const CwiseUnaryView<CustomViewOp, const Derived>
unaryViewExpr(const CustomViewOp& func = CustomViewOp()) const
{
  return CwiseUnaryView<CustomViewOp, const Derived>(derived(), func);
}




inline NonConstRealReturnType
real() { return derived(); }




inline NonConstImagReturnType
imag() { return derived(); }
# 150 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/MatrixBase.h" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h" 1
# 34 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h"
template<typename OtherDerived> inline const CwiseBinaryOp<internal::scalar_difference_op<Scalar>, const Derived, const OtherDerived> (operator-)(const Eigen::MatrixBase<OtherDerived> &other) const { return CwiseBinaryOp<internal::scalar_difference_op<Scalar>, const Derived, const OtherDerived>(derived(), other.derived()); }







template<typename OtherDerived> inline const CwiseBinaryOp<internal::scalar_sum_op<Scalar>, const Derived, const OtherDerived> (operator+)(const Eigen::MatrixBase<OtherDerived> &other) const { return CwiseBinaryOp<internal::scalar_sum_op<Scalar>, const Derived, const OtherDerived>(derived(), other.derived()); }
# 55 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h"
template<typename CustomBinaryOp, typename OtherDerived>
inline const CwiseBinaryOp<CustomBinaryOp, const Derived, const OtherDerived>
binaryExpr(const Eigen::MatrixBase<OtherDerived> &other, const CustomBinaryOp& func = CustomBinaryOp()) const
{
  return CwiseBinaryOp<CustomBinaryOp, const Derived, const OtherDerived>(derived(), other.derived(), func);
}
# 151 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/MatrixBase.h" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/MatrixCwiseUnaryOps.h" 1
# 35 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/MatrixCwiseUnaryOps.h"
inline const CwiseUnaryOp<internal::scalar_abs_op<Scalar>, const Derived>
cwiseAbs() const { return derived(); }
# 45 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/MatrixCwiseUnaryOps.h"
inline const CwiseUnaryOp<internal::scalar_abs2_op<Scalar>, const Derived>
cwiseAbs2() const { return derived(); }
# 55 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/MatrixCwiseUnaryOps.h"
inline const CwiseUnaryOp<internal::scalar_sqrt_op<Scalar>, const Derived>
cwiseSqrt() const { return derived(); }
# 65 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/MatrixCwiseUnaryOps.h"
inline const CwiseUnaryOp<internal::scalar_inverse_op<Scalar>, const Derived>
cwiseInverse() const { return derived(); }
# 77 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/MatrixCwiseUnaryOps.h"
inline const CwiseUnaryOp<std::binder1st<std::equal_to<Scalar> >, const Derived>
cwiseEqual(const Scalar& s) const
{
  return CwiseUnaryOp<std::binder1st<std::equal_to<Scalar> >,const Derived>
          (derived(), std::bind1st(std::equal_to<Scalar>(), s));
}
# 152 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/MatrixBase.h" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/MatrixCwiseBinaryOps.h" 1
# 35 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/MatrixCwiseBinaryOps.h"
template<typename OtherDerived>
inline const CwiseBinaryOp< internal::scalar_product_op< typename internal::traits<Derived>::Scalar, typename internal::traits<OtherDerived>::Scalar >, const Derived, const OtherDerived >
cwiseProduct(const Eigen::MatrixBase<OtherDerived> &other) const
{
  return CwiseBinaryOp< internal::scalar_product_op< typename internal::traits<Derived>::Scalar, typename internal::traits<OtherDerived>::Scalar >, const Derived, const OtherDerived >(derived(), other.derived());
}
# 54 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/MatrixCwiseBinaryOps.h"
template<typename OtherDerived>
inline const CwiseBinaryOp<std::equal_to<Scalar>, const Derived, const OtherDerived>
cwiseEqual(const Eigen::MatrixBase<OtherDerived> &other) const
{
  return CwiseBinaryOp<std::equal_to<Scalar>, const Derived, const OtherDerived>(derived(), other.derived());
}
# 73 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/MatrixCwiseBinaryOps.h"
template<typename OtherDerived>
inline const CwiseBinaryOp<std::not_equal_to<Scalar>, const Derived, const OtherDerived>
cwiseNotEqual(const Eigen::MatrixBase<OtherDerived> &other) const
{
  return CwiseBinaryOp<std::not_equal_to<Scalar>, const Derived, const OtherDerived>(derived(), other.derived());
}
# 87 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/MatrixCwiseBinaryOps.h"
template<typename OtherDerived>
inline const CwiseBinaryOp<internal::scalar_min_op<Scalar>, const Derived, const OtherDerived>
cwiseMin(const Eigen::MatrixBase<OtherDerived> &other) const
{
  return CwiseBinaryOp<internal::scalar_min_op<Scalar>, const Derived, const OtherDerived>(derived(), other.derived());
}
# 101 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/MatrixCwiseBinaryOps.h"
template<typename OtherDerived>
inline const CwiseBinaryOp<internal::scalar_max_op<Scalar>, const Derived, const OtherDerived>
cwiseMax(const Eigen::MatrixBase<OtherDerived> &other) const
{
  return CwiseBinaryOp<internal::scalar_max_op<Scalar>, const Derived, const OtherDerived>(derived(), other.derived());
}
# 115 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/MatrixCwiseBinaryOps.h"
template<typename OtherDerived>
inline const CwiseBinaryOp<internal::scalar_quotient_op<Scalar>, const Derived, const OtherDerived>
cwiseQuotient(const Eigen::MatrixBase<OtherDerived> &other) const
{
  return CwiseBinaryOp<internal::scalar_quotient_op<Scalar>, const Derived, const OtherDerived>(derived(), other.derived());
}
# 153 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/MatrixBase.h" 2








    Derived& operator=(const MatrixBase& other);




    template <typename OtherDerived>
    Derived& operator=(const DenseBase<OtherDerived>& other);

    template <typename OtherDerived>
    Derived& operator=(const EigenBase<OtherDerived>& other);

    template<typename OtherDerived>
    Derived& operator=(const ReturnByValue<OtherDerived>& other);


    template<typename ProductDerived, typename Lhs, typename Rhs>
    Derived& lazyAssign(const ProductBase<ProductDerived, Lhs,Rhs>& other);


    template<typename OtherDerived>
    Derived& operator+=(const MatrixBase<OtherDerived>& other);
    template<typename OtherDerived>
    Derived& operator-=(const MatrixBase<OtherDerived>& other);

    template<typename OtherDerived>
    const typename ProductReturnType<Derived,OtherDerived>::Type
    operator*(const MatrixBase<OtherDerived> &other) const;

    template<typename OtherDerived>
    const typename LazyProductReturnType<Derived,OtherDerived>::Type
    lazyProduct(const MatrixBase<OtherDerived> &other) const;

    template<typename OtherDerived>
    Derived& operator*=(const EigenBase<OtherDerived>& other);

    template<typename OtherDerived>
    void applyOnTheLeft(const EigenBase<OtherDerived>& other);

    template<typename OtherDerived>
    void applyOnTheRight(const EigenBase<OtherDerived>& other);

    template<typename DiagonalDerived>
    const DiagonalProduct<Derived, DiagonalDerived, OnTheRight>
    operator*(const DiagonalBase<DiagonalDerived> &diagonal) const;

    template<typename OtherDerived>
    typename internal::scalar_product_traits<typename internal::traits<Derived>::Scalar,typename internal::traits<OtherDerived>::Scalar>::ReturnType
    dot(const MatrixBase<OtherDerived>& other) const;






    RealScalar squaredNorm() const;
    RealScalar norm() const;
    RealScalar stableNorm() const;
    RealScalar blueNorm() const;
    RealScalar hypotNorm() const;
    const PlainObject normalized() const;
    void normalize();

    const AdjointReturnType adjoint() const;
    void adjointInPlace();

    typedef Diagonal<Derived> DiagonalReturnType;
    DiagonalReturnType diagonal();
    typedef const Diagonal<const Derived> ConstDiagonalReturnType;
    const ConstDiagonalReturnType diagonal() const;

    template<int Index> struct DiagonalIndexReturnType { typedef Diagonal<Derived,Index> Type; };
    template<int Index> struct ConstDiagonalIndexReturnType { typedef const Diagonal<const Derived,Index> Type; };

    template<int Index> typename DiagonalIndexReturnType<Index>::Type diagonal();
    template<int Index> typename ConstDiagonalIndexReturnType<Index>::Type diagonal() const;







    typename DiagonalIndexReturnType<Dynamic>::Type diagonal(Index index);
    typename ConstDiagonalIndexReturnType<Dynamic>::Type diagonal(Index index) const;
# 259 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/MatrixBase.h"
    template<unsigned int Mode> struct TriangularViewReturnType { typedef TriangularView<Derived, Mode> Type; };
    template<unsigned int Mode> struct ConstTriangularViewReturnType { typedef const TriangularView<const Derived, Mode> Type; };

    template<unsigned int Mode> typename TriangularViewReturnType<Mode>::Type triangularView();
    template<unsigned int Mode> typename ConstTriangularViewReturnType<Mode>::Type triangularView() const;

    template<unsigned int UpLo> struct SelfAdjointViewReturnType { typedef SelfAdjointView<Derived, UpLo> Type; };
    template<unsigned int UpLo> struct ConstSelfAdjointViewReturnType { typedef const SelfAdjointView<const Derived, UpLo> Type; };

    template<unsigned int UpLo> typename SelfAdjointViewReturnType<UpLo>::Type selfadjointView();
    template<unsigned int UpLo> typename ConstSelfAdjointViewReturnType<UpLo>::Type selfadjointView() const;

    const SparseView<Derived> sparseView(const Scalar& m_reference = Scalar(0),
                                         typename NumTraits<Scalar>::Real m_epsilon = NumTraits<Scalar>::dummy_precision()) const;
    static const IdentityReturnType Identity();
    static const IdentityReturnType Identity(Index rows, Index cols);
    static const BasisReturnType Unit(Index size, Index i);
    static const BasisReturnType Unit(Index i);
    static const BasisReturnType UnitX();
    static const BasisReturnType UnitY();
    static const BasisReturnType UnitZ();
    static const BasisReturnType UnitW();

    const DiagonalWrapper<const Derived> asDiagonal() const;
    const PermutationWrapper<const Derived> asPermutation() const;

    Derived& setIdentity();
    Derived& setIdentity(Index rows, Index cols);

    bool isIdentity(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;
    bool isDiagonal(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;

    bool isUpperTriangular(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;
    bool isLowerTriangular(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;

    template<typename OtherDerived>
    bool isOrthogonal(const MatrixBase<OtherDerived>& other,
                      RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;
    bool isUnitary(RealScalar prec = NumTraits<Scalar>::dummy_precision()) const;





    template<typename OtherDerived>
    inline bool operator==(const MatrixBase<OtherDerived>& other) const
    { return cwiseEqual(other).all(); }





    template<typename OtherDerived>
    inline bool operator!=(const MatrixBase<OtherDerived>& other) const
    { return cwiseNotEqual(other).any(); }

    NoAlias<Derived,Eigen::MatrixBase > noalias();

    inline const ForceAlignedAccess<Derived> forceAlignedAccess() const;
    inline ForceAlignedAccess<Derived> forceAlignedAccess();
    template<bool Enable> inline typename internal::add_const_on_value_type<typename internal::conditional<Enable,ForceAlignedAccess<Derived>,Derived&>::type>::type forceAlignedAccessIf() const;
    template<bool Enable> inline typename internal::conditional<Enable,ForceAlignedAccess<Derived>,Derived&>::type forceAlignedAccessIf();

    Scalar trace() const;



    template<int p> RealScalar lpNorm() const;

    MatrixBase<Derived>& matrix() { return *this; }
    const MatrixBase<Derived>& matrix() const { return *this; }



    ArrayWrapper<Derived> array() { return derived(); }
    const ArrayWrapper<Derived> array() const { return derived(); }



    const FullPivLU<PlainObject> fullPivLu() const;
    const PartialPivLU<PlainObject> partialPivLu() const;
# 350 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/MatrixBase.h"
    const PartialPivLU<PlainObject> lu() const;
# 360 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/MatrixBase.h"
    const internal::inverse_impl<Derived> inverse() const;
    template<typename ResultType>
    void computeInverseAndDetWithCheck(
      ResultType& inverse,
      typename ResultType::Scalar& determinant,
      bool& invertible,
      const RealScalar& absDeterminantThreshold = NumTraits<Scalar>::dummy_precision()
    ) const;
    template<typename ResultType>
    void computeInverseWithCheck(
      ResultType& inverse,
      bool& invertible,
      const RealScalar& absDeterminantThreshold = NumTraits<Scalar>::dummy_precision()
    ) const;
    Scalar determinant() const;



    const LLT<PlainObject> llt() const;
    const LDLT<PlainObject> ldlt() const;



    const HouseholderQR<PlainObject> householderQr() const;
    const ColPivHouseholderQR<PlainObject> colPivHouseholderQr() const;
    const FullPivHouseholderQR<PlainObject> fullPivHouseholderQr() const;





    EigenvaluesReturnType eigenvalues() const;
    RealScalar operatorNorm() const;



    JacobiSVD<PlainObject> jacobiSvd(unsigned int computationOptions = 0) const;
# 406 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/MatrixBase.h"
    template<typename OtherDerived> struct cross_product_return_type {
      typedef typename internal::scalar_product_traits<typename internal::traits<Derived>::Scalar,typename internal::traits<OtherDerived>::Scalar>::ReturnType Scalar;
      typedef Matrix<Scalar,MatrixBase::RowsAtCompileTime,MatrixBase::ColsAtCompileTime> type;
    };

    template<typename OtherDerived>
    typename cross_product_return_type<OtherDerived>::type
    cross(const MatrixBase<OtherDerived>& other) const;
    template<typename OtherDerived>
    PlainObject cross3(const MatrixBase<OtherDerived>& other) const;
    PlainObject unitOrthogonal(void) const;
    Matrix<Scalar,3,1> eulerAngles(Index a0, Index a1, Index a2) const;


    ScalarMultipleReturnType operator*(const UniformScaling<Scalar>& s) const;

    enum { HomogeneousReturnTypeDirection = ColsAtCompileTime==1?Vertical:Horizontal };
    typedef Homogeneous<Derived, HomogeneousReturnTypeDirection> HomogeneousReturnType;
    HomogeneousReturnType homogeneous() const;


    enum {
      SizeMinusOne = SizeAtCompileTime==Dynamic ? Dynamic : SizeAtCompileTime-1
    };
    typedef Block<const Derived,
                  internal::traits<Derived>::ColsAtCompileTime==1 ? SizeMinusOne : 1,
                  internal::traits<Derived>::ColsAtCompileTime==1 ? 1 : SizeMinusOne> ConstStartMinusOne;
    typedef CwiseUnaryOp<internal::scalar_quotient1_op<typename internal::traits<Derived>::Scalar>,
                const ConstStartMinusOne > HNormalizedReturnType;

    const HNormalizedReturnType hnormalized() const;



    void makeHouseholderInPlace(Scalar& tau, RealScalar& beta);
    template<typename EssentialPart>
    void makeHouseholder(EssentialPart& essential,
                         Scalar& tau, RealScalar& beta) const;
    template<typename EssentialPart>
    void applyHouseholderOnTheLeft(const EssentialPart& essential,
                                   const Scalar& tau,
                                   Scalar* workspace);
    template<typename EssentialPart>
    void applyHouseholderOnTheRight(const EssentialPart& essential,
                                    const Scalar& tau,
                                    Scalar* workspace);



    template<typename OtherScalar>
    void applyOnTheLeft(Index p, Index q, const JacobiRotation<OtherScalar>& j);
    template<typename OtherScalar>
    void applyOnTheRight(Index p, Index q, const JacobiRotation<OtherScalar>& j);



    typedef typename internal::stem_function<Scalar>::type StemFunction;
    const MatrixExponentialReturnValue<Derived> exp() const;
    const MatrixFunctionReturnValue<Derived> matrixFunction(StemFunction f) const;
    const MatrixFunctionReturnValue<Derived> cosh() const;
    const MatrixFunctionReturnValue<Derived> sinh() const;
    const MatrixFunctionReturnValue<Derived> cos() const;
    const MatrixFunctionReturnValue<Derived> sin() const;
# 505 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/MatrixBase.h"
  protected:
    MatrixBase() : Base() {}

  private:
    explicit MatrixBase(int);
    MatrixBase(int,int);
    template<typename OtherDerived> explicit MatrixBase(const MatrixBase<OtherDerived>&);
  protected:

    template<typename OtherDerived> Derived& operator+=(const ArrayBase<OtherDerived>& )
    {if (Eigen::internal::static_assertion<bool(sizeof(typename OtherDerived::Scalar)==-1)>::YOU_CANNOT_MIX_ARRAYS_AND_MATRICES) {};}

    template<typename OtherDerived> Derived& operator-=(const ArrayBase<OtherDerived>& )
    {if (Eigen::internal::static_assertion<bool(sizeof(typename OtherDerived::Scalar)==-1)>::YOU_CANNOT_MIX_ARRAYS_AND_MATRICES) {};}
};
# 279 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/EigenBase.h" 1
# 40 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/EigenBase.h"
template<typename Derived> struct EigenBase
{


  typedef typename internal::traits<Derived>::StorageKind StorageKind;
  typedef typename internal::traits<Derived>::Index Index;


  Derived& derived() { return *static_cast<Derived*>(this); }

  const Derived& derived() const { return *static_cast<const Derived*>(this); }

  inline Derived& const_cast_derived() const
  { return *static_cast<Derived*>(const_cast<EigenBase*>(this)); }
  inline const Derived& const_derived() const
  { return *static_cast<const Derived*>(this); }


  inline Index rows() const { return derived().rows(); }

  inline Index cols() const { return derived().cols(); }


  inline Index size() const { return rows() * cols(); }


  template<typename Dest> inline void evalTo(Dest& dst) const
  { derived().evalTo(dst); }


  template<typename Dest> inline void addTo(Dest& dst) const
  {


    typename Dest::PlainObject res(rows(),cols());
    evalTo(res);
    dst += res;
  }


  template<typename Dest> inline void subTo(Dest& dst) const
  {


    typename Dest::PlainObject res(rows(),cols());
    evalTo(res);
    dst -= res;
  }


  template<typename Dest> inline void applyThisOnTheRight(Dest& dst) const
  {


    dst = dst * this->derived();
  }


  template<typename Dest> inline void applyThisOnTheLeft(Dest& dst) const
  {


    dst = this->derived() * dst;
  }

};
# 119 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/EigenBase.h"
template<typename Derived>
template<typename OtherDerived>
Derived& DenseBase<Derived>::operator=(const EigenBase<OtherDerived> &other)
{
  other.derived().evalTo(derived());
  return derived();
}

template<typename Derived>
template<typename OtherDerived>
Derived& DenseBase<Derived>::operator+=(const EigenBase<OtherDerived> &other)
{
  other.derived().addTo(derived());
  return derived();
}

template<typename Derived>
template<typename OtherDerived>
Derived& DenseBase<Derived>::operator-=(const EigenBase<OtherDerived> &other)
{
  other.derived().subTo(derived());
  return derived();
}





template<typename Derived>
template<typename OtherDerived>
inline Derived&
MatrixBase<Derived>::operator*=(const EigenBase<OtherDerived> &other)
{
  other.derived().applyThisOnTheRight(derived());
  return derived();
}


template<typename Derived>
template<typename OtherDerived>
inline void MatrixBase<Derived>::applyOnTheRight(const EigenBase<OtherDerived> &other)
{
  other.derived().applyThisOnTheRight(derived());
}


template<typename Derived>
template<typename OtherDerived>
inline void MatrixBase<Derived>::applyOnTheLeft(const EigenBase<OtherDerived> &other)
{
  other.derived().applyThisOnTheLeft(derived());
}
# 280 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2



# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Assign.h" 1
# 30 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Assign.h"
namespace internal {





template <typename Derived, typename OtherDerived>
struct assign_traits
{
public:
  enum {
    DstIsAligned = Derived::Flags & AlignedBit,
    DstHasDirectAccess = Derived::Flags & DirectAccessBit,
    SrcIsAligned = OtherDerived::Flags & AlignedBit,
    JointAlignment = bool(DstIsAligned) && bool(SrcIsAligned) ? Aligned : Unaligned
  };

private:
  enum {
    InnerSize = int(Derived::IsVectorAtCompileTime) ? int(Derived::SizeAtCompileTime)
              : int(Derived::Flags)&RowMajorBit ? int(Derived::ColsAtCompileTime)
              : int(Derived::RowsAtCompileTime),
    InnerMaxSize = int(Derived::IsVectorAtCompileTime) ? int(Derived::MaxSizeAtCompileTime)
              : int(Derived::Flags)&RowMajorBit ? int(Derived::MaxColsAtCompileTime)
              : int(Derived::MaxRowsAtCompileTime),
    MaxSizeAtCompileTime = Derived::SizeAtCompileTime,
    PacketSize = packet_traits<typename Derived::Scalar>::size
  };

  enum {
    StorageOrdersAgree = (int(Derived::IsRowMajor) == int(OtherDerived::IsRowMajor)),
    MightVectorize = StorageOrdersAgree
                  && (int(Derived::Flags) & int(OtherDerived::Flags) & ActualPacketAccessBit),
    MayInnerVectorize = MightVectorize && int(InnerSize)!=Dynamic && int(InnerSize)%int(PacketSize)==0
                       && int(DstIsAligned) && int(SrcIsAligned),
    MayLinearize = StorageOrdersAgree && (int(Derived::Flags) & int(OtherDerived::Flags) & LinearAccessBit),
    MayLinearVectorize = MightVectorize && MayLinearize && DstHasDirectAccess
                       && (DstIsAligned || MaxSizeAtCompileTime == Dynamic),


    MaySliceVectorize = MightVectorize && DstHasDirectAccess
                       && (int(InnerMaxSize)==Dynamic || int(InnerMaxSize)>=3*PacketSize)



  };

public:
  enum {
    Traversal = int(MayInnerVectorize) ? int(InnerVectorizedTraversal)
              : int(MayLinearVectorize) ? int(LinearVectorizedTraversal)
              : int(MaySliceVectorize) ? int(SliceVectorizedTraversal)
              : int(MayLinearize) ? int(LinearTraversal)
                                        : int(DefaultTraversal),
    Vectorized = int(Traversal) == InnerVectorizedTraversal
              || int(Traversal) == LinearVectorizedTraversal
              || int(Traversal) == SliceVectorizedTraversal
  };

private:
  enum {
    UnrollingLimit = 100 * (Vectorized ? int(PacketSize) : 1),
    MayUnrollCompletely = int(Derived::SizeAtCompileTime) != Dynamic
                       && int(OtherDerived::CoeffReadCost) != Dynamic
                       && int(Derived::SizeAtCompileTime) * int(OtherDerived::CoeffReadCost) <= int(UnrollingLimit),
    MayUnrollInner = int(InnerSize) != Dynamic
                       && int(OtherDerived::CoeffReadCost) != Dynamic
                       && int(InnerSize) * int(OtherDerived::CoeffReadCost) <= int(UnrollingLimit)
  };

public:
  enum {
    Unrolling = (int(Traversal) == int(InnerVectorizedTraversal) || int(Traversal) == int(DefaultTraversal))
                ? (
                    int(MayUnrollCompletely) ? int(CompleteUnrolling)
                  : int(MayUnrollInner) ? int(InnerUnrolling)
                                             : int(NoUnrolling)
                  )
              : int(Traversal) == int(LinearVectorizedTraversal)
                ? ( bool(MayUnrollCompletely) && bool(DstIsAligned) ? int(CompleteUnrolling) : int(NoUnrolling) )
              : int(Traversal) == int(LinearTraversal)
                ? ( bool(MayUnrollCompletely) ? int(CompleteUnrolling) : int(NoUnrolling) )
              : int(NoUnrolling)
  };
# 137 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Assign.h"
};
# 147 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Assign.h"
template<typename Derived1, typename Derived2, int Index, int Stop>
struct assign_DefaultTraversal_CompleteUnrolling
{
  enum {
    outer = Index / Derived1::InnerSizeAtCompileTime,
    inner = Index % Derived1::InnerSizeAtCompileTime
  };

  inline static void run(Derived1 &dst, const Derived2 &src)
  {
    dst.copyCoeffByOuterInner(outer, inner, src);
    assign_DefaultTraversal_CompleteUnrolling<Derived1, Derived2, Index+1, Stop>::run(dst, src);
  }
};

template<typename Derived1, typename Derived2, int Stop>
struct assign_DefaultTraversal_CompleteUnrolling<Derived1, Derived2, Stop, Stop>
{
  inline static void run(Derived1 &, const Derived2 &) {}
};

template<typename Derived1, typename Derived2, int Index, int Stop>
struct assign_DefaultTraversal_InnerUnrolling
{
  inline static void run(Derived1 &dst, const Derived2 &src, int outer)
  {
    dst.copyCoeffByOuterInner(outer, Index, src);
    assign_DefaultTraversal_InnerUnrolling<Derived1, Derived2, Index+1, Stop>::run(dst, src, outer);
  }
};

template<typename Derived1, typename Derived2, int Stop>
struct assign_DefaultTraversal_InnerUnrolling<Derived1, Derived2, Stop, Stop>
{
  inline static void run(Derived1 &, const Derived2 &, int) {}
};





template<typename Derived1, typename Derived2, int Index, int Stop>
struct assign_LinearTraversal_CompleteUnrolling
{
  inline static void run(Derived1 &dst, const Derived2 &src)
  {
    dst.copyCoeff(Index, src);
    assign_LinearTraversal_CompleteUnrolling<Derived1, Derived2, Index+1, Stop>::run(dst, src);
  }
};

template<typename Derived1, typename Derived2, int Stop>
struct assign_LinearTraversal_CompleteUnrolling<Derived1, Derived2, Stop, Stop>
{
  inline static void run(Derived1 &, const Derived2 &) {}
};





template<typename Derived1, typename Derived2, int Index, int Stop>
struct assign_innervec_CompleteUnrolling
{
  enum {
    outer = Index / Derived1::InnerSizeAtCompileTime,
    inner = Index % Derived1::InnerSizeAtCompileTime,
    JointAlignment = assign_traits<Derived1,Derived2>::JointAlignment
  };

  inline static void run(Derived1 &dst, const Derived2 &src)
  {
    dst.template copyPacketByOuterInner<Derived2, Aligned, JointAlignment>(outer, inner, src);
    assign_innervec_CompleteUnrolling<Derived1, Derived2,
      Index+packet_traits<typename Derived1::Scalar>::size, Stop>::run(dst, src);
  }
};

template<typename Derived1, typename Derived2, int Stop>
struct assign_innervec_CompleteUnrolling<Derived1, Derived2, Stop, Stop>
{
  inline static void run(Derived1 &, const Derived2 &) {}
};

template<typename Derived1, typename Derived2, int Index, int Stop>
struct assign_innervec_InnerUnrolling
{
  inline static void run(Derived1 &dst, const Derived2 &src, int outer)
  {
    dst.template copyPacketByOuterInner<Derived2, Aligned, Aligned>(outer, Index, src);
    assign_innervec_InnerUnrolling<Derived1, Derived2,
      Index+packet_traits<typename Derived1::Scalar>::size, Stop>::run(dst, src, outer);
  }
};

template<typename Derived1, typename Derived2, int Stop>
struct assign_innervec_InnerUnrolling<Derived1, Derived2, Stop, Stop>
{
  inline static void run(Derived1 &, const Derived2 &, int) {}
};





template<typename Derived1, typename Derived2,
         int Traversal = assign_traits<Derived1, Derived2>::Traversal,
         int Unrolling = assign_traits<Derived1, Derived2>::Unrolling>
struct assign_impl;





template<typename Derived1, typename Derived2, int Unrolling>
struct assign_impl<Derived1, Derived2, InvalidTraversal, Unrolling>
{
  inline static void run(Derived1 &, const Derived2 &) { }
};

template<typename Derived1, typename Derived2>
struct assign_impl<Derived1, Derived2, DefaultTraversal, NoUnrolling>
{
  typedef typename Derived1::Index Index;
  inline static void run(Derived1 &dst, const Derived2 &src)
  {
    const Index innerSize = dst.innerSize();
    const Index outerSize = dst.outerSize();
    for(Index outer = 0; outer < outerSize; ++outer)
      for(Index inner = 0; inner < innerSize; ++inner)
        dst.copyCoeffByOuterInner(outer, inner, src);
  }
};

template<typename Derived1, typename Derived2>
struct assign_impl<Derived1, Derived2, DefaultTraversal, CompleteUnrolling>
{
  inline static void run(Derived1 &dst, const Derived2 &src)
  {
    assign_DefaultTraversal_CompleteUnrolling<Derived1, Derived2, 0, Derived1::SizeAtCompileTime>
      ::run(dst, src);
  }
};

template<typename Derived1, typename Derived2>
struct assign_impl<Derived1, Derived2, DefaultTraversal, InnerUnrolling>
{
  typedef typename Derived1::Index Index;
  inline static void run(Derived1 &dst, const Derived2 &src)
  {
    const Index outerSize = dst.outerSize();
    for(Index outer = 0; outer < outerSize; ++outer)
      assign_DefaultTraversal_InnerUnrolling<Derived1, Derived2, 0, Derived1::InnerSizeAtCompileTime>
        ::run(dst, src, outer);
  }
};





template<typename Derived1, typename Derived2>
struct assign_impl<Derived1, Derived2, LinearTraversal, NoUnrolling>
{
  typedef typename Derived1::Index Index;
  inline static void run(Derived1 &dst, const Derived2 &src)
  {
    const Index size = dst.size();
    for(Index i = 0; i < size; ++i)
      dst.copyCoeff(i, src);
  }
};

template<typename Derived1, typename Derived2>
struct assign_impl<Derived1, Derived2, LinearTraversal, CompleteUnrolling>
{
  inline static void run(Derived1 &dst, const Derived2 &src)
  {
    assign_LinearTraversal_CompleteUnrolling<Derived1, Derived2, 0, Derived1::SizeAtCompileTime>
      ::run(dst, src);
  }
};





template<typename Derived1, typename Derived2>
struct assign_impl<Derived1, Derived2, InnerVectorizedTraversal, NoUnrolling>
{
  typedef typename Derived1::Index Index;
  inline static void run(Derived1 &dst, const Derived2 &src)
  {
    const Index innerSize = dst.innerSize();
    const Index outerSize = dst.outerSize();
    const Index packetSize = packet_traits<typename Derived1::Scalar>::size;
    for(Index outer = 0; outer < outerSize; ++outer)
      for(Index inner = 0; inner < innerSize; inner+=packetSize)
        dst.template copyPacketByOuterInner<Derived2, Aligned, Aligned>(outer, inner, src);
  }
};

template<typename Derived1, typename Derived2>
struct assign_impl<Derived1, Derived2, InnerVectorizedTraversal, CompleteUnrolling>
{
  inline static void run(Derived1 &dst, const Derived2 &src)
  {
    assign_innervec_CompleteUnrolling<Derived1, Derived2, 0, Derived1::SizeAtCompileTime>
      ::run(dst, src);
  }
};

template<typename Derived1, typename Derived2>
struct assign_impl<Derived1, Derived2, InnerVectorizedTraversal, InnerUnrolling>
{
  typedef typename Derived1::Index Index;
  inline static void run(Derived1 &dst, const Derived2 &src)
  {
    const Index outerSize = dst.outerSize();
    for(Index outer = 0; outer < outerSize; ++outer)
      assign_innervec_InnerUnrolling<Derived1, Derived2, 0, Derived1::InnerSizeAtCompileTime>
        ::run(dst, src, outer);
  }
};





template <bool IsAligned = false>
struct unaligned_assign_impl
{
  template <typename Derived, typename OtherDerived>
  static inline void run(const Derived&, OtherDerived&, typename Derived::Index, typename Derived::Index) {}
};

template <>
struct unaligned_assign_impl<false>
{






  template <typename Derived, typename OtherDerived>
  static inline void run(const Derived& src, OtherDerived& dst, typename Derived::Index start, typename Derived::Index end)

  {
    for (typename Derived::Index index = start; index < end; ++index)
      dst.copyCoeff(index, src);
  }
};

template<typename Derived1, typename Derived2>
struct assign_impl<Derived1, Derived2, LinearVectorizedTraversal, NoUnrolling>
{
  typedef typename Derived1::Index Index;
  inline static void run(Derived1 &dst, const Derived2 &src)
  {
    const Index size = dst.size();
    typedef packet_traits<typename Derived1::Scalar> PacketTraits;
    enum {
      packetSize = PacketTraits::size,
      dstAlignment = PacketTraits::AlignedOnScalar ? Aligned : int(assign_traits<Derived1,Derived2>::DstIsAligned) ,
      srcAlignment = assign_traits<Derived1,Derived2>::JointAlignment
    };
    const Index alignedStart = assign_traits<Derived1,Derived2>::DstIsAligned ? 0
                             : first_aligned(&dst.coeffRef(0), size);
    const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;

    unaligned_assign_impl<assign_traits<Derived1,Derived2>::DstIsAligned!=0>::run(src,dst,0,alignedStart);

    for(Index index = alignedStart; index < alignedEnd; index += packetSize)
    {
      dst.template copyPacket<Derived2, dstAlignment, srcAlignment>(index, src);
    }

    unaligned_assign_impl<>::run(src,dst,alignedEnd,size);
  }
};

template<typename Derived1, typename Derived2>
struct assign_impl<Derived1, Derived2, LinearVectorizedTraversal, CompleteUnrolling>
{
  typedef typename Derived1::Index Index;
  inline static void run(Derived1 &dst, const Derived2 &src)
  {
    enum { size = Derived1::SizeAtCompileTime,
           packetSize = packet_traits<typename Derived1::Scalar>::size,
           alignedSize = (size/packetSize)*packetSize };

    assign_innervec_CompleteUnrolling<Derived1, Derived2, 0, alignedSize>::run(dst, src);
    assign_DefaultTraversal_CompleteUnrolling<Derived1, Derived2, alignedSize, size>::run(dst, src);
  }
};





template<typename Derived1, typename Derived2>
struct assign_impl<Derived1, Derived2, SliceVectorizedTraversal, NoUnrolling>
{
  typedef typename Derived1::Index Index;
  inline static void run(Derived1 &dst, const Derived2 &src)
  {
    typedef packet_traits<typename Derived1::Scalar> PacketTraits;
    enum {
      packetSize = PacketTraits::size,
      alignable = PacketTraits::AlignedOnScalar,
      dstAlignment = alignable ? Aligned : int(assign_traits<Derived1,Derived2>::DstIsAligned) ,
      srcAlignment = assign_traits<Derived1,Derived2>::JointAlignment
    };
    const Index packetAlignedMask = packetSize - 1;
    const Index innerSize = dst.innerSize();
    const Index outerSize = dst.outerSize();
    const Index alignedStep = alignable ? (packetSize - dst.outerStride() % packetSize) & packetAlignedMask : 0;
    Index alignedStart = ((!alignable) || assign_traits<Derived1,Derived2>::DstIsAligned) ? 0
                       : first_aligned(&dst.coeffRef(0,0), innerSize);

    for(Index outer = 0; outer < outerSize; ++outer)
    {
      const Index alignedEnd = alignedStart + ((innerSize-alignedStart) & ~packetAlignedMask);

      for(Index inner = 0; inner<alignedStart ; ++inner)
        dst.copyCoeffByOuterInner(outer, inner, src);


      for(Index inner = alignedStart; inner<alignedEnd; inner+=packetSize)
        dst.template copyPacketByOuterInner<Derived2, dstAlignment, Unaligned>(outer, inner, src);


      for(Index inner = alignedEnd; inner<innerSize ; ++inner)
        dst.copyCoeffByOuterInner(outer, inner, src);

      alignedStart = std::min<Index>((alignedStart+alignedStep)%packetSize, innerSize);
    }
  }
};

}





template<typename Derived>
template<typename OtherDerived>
inline Derived& DenseBase<Derived>
  ::lazyAssign(const DenseBase<OtherDerived>& other)
{
  enum{
    SameType = internal::is_same<typename Derived::Scalar,typename OtherDerived::Scalar>::value
  };

  if (Eigen::internal::static_assertion<bool(internal::is_lvalue<Derived>::value)>::THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY) {}
  if (Eigen::internal::static_assertion<bool(( (int(Derived::SizeAtCompileTime)==0 && int(OtherDerived::SizeAtCompileTime)==0) || ( (int(Derived::RowsAtCompileTime)==Eigen::Dynamic || int(OtherDerived::RowsAtCompileTime)==Eigen::Dynamic || int(Derived::RowsAtCompileTime)==int(OtherDerived::RowsAtCompileTime)) && (int(Derived::ColsAtCompileTime)==Eigen::Dynamic || int(OtherDerived::ColsAtCompileTime)==Eigen::Dynamic || int(Derived::ColsAtCompileTime)==int(OtherDerived::ColsAtCompileTime)) ) ))>::YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES) {}
  if (Eigen::internal::static_assertion<bool(SameType)>::YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY) {}




  if( (!Eigen::internal::copy_bool(rows() == other.rows() && cols() == other.cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(rows() == other.rows() && cols() == other.cols())) Eigen::internal::assert_fail("rows() == other.rows() && cols() == other.cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Assign.h", 510); } while(false); else throw Eigen::eigen_assert_exception(); };
  internal::assign_impl<Derived, OtherDerived, int(SameType) ? int(internal::assign_traits<Derived, OtherDerived>::Traversal)
                                                       : int(InvalidTraversal)>::run(derived(),other.derived());

  checkTransposeAliasing(other.derived());

  return derived();
}

namespace internal {

template<typename Derived, typename OtherDerived,
         bool EvalBeforeAssigning = (int(OtherDerived::Flags) & EvalBeforeAssigningBit) != 0,
         bool NeedToTranspose = Derived::IsVectorAtCompileTime
                && OtherDerived::IsVectorAtCompileTime
                && ((int(Derived::RowsAtCompileTime) == 1 && int(OtherDerived::ColsAtCompileTime) == 1)
                      |

                    (int(Derived::ColsAtCompileTime) == 1 && int(OtherDerived::RowsAtCompileTime) == 1))
                && int(Derived::SizeAtCompileTime) != 1>
struct assign_selector;

template<typename Derived, typename OtherDerived>
struct assign_selector<Derived,OtherDerived,false,false> {
  inline static Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }
};
template<typename Derived, typename OtherDerived>
struct assign_selector<Derived,OtherDerived,true,false> {
  inline static Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.eval()); }
};
template<typename Derived, typename OtherDerived>
struct assign_selector<Derived,OtherDerived,false,true> {
  inline static Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.transpose()); }
};
template<typename Derived, typename OtherDerived>
struct assign_selector<Derived,OtherDerived,true,true> {
  inline static Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.transpose().eval()); }
};

}

template<typename Derived>
template<typename OtherDerived>
inline Derived& DenseBase<Derived>::operator=(const DenseBase<OtherDerived>& other)
{
  return internal::assign_selector<Derived,OtherDerived>::run(derived(), other.derived());
}

template<typename Derived>
inline Derived& DenseBase<Derived>::operator=(const DenseBase& other)
{
  return internal::assign_selector<Derived,Derived>::run(derived(), other.derived());
}

template<typename Derived>
inline Derived& MatrixBase<Derived>::operator=(const MatrixBase& other)
{
  return internal::assign_selector<Derived,Derived>::run(derived(), other.derived());
}

template<typename Derived>
template <typename OtherDerived>
inline Derived& MatrixBase<Derived>::operator=(const DenseBase<OtherDerived>& other)
{
  return internal::assign_selector<Derived,OtherDerived>::run(derived(), other.derived());
}

template<typename Derived>
template <typename OtherDerived>
inline Derived& MatrixBase<Derived>::operator=(const EigenBase<OtherDerived>& other)
{
  other.derived().evalTo(derived());
  return derived();
}

template<typename Derived>
template<typename OtherDerived>
inline Derived& MatrixBase<Derived>::operator=(const ReturnByValue<OtherDerived>& other)
{
  other.evalTo(derived());
  return derived();
}
# 284 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2


# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/BlasUtil.h" 1
# 31 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/BlasUtil.h"
namespace internal {


template<typename LhsScalar, typename RhsScalar, typename Index, int mr, int nr, bool ConjugateLhs=false, bool ConjugateRhs=false>
struct gebp_kernel;

template<typename Scalar, typename Index, int nr, int StorageOrder, bool Conjugate = false, bool PanelMode=false>
struct gemm_pack_rhs;

template<typename Scalar, typename Index, int Pack1, int Pack2, int StorageOrder, bool Conjugate = false, bool PanelMode = false>
struct gemm_pack_lhs;

template<
  typename Index,
  typename LhsScalar, int LhsStorageOrder, bool ConjugateLhs,
  typename RhsScalar, int RhsStorageOrder, bool ConjugateRhs,
  int ResStorageOrder>
struct general_matrix_matrix_product;

template<typename Index, typename LhsScalar, int LhsStorageOrder, bool ConjugateLhs, typename RhsScalar, bool ConjugateRhs>
struct general_matrix_vector_product;


template<bool Conjugate> struct conj_if;

template<> struct conj_if<true> {
  template<typename T>
  inline T operator()(const T& x) { return conj(x); }
};

template<> struct conj_if<false> {
  template<typename T>
  inline const T& operator()(const T& x) { return x; }
};

template<typename Scalar> struct conj_helper<Scalar,Scalar,false,false>
{
  inline Scalar pmadd(const Scalar& x, const Scalar& y, const Scalar& c) const { return internal::pmadd(x,y,c); }
  inline Scalar pmul(const Scalar& x, const Scalar& y) const { return internal::pmul(x,y); }
};

template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, false,true>
{
  typedef std::complex<RealScalar> Scalar;
  inline Scalar pmadd(const Scalar& x, const Scalar& y, const Scalar& c) const
  { return c + pmul(x,y); }

  inline Scalar pmul(const Scalar& x, const Scalar& y) const
  { return Scalar(real(x)*real(y) + imag(x)*imag(y), imag(x)*real(y) - real(x)*imag(y)); }
};

template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, true,false>
{
  typedef std::complex<RealScalar> Scalar;
  inline Scalar pmadd(const Scalar& x, const Scalar& y, const Scalar& c) const
  { return c + pmul(x,y); }

  inline Scalar pmul(const Scalar& x, const Scalar& y) const
  { return Scalar(real(x)*real(y) + imag(x)*imag(y), real(x)*imag(y) - imag(x)*real(y)); }
};

template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, true,true>
{
  typedef std::complex<RealScalar> Scalar;
  inline Scalar pmadd(const Scalar& x, const Scalar& y, const Scalar& c) const
  { return c + pmul(x,y); }

  inline Scalar pmul(const Scalar& x, const Scalar& y) const
  { return Scalar(real(x)*real(y) - imag(x)*imag(y), - real(x)*imag(y) - imag(x)*real(y)); }
};

template<typename RealScalar,bool Conj> struct conj_helper<std::complex<RealScalar>, RealScalar, Conj,false>
{
  typedef std::complex<RealScalar> Scalar;
  inline Scalar pmadd(const Scalar& x, const RealScalar& y, const Scalar& c) const
  { return padd(c, pmul(x,y)); }
  inline Scalar pmul(const Scalar& x, const RealScalar& y) const
  { return conj_if<Conj>()(x)*y; }
};

template<typename RealScalar,bool Conj> struct conj_helper<RealScalar, std::complex<RealScalar>, false,Conj>
{
  typedef std::complex<RealScalar> Scalar;
  inline Scalar pmadd(const RealScalar& x, const Scalar& y, const Scalar& c) const
  { return padd(c, pmul(x,y)); }
  inline Scalar pmul(const RealScalar& x, const Scalar& y) const
  { return x*conj_if<Conj>()(y); }
};

template<typename From,typename To> struct get_factor {
  inline static To run(const From& x) { return x; }
};

template<typename Scalar> struct get_factor<Scalar,typename NumTraits<Scalar>::Real> {
  inline static typename NumTraits<Scalar>::Real run(const Scalar& x) { return real(x); }
};




template<typename Scalar, typename Index, int StorageOrder>
class blas_data_mapper
{
  public:
    blas_data_mapper(Scalar* data, Index stride) : m_data(data), m_stride(stride) {}
    inline Scalar& operator()(Index i, Index j)
    { return m_data[StorageOrder==RowMajor ? j + i*m_stride : i + j*m_stride]; }
  protected:
    Scalar* __restrict m_data;
    Index m_stride;
};


template<typename Scalar, typename Index, int StorageOrder>
class const_blas_data_mapper
{
  public:
    const_blas_data_mapper(const Scalar* data, Index stride) : m_data(data), m_stride(stride) {}
    inline const Scalar& operator()(Index i, Index j) const
    { return m_data[StorageOrder==RowMajor ? j + i*m_stride : i + j*m_stride]; }
  protected:
    const Scalar* __restrict m_data;
    Index m_stride;
};





template<typename XprType> struct blas_traits
{
  typedef typename traits<XprType>::Scalar Scalar;
  typedef const XprType& ExtractType;
  typedef XprType _ExtractType;
  enum {
    IsComplex = NumTraits<Scalar>::IsComplex,
    IsTransposed = false,
    NeedToConjugate = false,
    HasUsableDirectAccess = ( (int(XprType::Flags)&DirectAccessBit)
                              && ( bool(XprType::IsVectorAtCompileTime)
                                  || int(inner_stride_at_compile_time<XprType>::ret) == 1)
                             ) ? 1 : 0
  };
  typedef typename conditional<bool(HasUsableDirectAccess),
    ExtractType,
    typename _ExtractType::PlainObject
    >::type DirectLinearAccessType;
  static inline const ExtractType extract(const XprType& x) { return x; }
  static inline const Scalar extractScalarFactor(const XprType&) { return Scalar(1); }
};


template<typename Scalar, typename NestedXpr>
struct blas_traits<CwiseUnaryOp<scalar_conjugate_op<Scalar>, NestedXpr> >
 : blas_traits<NestedXpr>
{
  typedef blas_traits<NestedXpr> Base;
  typedef CwiseUnaryOp<scalar_conjugate_op<Scalar>, NestedXpr> XprType;
  typedef typename Base::ExtractType ExtractType;

  enum {
    IsComplex = NumTraits<Scalar>::IsComplex,
    NeedToConjugate = Base::NeedToConjugate ? 0 : IsComplex
  };
  static inline const ExtractType extract(const XprType& x) { return Base::extract(x.nestedExpression()); }
  static inline Scalar extractScalarFactor(const XprType& x) { return conj(Base::extractScalarFactor(x.nestedExpression())); }
};


template<typename Scalar, typename NestedXpr>
struct blas_traits<CwiseUnaryOp<scalar_multiple_op<Scalar>, NestedXpr> >
 : blas_traits<NestedXpr>
{
  typedef blas_traits<NestedXpr> Base;
  typedef CwiseUnaryOp<scalar_multiple_op<Scalar>, NestedXpr> XprType;
  typedef typename Base::ExtractType ExtractType;
  static inline const ExtractType extract(const XprType& x) { return Base::extract(x.nestedExpression()); }
  static inline Scalar extractScalarFactor(const XprType& x)
  { return x.functor().m_other * Base::extractScalarFactor(x.nestedExpression()); }
};


template<typename Scalar, typename NestedXpr>
struct blas_traits<CwiseUnaryOp<scalar_opposite_op<Scalar>, NestedXpr> >
 : blas_traits<NestedXpr>
{
  typedef blas_traits<NestedXpr> Base;
  typedef CwiseUnaryOp<scalar_opposite_op<Scalar>, NestedXpr> XprType;
  typedef typename Base::ExtractType ExtractType;
  static inline const ExtractType extract(const XprType& x) { return Base::extract(x.nestedExpression()); }
  static inline Scalar extractScalarFactor(const XprType& x)
  { return - Base::extractScalarFactor(x.nestedExpression()); }
};


template<typename NestedXpr>
struct blas_traits<Transpose<NestedXpr> >
 : blas_traits<NestedXpr>
{
  typedef typename NestedXpr::Scalar Scalar;
  typedef blas_traits<NestedXpr> Base;
  typedef Transpose<NestedXpr> XprType;
  typedef Transpose<const typename Base::_ExtractType> ExtractType;
  typedef Transpose<const typename Base::_ExtractType> _ExtractType;
  typedef typename conditional<bool(Base::HasUsableDirectAccess),
    ExtractType,
    typename ExtractType::PlainObject
    >::type DirectLinearAccessType;
  enum {
    IsTransposed = Base::IsTransposed ? 0 : 1
  };
  static inline const ExtractType extract(const XprType& x) { return Base::extract(x.nestedExpression()); }
  static inline Scalar extractScalarFactor(const XprType& x) { return Base::extractScalarFactor(x.nestedExpression()); }
};

template<typename T>
struct blas_traits<const T>
     : blas_traits<T>
{};

template<typename T, bool HasUsableDirectAccess=blas_traits<T>::HasUsableDirectAccess>
struct extract_data_selector {
  static const typename T::Scalar* run(const T& m)
  {
    return const_cast<typename T::Scalar*>(&blas_traits<T>::extract(m).coeffRef(0,0));
  }
};

template<typename T>
struct extract_data_selector<T,false> {
  static typename T::Scalar* run(const T&) { return 0; }
};

template<typename T> const typename T::Scalar* extract_data(const T& m)
{
  return extract_data_selector<T>::run(m);
}

}
# 287 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseStorage.h" 1
# 36 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseStorage.h"
namespace internal {

struct constructor_without_unaligned_array_assert {};





template <typename T, int Size, int MatrixOrArrayOptions,
          int Alignment = (MatrixOrArrayOptions&DontAlign) ? 0
                        : (((Size*sizeof(T))%16)==0) ? 16
                        : 0 >
struct plain_array
{
  T array[Size];
  plain_array() {}
  plain_array(constructor_without_unaligned_array_assert) {}
};
# 65 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseStorage.h"
template <typename T, int Size, int MatrixOrArrayOptions>
struct plain_array<T, Size, MatrixOrArrayOptions, 16>
{
  __attribute__((aligned(16))) T array[Size];
  plain_array() { if( (!Eigen::internal::copy_bool((reinterpret_cast<size_t>(array) & 0xf) == 0 && "this assertion is explained here: " "http://eigen.tuxfamily.org/dox-devel/TopicUnalignedArrayAssert.html" " **** READ THIS WEB PAGE !!! ****")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool((reinterpret_cast<size_t>(array) & 0xf) == 0 && "this assertion is explained here: " "http://eigen.tuxfamily.org/dox-devel/TopicUnalignedArrayAssert.html" " **** READ THIS WEB PAGE !!! ****")) Eigen::internal::assert_fail("(reinterpret_cast<size_t>(array) & 0xf) == 0 && \"this assertion is explained here: \" \"http://eigen.tuxfamily.org/dox-devel/TopicUnalignedArrayAssert.html\" \" **** READ THIS WEB PAGE !!! ****\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseStorage.h", 69); } while(false); else throw Eigen::eigen_assert_exception(); }; }
  plain_array(constructor_without_unaligned_array_assert) {}
};

template <typename T, int MatrixOrArrayOptions, int Alignment>
struct plain_array<T, 0, MatrixOrArrayOptions, Alignment>
{
  __attribute__((aligned(16))) T array[1];
  plain_array() {}
  plain_array(constructor_without_unaligned_array_assert) {}
};

}
# 95 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DenseStorage.h"
template<typename T, int Size, int _Rows, int _Cols, int _Options> class DenseStorage;


template<typename T, int Size, int _Rows, int _Cols, int _Options> class DenseStorage
{
    internal::plain_array<T,Size,_Options> m_data;
  public:
    inline explicit DenseStorage() {}
    inline DenseStorage(internal::constructor_without_unaligned_array_assert)
      : m_data(internal::constructor_without_unaligned_array_assert()) {}
    inline DenseStorage(DenseIndex,DenseIndex,DenseIndex) {}
    inline void swap(DenseStorage& other) { std::swap(m_data,other.m_data); }
    inline static DenseIndex rows(void) {return _Rows;}
    inline static DenseIndex cols(void) {return _Cols;}
    inline void conservativeResize(DenseIndex,DenseIndex,DenseIndex) {}
    inline void resize(DenseIndex,DenseIndex,DenseIndex) {}
    inline const T *data() const { return m_data.array; }
    inline T *data() { return m_data.array; }
};


template<typename T, int _Rows, int _Cols, int _Options> class DenseStorage<T, 0, _Rows, _Cols, _Options>
{
  public:
    inline explicit DenseStorage() {}
    inline DenseStorage(internal::constructor_without_unaligned_array_assert) {}
    inline DenseStorage(DenseIndex,DenseIndex,DenseIndex) {}
    inline void swap(DenseStorage& ) {}
    inline static DenseIndex rows(void) {return _Rows;}
    inline static DenseIndex cols(void) {return _Cols;}
    inline void conservativeResize(DenseIndex,DenseIndex,DenseIndex) {}
    inline void resize(DenseIndex,DenseIndex,DenseIndex) {}
    inline const T *data() const { return 0; }
    inline T *data() { return 0; }
};


template<typename T, int Size, int _Options> class DenseStorage<T, Size, Dynamic, Dynamic, _Options>
{
    internal::plain_array<T,Size,_Options> m_data;
    DenseIndex m_rows;
    DenseIndex m_cols;
  public:
    inline explicit DenseStorage() : m_rows(0), m_cols(0) {}
    inline DenseStorage(internal::constructor_without_unaligned_array_assert)
      : m_data(internal::constructor_without_unaligned_array_assert()), m_rows(0), m_cols(0) {}
    inline DenseStorage(DenseIndex, DenseIndex rows, DenseIndex cols) : m_rows(rows), m_cols(cols) {}
    inline void swap(DenseStorage& other)
    { std::swap(m_data,other.m_data); std::swap(m_rows,other.m_rows); std::swap(m_cols,other.m_cols); }
    inline DenseIndex rows(void) const {return m_rows;}
    inline DenseIndex cols(void) const {return m_cols;}
    inline void conservativeResize(DenseIndex, DenseIndex rows, DenseIndex cols) { m_rows = rows; m_cols = cols; }
    inline void resize(DenseIndex, DenseIndex rows, DenseIndex cols) { m_rows = rows; m_cols = cols; }
    inline const T *data() const { return m_data.array; }
    inline T *data() { return m_data.array; }
};


template<typename T, int Size, int _Cols, int _Options> class DenseStorage<T, Size, Dynamic, _Cols, _Options>
{
    internal::plain_array<T,Size,_Options> m_data;
    DenseIndex m_rows;
  public:
    inline explicit DenseStorage() : m_rows(0) {}
    inline DenseStorage(internal::constructor_without_unaligned_array_assert)
      : m_data(internal::constructor_without_unaligned_array_assert()), m_rows(0) {}
    inline DenseStorage(DenseIndex, DenseIndex rows, DenseIndex) : m_rows(rows) {}
    inline void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_rows,other.m_rows); }
    inline DenseIndex rows(void) const {return m_rows;}
    inline DenseIndex cols(void) const {return _Cols;}
    inline void conservativeResize(DenseIndex, DenseIndex rows, DenseIndex) { m_rows = rows; }
    inline void resize(DenseIndex, DenseIndex rows, DenseIndex) { m_rows = rows; }
    inline const T *data() const { return m_data.array; }
    inline T *data() { return m_data.array; }
};


template<typename T, int Size, int _Rows, int _Options> class DenseStorage<T, Size, _Rows, Dynamic, _Options>
{
    internal::plain_array<T,Size,_Options> m_data;
    DenseIndex m_cols;
  public:
    inline explicit DenseStorage() : m_cols(0) {}
    inline DenseStorage(internal::constructor_without_unaligned_array_assert)
      : m_data(internal::constructor_without_unaligned_array_assert()), m_cols(0) {}
    inline DenseStorage(DenseIndex, DenseIndex, DenseIndex cols) : m_cols(cols) {}
    inline void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_cols,other.m_cols); }
    inline DenseIndex rows(void) const {return _Rows;}
    inline DenseIndex cols(void) const {return m_cols;}
    inline void conservativeResize(DenseIndex, DenseIndex, DenseIndex cols) { m_cols = cols; }
    inline void resize(DenseIndex, DenseIndex, DenseIndex cols) { m_cols = cols; }
    inline const T *data() const { return m_data.array; }
    inline T *data() { return m_data.array; }
};


template<typename T, int _Options> class DenseStorage<T, Dynamic, Dynamic, Dynamic, _Options>
{
    T *m_data;
    DenseIndex m_rows;
    DenseIndex m_cols;
  public:
    inline explicit DenseStorage() : m_data(0), m_rows(0), m_cols(0) {}
    inline DenseStorage(internal::constructor_without_unaligned_array_assert)
       : m_data(0), m_rows(0), m_cols(0) {}
    inline DenseStorage(DenseIndex size, DenseIndex rows, DenseIndex cols)
      : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_rows(rows), m_cols(cols)
    { }
    inline ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, m_rows*m_cols); }
    inline void swap(DenseStorage& other)
    { std::swap(m_data,other.m_data); std::swap(m_rows,other.m_rows); std::swap(m_cols,other.m_cols); }
    inline DenseIndex rows(void) const {return m_rows;}
    inline DenseIndex cols(void) const {return m_cols;}
    inline void conservativeResize(DenseIndex size, DenseIndex rows, DenseIndex cols)
    {
      m_data = internal::conditional_aligned_realloc_new_auto<T,(_Options&DontAlign)==0>(m_data, size, m_rows*m_cols);
      m_rows = rows;
      m_cols = cols;
    }
    void resize(DenseIndex size, DenseIndex rows, DenseIndex cols)
    {
      if(size != m_rows*m_cols)
      {
        internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, m_rows*m_cols);
        if (size)
          m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);
        else
          m_data = 0;

      }
      m_rows = rows;
      m_cols = cols;
    }
    inline const T *data() const { return m_data; }
    inline T *data() { return m_data; }
};


template<typename T, int _Rows, int _Options> class DenseStorage<T, Dynamic, _Rows, Dynamic, _Options>
{
    T *m_data;
    DenseIndex m_cols;
  public:
    inline explicit DenseStorage() : m_data(0), m_cols(0) {}
    inline DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(0), m_cols(0) {}
    inline DenseStorage(DenseIndex size, DenseIndex, DenseIndex cols) : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_cols(cols)
    { }
    inline ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Rows*m_cols); }
    inline void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_cols,other.m_cols); }
    inline static DenseIndex rows(void) {return _Rows;}
    inline DenseIndex cols(void) const {return m_cols;}
    inline void conservativeResize(DenseIndex size, DenseIndex, DenseIndex cols)
    {
      m_data = internal::conditional_aligned_realloc_new_auto<T,(_Options&DontAlign)==0>(m_data, size, _Rows*m_cols);
      m_cols = cols;
    }
    inline void resize(DenseIndex size, DenseIndex, DenseIndex cols)
    {
      if(size != _Rows*m_cols)
      {
        internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Rows*m_cols);
        if (size)
          m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);
        else
          m_data = 0;

      }
      m_cols = cols;
    }
    inline const T *data() const { return m_data; }
    inline T *data() { return m_data; }
};


template<typename T, int _Cols, int _Options> class DenseStorage<T, Dynamic, Dynamic, _Cols, _Options>
{
    T *m_data;
    DenseIndex m_rows;
  public:
    inline explicit DenseStorage() : m_data(0), m_rows(0) {}
    inline DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(0), m_rows(0) {}
    inline DenseStorage(DenseIndex size, DenseIndex rows, DenseIndex) : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_rows(rows)
    { }
    inline ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Cols*m_rows); }
    inline void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_rows,other.m_rows); }
    inline DenseIndex rows(void) const {return m_rows;}
    inline static DenseIndex cols(void) {return _Cols;}
    inline void conservativeResize(DenseIndex size, DenseIndex rows, DenseIndex)
    {
      m_data = internal::conditional_aligned_realloc_new_auto<T,(_Options&DontAlign)==0>(m_data, size, m_rows*_Cols);
      m_rows = rows;
    }
    inline void resize(DenseIndex size, DenseIndex rows, DenseIndex)
    {
      if(size != m_rows*_Cols)
      {
        internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Cols*m_rows);
        if (size)
          m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);
        else
          m_data = 0;

      }
      m_rows = rows;
    }
    inline const T *data() const { return m_data; }
    inline T *data() { return m_data; }
};
# 288 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/NestByValue.h" 1
# 42 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/NestByValue.h"
namespace internal {
template<typename ExpressionType>
struct traits<NestByValue<ExpressionType> > : public traits<ExpressionType>
{};
}

template<typename ExpressionType> class NestByValue
  : public internal::dense_xpr_base< NestByValue<ExpressionType> >::type
{
  public:

    typedef typename internal::dense_xpr_base<NestByValue>::type Base;
    typedef typename Eigen::internal::traits<NestByValue>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<NestByValue>::type Nested; typedef typename Eigen::internal::traits<NestByValue>::StorageKind StorageKind; typedef typename Eigen::internal::traits<NestByValue>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<NestByValue>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<NestByValue>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<NestByValue>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<NestByValue>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<NestByValue>::Flags, CoeffReadCost = Eigen::internal::traits<NestByValue>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived;

    inline NestByValue(const ExpressionType& matrix) : m_expression(matrix) {}

    inline Index rows() const { return m_expression.rows(); }
    inline Index cols() const { return m_expression.cols(); }
    inline Index outerStride() const { return m_expression.outerStride(); }
    inline Index innerStride() const { return m_expression.innerStride(); }

    inline const CoeffReturnType coeff(Index row, Index col) const
    {
      return m_expression.coeff(row, col);
    }

    inline Scalar& coeffRef(Index row, Index col)
    {
      return m_expression.const_cast_derived().coeffRef(row, col);
    }

    inline const CoeffReturnType coeff(Index index) const
    {
      return m_expression.coeff(index);
    }

    inline Scalar& coeffRef(Index index)
    {
      return m_expression.const_cast_derived().coeffRef(index);
    }

    template<int LoadMode>
    inline const PacketScalar packet(Index row, Index col) const
    {
      return m_expression.template packet<LoadMode>(row, col);
    }

    template<int LoadMode>
    inline void writePacket(Index row, Index col, const PacketScalar& x)
    {
      m_expression.const_cast_derived().template writePacket<LoadMode>(row, col, x);
    }

    template<int LoadMode>
    inline const PacketScalar packet(Index index) const
    {
      return m_expression.template packet<LoadMode>(index);
    }

    template<int LoadMode>
    inline void writePacket(Index index, const PacketScalar& x)
    {
      m_expression.const_cast_derived().template writePacket<LoadMode>(index, x);
    }

    operator const ExpressionType&() const { return m_expression; }

  protected:
    const ExpressionType m_expression;
};



template<typename Derived>
inline const NestByValue<Derived>
DenseBase<Derived>::nestByValue() const
{
  return NestByValue<Derived>(derived());
}
# 289 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/ForceAlignedAccess.h" 1
# 41 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/ForceAlignedAccess.h"
namespace internal {
template<typename ExpressionType>
struct traits<ForceAlignedAccess<ExpressionType> > : public traits<ExpressionType>
{};
}

template<typename ExpressionType> class ForceAlignedAccess
  : public internal::dense_xpr_base< ForceAlignedAccess<ExpressionType> >::type
{
  public:

    typedef typename internal::dense_xpr_base<ForceAlignedAccess>::type Base;
    typedef typename Eigen::internal::traits<ForceAlignedAccess>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<ForceAlignedAccess>::type Nested; typedef typename Eigen::internal::traits<ForceAlignedAccess>::StorageKind StorageKind; typedef typename Eigen::internal::traits<ForceAlignedAccess>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<ForceAlignedAccess>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<ForceAlignedAccess>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<ForceAlignedAccess>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<ForceAlignedAccess>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<ForceAlignedAccess>::Flags, CoeffReadCost = Eigen::internal::traits<ForceAlignedAccess>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived;

    inline ForceAlignedAccess(const ExpressionType& matrix) : m_expression(matrix) {}

    inline Index rows() const { return m_expression.rows(); }
    inline Index cols() const { return m_expression.cols(); }
    inline Index outerStride() const { return m_expression.outerStride(); }
    inline Index innerStride() const { return m_expression.innerStride(); }

    inline const CoeffReturnType coeff(Index row, Index col) const
    {
      return m_expression.coeff(row, col);
    }

    inline Scalar& coeffRef(Index row, Index col)
    {
      return m_expression.const_cast_derived().coeffRef(row, col);
    }

    inline const CoeffReturnType coeff(Index index) const
    {
      return m_expression.coeff(index);
    }

    inline Scalar& coeffRef(Index index)
    {
      return m_expression.const_cast_derived().coeffRef(index);
    }

    template<int LoadMode>
    inline const PacketScalar packet(Index row, Index col) const
    {
      return m_expression.template packet<Aligned>(row, col);
    }

    template<int LoadMode>
    inline void writePacket(Index row, Index col, const PacketScalar& x)
    {
      m_expression.const_cast_derived().template writePacket<Aligned>(row, col, x);
    }

    template<int LoadMode>
    inline const PacketScalar packet(Index index) const
    {
      return m_expression.template packet<Aligned>(index);
    }

    template<int LoadMode>
    inline void writePacket(Index index, const PacketScalar& x)
    {
      m_expression.const_cast_derived().template writePacket<Aligned>(index, x);
    }

    operator const ExpressionType&() const { return m_expression; }

  protected:
    const ExpressionType& m_expression;

  private:
    ForceAlignedAccess& operator=(const ForceAlignedAccess&);
};




template<typename Derived>
inline const ForceAlignedAccess<Derived>
MatrixBase<Derived>::forceAlignedAccess() const
{
  return ForceAlignedAccess<Derived>(derived());
}




template<typename Derived>
inline ForceAlignedAccess<Derived>
MatrixBase<Derived>::forceAlignedAccess()
{
  return ForceAlignedAccess<Derived>(derived());
}




template<typename Derived>
template<bool Enable>
inline typename internal::add_const_on_value_type<typename internal::conditional<Enable,ForceAlignedAccess<Derived>,Derived&>::type>::type
MatrixBase<Derived>::forceAlignedAccessIf() const
{
  return derived();
}




template<typename Derived>
template<bool Enable>
inline typename internal::conditional<Enable,ForceAlignedAccess<Derived>,Derived&>::type
MatrixBase<Derived>::forceAlignedAccessIf()
{
  return derived();
}
# 290 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/ReturnByValue.h" 1
# 34 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/ReturnByValue.h"
namespace internal {

template<typename Derived>
struct traits<ReturnByValue<Derived> >
  : public traits<typename traits<Derived>::ReturnType>
{
  enum {



    Flags = (traits<typename traits<Derived>::ReturnType>::Flags
             | EvalBeforeNestingBit) & ~DirectAccessBit
  };
};







template<typename Derived,int n,typename PlainObject>
struct nested<ReturnByValue<Derived>, n, PlainObject>
{
  typedef typename traits<Derived>::ReturnType type;
};

}

template<typename Derived> class ReturnByValue
  : public internal::dense_xpr_base< ReturnByValue<Derived> >::type
{
  public:
    typedef typename internal::traits<Derived>::ReturnType ReturnType;

    typedef typename internal::dense_xpr_base<ReturnByValue>::type Base;
    typedef typename Eigen::internal::traits<ReturnByValue>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<ReturnByValue>::type Nested; typedef typename Eigen::internal::traits<ReturnByValue>::StorageKind StorageKind; typedef typename Eigen::internal::traits<ReturnByValue>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<ReturnByValue>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<ReturnByValue>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<ReturnByValue>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<ReturnByValue>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<ReturnByValue>::Flags, CoeffReadCost = Eigen::internal::traits<ReturnByValue>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived;

    template<typename Dest>
    inline void evalTo(Dest& dst) const
    { static_cast<const Derived*>(this)->evalTo(dst); }
    inline Index rows() const { return static_cast<const Derived*>(this)->rows(); }
    inline Index cols() const { return static_cast<const Derived*>(this)->cols(); }



    class YOU_ARE_TRYING_TO_ACCESS_A_SINGLE_COEFFICIENT_IN_A_SPECIAL_EXPRESSION_WHERE_THAT_IS_NOT_ALLOWED_BECAUSE_THAT_WOULD_BE_INEFFICIENT{
      YOU_ARE_TRYING_TO_ACCESS_A_SINGLE_COEFFICIENT_IN_A_SPECIAL_EXPRESSION_WHERE_THAT_IS_NOT_ALLOWED_BECAUSE_THAT_WOULD_BE_INEFFICIENT(const YOU_ARE_TRYING_TO_ACCESS_A_SINGLE_COEFFICIENT_IN_A_SPECIAL_EXPRESSION_WHERE_THAT_IS_NOT_ALLOWED_BECAUSE_THAT_WOULD_BE_INEFFICIENT&) {}
      YOU_ARE_TRYING_TO_ACCESS_A_SINGLE_COEFFICIENT_IN_A_SPECIAL_EXPRESSION_WHERE_THAT_IS_NOT_ALLOWED_BECAUSE_THAT_WOULD_BE_INEFFICIENT& operator=(const YOU_ARE_TRYING_TO_ACCESS_A_SINGLE_COEFFICIENT_IN_A_SPECIAL_EXPRESSION_WHERE_THAT_IS_NOT_ALLOWED_BECAUSE_THAT_WOULD_BE_INEFFICIENT&) {return *this;}
    };
    const YOU_ARE_TRYING_TO_ACCESS_A_SINGLE_COEFFICIENT_IN_A_SPECIAL_EXPRESSION_WHERE_THAT_IS_NOT_ALLOWED_BECAUSE_THAT_WOULD_BE_INEFFICIENT& coeff(Index) const { return *reinterpret_cast<const YOU_ARE_TRYING_TO_ACCESS_A_SINGLE_COEFFICIENT_IN_A_SPECIAL_EXPRESSION_WHERE_THAT_IS_NOT_ALLOWED_BECAUSE_THAT_WOULD_BE_INEFFICIENT*>(this); }
    const YOU_ARE_TRYING_TO_ACCESS_A_SINGLE_COEFFICIENT_IN_A_SPECIAL_EXPRESSION_WHERE_THAT_IS_NOT_ALLOWED_BECAUSE_THAT_WOULD_BE_INEFFICIENT& coeff(Index,Index) const { return *reinterpret_cast<const YOU_ARE_TRYING_TO_ACCESS_A_SINGLE_COEFFICIENT_IN_A_SPECIAL_EXPRESSION_WHERE_THAT_IS_NOT_ALLOWED_BECAUSE_THAT_WOULD_BE_INEFFICIENT*>(this); }
    YOU_ARE_TRYING_TO_ACCESS_A_SINGLE_COEFFICIENT_IN_A_SPECIAL_EXPRESSION_WHERE_THAT_IS_NOT_ALLOWED_BECAUSE_THAT_WOULD_BE_INEFFICIENT& coeffRef(Index) { return *reinterpret_cast<YOU_ARE_TRYING_TO_ACCESS_A_SINGLE_COEFFICIENT_IN_A_SPECIAL_EXPRESSION_WHERE_THAT_IS_NOT_ALLOWED_BECAUSE_THAT_WOULD_BE_INEFFICIENT*>(this); }
    YOU_ARE_TRYING_TO_ACCESS_A_SINGLE_COEFFICIENT_IN_A_SPECIAL_EXPRESSION_WHERE_THAT_IS_NOT_ALLOWED_BECAUSE_THAT_WOULD_BE_INEFFICIENT& coeffRef(Index,Index) { return *reinterpret_cast<YOU_ARE_TRYING_TO_ACCESS_A_SINGLE_COEFFICIENT_IN_A_SPECIAL_EXPRESSION_WHERE_THAT_IS_NOT_ALLOWED_BECAUSE_THAT_WOULD_BE_INEFFICIENT*>(this); }

};

template<typename Derived>
template<typename OtherDerived>
Derived& DenseBase<Derived>::operator=(const ReturnByValue<OtherDerived>& other)
{
  other.evalTo(derived());
  return derived();
}
# 291 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/NoAlias.h" 1
# 43 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/NoAlias.h"
template<typename ExpressionType, template <typename> class StorageBase>
class NoAlias
{
    typedef typename ExpressionType::Scalar Scalar;
  public:
    NoAlias(ExpressionType& expression) : m_expression(expression) {}



    template<typename OtherDerived>
    inline ExpressionType& operator=(const StorageBase<OtherDerived>& other)
    { return internal::assign_selector<ExpressionType,OtherDerived,false>::run(m_expression,other.derived()); }


    template<typename OtherDerived>
    inline ExpressionType& operator+=(const StorageBase<OtherDerived>& other)
    {
      typedef SelfCwiseBinaryOp<internal::scalar_sum_op<Scalar>, ExpressionType, OtherDerived> SelfAdder;
      SelfAdder tmp(m_expression);
      typedef typename internal::nested<OtherDerived>::type OtherDerivedNested;
      typedef typename internal::remove_all<OtherDerivedNested>::type _OtherDerivedNested;
      internal::assign_selector<SelfAdder,_OtherDerivedNested,false>::run(tmp,OtherDerivedNested(other.derived()));
      return m_expression;
    }


    template<typename OtherDerived>
    inline ExpressionType& operator-=(const StorageBase<OtherDerived>& other)
    {
      typedef SelfCwiseBinaryOp<internal::scalar_difference_op<Scalar>, ExpressionType, OtherDerived> SelfAdder;
      SelfAdder tmp(m_expression);
      typedef typename internal::nested<OtherDerived>::type OtherDerivedNested;
      typedef typename internal::remove_all<OtherDerivedNested>::type _OtherDerivedNested;
      internal::assign_selector<SelfAdder,_OtherDerivedNested,false>::run(tmp,OtherDerivedNested(other.derived()));
      return m_expression;
    }


    template<typename ProductDerived, typename Lhs, typename Rhs>
    inline ExpressionType& operator+=(const ProductBase<ProductDerived, Lhs,Rhs>& other)
    { other.derived().addTo(m_expression); return m_expression; }

    template<typename ProductDerived, typename Lhs, typename Rhs>
    inline ExpressionType& operator-=(const ProductBase<ProductDerived, Lhs,Rhs>& other)
    { other.derived().subTo(m_expression); return m_expression; }

    template<typename Lhs, typename Rhs, int NestingFlags>
    inline ExpressionType& operator+=(const CoeffBasedProduct<Lhs,Rhs,NestingFlags>& other)
    { return m_expression.derived() += CoeffBasedProduct<Lhs,Rhs,NestByRefBit>(other.lhs(), other.rhs()); }

    template<typename Lhs, typename Rhs, int NestingFlags>
    inline ExpressionType& operator-=(const CoeffBasedProduct<Lhs,Rhs,NestingFlags>& other)
    { return m_expression.derived() -= CoeffBasedProduct<Lhs,Rhs,NestByRefBit>(other.lhs(), other.rhs()); }


  protected:
    ExpressionType& m_expression;
};
# 130 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/NoAlias.h"
template<typename Derived>
NoAlias<Derived,MatrixBase> MatrixBase<Derived>::noalias()
{
  return derived();
}
# 292 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PlainObjectBase.h" 1
# 35 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PlainObjectBase.h"
namespace internal {

template <typename Derived, typename OtherDerived = Derived, bool IsVector = static_cast<bool>(Derived::IsVectorAtCompileTime)> struct conservative_resize_like_impl;

template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;

}
# 51 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PlainObjectBase.h"
template<typename Derived>
class PlainObjectBase : public internal::dense_xpr_base<Derived>::type
{
  public:
    enum { Options = internal::traits<Derived>::Options };
    typedef typename internal::dense_xpr_base<Derived>::type Base;

    typedef typename internal::traits<Derived>::StorageKind StorageKind;
    typedef typename internal::traits<Derived>::Index Index;
    typedef typename internal::traits<Derived>::Scalar Scalar;
    typedef typename internal::packet_traits<Scalar>::type PacketScalar;
    typedef typename NumTraits<Scalar>::Real RealScalar;
    typedef Derived DenseType;

    using Base::RowsAtCompileTime;
    using Base::ColsAtCompileTime;
    using Base::SizeAtCompileTime;
    using Base::MaxRowsAtCompileTime;
    using Base::MaxColsAtCompileTime;
    using Base::MaxSizeAtCompileTime;
    using Base::IsVectorAtCompileTime;
    using Base::Flags;

    template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
    friend class Eigen::Map<Derived, Unaligned>;
    typedef Eigen::Map<Derived, Unaligned> MapType;
    friend class Eigen::Map<const Derived, Unaligned>;
    typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
    friend class Eigen::Map<Derived, Aligned>;
    typedef Eigen::Map<Derived, Aligned> AlignedMapType;
    friend class Eigen::Map<const Derived, Aligned>;
    typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;
    template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };
    template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };
    template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };
    template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };


  protected:
    DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;

  public:
    enum { NeedsToAlign = (!(Options&DontAlign))
                          && SizeAtCompileTime!=Dynamic && ((static_cast<int>(sizeof(Scalar))*SizeAtCompileTime)%16)==0 };
    void *operator new(size_t size) { return Eigen::internal::conditional_aligned_malloc<NeedsToAlign>(size); } void *operator new[](size_t size) { return Eigen::internal::conditional_aligned_malloc<NeedsToAlign>(size); } void operator delete(void * ptr) { Eigen::internal::conditional_aligned_free<NeedsToAlign>(ptr); } void operator delete[](void * ptr) { Eigen::internal::conditional_aligned_free<NeedsToAlign>(ptr); } static void *operator new(size_t size, void *ptr) { return ::operator new(size,ptr); } void operator delete(void * memory, void *ptr) { return ::operator delete(memory,ptr); } void* operator new(size_t size, const std::nothrow_t&) { try { return Eigen::internal::conditional_aligned_malloc<NeedsToAlign>(size); } catch (...) { return 0; } return 0; } void operator delete(void *ptr, const std::nothrow_t&) { Eigen::internal::conditional_aligned_free<NeedsToAlign>(ptr); } typedef void eigen_aligned_operator_new_marker_type;

    Base& base() { return *static_cast<Base*>(this); }
    const Base& base() const { return *static_cast<const Base*>(this); }

    inline Index rows() const { return m_storage.rows(); }
    inline Index cols() const { return m_storage.cols(); }

    inline const Scalar& coeff(Index row, Index col) const
    {
      if(Flags & RowMajorBit)
        return m_storage.data()[col + row * m_storage.cols()];
      else
        return m_storage.data()[row + col * m_storage.rows()];
    }

    inline const Scalar& coeff(Index index) const
    {
      return m_storage.data()[index];
    }

    inline Scalar& coeffRef(Index row, Index col)
    {
      if(Flags & RowMajorBit)
        return m_storage.data()[col + row * m_storage.cols()];
      else
        return m_storage.data()[row + col * m_storage.rows()];
    }

    inline Scalar& coeffRef(Index index)
    {
      return m_storage.data()[index];
    }

    inline const Scalar& coeffRef(Index row, Index col) const
    {
      if(Flags & RowMajorBit)
        return m_storage.data()[col + row * m_storage.cols()];
      else
        return m_storage.data()[row + col * m_storage.rows()];
    }

    inline const Scalar& coeffRef(Index index) const
    {
      return m_storage.data()[index];
    }


    template<int LoadMode>
    inline PacketScalar packet(Index row, Index col) const
    {
      return internal::ploadt<PacketScalar, LoadMode>
               (m_storage.data() + (Flags & RowMajorBit
                                   ? col + row * m_storage.cols()
                                   : row + col * m_storage.rows()));
    }


    template<int LoadMode>
    inline PacketScalar packet(Index index) const
    {
      return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);
    }


    template<int StoreMode>
    inline void writePacket(Index row, Index col, const PacketScalar& x)
    {
      internal::pstoret<Scalar, PacketScalar, StoreMode>
              (m_storage.data() + (Flags & RowMajorBit
                                   ? col + row * m_storage.cols()
                                   : row + col * m_storage.rows()), x);
    }


    template<int StoreMode>
    inline void writePacket(Index index, const PacketScalar& x)
    {
      internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, x);
    }


    inline const Scalar *data() const
    { return m_storage.data(); }


    inline Scalar *data()
    { return m_storage.data(); }
# 200 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PlainObjectBase.h"
    inline void resize(Index rows, Index cols)
    {






        m_storage.resize(rows*cols, rows, cols);

    }
# 223 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PlainObjectBase.h"
    inline void resize(Index size)
    {
      if (Eigen::internal::static_assertion<bool(PlainObjectBase::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
      if( (!Eigen::internal::copy_bool(SizeAtCompileTime == Dynamic || SizeAtCompileTime == size)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(SizeAtCompileTime == Dynamic || SizeAtCompileTime == size)) Eigen::internal::assert_fail("SizeAtCompileTime == Dynamic || SizeAtCompileTime == size", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PlainObjectBase.h", 226); } while(false); else throw Eigen::eigen_assert_exception(); };



      if(RowsAtCompileTime == 1)
        m_storage.resize(size, 1, size);
      else
        m_storage.resize(size, size, 1);



    }
# 247 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PlainObjectBase.h"
    inline void resize(NoChange_t, Index cols)
    {
      resize(rows(), cols);
    }
# 260 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PlainObjectBase.h"
    inline void resize(Index rows, NoChange_t)
    {
      resize(rows, cols());
    }
# 272 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PlainObjectBase.h"
    template<typename OtherDerived>
    inline void resizeLike(const EigenBase<OtherDerived>& _other)
    {
      const OtherDerived& other = _other.derived();
      const Index othersize = other.rows()*other.cols();
      if(RowsAtCompileTime == 1)
      {
        if( (!Eigen::internal::copy_bool(other.rows() == 1 || other.cols() == 1)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(other.rows() == 1 || other.cols() == 1)) Eigen::internal::assert_fail("other.rows() == 1 || other.cols() == 1", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PlainObjectBase.h", 279); } while(false); else throw Eigen::eigen_assert_exception(); };
        resize(1, othersize);
      }
      else if(ColsAtCompileTime == 1)
      {
        if( (!Eigen::internal::copy_bool(other.rows() == 1 || other.cols() == 1)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(other.rows() == 1 || other.cols() == 1)) Eigen::internal::assert_fail("other.rows() == 1 || other.cols() == 1", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PlainObjectBase.h", 284); } while(false); else throw Eigen::eigen_assert_exception(); };
        resize(othersize, 1);
      }
      else resize(other.rows(), other.cols());
    }
# 299 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PlainObjectBase.h"
    inline void conservativeResize(Index rows, Index cols)
    {
      internal::conservative_resize_like_impl<Derived>::run(*this, rows, cols);
    }
# 311 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PlainObjectBase.h"
    inline void conservativeResize(Index rows, NoChange_t)
    {

      conservativeResize(rows, cols());
    }
# 324 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PlainObjectBase.h"
    inline void conservativeResize(NoChange_t, Index cols)
    {

      conservativeResize(rows(), cols);
    }
# 338 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PlainObjectBase.h"
    inline void conservativeResize(Index size)
    {
      internal::conservative_resize_like_impl<Derived>::run(*this, size);
    }
# 352 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PlainObjectBase.h"
    template<typename OtherDerived>
    inline void conservativeResizeLike(const DenseBase<OtherDerived>& other)
    {
      internal::conservative_resize_like_impl<Derived,OtherDerived>::run(*this, other);
    }




    inline Derived& operator=(const PlainObjectBase& other)
    {
      return _set(other);
    }


    template<typename OtherDerived>
    inline Derived& lazyAssign(const DenseBase<OtherDerived>& other)
    {
      _resize_to_match(other);
      return Base::lazyAssign(other.derived());
    }

    template<typename OtherDerived>
    inline Derived& operator=(const ReturnByValue<OtherDerived>& func)
    {
      resize(func.rows(), func.cols());
      return Base::operator=(func);
    }

    inline explicit PlainObjectBase() : m_storage()
    {


    }




    PlainObjectBase(internal::constructor_without_unaligned_array_assert)
      : m_storage(internal::constructor_without_unaligned_array_assert())
    {

    }


    inline PlainObjectBase(Index size, Index rows, Index cols)
      : m_storage(size, rows, cols)
    {


    }



    template<typename OtherDerived>
    inline Derived& operator=(const EigenBase<OtherDerived> &other)
    {
      _resize_to_match(other);
      Base::operator=(other.derived());
      return this->derived();
    }


    template<typename OtherDerived>
    inline PlainObjectBase(const EigenBase<OtherDerived> &other)
      : m_storage(other.derived().rows() * other.derived().cols(), other.derived().rows(), other.derived().cols())
    {
      _check_template_params();
      Base::operator=(other.derived());
    }
# 431 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PlainObjectBase.h"
    inline static ConstMapType Map(const Scalar* data)
    { return ConstMapType(data); }
    inline static MapType Map(Scalar* data)
    { return MapType(data); }
    inline static ConstMapType Map(const Scalar* data, Index size)
    { return ConstMapType(data, size); }
    inline static MapType Map(Scalar* data, Index size)
    { return MapType(data, size); }
    inline static ConstMapType Map(const Scalar* data, Index rows, Index cols)
    { return ConstMapType(data, rows, cols); }
    inline static MapType Map(Scalar* data, Index rows, Index cols)
    { return MapType(data, rows, cols); }

    inline static ConstAlignedMapType MapAligned(const Scalar* data)
    { return ConstAlignedMapType(data); }
    inline static AlignedMapType MapAligned(Scalar* data)
    { return AlignedMapType(data); }
    inline static ConstAlignedMapType MapAligned(const Scalar* data, Index size)
    { return ConstAlignedMapType(data, size); }
    inline static AlignedMapType MapAligned(Scalar* data, Index size)
    { return AlignedMapType(data, size); }
    inline static ConstAlignedMapType MapAligned(const Scalar* data, Index rows, Index cols)
    { return ConstAlignedMapType(data, rows, cols); }
    inline static AlignedMapType MapAligned(Scalar* data, Index rows, Index cols)
    { return AlignedMapType(data, rows, cols); }

    template<int Outer, int Inner>
    inline static typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, const Stride<Outer, Inner>& stride)
    { return typename StridedConstMapType<Stride<Outer, Inner> >::type(data, stride); }
    template<int Outer, int Inner>
    inline static typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, const Stride<Outer, Inner>& stride)
    { return typename StridedMapType<Stride<Outer, Inner> >::type(data, stride); }
    template<int Outer, int Inner>
    inline static typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)
    { return typename StridedConstMapType<Stride<Outer, Inner> >::type(data, size, stride); }
    template<int Outer, int Inner>
    inline static typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, Index size, const Stride<Outer, Inner>& stride)
    { return typename StridedMapType<Stride<Outer, Inner> >::type(data, size, stride); }
    template<int Outer, int Inner>
    inline static typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)
    { return typename StridedConstMapType<Stride<Outer, Inner> >::type(data, rows, cols, stride); }
    template<int Outer, int Inner>
    inline static typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)
    { return typename StridedMapType<Stride<Outer, Inner> >::type(data, rows, cols, stride); }

    template<int Outer, int Inner>
    inline static typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, const Stride<Outer, Inner>& stride)
    { return typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type(data, stride); }
    template<int Outer, int Inner>
    inline static typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, const Stride<Outer, Inner>& stride)
    { return typename StridedAlignedMapType<Stride<Outer, Inner> >::type(data, stride); }
    template<int Outer, int Inner>
    inline static typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)
    { return typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type(data, size, stride); }
    template<int Outer, int Inner>
    inline static typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, Index size, const Stride<Outer, Inner>& stride)
    { return typename StridedAlignedMapType<Stride<Outer, Inner> >::type(data, size, stride); }
    template<int Outer, int Inner>
    inline static typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)
    { return typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type(data, rows, cols, stride); }
    template<int Outer, int Inner>
    inline static typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)
    { return typename StridedAlignedMapType<Stride<Outer, Inner> >::type(data, rows, cols, stride); }


    using Base::setConstant;
    Derived& setConstant(Index size, const Scalar& value);
    Derived& setConstant(Index rows, Index cols, const Scalar& value);

    using Base::setZero;
    Derived& setZero(Index size);
    Derived& setZero(Index rows, Index cols);

    using Base::setOnes;
    Derived& setOnes(Index size);
    Derived& setOnes(Index rows, Index cols);

    using Base::setRandom;
    Derived& setRandom(Index size);
    Derived& setRandom(Index rows, Index cols);





  protected:







    template<typename OtherDerived>
    inline void _resize_to_match(const EigenBase<OtherDerived>& other)
    {





      resizeLike(other);

    }
# 550 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PlainObjectBase.h"
    template<typename OtherDerived>
    inline Derived& _set(const DenseBase<OtherDerived>& other)
    {
      _set_selector(other.derived(), typename internal::conditional<static_cast<bool>(int(OtherDerived::Flags) & EvalBeforeAssigningBit), internal::true_type, internal::false_type>::type());
      return this->derived();
    }

    template<typename OtherDerived>
    inline void _set_selector(const OtherDerived& other, const internal::true_type&) { _set_noalias(other.eval()); }

    template<typename OtherDerived>
    inline void _set_selector(const OtherDerived& other, const internal::false_type&) { _set_noalias(other); }






    template<typename OtherDerived>
    inline Derived& _set_noalias(const DenseBase<OtherDerived>& other)
    {





      return internal::assign_selector<Derived,OtherDerived,false>::run(this->derived(), other.derived());
    }

    template<typename T0, typename T1>
    inline void _init2(Index rows, Index cols, typename internal::enable_if<Base::SizeAtCompileTime!=2,T0>::type* = 0)
    {
      if( (!Eigen::internal::copy_bool(rows >= 0 && (RowsAtCompileTime == Dynamic || RowsAtCompileTime == rows) && cols >= 0 && (ColsAtCompileTime == Dynamic || ColsAtCompileTime == cols))) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(rows >= 0 && (RowsAtCompileTime == Dynamic || RowsAtCompileTime == rows) && cols >= 0 && (ColsAtCompileTime == Dynamic || ColsAtCompileTime == cols))) Eigen::internal::assert_fail("rows >= 0 && (RowsAtCompileTime == Dynamic || RowsAtCompileTime == rows) && cols >= 0 && (ColsAtCompileTime == Dynamic || ColsAtCompileTime == cols)", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PlainObjectBase.h", 583); } while(false); else throw Eigen::eigen_assert_exception(); };

      m_storage.resize(rows*cols,rows,cols);

    }
    template<typename T0, typename T1>
    inline void _init2(const Scalar& x, const Scalar& y, typename internal::enable_if<Base::SizeAtCompileTime==2,T0>::type* = 0)
    {
      if (Eigen::internal::static_assertion<bool(PlainObjectBase::IsVectorAtCompileTime && PlainObjectBase::SizeAtCompileTime==2)>::THIS_METHOD_IS_ONLY_FOR_VECTORS_OF_A_SPECIFIC_SIZE) {}
      m_storage.data()[0] = x;
      m_storage.data()[1] = y;
    }

    template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers>
    friend struct internal::matrix_swap_impl;




    template<typename OtherDerived>
    void _swap(DenseBase<OtherDerived> const & other)
    {
      enum { SwapPointers = internal::is_same<Derived, OtherDerived>::value && Base::SizeAtCompileTime==Dynamic };
      internal::matrix_swap_impl<Derived, OtherDerived, bool(SwapPointers)>::run(this->derived(), other.const_cast_derived());
    }

  public:

    inline static void _check_template_params()
    {
      if (Eigen::internal::static_assertion<bool(((!(MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1) || ((Options&RowMajor)==RowMajor)) && (!(MaxColsAtCompileTime==1 && MaxRowsAtCompileTime!=1) || ((Options&RowMajor)==0)) && ((RowsAtCompileTime == Dynamic) || (RowsAtCompileTime >= 0)) && ((ColsAtCompileTime == Dynamic) || (ColsAtCompileTime >= 0)) && ((MaxRowsAtCompileTime == Dynamic) || (MaxRowsAtCompileTime >= 0)) && ((MaxColsAtCompileTime == Dynamic) || (MaxColsAtCompileTime >= 0)) && (MaxRowsAtCompileTime == RowsAtCompileTime || RowsAtCompileTime==Dynamic) && (MaxColsAtCompileTime == ColsAtCompileTime || ColsAtCompileTime==Dynamic) && (Options & (DontAlign|RowMajor)) == Options))>::INVALID_MATRIX_TEMPLATE_PARAMETERS) {}
# 622 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PlainObjectBase.h"
    }


private:
    enum { ThisConstantIsPrivateInPlainObjectBase };
};

template <typename Derived, typename OtherDerived, bool IsVector>
struct internal::conservative_resize_like_impl
{
  typedef typename Derived::Index Index;
  static void run(DenseBase<Derived>& _this, Index rows, Index cols)
  {
    if (_this.rows() == rows && _this.cols() == cols) return;
    if (Eigen::internal::static_assertion<bool(Derived::SizeAtCompileTime==Eigen::Dynamic)>::YOU_CALLED_A_DYNAMIC_SIZE_METHOD_ON_A_FIXED_SIZE_MATRIX_OR_VECTOR) {}

    if ( ( Derived::IsRowMajor && _this.cols() == cols) ||
         (!Derived::IsRowMajor && _this.rows() == rows) )
    {
      _this.derived().m_storage.conservativeResize(rows*cols,rows,cols);
    }
    else
    {

      typename Derived::PlainObject tmp(rows,cols);
      const Index common_rows = (std::min)(rows, _this.rows());
      const Index common_cols = (std::min)(cols, _this.cols());
      tmp.block(0,0,common_rows,common_cols) = _this.block(0,0,common_rows,common_cols);
      _this.derived().swap(tmp);
    }
  }

  static void run(DenseBase<Derived>& _this, const DenseBase<OtherDerived>& other)
  {
    if (_this.rows() == other.rows() && _this.cols() == other.cols()) return;






    if (Eigen::internal::static_assertion<bool(Derived::SizeAtCompileTime==Eigen::Dynamic)>::YOU_CALLED_A_DYNAMIC_SIZE_METHOD_ON_A_FIXED_SIZE_MATRIX_OR_VECTOR) {}
    if (Eigen::internal::static_assertion<bool(OtherDerived::SizeAtCompileTime==Eigen::Dynamic)>::YOU_CALLED_A_DYNAMIC_SIZE_METHOD_ON_A_FIXED_SIZE_MATRIX_OR_VECTOR) {}

    if ( ( Derived::IsRowMajor && _this.cols() == other.cols()) ||
         (!Derived::IsRowMajor && _this.rows() == other.rows()) )
    {
      const Index new_rows = other.rows() - _this.rows();
      const Index new_cols = other.cols() - _this.cols();
      _this.derived().m_storage.conservativeResize(other.size(),other.rows(),other.cols());
      if (new_rows>0)
        _this.bottomRightCorner(new_rows, other.cols()) = other.bottomRows(new_rows);
      else if (new_cols>0)
        _this.bottomRightCorner(other.rows(), new_cols) = other.rightCols(new_cols);
    }
    else
    {

      typename Derived::PlainObject tmp(other);
      const Index common_rows = (std::min)(tmp.rows(), _this.rows());
      const Index common_cols = (std::min)(tmp.cols(), _this.cols());
      tmp.block(0,0,common_rows,common_cols) = _this.block(0,0,common_rows,common_cols);
      _this.derived().swap(tmp);
    }
  }
};

namespace internal {

template <typename Derived, typename OtherDerived>
struct conservative_resize_like_impl<Derived,OtherDerived,true>
{
  typedef typename Derived::Index Index;
  static void run(DenseBase<Derived>& _this, Index size)
  {
    const Index new_rows = Derived::RowsAtCompileTime==1 ? 1 : size;
    const Index new_cols = Derived::RowsAtCompileTime==1 ? size : 1;
    _this.derived().m_storage.conservativeResize(size,new_rows,new_cols);
  }

  static void run(DenseBase<Derived>& _this, const DenseBase<OtherDerived>& other)
  {
    if (_this.rows() == other.rows() && _this.cols() == other.cols()) return;

    const Index num_new_elements = other.size() - _this.size();

    const Index new_rows = Derived::RowsAtCompileTime==1 ? 1 : other.rows();
    const Index new_cols = Derived::RowsAtCompileTime==1 ? other.cols() : 1;
    _this.derived().m_storage.conservativeResize(other.size(),new_rows,new_cols);

    if (num_new_elements > 0)
      _this.tail(num_new_elements) = other.tail(num_new_elements);
  }
};

template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers>
struct matrix_swap_impl
{
  static inline void run(MatrixTypeA& a, MatrixTypeB& b)
  {
    a.base().swap(b);
  }
};

template<typename MatrixTypeA, typename MatrixTypeB>
struct matrix_swap_impl<MatrixTypeA, MatrixTypeB, true>
{
  static inline void run(MatrixTypeA& a, MatrixTypeB& b)
  {
    static_cast<typename MatrixTypeA::Base&>(a).m_storage.swap(static_cast<typename MatrixTypeB::Base&>(b).m_storage);
  }
};

}
# 293 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Matrix.h" 1
# 117 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Matrix.h"
namespace internal {
template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
struct traits<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
{
  typedef _Scalar Scalar;
  typedef Dense StorageKind;
  typedef DenseIndex Index;
  typedef MatrixXpr XprKind;
  enum {
    RowsAtCompileTime = _Rows,
    ColsAtCompileTime = _Cols,
    MaxRowsAtCompileTime = _MaxRows,
    MaxColsAtCompileTime = _MaxCols,
    Flags = compute_matrix_flags<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::ret,
    CoeffReadCost = NumTraits<Scalar>::ReadCost,
    Options = _Options,
    InnerStrideAtCompileTime = 1,
    OuterStrideAtCompileTime = (Options&RowMajor) ? ColsAtCompileTime : RowsAtCompileTime
  };
};
}

template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
class Matrix
  : public PlainObjectBase<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
{
  public:




    typedef PlainObjectBase<Matrix> Base;

    enum { Options = _Options };

    typedef typename Eigen::internal::traits<Matrix>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<Matrix>::type Nested; typedef typename Eigen::internal::traits<Matrix>::StorageKind StorageKind; typedef typename Eigen::internal::traits<Matrix>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<Matrix>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<Matrix>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<Matrix>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<Matrix>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<Matrix>::Flags, CoeffReadCost = Eigen::internal::traits<Matrix>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived;

    typedef typename Base::PlainObject PlainObject;

    enum { NeedsToAlign = (!(Options&DontAlign))
                          && SizeAtCompileTime!=Dynamic && ((static_cast<int>(sizeof(Scalar))*SizeAtCompileTime)%16)==0 };
    void *operator new(size_t size) { return Eigen::internal::conditional_aligned_malloc<NeedsToAlign>(size); } void *operator new[](size_t size) { return Eigen::internal::conditional_aligned_malloc<NeedsToAlign>(size); } void operator delete(void * ptr) { Eigen::internal::conditional_aligned_free<NeedsToAlign>(ptr); } void operator delete[](void * ptr) { Eigen::internal::conditional_aligned_free<NeedsToAlign>(ptr); } static void *operator new(size_t size, void *ptr) { return ::operator new(size,ptr); } void operator delete(void * memory, void *ptr) { return ::operator delete(memory,ptr); } void* operator new(size_t size, const std::nothrow_t&) { try { return Eigen::internal::conditional_aligned_malloc<NeedsToAlign>(size); } catch (...) { return 0; } return 0; } void operator delete(void *ptr, const std::nothrow_t&) { Eigen::internal::conditional_aligned_free<NeedsToAlign>(ptr); } typedef void eigen_aligned_operator_new_marker_type;

    using Base::base;
    using Base::coeffRef;
# 171 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Matrix.h"
    inline Matrix& operator=(const Matrix& other)
    {
      return Base::_set(other);
    }
# 186 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Matrix.h"
    template<typename OtherDerived>
    inline Matrix& operator=(const MatrixBase<OtherDerived>& other)
    {
      return Base::_set(other);
    }







    template<typename OtherDerived>
    inline Matrix& operator=(const EigenBase<OtherDerived> &other)
    {
      return Base::operator=(other);
    }

    template<typename OtherDerived>
    inline Matrix& operator=(const ReturnByValue<OtherDerived>& func)
    {
      return Base::operator=(func);
    }
# 220 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Matrix.h"
    inline explicit Matrix() : Base()
    {
      Base::_check_template_params();

    }


    Matrix(internal::constructor_without_unaligned_array_assert)
      : Base(internal::constructor_without_unaligned_array_assert())
    { Base::_check_template_params(); }







    inline explicit Matrix(Index dim)
      : Base(dim, RowsAtCompileTime == 1 ? 1 : dim, ColsAtCompileTime == 1 ? 1 : dim)
    {
      Base::_check_template_params();
      if (Eigen::internal::static_assertion<bool(Matrix::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
      if( (!Eigen::internal::copy_bool(dim >= 0)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(dim >= 0)) Eigen::internal::assert_fail("dim >= 0", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Matrix.h", 242); } while(false); else throw Eigen::eigen_assert_exception(); };
      if( (!Eigen::internal::copy_bool(SizeAtCompileTime == Dynamic || SizeAtCompileTime == dim)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(SizeAtCompileTime == Dynamic || SizeAtCompileTime == dim)) Eigen::internal::assert_fail("SizeAtCompileTime == Dynamic || SizeAtCompileTime == dim", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Matrix.h", 243); } while(false); else throw Eigen::eigen_assert_exception(); };

    }


    template<typename T0, typename T1>
    inline Matrix(const T0& x, const T1& y)
    {
      Base::_check_template_params();
      Base::template _init2<T0,T1>(x, y);
    }
# 266 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Matrix.h"
    inline Matrix(const Scalar& x, const Scalar& y, const Scalar& z)
    {
      Base::_check_template_params();
      if (Eigen::internal::static_assertion<bool(Matrix::IsVectorAtCompileTime && Matrix::SizeAtCompileTime==3)>::THIS_METHOD_IS_ONLY_FOR_VECTORS_OF_A_SPECIFIC_SIZE) {}
      m_storage.data()[0] = x;
      m_storage.data()[1] = y;
      m_storage.data()[2] = z;
    }

    inline Matrix(const Scalar& x, const Scalar& y, const Scalar& z, const Scalar& w)
    {
      Base::_check_template_params();
      if (Eigen::internal::static_assertion<bool(Matrix::IsVectorAtCompileTime && Matrix::SizeAtCompileTime==4)>::THIS_METHOD_IS_ONLY_FOR_VECTORS_OF_A_SPECIFIC_SIZE) {}
      m_storage.data()[0] = x;
      m_storage.data()[1] = y;
      m_storage.data()[2] = z;
      m_storage.data()[3] = w;
    }

    explicit Matrix(const Scalar *data);


    template<typename OtherDerived>
    inline Matrix(const MatrixBase<OtherDerived>& other)
             : Base(other.rows() * other.cols(), other.rows(), other.cols())
    {


      if (Eigen::internal::static_assertion<bool((internal::is_same<Scalar, typename OtherDerived::Scalar>::value))>::YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY) {}


      Base::_check_template_params();
      Base::_set_noalias(other);
    }

    inline Matrix(const Matrix& other)
            : Base(other.rows() * other.cols(), other.rows(), other.cols())
    {
      Base::_check_template_params();
      Base::_set_noalias(other);
    }

    template<typename OtherDerived>
    inline Matrix(const ReturnByValue<OtherDerived>& other)
    {
      Base::_check_template_params();
      Base::resize(other.rows(), other.cols());
      other.evalTo(*this);
    }




    template<typename OtherDerived>
    inline Matrix(const EigenBase<OtherDerived> &other)
      : Base(other.derived().rows() * other.derived().cols(), other.derived().rows(), other.derived().cols())
    {
      Base::_check_template_params();
      Base::resize(other.rows(), other.cols());


      *this = other;
    }





    template<typename OtherDerived>
    void swap(MatrixBase<OtherDerived> const & other)
    { this->_swap(other.derived()); }

    inline Index innerStride() const { return 1; }
    inline Index outerStride() const { return this->innerSize(); }



    template<typename OtherDerived>
    explicit Matrix(const RotationBase<OtherDerived,ColsAtCompileTime>& r);
    template<typename OtherDerived>
    Matrix& operator=(const RotationBase<OtherDerived,ColsAtCompileTime>& r);
# 360 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Matrix.h"
  protected:
    template <typename Derived, typename OtherDerived, bool IsVector>
    friend struct internal::conservative_resize_like_impl;

    using Base::m_storage;
};
# 410 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Matrix.h"
typedef Matrix<int, 2, 2> Matrix2i; typedef Matrix<int, 2, 1> Vector2i; typedef Matrix<int, 1, 2> RowVector2i; typedef Matrix<int, 3, 3> Matrix3i; typedef Matrix<int, 3, 1> Vector3i; typedef Matrix<int, 1, 3> RowVector3i; typedef Matrix<int, 4, 4> Matrix4i; typedef Matrix<int, 4, 1> Vector4i; typedef Matrix<int, 1, 4> RowVector4i; typedef Matrix<int, Dynamic, Dynamic> MatrixXi; typedef Matrix<int, Dynamic, 1> VectorXi; typedef Matrix<int, 1, Dynamic> RowVectorXi; typedef Matrix<int, 2, Dynamic> Matrix2Xi; typedef Matrix<int, Dynamic, 2> MatrixX2i; typedef Matrix<int, 3, Dynamic> Matrix3Xi; typedef Matrix<int, Dynamic, 3> MatrixX3i; typedef Matrix<int, 4, Dynamic> Matrix4Xi; typedef Matrix<int, Dynamic, 4> MatrixX4i;
typedef Matrix<float, 2, 2> Matrix2f; typedef Matrix<float, 2, 1> Vector2f; typedef Matrix<float, 1, 2> RowVector2f; typedef Matrix<float, 3, 3> Matrix3f; typedef Matrix<float, 3, 1> Vector3f; typedef Matrix<float, 1, 3> RowVector3f; typedef Matrix<float, 4, 4> Matrix4f; typedef Matrix<float, 4, 1> Vector4f; typedef Matrix<float, 1, 4> RowVector4f; typedef Matrix<float, Dynamic, Dynamic> MatrixXf; typedef Matrix<float, Dynamic, 1> VectorXf; typedef Matrix<float, 1, Dynamic> RowVectorXf; typedef Matrix<float, 2, Dynamic> Matrix2Xf; typedef Matrix<float, Dynamic, 2> MatrixX2f; typedef Matrix<float, 3, Dynamic> Matrix3Xf; typedef Matrix<float, Dynamic, 3> MatrixX3f; typedef Matrix<float, 4, Dynamic> Matrix4Xf; typedef Matrix<float, Dynamic, 4> MatrixX4f;
typedef Matrix<double, 2, 2> Matrix2d; typedef Matrix<double, 2, 1> Vector2d; typedef Matrix<double, 1, 2> RowVector2d; typedef Matrix<double, 3, 3> Matrix3d; typedef Matrix<double, 3, 1> Vector3d; typedef Matrix<double, 1, 3> RowVector3d; typedef Matrix<double, 4, 4> Matrix4d; typedef Matrix<double, 4, 1> Vector4d; typedef Matrix<double, 1, 4> RowVector4d; typedef Matrix<double, Dynamic, Dynamic> MatrixXd; typedef Matrix<double, Dynamic, 1> VectorXd; typedef Matrix<double, 1, Dynamic> RowVectorXd; typedef Matrix<double, 2, Dynamic> Matrix2Xd; typedef Matrix<double, Dynamic, 2> MatrixX2d; typedef Matrix<double, 3, Dynamic> Matrix3Xd; typedef Matrix<double, Dynamic, 3> MatrixX3d; typedef Matrix<double, 4, Dynamic> Matrix4Xd; typedef Matrix<double, Dynamic, 4> MatrixX4d;
typedef Matrix<std::complex<float>, 2, 2> Matrix2cf; typedef Matrix<std::complex<float>, 2, 1> Vector2cf; typedef Matrix<std::complex<float>, 1, 2> RowVector2cf; typedef Matrix<std::complex<float>, 3, 3> Matrix3cf; typedef Matrix<std::complex<float>, 3, 1> Vector3cf; typedef Matrix<std::complex<float>, 1, 3> RowVector3cf; typedef Matrix<std::complex<float>, 4, 4> Matrix4cf; typedef Matrix<std::complex<float>, 4, 1> Vector4cf; typedef Matrix<std::complex<float>, 1, 4> RowVector4cf; typedef Matrix<std::complex<float>, Dynamic, Dynamic> MatrixXcf; typedef Matrix<std::complex<float>, Dynamic, 1> VectorXcf; typedef Matrix<std::complex<float>, 1, Dynamic> RowVectorXcf; typedef Matrix<std::complex<float>, 2, Dynamic> Matrix2Xcf; typedef Matrix<std::complex<float>, Dynamic, 2> MatrixX2cf; typedef Matrix<std::complex<float>, 3, Dynamic> Matrix3Xcf; typedef Matrix<std::complex<float>, Dynamic, 3> MatrixX3cf; typedef Matrix<std::complex<float>, 4, Dynamic> Matrix4Xcf; typedef Matrix<std::complex<float>, Dynamic, 4> MatrixX4cf;
typedef Matrix<std::complex<double>, 2, 2> Matrix2cd; typedef Matrix<std::complex<double>, 2, 1> Vector2cd; typedef Matrix<std::complex<double>, 1, 2> RowVector2cd; typedef Matrix<std::complex<double>, 3, 3> Matrix3cd; typedef Matrix<std::complex<double>, 3, 1> Vector3cd; typedef Matrix<std::complex<double>, 1, 3> RowVector3cd; typedef Matrix<std::complex<double>, 4, 4> Matrix4cd; typedef Matrix<std::complex<double>, 4, 1> Vector4cd; typedef Matrix<std::complex<double>, 1, 4> RowVector4cd; typedef Matrix<std::complex<double>, Dynamic, Dynamic> MatrixXcd; typedef Matrix<std::complex<double>, Dynamic, 1> VectorXcd; typedef Matrix<std::complex<double>, 1, Dynamic> RowVectorXcd; typedef Matrix<std::complex<double>, 2, Dynamic> Matrix2Xcd; typedef Matrix<std::complex<double>, Dynamic, 2> MatrixX2cd; typedef Matrix<std::complex<double>, 3, Dynamic> Matrix3Xcd; typedef Matrix<std::complex<double>, Dynamic, 3> MatrixX3cd; typedef Matrix<std::complex<double>, 4, Dynamic> Matrix4Xcd; typedef Matrix<std::complex<double>, Dynamic, 4> MatrixX4cd;
# 294 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Array.h" 1
# 45 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Array.h"
namespace internal {
template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
struct traits<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > : traits<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
{
  typedef ArrayXpr XprKind;
  typedef ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > XprBase;
};
}

template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
class Array
  : public PlainObjectBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
{
  public:

    typedef PlainObjectBase<Array> Base;
    typedef typename Eigen::internal::traits<Array>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<Array>::type Nested; typedef typename Eigen::internal::traits<Array>::StorageKind StorageKind; typedef typename Eigen::internal::traits<Array>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<Array>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<Array>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<Array>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<Array>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<Array>::Flags, CoeffReadCost = Eigen::internal::traits<Array>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived;

    enum { Options = _Options };
    typedef typename Base::PlainObject PlainObject;

  protected:
    template <typename Derived, typename OtherDerived, bool IsVector>
    friend struct internal::conservative_resize_like_impl;

    using Base::m_storage;
  public:
    enum { NeedsToAlign = (!(Options&DontAlign))
                          && SizeAtCompileTime!=Dynamic && ((static_cast<int>(sizeof(Scalar))*SizeAtCompileTime)%16)==0 };
    void *operator new(size_t size) { return Eigen::internal::conditional_aligned_malloc<NeedsToAlign>(size); } void *operator new[](size_t size) { return Eigen::internal::conditional_aligned_malloc<NeedsToAlign>(size); } void operator delete(void * ptr) { Eigen::internal::conditional_aligned_free<NeedsToAlign>(ptr); } void operator delete[](void * ptr) { Eigen::internal::conditional_aligned_free<NeedsToAlign>(ptr); } static void *operator new(size_t size, void *ptr) { return ::operator new(size,ptr); } void operator delete(void * memory, void *ptr) { return ::operator delete(memory,ptr); } void* operator new(size_t size, const std::nothrow_t&) { try { return Eigen::internal::conditional_aligned_malloc<NeedsToAlign>(size); } catch (...) { return 0; } return 0; } void operator delete(void *ptr, const std::nothrow_t&) { Eigen::internal::conditional_aligned_free<NeedsToAlign>(ptr); } typedef void eigen_aligned_operator_new_marker_type;

    using Base::base;
    using Base::coeff;
    using Base::coeffRef;







    template<typename OtherDerived>
    inline Array& operator=(const EigenBase<OtherDerived> &other)
    {
      return Base::operator=(other);
    }
# 101 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Array.h"
    template<typename OtherDerived>
    inline Array& operator=(const ArrayBase<OtherDerived>& other)
    {
      return Base::_set(other);
    }




    inline Array& operator=(const Array& other)
    {
      return Base::_set(other);
    }
# 125 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Array.h"
    inline explicit Array() : Base()
    {
      Base::_check_template_params();

    }




    Array(internal::constructor_without_unaligned_array_assert)
      : Base(internal::constructor_without_unaligned_array_assert())
    {
      Base::_check_template_params();

    }
# 148 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Array.h"
    inline explicit Array(Index dim)
      : Base(dim, RowsAtCompileTime == 1 ? 1 : dim, ColsAtCompileTime == 1 ? 1 : dim)
    {
      Base::_check_template_params();
      if (Eigen::internal::static_assertion<bool(Array::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
      if( (!Eigen::internal::copy_bool(dim >= 0)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(dim >= 0)) Eigen::internal::assert_fail("dim >= 0", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Array.h", 153); } while(false); else throw Eigen::eigen_assert_exception(); };
      if( (!Eigen::internal::copy_bool(SizeAtCompileTime == Dynamic || SizeAtCompileTime == dim)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(SizeAtCompileTime == Dynamic || SizeAtCompileTime == dim)) Eigen::internal::assert_fail("SizeAtCompileTime == Dynamic || SizeAtCompileTime == dim", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Array.h", 154); } while(false); else throw Eigen::eigen_assert_exception(); };

    }


    template<typename T0, typename T1>
    inline Array(const T0& x, const T1& y)
    {
      Base::_check_template_params();
      this->template _init2<T0,T1>(x, y);
    }
# 177 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Array.h"
    inline Array(const Scalar& x, const Scalar& y, const Scalar& z)
    {
      Base::_check_template_params();
      if (Eigen::internal::static_assertion<bool(Array::IsVectorAtCompileTime && Array::SizeAtCompileTime==3)>::THIS_METHOD_IS_ONLY_FOR_VECTORS_OF_A_SPECIFIC_SIZE) {}
      m_storage.data()[0] = x;
      m_storage.data()[1] = y;
      m_storage.data()[2] = z;
    }

    inline Array(const Scalar& x, const Scalar& y, const Scalar& z, const Scalar& w)
    {
      Base::_check_template_params();
      if (Eigen::internal::static_assertion<bool(Array::IsVectorAtCompileTime && Array::SizeAtCompileTime==4)>::THIS_METHOD_IS_ONLY_FOR_VECTORS_OF_A_SPECIFIC_SIZE) {}
      m_storage.data()[0] = x;
      m_storage.data()[1] = y;
      m_storage.data()[2] = z;
      m_storage.data()[3] = w;
    }

    explicit Array(const Scalar *data);


    template<typename OtherDerived>
    inline Array(const ArrayBase<OtherDerived>& other)
             : Base(other.rows() * other.cols(), other.rows(), other.cols())
    {
      Base::_check_template_params();
      Base::_set_noalias(other);
    }

    inline Array(const Array& other)
            : Base(other.rows() * other.cols(), other.rows(), other.cols())
    {
      Base::_check_template_params();
      Base::_set_noalias(other);
    }

    template<typename OtherDerived>
    inline Array(const ReturnByValue<OtherDerived>& other)
    {
      Base::_check_template_params();
      Base::resize(other.rows(), other.cols());
      other.evalTo(*this);
    }


    template<typename OtherDerived>
    inline Array(const EigenBase<OtherDerived> &other)
      : Base(other.derived().rows() * other.derived().cols(), other.derived().rows(), other.derived().cols())
    {
      Base::_check_template_params();
      Base::resize(other.rows(), other.cols());
      *this = other;
    }




    template<typename OtherDerived>
    void swap(ArrayBase<OtherDerived> const & other)
    { this->_swap(other.derived()); }

    inline Index innerStride() const { return 1; }
    inline Index outerStride() const { return this->innerSize(); }





  private:

    template<typename MatrixType, typename OtherDerived, bool SwapPointers>
    friend struct internal::matrix_swap_impl;
};
# 292 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Array.h"
typedef Array<int, 2, 2> Array22i; typedef Array<int, 2, 1> Array2i; typedef Array<int, 3, 3> Array33i; typedef Array<int, 3, 1> Array3i; typedef Array<int, 4, 4> Array44i; typedef Array<int, 4, 1> Array4i; typedef Array<int, Dynamic, Dynamic> ArrayXXi; typedef Array<int, Dynamic, 1> ArrayXi; typedef Array<int, 2, Dynamic> Array2Xi; typedef Array<int, Dynamic, 2> ArrayX2i; typedef Array<int, 3, Dynamic> Array3Xi; typedef Array<int, Dynamic, 3> ArrayX3i; typedef Array<int, 4, Dynamic> Array4Xi; typedef Array<int, Dynamic, 4> ArrayX4i;
typedef Array<float, 2, 2> Array22f; typedef Array<float, 2, 1> Array2f; typedef Array<float, 3, 3> Array33f; typedef Array<float, 3, 1> Array3f; typedef Array<float, 4, 4> Array44f; typedef Array<float, 4, 1> Array4f; typedef Array<float, Dynamic, Dynamic> ArrayXXf; typedef Array<float, Dynamic, 1> ArrayXf; typedef Array<float, 2, Dynamic> Array2Xf; typedef Array<float, Dynamic, 2> ArrayX2f; typedef Array<float, 3, Dynamic> Array3Xf; typedef Array<float, Dynamic, 3> ArrayX3f; typedef Array<float, 4, Dynamic> Array4Xf; typedef Array<float, Dynamic, 4> ArrayX4f;
typedef Array<double, 2, 2> Array22d; typedef Array<double, 2, 1> Array2d; typedef Array<double, 3, 3> Array33d; typedef Array<double, 3, 1> Array3d; typedef Array<double, 4, 4> Array44d; typedef Array<double, 4, 1> Array4d; typedef Array<double, Dynamic, Dynamic> ArrayXXd; typedef Array<double, Dynamic, 1> ArrayXd; typedef Array<double, 2, Dynamic> Array2Xd; typedef Array<double, Dynamic, 2> ArrayX2d; typedef Array<double, 3, Dynamic> Array3Xd; typedef Array<double, Dynamic, 3> ArrayX3d; typedef Array<double, 4, Dynamic> Array4Xd; typedef Array<double, Dynamic, 4> ArrayX4d;
typedef Array<std::complex<float>, 2, 2> Array22cf; typedef Array<std::complex<float>, 2, 1> Array2cf; typedef Array<std::complex<float>, 3, 3> Array33cf; typedef Array<std::complex<float>, 3, 1> Array3cf; typedef Array<std::complex<float>, 4, 4> Array44cf; typedef Array<std::complex<float>, 4, 1> Array4cf; typedef Array<std::complex<float>, Dynamic, Dynamic> ArrayXXcf; typedef Array<std::complex<float>, Dynamic, 1> ArrayXcf; typedef Array<std::complex<float>, 2, Dynamic> Array2Xcf; typedef Array<std::complex<float>, Dynamic, 2> ArrayX2cf; typedef Array<std::complex<float>, 3, Dynamic> Array3Xcf; typedef Array<std::complex<float>, Dynamic, 3> ArrayX3cf; typedef Array<std::complex<float>, 4, Dynamic> Array4Xcf; typedef Array<std::complex<float>, Dynamic, 4> ArrayX4cf;
typedef Array<std::complex<double>, 2, 2> Array22cd; typedef Array<std::complex<double>, 2, 1> Array2cd; typedef Array<std::complex<double>, 3, 3> Array33cd; typedef Array<std::complex<double>, 3, 1> Array3cd; typedef Array<std::complex<double>, 4, 4> Array44cd; typedef Array<std::complex<double>, 4, 1> Array4cd; typedef Array<std::complex<double>, Dynamic, Dynamic> ArrayXXcd; typedef Array<std::complex<double>, Dynamic, 1> ArrayXcd; typedef Array<std::complex<double>, 2, Dynamic> Array2Xcd; typedef Array<std::complex<double>, Dynamic, 2> ArrayX2cd; typedef Array<std::complex<double>, 3, Dynamic> Array3Xcd; typedef Array<std::complex<double>, Dynamic, 3> ArrayX3cd; typedef Array<std::complex<double>, 4, Dynamic> Array4Xcd; typedef Array<std::complex<double>, Dynamic, 4> ArrayX4cd;
# 295 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseBinaryOp.h" 1
# 49 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseBinaryOp.h"
namespace internal {
template<typename BinaryOp, typename Lhs, typename Rhs>
struct traits<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >
{


  typedef typename remove_all<Lhs>::type Ancestor;
  typedef typename traits<Ancestor>::XprKind XprKind;
  enum {
    RowsAtCompileTime = traits<Ancestor>::RowsAtCompileTime,
    ColsAtCompileTime = traits<Ancestor>::ColsAtCompileTime,
    MaxRowsAtCompileTime = traits<Ancestor>::MaxRowsAtCompileTime,
    MaxColsAtCompileTime = traits<Ancestor>::MaxColsAtCompileTime
  };



  typedef typename result_of<
                     BinaryOp(
                       typename Lhs::Scalar,
                       typename Rhs::Scalar
                     )
                   >::type Scalar;
  typedef typename promote_storage_type<typename traits<Lhs>::StorageKind,
                                           typename traits<Rhs>::StorageKind>::ret StorageKind;
  typedef typename promote_index_type<typename traits<Lhs>::Index,
                                         typename traits<Rhs>::Index>::type Index;
  typedef typename Lhs::Nested LhsNested;
  typedef typename Rhs::Nested RhsNested;
  typedef typename remove_reference<LhsNested>::type _LhsNested;
  typedef typename remove_reference<RhsNested>::type _RhsNested;
  enum {
    LhsCoeffReadCost = _LhsNested::CoeffReadCost,
    RhsCoeffReadCost = _RhsNested::CoeffReadCost,
    LhsFlags = _LhsNested::Flags,
    RhsFlags = _RhsNested::Flags,
    SameType = is_same<typename _LhsNested::Scalar,typename _RhsNested::Scalar>::value,
    StorageOrdersAgree = (int(Lhs::Flags)&RowMajorBit)==(int(Rhs::Flags)&RowMajorBit),
    Flags0 = (int(LhsFlags) | int(RhsFlags)) & (
        HereditaryBits
      | (int(LhsFlags) & int(RhsFlags) &
           ( AlignedBit
           | (StorageOrdersAgree ? LinearAccessBit : 0)
           | (functor_traits<BinaryOp>::PacketAccess && StorageOrdersAgree && SameType ? PacketAccessBit : 0)
           )
        )
     ),
    Flags = (Flags0 & ~RowMajorBit) | (LhsFlags & RowMajorBit),
    CoeffReadCost = LhsCoeffReadCost + RhsCoeffReadCost + functor_traits<BinaryOp>::Cost
  };
};
}
# 115 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseBinaryOp.h"
template<typename BinaryOp, typename Lhs, typename Rhs, typename StorageKind>
class CwiseBinaryOpImpl;

template<typename BinaryOp, typename Lhs, typename Rhs>
class CwiseBinaryOp : internal::no_assignment_operator,
  public CwiseBinaryOpImpl<
          BinaryOp, Lhs, Rhs,
          typename internal::promote_storage_type<typename internal::traits<Lhs>::StorageKind,
                                           typename internal::traits<Rhs>::StorageKind>::ret>
{
  public:

    typedef typename CwiseBinaryOpImpl<
        BinaryOp, Lhs, Rhs,
        typename internal::promote_storage_type<typename internal::traits<Lhs>::StorageKind,
                                         typename internal::traits<Rhs>::StorageKind>::ret>::Base Base;
    typedef typename Eigen::internal::traits<CwiseBinaryOp>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<CwiseBinaryOp>::type Nested; typedef typename Eigen::internal::traits<CwiseBinaryOp>::StorageKind StorageKind; typedef typename Eigen::internal::traits<CwiseBinaryOp>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<CwiseBinaryOp>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<CwiseBinaryOp>::ColsAtCompileTime, Flags = Eigen::internal::traits<CwiseBinaryOp>::Flags, CoeffReadCost = Eigen::internal::traits<CwiseBinaryOp>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime };

    typedef typename internal::nested<Lhs>::type LhsNested;
    typedef typename internal::nested<Rhs>::type RhsNested;
    typedef typename internal::remove_reference<LhsNested>::type _LhsNested;
    typedef typename internal::remove_reference<RhsNested>::type _RhsNested;

    inline CwiseBinaryOp(const Lhs& lhs, const Rhs& rhs, const BinaryOp& func = BinaryOp())
      : m_lhs(lhs), m_rhs(rhs), m_functor(func)
    {
      if (Eigen::internal::static_assertion<bool((internal::functor_allows_mixing_real_and_complex<BinaryOp>::ret ? int(internal::is_same<typename NumTraits<typename Lhs::Scalar>::Real, typename NumTraits<typename Rhs::Scalar>::Real>::value) : int(internal::is_same<typename Lhs::Scalar, typename Rhs::Scalar>::value)))>::YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY) {};

      if (Eigen::internal::static_assertion<bool(( (int(Lhs::SizeAtCompileTime)==0 && int(Rhs::SizeAtCompileTime)==0) || ( (int(Lhs::RowsAtCompileTime)==Eigen::Dynamic || int(Rhs::RowsAtCompileTime)==Eigen::Dynamic || int(Lhs::RowsAtCompileTime)==int(Rhs::RowsAtCompileTime)) && (int(Lhs::ColsAtCompileTime)==Eigen::Dynamic || int(Rhs::ColsAtCompileTime)==Eigen::Dynamic || int(Lhs::ColsAtCompileTime)==int(Rhs::ColsAtCompileTime)) ) ))>::YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES) {}
      if( (!Eigen::internal::copy_bool(lhs.rows() == rhs.rows() && lhs.cols() == rhs.cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(lhs.rows() == rhs.rows() && lhs.cols() == rhs.cols())) Eigen::internal::assert_fail("lhs.rows() == rhs.rows() && lhs.cols() == rhs.cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseBinaryOp.h", 144); } while(false); else throw Eigen::eigen_assert_exception(); };
    }

    inline Index rows() const {

      if (internal::traits<typename internal::remove_all<LhsNested>::type>::RowsAtCompileTime==Dynamic)
        return m_rhs.rows();
      else
        return m_lhs.rows();
    }
    inline Index cols() const {

      if (internal::traits<typename internal::remove_all<LhsNested>::type>::ColsAtCompileTime==Dynamic)
        return m_rhs.cols();
      else
        return m_lhs.cols();
    }


    const _LhsNested& lhs() const { return m_lhs; }

    const _RhsNested& rhs() const { return m_rhs; }

    const BinaryOp& functor() const { return m_functor; }

  protected:
    const LhsNested m_lhs;
    const RhsNested m_rhs;
    const BinaryOp m_functor;
};

template<typename BinaryOp, typename Lhs, typename Rhs>
class CwiseBinaryOpImpl<BinaryOp, Lhs, Rhs, Dense>
  : public internal::dense_xpr_base<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >::type
{
    typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> Derived;
  public:

    typedef typename internal::dense_xpr_base<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >::type Base;
    typedef typename Eigen::internal::traits<Derived>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<Derived>::type Nested; typedef typename Eigen::internal::traits<Derived>::StorageKind StorageKind; typedef typename Eigen::internal::traits<Derived>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<Derived>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<Derived>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<Derived>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<Derived>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<Derived>::Flags, CoeffReadCost = Eigen::internal::traits<Derived>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived;

    inline const Scalar coeff(Index row, Index col) const
    {
      return derived().functor()(derived().lhs().coeff(row, col),
                                 derived().rhs().coeff(row, col));
    }

    template<int LoadMode>
    inline PacketScalar packet(Index row, Index col) const
    {
      return derived().functor().packetOp(derived().lhs().template packet<LoadMode>(row, col),
                                          derived().rhs().template packet<LoadMode>(row, col));
    }

    inline const Scalar coeff(Index index) const
    {
      return derived().functor()(derived().lhs().coeff(index),
                                 derived().rhs().coeff(index));
    }

    template<int LoadMode>
    inline PacketScalar packet(Index index) const
    {
      return derived().functor().packetOp(derived().lhs().template packet<LoadMode>(index),
                                          derived().rhs().template packet<LoadMode>(index));
    }
};





template<typename Derived>
template<typename OtherDerived>
inline Derived &
MatrixBase<Derived>::operator-=(const MatrixBase<OtherDerived> &other)
{
  SelfCwiseBinaryOp<internal::scalar_difference_op<Scalar>, Derived, OtherDerived> tmp(derived());
  tmp = other.derived();
  return derived();
}





template<typename Derived>
template<typename OtherDerived>
inline Derived &
MatrixBase<Derived>::operator+=(const MatrixBase<OtherDerived>& other)
{
  SelfCwiseBinaryOp<internal::scalar_sum_op<Scalar>, Derived, OtherDerived> tmp(derived());
  tmp = other.derived();
  return derived();
}
# 296 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseUnaryOp.h" 1
# 49 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseUnaryOp.h"
namespace internal {
template<typename UnaryOp, typename XprType>
struct traits<CwiseUnaryOp<UnaryOp, XprType> >
 : traits<XprType>
{
  typedef typename result_of<
                     UnaryOp(typename XprType::Scalar)
                   >::type Scalar;
  typedef typename XprType::Nested XprTypeNested;
  typedef typename remove_reference<XprTypeNested>::type _XprTypeNested;
  enum {
    Flags = _XprTypeNested::Flags & (
      HereditaryBits | LinearAccessBit | AlignedBit
      | (functor_traits<UnaryOp>::PacketAccess ? PacketAccessBit : 0)),
    CoeffReadCost = _XprTypeNested::CoeffReadCost + functor_traits<UnaryOp>::Cost
  };
};
}

template<typename UnaryOp, typename XprType, typename StorageKind>
class CwiseUnaryOpImpl;

template<typename UnaryOp, typename XprType>
class CwiseUnaryOp : internal::no_assignment_operator,
  public CwiseUnaryOpImpl<UnaryOp, XprType, typename internal::traits<XprType>::StorageKind>
{
  public:

    typedef typename CwiseUnaryOpImpl<UnaryOp, XprType,typename internal::traits<XprType>::StorageKind>::Base Base;
    typedef typename Eigen::internal::traits<CwiseUnaryOp>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<CwiseUnaryOp>::type Nested; typedef typename Eigen::internal::traits<CwiseUnaryOp>::StorageKind StorageKind; typedef typename Eigen::internal::traits<CwiseUnaryOp>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<CwiseUnaryOp>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<CwiseUnaryOp>::ColsAtCompileTime, Flags = Eigen::internal::traits<CwiseUnaryOp>::Flags, CoeffReadCost = Eigen::internal::traits<CwiseUnaryOp>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime };

    inline CwiseUnaryOp(const XprType& xpr, const UnaryOp& func = UnaryOp())
      : m_xpr(xpr), m_functor(func) {}

    inline Index rows() const { return m_xpr.rows(); }
    inline Index cols() const { return m_xpr.cols(); }


    const UnaryOp& functor() const { return m_functor; }


    const typename internal::remove_all<typename XprType::Nested>::type&
    nestedExpression() const { return m_xpr; }


    typename internal::remove_all<typename XprType::Nested>::type&
    nestedExpression() { return m_xpr.const_cast_derived(); }

  protected:
    const typename XprType::Nested m_xpr;
    const UnaryOp m_functor;
};



template<typename UnaryOp, typename XprType>
class CwiseUnaryOpImpl<UnaryOp,XprType,Dense>
  : public internal::dense_xpr_base<CwiseUnaryOp<UnaryOp, XprType> >::type
{
  public:

    typedef CwiseUnaryOp<UnaryOp, XprType> Derived;
    typedef typename internal::dense_xpr_base<CwiseUnaryOp<UnaryOp, XprType> >::type Base;
    typedef typename Eigen::internal::traits<Derived>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<Derived>::type Nested; typedef typename Eigen::internal::traits<Derived>::StorageKind StorageKind; typedef typename Eigen::internal::traits<Derived>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<Derived>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<Derived>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<Derived>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<Derived>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<Derived>::Flags, CoeffReadCost = Eigen::internal::traits<Derived>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived;

    inline const Scalar coeff(Index row, Index col) const
    {
      return derived().functor()(derived().nestedExpression().coeff(row, col));
    }

    template<int LoadMode>
    inline PacketScalar packet(Index row, Index col) const
    {
      return derived().functor().packetOp(derived().nestedExpression().template packet<LoadMode>(row, col));
    }

    inline const Scalar coeff(Index index) const
    {
      return derived().functor()(derived().nestedExpression().coeff(index));
    }

    template<int LoadMode>
    inline PacketScalar packet(Index index) const
    {
      return derived().functor().packetOp(derived().nestedExpression().template packet<LoadMode>(index));
    }
};
# 297 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h" 1
# 46 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
namespace internal {
template<typename NullaryOp, typename PlainObjectType>
struct traits<CwiseNullaryOp<NullaryOp, PlainObjectType> > : traits<PlainObjectType>
{
  enum {
    Flags = (traits<PlainObjectType>::Flags
      & ( HereditaryBits
         | (functor_has_linear_access<NullaryOp>::ret ? LinearAccessBit : 0)
         | (functor_traits<NullaryOp>::PacketAccess ? PacketAccessBit : 0)))
      | (functor_traits<NullaryOp>::IsRepeatable ? 0 : EvalBeforeNestingBit),
    CoeffReadCost = functor_traits<NullaryOp>::Cost
  };
};
}

template<typename NullaryOp, typename PlainObjectType>
class CwiseNullaryOp : internal::no_assignment_operator,
  public internal::dense_xpr_base< CwiseNullaryOp<NullaryOp, PlainObjectType> >::type
{
  public:

    typedef typename internal::dense_xpr_base<CwiseNullaryOp>::type Base;
    typedef typename Eigen::internal::traits<CwiseNullaryOp>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<CwiseNullaryOp>::type Nested; typedef typename Eigen::internal::traits<CwiseNullaryOp>::StorageKind StorageKind; typedef typename Eigen::internal::traits<CwiseNullaryOp>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<CwiseNullaryOp>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<CwiseNullaryOp>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<CwiseNullaryOp>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<CwiseNullaryOp>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<CwiseNullaryOp>::Flags, CoeffReadCost = Eigen::internal::traits<CwiseNullaryOp>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived;

    CwiseNullaryOp(Index rows, Index cols, const NullaryOp& func = NullaryOp())
      : m_rows(rows), m_cols(cols), m_functor(func)
    {
      if( (!Eigen::internal::copy_bool(rows >= 0 && (RowsAtCompileTime == Dynamic || RowsAtCompileTime == rows) && cols >= 0 && (ColsAtCompileTime == Dynamic || ColsAtCompileTime == cols))) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(rows >= 0 && (RowsAtCompileTime == Dynamic || RowsAtCompileTime == rows) && cols >= 0 && (ColsAtCompileTime == Dynamic || ColsAtCompileTime == cols))) Eigen::internal::assert_fail("rows >= 0 && (RowsAtCompileTime == Dynamic || RowsAtCompileTime == rows) && cols >= 0 && (ColsAtCompileTime == Dynamic || ColsAtCompileTime == cols)", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h", 76); } while(false); else throw Eigen::eigen_assert_exception(); };



    }

    inline Index rows() const { return m_rows.value(); }
    inline Index cols() const { return m_cols.value(); }

    inline const Scalar coeff(Index rows, Index cols) const
    {
      return m_functor(rows, cols);
    }

    template<int LoadMode>
    inline PacketScalar packet(Index row, Index col) const
    {
      return m_functor.packetOp(row, col);
    }

    inline const Scalar coeff(Index index) const
    {
      return m_functor(index);
    }

    template<int LoadMode>
    inline PacketScalar packet(Index index) const
    {
      return m_functor.packetOp(index);
    }

  protected:
    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_rows;
    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_cols;
    const NullaryOp m_functor;
};
# 124 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
template<typename CustomNullaryOp>
inline const CwiseNullaryOp<CustomNullaryOp, Derived>
DenseBase<Derived>::NullaryExpr(Index rows, Index cols, const CustomNullaryOp& func)
{
  return CwiseNullaryOp<CustomNullaryOp, Derived>(rows, cols, func);
}
# 147 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
template<typename CustomNullaryOp>
inline const CwiseNullaryOp<CustomNullaryOp, Derived>
DenseBase<Derived>::NullaryExpr(Index size, const CustomNullaryOp& func)
{
  if (Eigen::internal::static_assertion<bool(Derived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
  if(RowsAtCompileTime == 1) return CwiseNullaryOp<CustomNullaryOp, Derived>(1, size, func);
  else return CwiseNullaryOp<CustomNullaryOp, Derived>(size, 1, func);
}
# 166 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
template<typename CustomNullaryOp>
inline const CwiseNullaryOp<CustomNullaryOp, Derived>
DenseBase<Derived>::NullaryExpr(const CustomNullaryOp& func)
{
  return CwiseNullaryOp<CustomNullaryOp, Derived>(RowsAtCompileTime, ColsAtCompileTime, func);
}
# 187 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
inline const typename DenseBase<Derived>::ConstantReturnType
DenseBase<Derived>::Constant(Index rows, Index cols, const Scalar& value)
{
  return DenseBase<Derived>::NullaryExpr(rows, cols, internal::scalar_constant_op<Scalar>(value));
}
# 209 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
inline const typename DenseBase<Derived>::ConstantReturnType
DenseBase<Derived>::Constant(Index size, const Scalar& value)
{
  return DenseBase<Derived>::NullaryExpr(size, internal::scalar_constant_op<Scalar>(value));
}
# 225 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
inline const typename DenseBase<Derived>::ConstantReturnType
DenseBase<Derived>::Constant(const Scalar& value)
{
  if (Eigen::internal::static_assertion<bool(Derived::SizeAtCompileTime!=Eigen::Dynamic)>::YOU_CALLED_A_FIXED_SIZE_METHOD_ON_A_DYNAMIC_SIZE_MATRIX_OR_VECTOR) {}
  return DenseBase<Derived>::NullaryExpr(RowsAtCompileTime, ColsAtCompileTime, internal::scalar_constant_op<Scalar>(value));
}
# 248 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
inline const typename DenseBase<Derived>::SequentialLinSpacedReturnType
DenseBase<Derived>::LinSpaced(Sequential_t, Index size, const Scalar& low, const Scalar& high)
{
  if (Eigen::internal::static_assertion<bool(Derived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
  return DenseBase<Derived>::NullaryExpr(size, internal::linspaced_op<Scalar,false>(low,high,size));
}





template<typename Derived>
inline const typename DenseBase<Derived>::SequentialLinSpacedReturnType
DenseBase<Derived>::LinSpaced(Sequential_t, const Scalar& low, const Scalar& high)
{
  if (Eigen::internal::static_assertion<bool(Derived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
  if (Eigen::internal::static_assertion<bool(Derived::SizeAtCompileTime!=Eigen::Dynamic)>::YOU_CALLED_A_FIXED_SIZE_METHOD_ON_A_DYNAMIC_SIZE_MATRIX_OR_VECTOR) {}
  return DenseBase<Derived>::NullaryExpr(Derived::SizeAtCompileTime, internal::linspaced_op<Scalar,false>(low,high,Derived::SizeAtCompileTime));
}
# 281 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
inline const typename DenseBase<Derived>::RandomAccessLinSpacedReturnType
DenseBase<Derived>::LinSpaced(Index size, const Scalar& low, const Scalar& high)
{
  if (Eigen::internal::static_assertion<bool(Derived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
  return DenseBase<Derived>::NullaryExpr(size, internal::linspaced_op<Scalar,true>(low,high,size));
}





template<typename Derived>
inline const typename DenseBase<Derived>::RandomAccessLinSpacedReturnType
DenseBase<Derived>::LinSpaced(const Scalar& low, const Scalar& high)
{
  if (Eigen::internal::static_assertion<bool(Derived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
  if (Eigen::internal::static_assertion<bool(Derived::SizeAtCompileTime!=Eigen::Dynamic)>::YOU_CALLED_A_FIXED_SIZE_METHOD_ON_A_DYNAMIC_SIZE_MATRIX_OR_VECTOR) {}
  return DenseBase<Derived>::NullaryExpr(Derived::SizeAtCompileTime, internal::linspaced_op<Scalar,true>(low,high,Derived::SizeAtCompileTime));
}


template<typename Derived>
bool DenseBase<Derived>::isApproxToConstant
(const Scalar& value, RealScalar prec) const
{
  for(Index j = 0; j < cols(); ++j)
    for(Index i = 0; i < rows(); ++i)
      if(!internal::isApprox(this->coeff(i, j), value, prec))
        return false;
  return true;
}




template<typename Derived>
bool DenseBase<Derived>::isConstant
(const Scalar& value, RealScalar prec) const
{
  return isApproxToConstant(value, prec);
}





template<typename Derived>
inline void DenseBase<Derived>::fill(const Scalar& value)
{
  setConstant(value);
}





template<typename Derived>
inline Derived& DenseBase<Derived>::setConstant(const Scalar& value)
{
  return derived() = Constant(rows(), cols(), value);
}
# 353 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
inline Derived&
PlainObjectBase<Derived>::setConstant(Index size, const Scalar& value)
{
  resize(size);
  return setConstant(value);
}
# 372 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
inline Derived&
PlainObjectBase<Derived>::setConstant(Index rows, Index cols, const Scalar& value)
{
  resize(rows, cols);
  return setConstant(value);
}
# 392 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
inline Derived& DenseBase<Derived>::setLinSpaced(Index size, const Scalar& low, const Scalar& high)
{
  if (Eigen::internal::static_assertion<bool(Derived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
  return derived() = Derived::NullaryExpr(size, internal::linspaced_op<Scalar,false>(low,high,size));
}
# 415 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
inline const typename DenseBase<Derived>::ConstantReturnType
DenseBase<Derived>::Zero(Index rows, Index cols)
{
  return Constant(rows, cols, Scalar(0));
}
# 438 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
inline const typename DenseBase<Derived>::ConstantReturnType
DenseBase<Derived>::Zero(Index size)
{
  return Constant(size, Scalar(0));
}
# 455 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
inline const typename DenseBase<Derived>::ConstantReturnType
DenseBase<Derived>::Zero()
{
  return Constant(Scalar(0));
}
# 470 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
bool DenseBase<Derived>::isZero(RealScalar prec) const
{
  for(Index j = 0; j < cols(); ++j)
    for(Index i = 0; i < rows(); ++i)
      if(!internal::isMuchSmallerThan(this->coeff(i, j), static_cast<Scalar>(1), prec))
        return false;
  return true;
}
# 487 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
inline Derived& DenseBase<Derived>::setZero()
{
  return setConstant(Scalar(0));
}
# 502 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
inline Derived&
PlainObjectBase<Derived>::setZero(Index size)
{
  resize(size);
  return setConstant(Scalar(0));
}
# 520 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
inline Derived&
PlainObjectBase<Derived>::setZero(Index rows, Index cols)
{
  resize(rows, cols);
  return setConstant(Scalar(0));
}
# 544 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
inline const typename DenseBase<Derived>::ConstantReturnType
DenseBase<Derived>::Ones(Index rows, Index cols)
{
  return Constant(rows, cols, Scalar(1));
}
# 567 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
inline const typename DenseBase<Derived>::ConstantReturnType
DenseBase<Derived>::Ones(Index size)
{
  return Constant(size, Scalar(1));
}
# 584 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
inline const typename DenseBase<Derived>::ConstantReturnType
DenseBase<Derived>::Ones()
{
  return Constant(Scalar(1));
}
# 599 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
bool DenseBase<Derived>::isOnes
(RealScalar prec) const
{
  return isApproxToConstant(Scalar(1), prec);
}
# 613 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
inline Derived& DenseBase<Derived>::setOnes()
{
  return setConstant(Scalar(1));
}
# 628 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
inline Derived&
PlainObjectBase<Derived>::setOnes(Index size)
{
  resize(size);
  return setConstant(Scalar(1));
}
# 646 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
inline Derived&
PlainObjectBase<Derived>::setOnes(Index rows, Index cols)
{
  resize(rows, cols);
  return setConstant(Scalar(1));
}
# 670 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
inline const typename MatrixBase<Derived>::IdentityReturnType
MatrixBase<Derived>::Identity(Index rows, Index cols)
{
  return DenseBase<Derived>::NullaryExpr(rows, cols, internal::scalar_identity_op<Scalar>());
}
# 687 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
inline const typename MatrixBase<Derived>::IdentityReturnType
MatrixBase<Derived>::Identity()
{
  if (Eigen::internal::static_assertion<bool(Derived::SizeAtCompileTime!=Eigen::Dynamic)>::YOU_CALLED_A_FIXED_SIZE_METHOD_ON_A_DYNAMIC_SIZE_MATRIX_OR_VECTOR) {}
  return MatrixBase<Derived>::NullaryExpr(RowsAtCompileTime, ColsAtCompileTime, internal::scalar_identity_op<Scalar>());
}
# 704 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
bool MatrixBase<Derived>::isIdentity
(RealScalar prec) const
{
  for(Index j = 0; j < cols(); ++j)
  {
    for(Index i = 0; i < rows(); ++i)
    {
      if(i == j)
      {
        if(!internal::isApprox(this->coeff(i, j), static_cast<Scalar>(1), prec))
          return false;
      }
      else
      {
        if(!internal::isMuchSmallerThan(this->coeff(i, j), static_cast<RealScalar>(1), prec))
          return false;
      }
    }
  }
  return true;
}

namespace internal {

template<typename Derived, bool Big = (Derived::SizeAtCompileTime>=16)>
struct setIdentity_impl
{
  static inline Derived& run(Derived& m)
  {
    return m = Derived::Identity(m.rows(), m.cols());
  }
};

template<typename Derived>
struct setIdentity_impl<Derived, true>
{
  typedef typename Derived::Index Index;
  static inline Derived& run(Derived& m)
  {
    m.setZero();
    const Index size = (std::min)(m.rows(), m.cols());
    for(Index i = 0; i < size; ++i) m.coeffRef(i,i) = typename Derived::Scalar(1);
    return m;
  }
};

}
# 760 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
inline Derived& MatrixBase<Derived>::setIdentity()
{
  return internal::setIdentity_impl<Derived>::run(derived());
}
# 776 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
inline Derived& MatrixBase<Derived>::setIdentity(Index rows, Index cols)
{
  derived().resize(rows, cols);
  return setIdentity();
}







template<typename Derived>
inline const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::Unit(Index size, Index i)
{
  if (Eigen::internal::static_assertion<bool(Derived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
  return BasisReturnType(SquareMatrixType::Identity(size,size), i);
}
# 804 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseNullaryOp.h"
template<typename Derived>
inline const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::Unit(Index i)
{
  if (Eigen::internal::static_assertion<bool(Derived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
  return BasisReturnType(SquareMatrixType::Identity(),i);
}







template<typename Derived>
inline const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitX()
{ return Derived::Unit(0); }







template<typename Derived>
inline const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitY()
{ return Derived::Unit(1); }







template<typename Derived>
inline const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitZ()
{ return Derived::Unit(2); }







template<typename Derived>
inline const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitW()
{ return Derived::Unit(3); }
# 298 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseUnaryView.h" 1
# 42 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CwiseUnaryView.h"
namespace internal {
template<typename ViewOp, typename MatrixType>
struct traits<CwiseUnaryView<ViewOp, MatrixType> >
 : traits<MatrixType>
{
  typedef typename result_of<
                     ViewOp(typename traits<MatrixType>::Scalar)
                   >::type Scalar;
  typedef typename MatrixType::Nested MatrixTypeNested;
  typedef typename remove_all<MatrixTypeNested>::type _MatrixTypeNested;
  enum {
    Flags = (traits<_MatrixTypeNested>::Flags & (HereditaryBits | LvalueBit | LinearAccessBit | DirectAccessBit)),
    CoeffReadCost = traits<_MatrixTypeNested>::CoeffReadCost + functor_traits<ViewOp>::Cost,
    MatrixTypeInnerStride = inner_stride_at_compile_time<MatrixType>::ret,


    InnerStrideAtCompileTime = MatrixTypeInnerStride == Dynamic
                             ? int(Dynamic)
                             : int(MatrixTypeInnerStride)
                               * int(sizeof(typename traits<MatrixType>::Scalar) / sizeof(Scalar)),
    OuterStrideAtCompileTime = outer_stride_at_compile_time<MatrixType>::ret
  };
};
}

template<typename ViewOp, typename MatrixType, typename StorageKind>
class CwiseUnaryViewImpl;

template<typename ViewOp, typename MatrixType>
class CwiseUnaryView : internal::no_assignment_operator,
  public CwiseUnaryViewImpl<ViewOp, MatrixType, typename internal::traits<MatrixType>::StorageKind>
{
  public:

    typedef typename CwiseUnaryViewImpl<ViewOp, MatrixType,typename internal::traits<MatrixType>::StorageKind>::Base Base;
    typedef typename Eigen::internal::traits<CwiseUnaryView>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<CwiseUnaryView>::type Nested; typedef typename Eigen::internal::traits<CwiseUnaryView>::StorageKind StorageKind; typedef typename Eigen::internal::traits<CwiseUnaryView>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<CwiseUnaryView>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<CwiseUnaryView>::ColsAtCompileTime, Flags = Eigen::internal::traits<CwiseUnaryView>::Flags, CoeffReadCost = Eigen::internal::traits<CwiseUnaryView>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime };

    inline CwiseUnaryView(const MatrixType& mat, const ViewOp& func = ViewOp())
      : m_matrix(mat), m_functor(func) {}

    using Base::operator =; inline CwiseUnaryView& operator=(const CwiseUnaryView& other) { Base::operator=(other); return *this; }

    inline Index rows() const { return m_matrix.rows(); }
    inline Index cols() const { return m_matrix.cols(); }


    const ViewOp& functor() const { return m_functor; }


    const typename internal::remove_all<typename MatrixType::Nested>::type&
    nestedExpression() const { return m_matrix; }


    typename internal::remove_all<typename MatrixType::Nested>::type&
    nestedExpression() { return m_matrix.const_cast_derived(); }

  protected:

    const typename internal::nested<MatrixType>::type m_matrix;
    ViewOp m_functor;
};

template<typename ViewOp, typename MatrixType>
class CwiseUnaryViewImpl<ViewOp,MatrixType,Dense>
  : public internal::dense_xpr_base< CwiseUnaryView<ViewOp, MatrixType> >::type
{
  public:

    typedef CwiseUnaryView<ViewOp, MatrixType> Derived;
    typedef typename internal::dense_xpr_base< CwiseUnaryView<ViewOp, MatrixType> >::type Base;

    typedef typename Eigen::internal::traits<Derived>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<Derived>::type Nested; typedef typename Eigen::internal::traits<Derived>::StorageKind StorageKind; typedef typename Eigen::internal::traits<Derived>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<Derived>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<Derived>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<Derived>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<Derived>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<Derived>::Flags, CoeffReadCost = Eigen::internal::traits<Derived>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived;

    inline Index innerStride() const
    {
      return derived().nestedExpression().innerStride() * sizeof(typename internal::traits<MatrixType>::Scalar) / sizeof(Scalar);
    }

    inline Index outerStride() const
    {
      return derived().nestedExpression().outerStride();
    }

    inline CoeffReturnType coeff(Index row, Index col) const
    {
      return derived().functor()(derived().nestedExpression().coeff(row, col));
    }

    inline CoeffReturnType coeff(Index index) const
    {
      return derived().functor()(derived().nestedExpression().coeff(index));
    }

    inline Scalar& coeffRef(Index row, Index col)
    {
      return derived().functor()(const_cast_derived().nestedExpression().coeffRef(row, col));
    }

    inline Scalar& coeffRef(Index index)
    {
      return derived().functor()(const_cast_derived().nestedExpression().coeffRef(index));
    }
};
# 299 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/SelfCwiseBinaryOp.h" 1
# 43 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/SelfCwiseBinaryOp.h"
namespace internal {
template<typename BinaryOp, typename Lhs, typename Rhs>
struct traits<SelfCwiseBinaryOp<BinaryOp,Lhs,Rhs> >
  : traits<CwiseBinaryOp<BinaryOp,Lhs,Rhs> >
{
  enum {


    Flags = traits<CwiseBinaryOp<BinaryOp,Lhs,Rhs> >::Flags | (Lhs::Flags&DirectAccessBit) | (Lhs::Flags&LvalueBit),
    OuterStrideAtCompileTime = Lhs::OuterStrideAtCompileTime,
    InnerStrideAtCompileTime = Lhs::InnerStrideAtCompileTime
  };
};
}

template<typename BinaryOp, typename Lhs, typename Rhs> class SelfCwiseBinaryOp
  : public internal::dense_xpr_base< SelfCwiseBinaryOp<BinaryOp, Lhs, Rhs> >::type
{
  public:

    typedef typename internal::dense_xpr_base<SelfCwiseBinaryOp>::type Base;
    typedef typename Eigen::internal::traits<SelfCwiseBinaryOp>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<SelfCwiseBinaryOp>::type Nested; typedef typename Eigen::internal::traits<SelfCwiseBinaryOp>::StorageKind StorageKind; typedef typename Eigen::internal::traits<SelfCwiseBinaryOp>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<SelfCwiseBinaryOp>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<SelfCwiseBinaryOp>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<SelfCwiseBinaryOp>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<SelfCwiseBinaryOp>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<SelfCwiseBinaryOp>::Flags, CoeffReadCost = Eigen::internal::traits<SelfCwiseBinaryOp>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived;

    typedef typename internal::packet_traits<Scalar>::type Packet;

    inline SelfCwiseBinaryOp(Lhs& xpr, const BinaryOp& func = BinaryOp()) : m_matrix(xpr), m_functor(func) {}

    inline Index rows() const { return m_matrix.rows(); }
    inline Index cols() const { return m_matrix.cols(); }
    inline Index outerStride() const { return m_matrix.outerStride(); }
    inline Index innerStride() const { return m_matrix.innerStride(); }
    inline const Scalar* data() const { return m_matrix.data(); }



    inline Scalar& coeffRef(Index row, Index col)
    {
      if (Eigen::internal::static_assertion<bool(internal::is_lvalue<Lhs>::value)>::THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY) {}
      return m_matrix.const_cast_derived().coeffRef(row, col);
    }
    inline const Scalar& coeffRef(Index row, Index col) const
    {
      return m_matrix.coeffRef(row, col);
    }



    inline Scalar& coeffRef(Index index)
    {
      if (Eigen::internal::static_assertion<bool(internal::is_lvalue<Lhs>::value)>::THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY) {}
      return m_matrix.const_cast_derived().coeffRef(index);
    }
    inline const Scalar& coeffRef(Index index) const
    {
      return m_matrix.const_cast_derived().coeffRef(index);
    }

    template<typename OtherDerived>
    void copyCoeff(Index row, Index col, const DenseBase<OtherDerived>& other)
    {
      OtherDerived& _other = other.const_cast_derived();
      if( (!Eigen::internal::copy_bool(row >= 0 && row < rows() && col >= 0 && col < cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(row >= 0 && row < rows() && col >= 0 && col < cols())) Eigen::internal::assert_fail("row >= 0 && row < rows() && col >= 0 && col < cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/SelfCwiseBinaryOp.h", 105); } while(false); else throw Eigen::eigen_assert_exception(); };

      Scalar& tmp = m_matrix.coeffRef(row,col);
      tmp = m_functor(tmp, _other.coeff(row,col));
    }

    template<typename OtherDerived>
    void copyCoeff(Index index, const DenseBase<OtherDerived>& other)
    {
      OtherDerived& _other = other.const_cast_derived();
      if( (!Eigen::internal::copy_bool(index >= 0 && index < m_matrix.size())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(index >= 0 && index < m_matrix.size())) Eigen::internal::assert_fail("index >= 0 && index < m_matrix.size()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/SelfCwiseBinaryOp.h", 114); } while(false); else throw Eigen::eigen_assert_exception(); };
      Scalar& tmp = m_matrix.coeffRef(index);
      tmp = m_functor(tmp, _other.coeff(index));
    }

    template<typename OtherDerived, int StoreMode, int LoadMode>
    void copyPacket(Index row, Index col, const DenseBase<OtherDerived>& other)
    {
      OtherDerived& _other = other.const_cast_derived();
      if( (!Eigen::internal::copy_bool(row >= 0 && row < rows() && col >= 0 && col < cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(row >= 0 && row < rows() && col >= 0 && col < cols())) Eigen::internal::assert_fail("row >= 0 && row < rows() && col >= 0 && col < cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/SelfCwiseBinaryOp.h", 124); } while(false); else throw Eigen::eigen_assert_exception(); };

      m_matrix.template writePacket<StoreMode>(row, col,
        m_functor.packetOp(m_matrix.template packet<StoreMode>(row, col),_other.template packet<LoadMode>(row, col)) );
    }

    template<typename OtherDerived, int StoreMode, int LoadMode>
    void copyPacket(Index index, const DenseBase<OtherDerived>& other)
    {
      OtherDerived& _other = other.const_cast_derived();
      if( (!Eigen::internal::copy_bool(index >= 0 && index < m_matrix.size())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(index >= 0 && index < m_matrix.size())) Eigen::internal::assert_fail("index >= 0 && index < m_matrix.size()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/SelfCwiseBinaryOp.h", 133); } while(false); else throw Eigen::eigen_assert_exception(); };
      m_matrix.template writePacket<StoreMode>(index,
        m_functor.packetOp(m_matrix.template packet<StoreMode>(index),_other.template packet<LoadMode>(index)) );
    }



    template<typename RhsDerived>
    inline SelfCwiseBinaryOp& lazyAssign(const DenseBase<RhsDerived>& rhs)
    {
      if (Eigen::internal::static_assertion<bool(( (int(Lhs::SizeAtCompileTime)==0 && int(RhsDerived::SizeAtCompileTime)==0) || ( (int(Lhs::RowsAtCompileTime)==Eigen::Dynamic || int(RhsDerived::RowsAtCompileTime)==Eigen::Dynamic || int(Lhs::RowsAtCompileTime)==int(RhsDerived::RowsAtCompileTime)) && (int(Lhs::ColsAtCompileTime)==Eigen::Dynamic || int(RhsDerived::ColsAtCompileTime)==Eigen::Dynamic || int(Lhs::ColsAtCompileTime)==int(RhsDerived::ColsAtCompileTime)) ) ))>::YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES) {}
      if (Eigen::internal::static_assertion<bool((internal::functor_allows_mixing_real_and_complex<BinaryOp>::ret ? int(internal::is_same<typename NumTraits<typename Lhs::Scalar>::Real, typename NumTraits<typename RhsDerived::Scalar>::Real>::value) : int(internal::is_same<typename Lhs::Scalar, typename RhsDerived::Scalar>::value)))>::YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY) {};




      if( (!Eigen::internal::copy_bool(rows() == rhs.rows() && cols() == rhs.cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(rows() == rhs.rows() && cols() == rhs.cols())) Eigen::internal::assert_fail("rows() == rhs.rows() && cols() == rhs.cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/SelfCwiseBinaryOp.h", 149); } while(false); else throw Eigen::eigen_assert_exception(); };
      internal::assign_impl<SelfCwiseBinaryOp, RhsDerived>::run(*this,rhs.derived());

      this->checkTransposeAliasing(rhs.derived());

      return *this;
    }




    SelfCwiseBinaryOp& operator=(const Rhs& _rhs)
    {
      typename internal::nested<Rhs>::type rhs(_rhs);
      return Base::operator=(rhs);
    }

  protected:
    Lhs& m_matrix;
    const BinaryOp& m_functor;

  private:
    SelfCwiseBinaryOp& operator=(const SelfCwiseBinaryOp&);
};

template<typename Derived>
inline Derived& DenseBase<Derived>::operator*=(const Scalar& other)
{
  typedef typename Derived::PlainObject PlainObject;
  SelfCwiseBinaryOp<internal::scalar_product_op<Scalar>, Derived, typename PlainObject::ConstantReturnType> tmp(derived());
  tmp = PlainObject::Constant(rows(),cols(),other);
  return derived();
}

template<typename Derived>
inline Derived& DenseBase<Derived>::operator/=(const Scalar& other)
{
  typedef typename internal::conditional<NumTraits<Scalar>::IsInteger,
                                        internal::scalar_quotient_op<Scalar>,
                                        internal::scalar_product_op<Scalar> >::type BinOp;
  typedef typename Derived::PlainObject PlainObject;
  SelfCwiseBinaryOp<BinOp, Derived, typename PlainObject::ConstantReturnType> tmp(derived());
  tmp = PlainObject::Constant(rows(),cols(), NumTraits<Scalar>::IsInteger ? other : Scalar(1)/other);
  return derived();
}
# 300 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Dot.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Dot.h"
namespace internal {




template<typename T, typename U,

         bool NeedToTranspose = T::IsVectorAtCompileTime
                && U::IsVectorAtCompileTime
                && ((int(T::RowsAtCompileTime) == 1 && int(U::ColsAtCompileTime) == 1)
                      |

                    (int(T::ColsAtCompileTime) == 1 && int(U::RowsAtCompileTime) == 1))
>
struct dot_nocheck
{
  typedef typename scalar_product_traits<typename traits<T>::Scalar,typename traits<U>::Scalar>::ReturnType ResScalar;
  static inline ResScalar run(const MatrixBase<T>& a, const MatrixBase<U>& b)
  {
    return a.template binaryExpr<scalar_conj_product_op<typename traits<T>::Scalar,typename traits<U>::Scalar> >(b).sum();
  }
};

template<typename T, typename U>
struct dot_nocheck<T, U, true>
{
  typedef typename scalar_product_traits<typename traits<T>::Scalar,typename traits<U>::Scalar>::ReturnType ResScalar;
  static inline ResScalar run(const MatrixBase<T>& a, const MatrixBase<U>& b)
  {
    return a.transpose().template binaryExpr<scalar_conj_product_op<typename traits<T>::Scalar,typename traits<U>::Scalar> >(b).sum();
  }
};

}
# 73 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Dot.h"
template<typename Derived>
template<typename OtherDerived>
typename internal::scalar_product_traits<typename internal::traits<Derived>::Scalar,typename internal::traits<OtherDerived>::Scalar>::ReturnType
MatrixBase<Derived>::dot(const MatrixBase<OtherDerived>& other) const
{
  if (Eigen::internal::static_assertion<bool(Derived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
  if (Eigen::internal::static_assertion<bool(OtherDerived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
  if (Eigen::internal::static_assertion<bool((int(Derived::SizeAtCompileTime)==Eigen::Dynamic || int(OtherDerived::SizeAtCompileTime)==Eigen::Dynamic || int(Derived::SizeAtCompileTime)==int(OtherDerived::SizeAtCompileTime)))>::YOU_MIXED_VECTORS_OF_DIFFERENT_SIZES) {}
  typedef internal::scalar_conj_product_op<Scalar,typename OtherDerived::Scalar> func;
  if (Eigen::internal::static_assertion<bool((internal::functor_allows_mixing_real_and_complex<func>::ret ? int(internal::is_same<typename NumTraits<Scalar>::Real, typename NumTraits<typename OtherDerived::Scalar>::Real>::value) : int(internal::is_same<Scalar, typename OtherDerived::Scalar>::value)))>::YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY) {};

  if( (!Eigen::internal::copy_bool(size() == other.size())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(size() == other.size())) Eigen::internal::assert_fail("size() == other.size()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Dot.h", 84); } while(false); else throw Eigen::eigen_assert_exception(); };

  return internal::dot_nocheck<Derived,OtherDerived>::run(*this, other);
}
# 125 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Dot.h"
template<typename Derived>
inline typename NumTraits<typename internal::traits<Derived>::Scalar>::Real MatrixBase<Derived>::squaredNorm() const
{
  return internal::real((*this).cwiseAbs2().sum());
}







template<typename Derived>
inline typename NumTraits<typename internal::traits<Derived>::Scalar>::Real MatrixBase<Derived>::norm() const
{
  return internal::sqrt(squaredNorm());
}







template<typename Derived>
inline const typename MatrixBase<Derived>::PlainObject
MatrixBase<Derived>::normalized() const
{
  typedef typename internal::nested<Derived>::type Nested;
  typedef typename internal::remove_reference<Nested>::type _Nested;
  _Nested n(derived());
  return n / n.norm();
}







template<typename Derived>
inline void MatrixBase<Derived>::normalize()
{
  *this /= norm();
}



namespace internal {

template<typename Derived, int p>
struct lpNorm_selector
{
  typedef typename NumTraits<typename traits<Derived>::Scalar>::Real RealScalar;
  inline static RealScalar run(const MatrixBase<Derived>& m)
  {
    return pow(m.cwiseAbs().array().pow(p).sum(), RealScalar(1)/p);
  }
};

template<typename Derived>
struct lpNorm_selector<Derived, 1>
{
  inline static typename NumTraits<typename traits<Derived>::Scalar>::Real run(const MatrixBase<Derived>& m)
  {
    return m.cwiseAbs().sum();
  }
};

template<typename Derived>
struct lpNorm_selector<Derived, 2>
{
  inline static typename NumTraits<typename traits<Derived>::Scalar>::Real run(const MatrixBase<Derived>& m)
  {
    return m.norm();
  }
};

template<typename Derived>
struct lpNorm_selector<Derived, Infinity>
{
  inline static typename NumTraits<typename traits<Derived>::Scalar>::Real run(const MatrixBase<Derived>& m)
  {
    return m.cwiseAbs().maxCoeff();
  }
};

}







template<typename Derived>
template<int p>
inline typename NumTraits<typename internal::traits<Derived>::Scalar>::Real
MatrixBase<Derived>::lpNorm() const
{
  return internal::lpNorm_selector<Derived, p>::run(*this);
}
# 236 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Dot.h"
template<typename Derived>
template<typename OtherDerived>
bool MatrixBase<Derived>::isOrthogonal
(const MatrixBase<OtherDerived>& other, RealScalar prec) const
{
  typename internal::nested<Derived,2>::type nested(derived());
  typename internal::nested<OtherDerived,2>::type otherNested(other.derived());
  return internal::abs2(nested.dot(otherNested)) <= prec * prec * nested.squaredNorm() * otherNested.squaredNorm();
}
# 257 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Dot.h"
template<typename Derived>
bool MatrixBase<Derived>::isUnitary(RealScalar prec) const
{
  typename Derived::Nested nested(derived());
  for(Index i = 0; i < cols(); ++i)
  {
    if(!internal::isApprox(nested.col(i).squaredNorm(), static_cast<RealScalar>(1), prec))
      return false;
    for(Index j = 0; j < i; ++j)
      if(!internal::isMuchSmallerThan(nested.col(i).dot(nested.col(j)), static_cast<Scalar>(1), prec))
        return false;
  }
  return true;
}
# 301 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/StableNorm.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/StableNorm.h"
namespace internal {
template<typename ExpressionType, typename Scalar>
inline void stable_norm_kernel(const ExpressionType& bl, Scalar& ssq, Scalar& scale, Scalar& invScale)
{
  Scalar max = bl.cwiseAbs().maxCoeff();
  if (max>scale)
  {
    ssq = ssq * abs2(scale/max);
    scale = max;
    invScale = Scalar(1)/scale;
  }


  ssq += (bl*invScale).squaredNorm();
}
}
# 55 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/StableNorm.h"
template<typename Derived>
inline typename NumTraits<typename internal::traits<Derived>::Scalar>::Real
MatrixBase<Derived>::stableNorm() const
{
  using std::min;
  const Index blockSize = 4096;
  RealScalar scale = 0;
  RealScalar invScale = 1;
  RealScalar ssq = 0;
  enum {
    Alignment = (int(Flags)&DirectAccessBit) || (int(Flags)&AlignedBit) ? 1 : 0
  };
  Index n = size();
  Index bi = internal::first_aligned(derived());
  if (bi>0)
    internal::stable_norm_kernel(this->head(bi), ssq, scale, invScale);
  for (; bi<n; bi+=blockSize)
    internal::stable_norm_kernel(this->segment(bi,(min)(blockSize, n - bi)).template forceAlignedAccessIf<Alignment>(), ssq, scale, invScale);
  return scale * internal::sqrt(ssq);
}
# 85 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/StableNorm.h"
template<typename Derived>
inline typename NumTraits<typename internal::traits<Derived>::Scalar>::Real
MatrixBase<Derived>::blueNorm() const
{
  using std::pow;
  using std::min;
  using std::max;
  static Index nmax = -1;
  static RealScalar b1, b2, s1m, s2m, overfl, rbig, relerr;
  if(nmax <= 0)
  {
    int nbig, ibeta, it, iemin, iemax, iexp;
    RealScalar abig, eps;
# 106 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/StableNorm.h"
    nbig = (std::numeric_limits<Index>::max)();
    ibeta = std::numeric_limits<RealScalar>::radix;
    it = std::numeric_limits<RealScalar>::digits;
    iemin = std::numeric_limits<RealScalar>::min_exponent;
    iemax = std::numeric_limits<RealScalar>::max_exponent;
    rbig = (std::numeric_limits<RealScalar>::max)();

    iexp = -((1-iemin)/2);
    b1 = RealScalar(pow(RealScalar(ibeta),RealScalar(iexp)));
    iexp = (iemax + 1 - it)/2;
    b2 = RealScalar(pow(RealScalar(ibeta),RealScalar(iexp)));

    iexp = (2-iemin)/2;
    s1m = RealScalar(pow(RealScalar(ibeta),RealScalar(iexp)));
    iexp = - ((iemax+it)/2);
    s2m = RealScalar(pow(RealScalar(ibeta),RealScalar(iexp)));

    overfl = rbig*s2m;
    eps = RealScalar(pow(double(ibeta), 1-it));
    relerr = internal::sqrt(eps);
    abig = RealScalar(1.0/eps - 1.0);
    if (RealScalar(nbig)>abig) nmax = int(abig);
    else nmax = nbig;
  }
  Index n = size();
  RealScalar ab2 = b2 / RealScalar(n);
  RealScalar asml = RealScalar(0);
  RealScalar amed = RealScalar(0);
  RealScalar abig = RealScalar(0);
  for(Index j=0; j<n; ++j)
  {
    RealScalar ax = internal::abs(coeff(j));
    if(ax > ab2) abig += internal::abs2(ax*s2m);
    else if(ax < b1) asml += internal::abs2(ax*s1m);
    else amed += internal::abs2(ax);
  }
  if(abig > RealScalar(0))
  {
    abig = internal::sqrt(abig);
    if(abig > overfl)
    {
      if( (!Eigen::internal::copy_bool(false && "overflow")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(false && "overflow")) Eigen::internal::assert_fail("false && \"overflow\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/StableNorm.h", 147); } while(false); else throw Eigen::eigen_assert_exception(); };
      return rbig;
    }
    if(amed > RealScalar(0))
    {
      abig = abig/s2m;
      amed = internal::sqrt(amed);
    }
    else
      return abig/s2m;
  }
  else if(asml > RealScalar(0))
  {
    if (amed > RealScalar(0))
    {
      abig = internal::sqrt(amed);
      amed = internal::sqrt(asml) / s1m;
    }
    else
      return internal::sqrt(asml)/s1m;
  }
  else
    return internal::sqrt(amed);
  asml = (min)(abig, amed);
  abig = (max)(abig, amed);
  if(asml <= abig*relerr)
    return abig;
  else
    return abig * internal::sqrt(RealScalar(1) + internal::abs2(asml/abig));
}






template<typename Derived>
inline typename NumTraits<typename internal::traits<Derived>::Scalar>::Real
MatrixBase<Derived>::hypotNorm() const
{
  return this->cwiseAbs().redux(internal::scalar_hypot_op<RealScalar>());
}
# 302 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/MapBase.h" 1
# 41 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/MapBase.h"
template<typename Derived> class MapBase<Derived, ReadOnlyAccessors>
  : public internal::dense_xpr_base<Derived>::type
{
  public:

    typedef typename internal::dense_xpr_base<Derived>::type Base;
    enum {
      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,
      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,
      SizeAtCompileTime = Base::SizeAtCompileTime
    };

    typedef typename internal::traits<Derived>::StorageKind StorageKind;
    typedef typename internal::traits<Derived>::Index Index;
    typedef typename internal::traits<Derived>::Scalar Scalar;
    typedef typename internal::packet_traits<Scalar>::type PacketScalar;
    typedef typename NumTraits<Scalar>::Real RealScalar;
    typedef typename internal::conditional<
                         bool(internal::is_lvalue<Derived>::value),
                         Scalar *,
                         const Scalar *>::type
                     PointerType;

    using Base::derived;



    using Base::MaxRowsAtCompileTime;
    using Base::MaxColsAtCompileTime;
    using Base::MaxSizeAtCompileTime;
    using Base::IsVectorAtCompileTime;
    using Base::Flags;
    using Base::IsRowMajor;

    using Base::rows;
    using Base::cols;
    using Base::size;
    using Base::coeff;
    using Base::coeffRef;
    using Base::lazyAssign;
    using Base::eval;

    using Base::innerStride;
    using Base::outerStride;
    using Base::rowStride;
    using Base::colStride;


    using Base::operator=;

    typedef typename Base::CoeffReturnType CoeffReturnType;

    inline Index rows() const { return m_rows.value(); }
    inline Index cols() const { return m_cols.value(); }







    inline const Scalar* data() const { return m_data; }

    inline const Scalar& coeff(Index row, Index col) const
    {
      return m_data[col * colStride() + row * rowStride()];
    }

    inline const Scalar& coeff(Index index) const
    {
      if (Eigen::internal::static_assertion<bool((int(internal::traits<Derived>::Flags) & LinearAccessBit) || Derived::IsVectorAtCompileTime)>::YOU_ARE_TRYING_TO_USE_AN_INDEX_BASED_ACCESSOR_ON_AN_EXPRESSION_THAT_DOES_NOT_SUPPORT_THAT) {}
      return m_data[index * innerStride()];
    }

    inline const Scalar& coeffRef(Index row, Index col) const
    {
      return this->m_data[col * colStride() + row * rowStride()];
    }

    inline const Scalar& coeffRef(Index index) const
    {
      if (Eigen::internal::static_assertion<bool((int(internal::traits<Derived>::Flags) & LinearAccessBit) || Derived::IsVectorAtCompileTime)>::YOU_ARE_TRYING_TO_USE_AN_INDEX_BASED_ACCESSOR_ON_AN_EXPRESSION_THAT_DOES_NOT_SUPPORT_THAT) {}
      return this->m_data[index * innerStride()];
    }

    template<int LoadMode>
    inline PacketScalar packet(Index row, Index col) const
    {
      return internal::ploadt<PacketScalar, LoadMode>
               (m_data + (col * colStride() + row * rowStride()));
    }

    template<int LoadMode>
    inline PacketScalar packet(Index index) const
    {
      if (Eigen::internal::static_assertion<bool((int(internal::traits<Derived>::Flags) & LinearAccessBit) || Derived::IsVectorAtCompileTime)>::YOU_ARE_TRYING_TO_USE_AN_INDEX_BASED_ACCESSOR_ON_AN_EXPRESSION_THAT_DOES_NOT_SUPPORT_THAT) {}
      return internal::ploadt<PacketScalar, LoadMode>(m_data + index * innerStride());
    }

    inline MapBase(PointerType data) : m_data(data), m_rows(RowsAtCompileTime), m_cols(ColsAtCompileTime)
    {
      if (Eigen::internal::static_assertion<bool(Derived::SizeAtCompileTime!=Eigen::Dynamic)>::YOU_CALLED_A_FIXED_SIZE_METHOD_ON_A_DYNAMIC_SIZE_MATRIX_OR_VECTOR) {}
      checkSanity();
    }

    inline MapBase(PointerType data, Index size)
            : m_data(data),
              m_rows(RowsAtCompileTime == Dynamic ? size : Index(RowsAtCompileTime)),
              m_cols(ColsAtCompileTime == Dynamic ? size : Index(ColsAtCompileTime))
    {
      if (Eigen::internal::static_assertion<bool(Derived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
      if( (!Eigen::internal::copy_bool(size >= 0)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(size >= 0)) Eigen::internal::assert_fail("size >= 0", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/MapBase.h", 152); } while(false); else throw Eigen::eigen_assert_exception(); };
      if( (!Eigen::internal::copy_bool(data == 0 || SizeAtCompileTime == Dynamic || SizeAtCompileTime == size)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(data == 0 || SizeAtCompileTime == Dynamic || SizeAtCompileTime == size)) Eigen::internal::assert_fail("data == 0 || SizeAtCompileTime == Dynamic || SizeAtCompileTime == size", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/MapBase.h", 153); } while(false); else throw Eigen::eigen_assert_exception(); };
      checkSanity();
    }

    inline MapBase(PointerType data, Index rows, Index cols)
            : m_data(data), m_rows(rows), m_cols(cols)
    {
      if( (!Eigen::internal::copy_bool((data == 0) || ( rows >= 0 && (RowsAtCompileTime == Dynamic || RowsAtCompileTime == rows) && cols >= 0 && (ColsAtCompileTime == Dynamic || ColsAtCompileTime == cols)))) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool((data == 0) || ( rows >= 0 && (RowsAtCompileTime == Dynamic || RowsAtCompileTime == rows) && cols >= 0 && (ColsAtCompileTime == Dynamic || ColsAtCompileTime == cols)))) Eigen::internal::assert_fail("(data == 0) || ( rows >= 0 && (RowsAtCompileTime == Dynamic || RowsAtCompileTime == rows) && cols >= 0 && (ColsAtCompileTime == Dynamic || ColsAtCompileTime == cols))", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/MapBase.h", 162); } while(false); else throw Eigen::eigen_assert_exception(); };


      checkSanity();
    }

  protected:

    void checkSanity() const
    {
      if (Eigen::internal::static_assertion<bool((!(internal::traits<Derived>::Flags&PacketAccessBit) || (internal::inner_stride_at_compile_time<Derived>::ret==1)))>::PACKET_ACCESS_REQUIRES_TO_HAVE_INNER_STRIDE_FIXED_TO_1) {};


      if( (!Eigen::internal::copy_bool((!(internal::traits<Derived>::Flags&AlignedBit) || ((size_t(m_data) % (sizeof(Scalar)*internal::packet_traits<Scalar>::size)) == 0)) && "data is not aligned")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool((!(internal::traits<Derived>::Flags&AlignedBit) || ((size_t(m_data) % (sizeof(Scalar)*internal::packet_traits<Scalar>::size)) == 0)) && "data is not aligned")) Eigen::internal::assert_fail("(!(internal::traits<Derived>::Flags&AlignedBit) || ((size_t(m_data) % (sizeof(Scalar)*internal::packet_traits<Scalar>::size)) == 0)) && \"data is not aligned\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/MapBase.h", 174); } while(false); else throw Eigen::eigen_assert_exception(); };

    }

    PointerType m_data;
    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_rows;
    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_cols;
};

template<typename Derived> class MapBase<Derived, WriteAccessors>
  : public MapBase<Derived, ReadOnlyAccessors>
{
  public:

    typedef MapBase<Derived, ReadOnlyAccessors> Base;

    typedef typename Base::Scalar Scalar;
    typedef typename Base::PacketScalar PacketScalar;
    typedef typename Base::Index Index;
    typedef typename Base::PointerType PointerType;

    using Base::derived;
    using Base::rows;
    using Base::cols;
    using Base::size;
    using Base::coeff;
    using Base::coeffRef;

    using Base::innerStride;
    using Base::outerStride;
    using Base::rowStride;
    using Base::colStride;

    typedef typename internal::conditional<
                    internal::is_lvalue<Derived>::value,
                    Scalar,
                    const Scalar
                  >::type ScalarWithConstIfNotLvalue;

    inline const Scalar* data() const { return this->m_data; }
    inline ScalarWithConstIfNotLvalue* data() { return this->m_data; }

    inline ScalarWithConstIfNotLvalue& coeffRef(Index row, Index col)
    {
      return this->m_data[col * colStride() + row * rowStride()];
    }

    inline ScalarWithConstIfNotLvalue& coeffRef(Index index)
    {
      if (Eigen::internal::static_assertion<bool((int(internal::traits<Derived>::Flags) & LinearAccessBit) || Derived::IsVectorAtCompileTime)>::YOU_ARE_TRYING_TO_USE_AN_INDEX_BASED_ACCESSOR_ON_AN_EXPRESSION_THAT_DOES_NOT_SUPPORT_THAT) {}
      return this->m_data[index * innerStride()];
    }

    template<int StoreMode>
    inline void writePacket(Index row, Index col, const PacketScalar& x)
    {
      internal::pstoret<Scalar, PacketScalar, StoreMode>
               (this->m_data + (col * colStride() + row * rowStride()), x);
    }

    template<int StoreMode>
    inline void writePacket(Index index, const PacketScalar& x)
    {
      if (Eigen::internal::static_assertion<bool((int(internal::traits<Derived>::Flags) & LinearAccessBit) || Derived::IsVectorAtCompileTime)>::YOU_ARE_TRYING_TO_USE_AN_INDEX_BASED_ACCESSOR_ON_AN_EXPRESSION_THAT_DOES_NOT_SUPPORT_THAT) {}
      internal::pstoret<Scalar, PacketScalar, StoreMode>
                (this->m_data + index * innerStride(), x);
    }

    explicit inline MapBase(PointerType data) : Base(data) {}
    inline MapBase(PointerType data, Index size) : Base(data, size) {}
    inline MapBase(PointerType data, Index rows, Index cols) : Base(data, rows, cols) {}

    Derived& operator=(const MapBase& other)
    {
      Base::Base::operator=(other);
      return derived();
    }

    using Base::Base::operator=;
};
# 303 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Stride.h" 1
# 56 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Stride.h"
template<int _OuterStrideAtCompileTime, int _InnerStrideAtCompileTime>
class Stride
{
  public:
    typedef DenseIndex Index;
    enum {
      InnerStrideAtCompileTime = _InnerStrideAtCompileTime,
      OuterStrideAtCompileTime = _OuterStrideAtCompileTime
    };


    Stride()
      : m_outer(OuterStrideAtCompileTime), m_inner(InnerStrideAtCompileTime)
    {
      if( (!Eigen::internal::copy_bool(InnerStrideAtCompileTime != Dynamic && OuterStrideAtCompileTime != Dynamic)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(InnerStrideAtCompileTime != Dynamic && OuterStrideAtCompileTime != Dynamic)) Eigen::internal::assert_fail("InnerStrideAtCompileTime != Dynamic && OuterStrideAtCompileTime != Dynamic", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Stride.h", 70); } while(false); else throw Eigen::eigen_assert_exception(); };
    }


    Stride(Index outerStride, Index innerStride)
      : m_outer(outerStride), m_inner(innerStride)
    {
      if( (!Eigen::internal::copy_bool(innerStride>=0 && outerStride>=0)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(innerStride>=0 && outerStride>=0)) Eigen::internal::assert_fail("innerStride>=0 && outerStride>=0", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Stride.h", 77); } while(false); else throw Eigen::eigen_assert_exception(); };
    }


    Stride(const Stride& other)
      : m_outer(other.outer()), m_inner(other.inner())
    {}


    inline Index outer() const { return m_outer.value(); }

    inline Index inner() const { return m_inner.value(); }

  protected:
    internal::variable_if_dynamic<Index, OuterStrideAtCompileTime> m_outer;
    internal::variable_if_dynamic<Index, InnerStrideAtCompileTime> m_inner;
};



template<int Value = Dynamic>
class InnerStride : public Stride<0, Value>
{
    typedef Stride<0, Value> Base;
  public:
    typedef DenseIndex Index;
    InnerStride() : Base() {}
    InnerStride(Index v) : Base(0, v) {}
};



template<int Value = Dynamic>
class OuterStride : public Stride<Value, 0>
{
    typedef Stride<Value, 0> Base;
  public:
    typedef DenseIndex Index;
    OuterStride() : Base() {}
    OuterStride(Index v) : Base(v,0) {}
};
# 304 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Map.h" 1
# 80 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Map.h"
namespace internal {
template<typename PlainObjectType, int MapOptions, typename StrideType>
struct traits<Map<PlainObjectType, MapOptions, StrideType> >
  : public traits<PlainObjectType>
{
  typedef traits<PlainObjectType> TraitsBase;
  typedef typename PlainObjectType::Index Index;
  typedef typename PlainObjectType::Scalar Scalar;
  enum {
    InnerStrideAtCompileTime = StrideType::InnerStrideAtCompileTime == 0
                             ? int(PlainObjectType::InnerStrideAtCompileTime)
                             : int(StrideType::InnerStrideAtCompileTime),
    OuterStrideAtCompileTime = StrideType::OuterStrideAtCompileTime == 0
                             ? int(PlainObjectType::OuterStrideAtCompileTime)
                             : int(StrideType::OuterStrideAtCompileTime),
    HasNoInnerStride = InnerStrideAtCompileTime == 1,
    HasNoOuterStride = StrideType::OuterStrideAtCompileTime == 0,
    HasNoStride = HasNoInnerStride && HasNoOuterStride,
    IsAligned = bool(1) && ((int(MapOptions)&Aligned)==Aligned),
    IsDynamicSize = PlainObjectType::SizeAtCompileTime==Dynamic,
    KeepsPacketAccess = bool(HasNoInnerStride)
                        && ( bool(IsDynamicSize)
                           || HasNoOuterStride
                           || ( OuterStrideAtCompileTime!=Dynamic
                           && ((static_cast<int>(sizeof(Scalar))*OuterStrideAtCompileTime)%16)==0 ) ),
    Flags0 = TraitsBase::Flags,
    Flags1 = IsAligned ? (int(Flags0) | AlignedBit) : (int(Flags0) & ~AlignedBit),
    Flags2 = (bool(HasNoStride) || bool(PlainObjectType::IsVectorAtCompileTime))
           ? int(Flags1) : int(Flags1 & ~LinearAccessBit),
    Flags3 = is_lvalue<PlainObjectType>::value ? int(Flags2) : (int(Flags2) & ~LvalueBit),
    Flags = KeepsPacketAccess ? int(Flags3) : (int(Flags3) & ~PacketAccessBit)
  };
private:
  enum { Options };
};
}

template<typename PlainObjectType, int MapOptions, typename StrideType> class Map
  : public MapBase<Map<PlainObjectType, MapOptions, StrideType> >
{
  public:

    typedef MapBase<Map> Base;

    typedef typename Eigen::internal::traits<Map>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<Map>::type Nested; typedef typename Eigen::internal::traits<Map>::StorageKind StorageKind; typedef typename Eigen::internal::traits<Map>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<Map>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<Map>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<Map>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<Map>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<Map>::Flags, CoeffReadCost = Eigen::internal::traits<Map>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived;

    typedef typename Base::PointerType PointerType;




    typedef PointerType PointerArgType;
    inline PointerType cast_to_pointer_type(PointerArgType ptr) { return ptr; }


    inline Index innerStride() const
    {
      return StrideType::InnerStrideAtCompileTime != 0 ? m_stride.inner() : 1;
    }

    inline Index outerStride() const
    {
      return StrideType::OuterStrideAtCompileTime != 0 ? m_stride.outer()
           : IsVectorAtCompileTime ? this->size()
           : int(Flags)&RowMajorBit ? this->cols()
           : this->rows();
    }






    inline Map(PointerArgType data, const StrideType& stride = StrideType())
      : Base(cast_to_pointer_type(data)), m_stride(stride)
    {
      PlainObjectType::Base::_check_template_params();
    }







    inline Map(PointerArgType data, Index size, const StrideType& stride = StrideType())
      : Base(cast_to_pointer_type(data), size), m_stride(stride)
    {
      PlainObjectType::Base::_check_template_params();
    }
# 178 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Map.h"
    inline Map(PointerArgType data, Index rows, Index cols, const StrideType& stride = StrideType())
      : Base(cast_to_pointer_type(data), rows, cols), m_stride(stride)
    {
      PlainObjectType::Base::_check_template_params();
    }


    using Base::operator =; inline Map& operator=(const Map& other) { Base::operator=(other); return *this; }

  protected:
    StrideType m_stride;
};

template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
inline Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>
  ::Array(const Scalar *data)
{
  this->_set_noalias(Eigen::Map<const Array>(data));
}

template<typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols>
inline Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>
  ::Matrix(const Scalar *data)
{
  this->_set_noalias(Eigen::Map<const Matrix>(data));
}
# 305 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Block.h" 1
# 62 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Block.h"
namespace internal {
template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel, bool HasDirectAccess>
struct traits<Block<XprType, BlockRows, BlockCols, InnerPanel, HasDirectAccess> > : traits<XprType>
{
  typedef typename traits<XprType>::Scalar Scalar;
  typedef typename traits<XprType>::StorageKind StorageKind;
  typedef typename traits<XprType>::XprKind XprKind;
  typedef typename nested<XprType>::type XprTypeNested;
  typedef typename remove_reference<XprTypeNested>::type _XprTypeNested;
  enum{
    MatrixRows = traits<XprType>::RowsAtCompileTime,
    MatrixCols = traits<XprType>::ColsAtCompileTime,
    RowsAtCompileTime = MatrixRows == 0 ? 0 : BlockRows,
    ColsAtCompileTime = MatrixCols == 0 ? 0 : BlockCols,
    MaxRowsAtCompileTime = BlockRows==0 ? 0
                         : RowsAtCompileTime != Dynamic ? int(RowsAtCompileTime)
                         : int(traits<XprType>::MaxRowsAtCompileTime),
    MaxColsAtCompileTime = BlockCols==0 ? 0
                         : ColsAtCompileTime != Dynamic ? int(ColsAtCompileTime)
                         : int(traits<XprType>::MaxColsAtCompileTime),
    XprTypeIsRowMajor = (int(traits<XprType>::Flags)&RowMajorBit) != 0,
    IsRowMajor = (MaxRowsAtCompileTime==1&&MaxColsAtCompileTime!=1) ? 1
               : (MaxColsAtCompileTime==1&&MaxRowsAtCompileTime!=1) ? 0
               : XprTypeIsRowMajor,
    HasSameStorageOrderAsXprType = (IsRowMajor == XprTypeIsRowMajor),
    InnerSize = IsRowMajor ? int(ColsAtCompileTime) : int(RowsAtCompileTime),
    InnerStrideAtCompileTime = HasSameStorageOrderAsXprType
                             ? int(inner_stride_at_compile_time<XprType>::ret)
                             : int(outer_stride_at_compile_time<XprType>::ret),
    OuterStrideAtCompileTime = HasSameStorageOrderAsXprType
                             ? int(outer_stride_at_compile_time<XprType>::ret)
                             : int(inner_stride_at_compile_time<XprType>::ret),
    MaskPacketAccessBit = (InnerSize == Dynamic || (InnerSize % packet_traits<Scalar>::size) == 0)
                       && (InnerStrideAtCompileTime == 1)
                        ? PacketAccessBit : 0,
    MaskAlignedBit = (InnerPanel && (OuterStrideAtCompileTime!=Dynamic) && ((OuterStrideAtCompileTime % packet_traits<Scalar>::size) == 0)) ? AlignedBit : 0,
    FlagsLinearAccessBit = (RowsAtCompileTime == 1 || ColsAtCompileTime == 1) ? LinearAccessBit : 0,
    FlagsLvalueBit = is_lvalue<XprType>::value ? LvalueBit : 0,
    FlagsRowMajorBit = IsRowMajor ? RowMajorBit : 0,
    Flags0 = traits<XprType>::Flags & ( (HereditaryBits & ~RowMajorBit) |
                                        DirectAccessBit |
                                        MaskPacketAccessBit |
                                        MaskAlignedBit),
    Flags = Flags0 | FlagsLinearAccessBit | FlagsLvalueBit | FlagsRowMajorBit
  };
};
}

template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel, bool HasDirectAccess> class Block
  : public internal::dense_xpr_base<Block<XprType, BlockRows, BlockCols, InnerPanel, HasDirectAccess> >::type
{
  public:

    typedef typename internal::dense_xpr_base<Block>::type Base;
    typedef typename Eigen::internal::traits<Block>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<Block>::type Nested; typedef typename Eigen::internal::traits<Block>::StorageKind StorageKind; typedef typename Eigen::internal::traits<Block>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<Block>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<Block>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<Block>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<Block>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<Block>::Flags, CoeffReadCost = Eigen::internal::traits<Block>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived;

    class InnerIterator;



    inline Block(XprType& xpr, Index i)
      : m_xpr(xpr),




        m_startRow( (BlockRows==1) && (BlockCols==XprType::ColsAtCompileTime) ? i : 0),
        m_startCol( (BlockRows==XprType::RowsAtCompileTime) && (BlockCols==1) ? i : 0),
        m_blockRows(BlockRows==1 ? 1 : xpr.rows()),
        m_blockCols(BlockCols==1 ? 1 : xpr.cols())
    {
      if( (!Eigen::internal::copy_bool((i>=0) && ( ((BlockRows==1) && (BlockCols==XprType::ColsAtCompileTime) && i<xpr.rows()) ||((BlockRows==XprType::RowsAtCompileTime) && (BlockCols==1) && i<xpr.cols())))) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool((i>=0) && ( ((BlockRows==1) && (BlockCols==XprType::ColsAtCompileTime) && i<xpr.rows()) ||((BlockRows==XprType::RowsAtCompileTime) && (BlockCols==1) && i<xpr.cols())))) Eigen::internal::assert_fail("(i>=0) && ( ((BlockRows==1) && (BlockCols==XprType::ColsAtCompileTime) && i<xpr.rows()) ||((BlockRows==XprType::RowsAtCompileTime) && (BlockCols==1) && i<xpr.cols()))", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Block.h", 135); } while(false); else throw Eigen::eigen_assert_exception(); };


    }



    inline Block(XprType& xpr, Index startRow, Index startCol)
      : m_xpr(xpr), m_startRow(startRow), m_startCol(startCol),
        m_blockRows(BlockRows), m_blockCols(BlockCols)
    {
      if (Eigen::internal::static_assertion<bool(RowsAtCompileTime!=Dynamic && ColsAtCompileTime!=Dynamic)>::THIS_METHOD_IS_ONLY_FOR_FIXED_SIZE) {}
      if( (!Eigen::internal::copy_bool(startRow >= 0 && BlockRows >= 1 && startRow + BlockRows <= xpr.rows() && startCol >= 0 && BlockCols >= 1 && startCol + BlockCols <= xpr.cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(startRow >= 0 && BlockRows >= 1 && startRow + BlockRows <= xpr.rows() && startCol >= 0 && BlockCols >= 1 && startCol + BlockCols <= xpr.cols())) Eigen::internal::assert_fail("startRow >= 0 && BlockRows >= 1 && startRow + BlockRows <= xpr.rows() && startCol >= 0 && BlockCols >= 1 && startCol + BlockCols <= xpr.cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Block.h", 146); } while(false); else throw Eigen::eigen_assert_exception(); };

    }



    inline Block(XprType& xpr,
          Index startRow, Index startCol,
          Index blockRows, Index blockCols)
      : m_xpr(xpr), m_startRow(startRow), m_startCol(startCol),
                          m_blockRows(blockRows), m_blockCols(blockCols)
    {
      if( (!Eigen::internal::copy_bool((RowsAtCompileTime==Dynamic || RowsAtCompileTime==blockRows) && (ColsAtCompileTime==Dynamic || ColsAtCompileTime==blockCols))) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool((RowsAtCompileTime==Dynamic || RowsAtCompileTime==blockRows) && (ColsAtCompileTime==Dynamic || ColsAtCompileTime==blockCols))) Eigen::internal::assert_fail("(RowsAtCompileTime==Dynamic || RowsAtCompileTime==blockRows) && (ColsAtCompileTime==Dynamic || ColsAtCompileTime==blockCols)", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Block.h", 158); } while(false); else throw Eigen::eigen_assert_exception(); };

      if( (!Eigen::internal::copy_bool(startRow >= 0 && blockRows >= 0 && startRow + blockRows <= xpr.rows() && startCol >= 0 && blockCols >= 0 && startCol + blockCols <= xpr.cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(startRow >= 0 && blockRows >= 0 && startRow + blockRows <= xpr.rows() && startCol >= 0 && blockCols >= 0 && startCol + blockCols <= xpr.cols())) Eigen::internal::assert_fail("startRow >= 0 && blockRows >= 0 && startRow + blockRows <= xpr.rows() && startCol >= 0 && blockCols >= 0 && startCol + blockCols <= xpr.cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Block.h", 160); } while(false); else throw Eigen::eigen_assert_exception(); };

    }

    using Base::operator =; inline Block& operator=(const Block& other) { Base::operator=(other); return *this; }

    inline Index rows() const { return m_blockRows.value(); }
    inline Index cols() const { return m_blockCols.value(); }

    inline Scalar& coeffRef(Index row, Index col)
    {
      if (Eigen::internal::static_assertion<bool(internal::is_lvalue<XprType>::value)>::THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY) {}
      return m_xpr.const_cast_derived()
               .coeffRef(row + m_startRow.value(), col + m_startCol.value());
    }

    inline const Scalar& coeffRef(Index row, Index col) const
    {
      return m_xpr.derived()
               .coeffRef(row + m_startRow.value(), col + m_startCol.value());
    }

    inline const CoeffReturnType coeff(Index row, Index col) const
    {
      return m_xpr.coeff(row + m_startRow.value(), col + m_startCol.value());
    }

    inline Scalar& coeffRef(Index index)
    {
      if (Eigen::internal::static_assertion<bool(internal::is_lvalue<XprType>::value)>::THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY) {}
      return m_xpr.const_cast_derived()
             .coeffRef(m_startRow.value() + (RowsAtCompileTime == 1 ? 0 : index),
                       m_startCol.value() + (RowsAtCompileTime == 1 ? index : 0));
    }

    inline const Scalar& coeffRef(Index index) const
    {
      return m_xpr.const_cast_derived()
             .coeffRef(m_startRow.value() + (RowsAtCompileTime == 1 ? 0 : index),
                       m_startCol.value() + (RowsAtCompileTime == 1 ? index : 0));
    }

    inline const CoeffReturnType coeff(Index index) const
    {
      return m_xpr
             .coeff(m_startRow.value() + (RowsAtCompileTime == 1 ? 0 : index),
                    m_startCol.value() + (RowsAtCompileTime == 1 ? index : 0));
    }

    template<int LoadMode>
    inline PacketScalar packet(Index row, Index col) const
    {
      return m_xpr.template packet<Unaligned>
              (row + m_startRow.value(), col + m_startCol.value());
    }

    template<int LoadMode>
    inline void writePacket(Index row, Index col, const PacketScalar& x)
    {
      m_xpr.const_cast_derived().template writePacket<Unaligned>
              (row + m_startRow.value(), col + m_startCol.value(), x);
    }

    template<int LoadMode>
    inline PacketScalar packet(Index index) const
    {
      return m_xpr.template packet<Unaligned>
              (m_startRow.value() + (RowsAtCompileTime == 1 ? 0 : index),
               m_startCol.value() + (RowsAtCompileTime == 1 ? index : 0));
    }

    template<int LoadMode>
    inline void writePacket(Index index, const PacketScalar& x)
    {
      m_xpr.const_cast_derived().template writePacket<Unaligned>
         (m_startRow.value() + (RowsAtCompileTime == 1 ? 0 : index),
          m_startCol.value() + (RowsAtCompileTime == 1 ? index : 0), x);
    }
# 245 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Block.h"
  protected:

    const typename XprType::Nested m_xpr;
    const internal::variable_if_dynamic<Index, XprType::RowsAtCompileTime == 1 ? 0 : Dynamic> m_startRow;
    const internal::variable_if_dynamic<Index, XprType::ColsAtCompileTime == 1 ? 0 : Dynamic> m_startCol;
    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_blockRows;
    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_blockCols;
};


template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel>
class Block<XprType,BlockRows,BlockCols, InnerPanel,true>
  : public MapBase<Block<XprType, BlockRows, BlockCols, InnerPanel, true> >
{
  public:

    typedef MapBase<Block> Base;
    typedef typename Eigen::internal::traits<Block>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<Block>::type Nested; typedef typename Eigen::internal::traits<Block>::StorageKind StorageKind; typedef typename Eigen::internal::traits<Block>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<Block>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<Block>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<Block>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<Block>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<Block>::Flags, CoeffReadCost = Eigen::internal::traits<Block>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived;

    using Base::operator =; inline Block& operator=(const Block& other) { Base::operator=(other); return *this; }



    inline Block(XprType& xpr, Index i)
      : Base(internal::const_cast_ptr(&xpr.coeffRef(
              (BlockRows==1) && (BlockCols==XprType::ColsAtCompileTime) ? i : 0,
              (BlockRows==XprType::RowsAtCompileTime) && (BlockCols==1) ? i : 0)),
             BlockRows==1 ? 1 : xpr.rows(),
             BlockCols==1 ? 1 : xpr.cols()),
        m_xpr(xpr)
    {
      if( (!Eigen::internal::copy_bool((i>=0) && ( ((BlockRows==1) && (BlockCols==XprType::ColsAtCompileTime) && i<xpr.rows()) ||((BlockRows==XprType::RowsAtCompileTime) && (BlockCols==1) && i<xpr.cols())))) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool((i>=0) && ( ((BlockRows==1) && (BlockCols==XprType::ColsAtCompileTime) && i<xpr.rows()) ||((BlockRows==XprType::RowsAtCompileTime) && (BlockCols==1) && i<xpr.cols())))) Eigen::internal::assert_fail("(i>=0) && ( ((BlockRows==1) && (BlockCols==XprType::ColsAtCompileTime) && i<xpr.rows()) ||((BlockRows==XprType::RowsAtCompileTime) && (BlockCols==1) && i<xpr.cols()))", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Block.h", 278); } while(false); else throw Eigen::eigen_assert_exception(); };


      init();
    }



    inline Block(XprType& xpr, Index startRow, Index startCol)
      : Base(internal::const_cast_ptr(&xpr.coeffRef(startRow,startCol))), m_xpr(xpr)
    {
      if( (!Eigen::internal::copy_bool(startRow >= 0 && BlockRows >= 1 && startRow + BlockRows <= xpr.rows() && startCol >= 0 && BlockCols >= 1 && startCol + BlockCols <= xpr.cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(startRow >= 0 && BlockRows >= 1 && startRow + BlockRows <= xpr.rows() && startCol >= 0 && BlockCols >= 1 && startCol + BlockCols <= xpr.cols())) Eigen::internal::assert_fail("startRow >= 0 && BlockRows >= 1 && startRow + BlockRows <= xpr.rows() && startCol >= 0 && BlockCols >= 1 && startCol + BlockCols <= xpr.cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Block.h", 288); } while(false); else throw Eigen::eigen_assert_exception(); };

      init();
    }



    inline Block(XprType& xpr,
          Index startRow, Index startCol,
          Index blockRows, Index blockCols)
      : Base(internal::const_cast_ptr(&xpr.coeffRef(startRow,startCol)), blockRows, blockCols),
        m_xpr(xpr)
    {
      if( (!Eigen::internal::copy_bool((RowsAtCompileTime==Dynamic || RowsAtCompileTime==blockRows) && (ColsAtCompileTime==Dynamic || ColsAtCompileTime==blockCols))) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool((RowsAtCompileTime==Dynamic || RowsAtCompileTime==blockRows) && (ColsAtCompileTime==Dynamic || ColsAtCompileTime==blockCols))) Eigen::internal::assert_fail("(RowsAtCompileTime==Dynamic || RowsAtCompileTime==blockRows) && (ColsAtCompileTime==Dynamic || ColsAtCompileTime==blockCols)", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Block.h", 301); } while(false); else throw Eigen::eigen_assert_exception(); };

      if( (!Eigen::internal::copy_bool(startRow >= 0 && blockRows >= 0 && startRow + blockRows <= xpr.rows() && startCol >= 0 && blockCols >= 0 && startCol + blockCols <= xpr.cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(startRow >= 0 && blockRows >= 0 && startRow + blockRows <= xpr.rows() && startCol >= 0 && blockCols >= 0 && startCol + blockCols <= xpr.cols())) Eigen::internal::assert_fail("startRow >= 0 && blockRows >= 0 && startRow + blockRows <= xpr.rows() && startCol >= 0 && blockCols >= 0 && startCol + blockCols <= xpr.cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Block.h", 303); } while(false); else throw Eigen::eigen_assert_exception(); };

      init();
    }


    inline Index innerStride() const
    {
      return internal::traits<Block>::HasSameStorageOrderAsXprType
             ? m_xpr.innerStride()
             : m_xpr.outerStride();
    }


    inline Index outerStride() const
    {
      return m_outerStride;
    }




  protected:




    inline Block(XprType& xpr, const Scalar* data, Index blockRows, Index blockCols)
      : Base(data, blockRows, blockCols), m_xpr(xpr)
    {
      init();
    }


  protected:
    void init()
    {
      m_outerStride = internal::traits<Block>::HasSameStorageOrderAsXprType
                    ? m_xpr.outerStride()
                    : m_xpr.innerStride();
    }

    const typename XprType::Nested m_xpr;
    int m_outerStride;
};
# 306 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/VectorBlock.h" 1
# 60 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/VectorBlock.h"
namespace internal {
template<typename VectorType, int Size>
struct traits<VectorBlock<VectorType, Size> >
  : public traits<Block<VectorType,
                     traits<VectorType>::Flags & RowMajorBit ? 1 : Size,
                     traits<VectorType>::Flags & RowMajorBit ? Size : 1> >
{
};
}

template<typename VectorType, int Size> class VectorBlock
  : public Block<VectorType,
                     internal::traits<VectorType>::Flags & RowMajorBit ? 1 : Size,
                     internal::traits<VectorType>::Flags & RowMajorBit ? Size : 1>
{
    typedef Block<VectorType,
                     internal::traits<VectorType>::Flags & RowMajorBit ? 1 : Size,
                     internal::traits<VectorType>::Flags & RowMajorBit ? Size : 1> Base;
    enum {
      IsColVector = !(internal::traits<VectorType>::Flags & RowMajorBit)
    };
  public:
    typedef typename Eigen::internal::traits<VectorBlock>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<VectorBlock>::type Nested; typedef typename Eigen::internal::traits<VectorBlock>::StorageKind StorageKind; typedef typename Eigen::internal::traits<VectorBlock>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<VectorBlock>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<VectorBlock>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<VectorBlock>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<VectorBlock>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<VectorBlock>::Flags, CoeffReadCost = Eigen::internal::traits<VectorBlock>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived;

    using Base::operator=;



    inline VectorBlock(VectorType& vector, Index start, Index size)
      : Base(vector,
             IsColVector ? start : 0, IsColVector ? 0 : start,
             IsColVector ? size : 1, IsColVector ? 1 : size)
    {
      if (Eigen::internal::static_assertion<bool(VectorBlock::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {};
    }



    inline VectorBlock(VectorType& vector, Index start)
      : Base(vector, IsColVector ? start : 0, IsColVector ? 0 : start)
    {
      if (Eigen::internal::static_assertion<bool(VectorBlock::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {};
    }
};
# 122 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/VectorBlock.h"
template<typename Derived>
inline typename DenseBase<Derived>::SegmentReturnType
DenseBase<Derived>::segment(Index start, Index size)
{
  if (Eigen::internal::static_assertion<bool(Derived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
  return SegmentReturnType(derived(), start, size);
}


template<typename Derived>
inline typename DenseBase<Derived>::ConstSegmentReturnType
DenseBase<Derived>::segment(Index start, Index size) const
{
  if (Eigen::internal::static_assertion<bool(Derived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
  return ConstSegmentReturnType(derived(), start, size);
}
# 154 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/VectorBlock.h"
template<typename Derived>
inline typename DenseBase<Derived>::SegmentReturnType
DenseBase<Derived>::head(Index size)
{
  if (Eigen::internal::static_assertion<bool(Derived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
  return SegmentReturnType(derived(), 0, size);
}


template<typename Derived>
inline typename DenseBase<Derived>::ConstSegmentReturnType
DenseBase<Derived>::head(Index size) const
{
  if (Eigen::internal::static_assertion<bool(Derived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
  return ConstSegmentReturnType(derived(), 0, size);
}
# 186 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/VectorBlock.h"
template<typename Derived>
inline typename DenseBase<Derived>::SegmentReturnType
DenseBase<Derived>::tail(Index size)
{
  if (Eigen::internal::static_assertion<bool(Derived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
  return SegmentReturnType(derived(), this->size() - size, size);
}


template<typename Derived>
inline typename DenseBase<Derived>::ConstSegmentReturnType
DenseBase<Derived>::tail(Index size) const
{
  if (Eigen::internal::static_assertion<bool(Derived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
  return ConstSegmentReturnType(derived(), this->size() - size, size);
}
# 216 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/VectorBlock.h"
template<typename Derived>
template<int Size>
inline typename DenseBase<Derived>::template FixedSegmentReturnType<Size>::Type
DenseBase<Derived>::segment(Index start)
{
  if (Eigen::internal::static_assertion<bool(Derived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
  return typename FixedSegmentReturnType<Size>::Type(derived(), start);
}


template<typename Derived>
template<int Size>
inline typename DenseBase<Derived>::template ConstFixedSegmentReturnType<Size>::Type
DenseBase<Derived>::segment(Index start) const
{
  if (Eigen::internal::static_assertion<bool(Derived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
  return typename ConstFixedSegmentReturnType<Size>::Type(derived(), start);
}
# 246 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/VectorBlock.h"
template<typename Derived>
template<int Size>
inline typename DenseBase<Derived>::template FixedSegmentReturnType<Size>::Type
DenseBase<Derived>::head()
{
  if (Eigen::internal::static_assertion<bool(Derived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
  return typename FixedSegmentReturnType<Size>::Type(derived(), 0);
}


template<typename Derived>
template<int Size>
inline typename DenseBase<Derived>::template ConstFixedSegmentReturnType<Size>::Type
DenseBase<Derived>::head() const
{
  if (Eigen::internal::static_assertion<bool(Derived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
  return typename ConstFixedSegmentReturnType<Size>::Type(derived(), 0);
}
# 276 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/VectorBlock.h"
template<typename Derived>
template<int Size>
inline typename DenseBase<Derived>::template FixedSegmentReturnType<Size>::Type
DenseBase<Derived>::tail()
{
  if (Eigen::internal::static_assertion<bool(Derived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
  return typename FixedSegmentReturnType<Size>::Type(derived(), size() - Size);
}


template<typename Derived>
template<int Size>
inline typename DenseBase<Derived>::template ConstFixedSegmentReturnType<Size>::Type
DenseBase<Derived>::tail() const
{
  if (Eigen::internal::static_assertion<bool(Derived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
  return typename ConstFixedSegmentReturnType<Size>::Type(derived(), size() - Size);
}
# 307 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Transpose.h" 1
# 43 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Transpose.h"
namespace internal {
template<typename MatrixType>
struct traits<Transpose<MatrixType> > : traits<MatrixType>
{
  typedef typename MatrixType::Scalar Scalar;
  typedef typename nested<MatrixType>::type MatrixTypeNested;
  typedef typename remove_reference<MatrixTypeNested>::type MatrixTypeNestedPlain;
  typedef typename traits<MatrixType>::StorageKind StorageKind;
  typedef typename traits<MatrixType>::XprKind XprKind;
  enum {
    RowsAtCompileTime = MatrixType::ColsAtCompileTime,
    ColsAtCompileTime = MatrixType::RowsAtCompileTime,
    MaxRowsAtCompileTime = MatrixType::MaxColsAtCompileTime,
    MaxColsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
    FlagsLvalueBit = is_lvalue<MatrixType>::value ? LvalueBit : 0,
    Flags0 = MatrixTypeNestedPlain::Flags & ~(LvalueBit | NestByRefBit),
    Flags1 = Flags0 | FlagsLvalueBit,
    Flags = Flags1 ^ RowMajorBit,
    CoeffReadCost = MatrixTypeNestedPlain::CoeffReadCost,
    InnerStrideAtCompileTime = inner_stride_at_compile_time<MatrixType>::ret,
    OuterStrideAtCompileTime = outer_stride_at_compile_time<MatrixType>::ret
  };
};
}

template<typename MatrixType, typename StorageKind> class TransposeImpl;

template<typename MatrixType> class Transpose
  : public TransposeImpl<MatrixType,typename internal::traits<MatrixType>::StorageKind>
{
  public:

    typedef typename TransposeImpl<MatrixType,typename internal::traits<MatrixType>::StorageKind>::Base Base;
    typedef typename Eigen::internal::traits<Transpose>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<Transpose>::type Nested; typedef typename Eigen::internal::traits<Transpose>::StorageKind StorageKind; typedef typename Eigen::internal::traits<Transpose>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<Transpose>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<Transpose>::ColsAtCompileTime, Flags = Eigen::internal::traits<Transpose>::Flags, CoeffReadCost = Eigen::internal::traits<Transpose>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime };

    inline Transpose(MatrixType& matrix) : m_matrix(matrix) {}

    using Base::operator =; inline Transpose& operator=(const Transpose& other) { Base::operator=(other); return *this; }

    inline Index rows() const { return m_matrix.cols(); }
    inline Index cols() const { return m_matrix.rows(); }


    const typename internal::remove_all<typename MatrixType::Nested>::type&
    nestedExpression() const { return m_matrix; }


    typename internal::remove_all<typename MatrixType::Nested>::type&
    nestedExpression() { return m_matrix.const_cast_derived(); }

  protected:
    const typename MatrixType::Nested m_matrix;
};

namespace internal {

template<typename MatrixType, bool HasDirectAccess = has_direct_access<MatrixType>::ret>
struct TransposeImpl_base
{
  typedef typename dense_xpr_base<Transpose<MatrixType> >::type type;
};

template<typename MatrixType>
struct TransposeImpl_base<MatrixType, false>
{
  typedef typename dense_xpr_base<Transpose<MatrixType> >::type type;
};

}

template<typename MatrixType> class TransposeImpl<MatrixType,Dense>
  : public internal::TransposeImpl_base<MatrixType>::type
{
  public:

    typedef typename internal::TransposeImpl_base<MatrixType>::type Base;
    typedef typename Eigen::internal::traits<Transpose<MatrixType> >::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<Transpose<MatrixType> >::type Nested; typedef typename Eigen::internal::traits<Transpose<MatrixType> >::StorageKind StorageKind; typedef typename Eigen::internal::traits<Transpose<MatrixType> >::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<Transpose<MatrixType> >::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<Transpose<MatrixType> >::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<Transpose<MatrixType> >::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<Transpose<MatrixType> >::MaxColsAtCompileTime, Flags = Eigen::internal::traits<Transpose<MatrixType> >::Flags, CoeffReadCost = Eigen::internal::traits<Transpose<MatrixType> >::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived;

    inline Index innerStride() const { return derived().nestedExpression().innerStride(); }
    inline Index outerStride() const { return derived().nestedExpression().outerStride(); }

    typedef typename internal::conditional<
                       internal::is_lvalue<MatrixType>::value,
                       Scalar,
                       const Scalar
                     >::type ScalarWithConstIfNotLvalue;

    inline ScalarWithConstIfNotLvalue* data() { return derived().nestedExpression().data(); }
    inline const Scalar* data() const { return derived().nestedExpression().data(); }

    inline ScalarWithConstIfNotLvalue& coeffRef(Index row, Index col)
    {
      if (Eigen::internal::static_assertion<bool(internal::is_lvalue<MatrixType>::value)>::THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY) {}
      return derived().nestedExpression().const_cast_derived().coeffRef(col, row);
    }

    inline ScalarWithConstIfNotLvalue& coeffRef(Index index)
    {
      if (Eigen::internal::static_assertion<bool(internal::is_lvalue<MatrixType>::value)>::THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY) {}
      return derived().nestedExpression().const_cast_derived().coeffRef(index);
    }

    inline const Scalar& coeffRef(Index row, Index col) const
    {
      return derived().nestedExpression().coeffRef(col, row);
    }

    inline const Scalar& coeffRef(Index index) const
    {
      return derived().nestedExpression().coeffRef(index);
    }

    inline const CoeffReturnType coeff(Index row, Index col) const
    {
      return derived().nestedExpression().coeff(col, row);
    }

    inline const CoeffReturnType coeff(Index index) const
    {
      return derived().nestedExpression().coeff(index);
    }

    template<int LoadMode>
    inline const PacketScalar packet(Index row, Index col) const
    {
      return derived().nestedExpression().template packet<LoadMode>(col, row);
    }

    template<int LoadMode>
    inline void writePacket(Index row, Index col, const PacketScalar& x)
    {
      derived().nestedExpression().const_cast_derived().template writePacket<LoadMode>(col, row, x);
    }

    template<int LoadMode>
    inline const PacketScalar packet(Index index) const
    {
      return derived().nestedExpression().template packet<LoadMode>(index);
    }

    template<int LoadMode>
    inline void writePacket(Index index, const PacketScalar& x)
    {
      derived().nestedExpression().const_cast_derived().template writePacket<LoadMode>(index, x);
    }
};
# 209 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Transpose.h"
template<typename Derived>
inline Transpose<Derived>
DenseBase<Derived>::transpose()
{
  return derived();
}






template<typename Derived>
inline const typename DenseBase<Derived>::ConstTransposeReturnType
DenseBase<Derived>::transpose() const
{
  return ConstTransposeReturnType(derived());
}
# 247 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Transpose.h"
template<typename Derived>
inline const typename MatrixBase<Derived>::AdjointReturnType
MatrixBase<Derived>::adjoint() const
{
  return this->transpose();

}





namespace internal {

template<typename MatrixType,
  bool IsSquare = (MatrixType::RowsAtCompileTime == MatrixType::ColsAtCompileTime) && MatrixType::RowsAtCompileTime!=Dynamic>
struct inplace_transpose_selector;

template<typename MatrixType>
struct inplace_transpose_selector<MatrixType,true> {
  static void run(MatrixType& m) {
    m.template triangularView<StrictlyUpper>().swap(m.transpose());
  }
};

template<typename MatrixType>
struct inplace_transpose_selector<MatrixType,false> {
  static void run(MatrixType& m) {
    if (m.rows()==m.cols())
      m.template triangularView<StrictlyUpper>().swap(m.transpose());
    else
      m = m.transpose().eval();
  }
};

}
# 302 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Transpose.h"
template<typename Derived>
inline void DenseBase<Derived>::transposeInPlace()
{
  internal::inplace_transpose_selector<Derived>::run(derived());
}
# 330 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Transpose.h"
template<typename Derived>
inline void MatrixBase<Derived>::adjointInPlace()
{
  derived() = adjoint().eval();
}





namespace internal {

template<typename BinOp,typename NestedXpr,typename Rhs>
struct blas_traits<SelfCwiseBinaryOp<BinOp,NestedXpr,Rhs> >
 : blas_traits<NestedXpr>
{
  typedef SelfCwiseBinaryOp<BinOp,NestedXpr,Rhs> XprType;
  static inline const XprType extract(const XprType& x) { return x; }
};

template<bool DestIsTransposed, typename OtherDerived>
struct check_transpose_aliasing_compile_time_selector
{
  enum { ret = bool(blas_traits<OtherDerived>::IsTransposed) != DestIsTransposed };
};

template<bool DestIsTransposed, typename BinOp, typename DerivedA, typename DerivedB>
struct check_transpose_aliasing_compile_time_selector<DestIsTransposed,CwiseBinaryOp<BinOp,DerivedA,DerivedB> >
{
  enum { ret = bool(blas_traits<DerivedA>::IsTransposed) != DestIsTransposed
               || bool(blas_traits<DerivedB>::IsTransposed) != DestIsTransposed
  };
};

template<typename Scalar, bool DestIsTransposed, typename OtherDerived>
struct check_transpose_aliasing_run_time_selector
{
  static bool run(const Scalar* dest, const OtherDerived& src)
  {
    return (bool(blas_traits<OtherDerived>::IsTransposed) != DestIsTransposed) && (dest!=0 && dest==(Scalar*)extract_data(src));
  }
};

template<typename Scalar, bool DestIsTransposed, typename BinOp, typename DerivedA, typename DerivedB>
struct check_transpose_aliasing_run_time_selector<Scalar,DestIsTransposed,CwiseBinaryOp<BinOp,DerivedA,DerivedB> >
{
  static bool run(const Scalar* dest, const CwiseBinaryOp<BinOp,DerivedA,DerivedB>& src)
  {
    return ((blas_traits<DerivedA>::IsTransposed != DestIsTransposed) && (dest!=0 && dest==(Scalar*)extract_data(src.lhs())))
        || ((blas_traits<DerivedB>::IsTransposed != DestIsTransposed) && (dest!=0 && dest==(Scalar*)extract_data(src.rhs())));
  }
};







template<typename Derived, typename OtherDerived,
         bool MightHaveTransposeAliasing
                 = check_transpose_aliasing_compile_time_selector
                     <blas_traits<Derived>::IsTransposed,OtherDerived>::ret
        >
struct checkTransposeAliasing_impl
{
    static void run(const Derived& dst, const OtherDerived& other)
    {
        if( (!Eigen::internal::copy_bool((!check_transpose_aliasing_run_time_selector <typename Derived::Scalar,blas_traits<Derived>::IsTransposed,OtherDerived> ::run(extract_data(dst), other)) && "aliasing detected during tranposition, use transposeInPlace() " "or evaluate the rhs into a temporary using .eval()")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool((!check_transpose_aliasing_run_time_selector <typename Derived::Scalar,blas_traits<Derived>::IsTransposed,OtherDerived> ::run(extract_data(dst), other)) && "aliasing detected during tranposition, use transposeInPlace() " "or evaluate the rhs into a temporary using .eval()")) Eigen::internal::assert_fail("(!check_transpose_aliasing_run_time_selector <typename Derived::Scalar,blas_traits<Derived>::IsTransposed,OtherDerived> ::run(extract_data(dst), other)) && \"aliasing detected during tranposition, use transposeInPlace() \" \"or evaluate the rhs into a temporary using .eval()\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Transpose.h", 402); } while(false); else throw Eigen::eigen_assert_exception(); };





    }
};

template<typename Derived, typename OtherDerived>
struct checkTransposeAliasing_impl<Derived, OtherDerived, false>
{
    static void run(const Derived&, const OtherDerived&)
    {
    }
};

}

template<typename Derived>
template<typename OtherDerived>
void DenseBase<Derived>::checkTransposeAliasing(const OtherDerived& other) const
{
    internal::checkTransposeAliasing_impl<Derived, OtherDerived>::run(derived(), other);
}
# 308 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DiagonalMatrix.h" 1
# 30 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DiagonalMatrix.h"
template<typename Derived>
class DiagonalBase : public EigenBase<Derived>
{
  public:
    typedef typename internal::traits<Derived>::DiagonalVectorType DiagonalVectorType;
    typedef typename DiagonalVectorType::Scalar Scalar;
    typedef typename internal::traits<Derived>::StorageKind StorageKind;
    typedef typename internal::traits<Derived>::Index Index;

    enum {
      RowsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,
      ColsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,
      MaxRowsAtCompileTime = DiagonalVectorType::MaxSizeAtCompileTime,
      MaxColsAtCompileTime = DiagonalVectorType::MaxSizeAtCompileTime,
      IsVectorAtCompileTime = 0,
      Flags = 0
    };

    typedef Matrix<Scalar, RowsAtCompileTime, ColsAtCompileTime, 0, MaxRowsAtCompileTime, MaxColsAtCompileTime> DenseMatrixType;
    typedef DenseMatrixType DenseType;
    typedef DiagonalMatrix<Scalar,DiagonalVectorType::SizeAtCompileTime,DiagonalVectorType::MaxSizeAtCompileTime> PlainObject;

    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }
    inline Derived& derived() { return *static_cast<Derived*>(this); }

    DenseMatrixType toDenseMatrix() const { return derived(); }
    template<typename DenseDerived>
    void evalTo(MatrixBase<DenseDerived> &other) const;
    template<typename DenseDerived>
    void addTo(MatrixBase<DenseDerived> &other) const
    { other.diagonal() += diagonal(); }
    template<typename DenseDerived>
    void subTo(MatrixBase<DenseDerived> &other) const
    { other.diagonal() -= diagonal(); }

    inline const DiagonalVectorType& diagonal() const { return derived().diagonal(); }
    inline DiagonalVectorType& diagonal() { return derived().diagonal(); }

    inline Index rows() const { return diagonal().size(); }
    inline Index cols() const { return diagonal().size(); }

    template<typename MatrixDerived>
    const DiagonalProduct<MatrixDerived, Derived, OnTheLeft>
    operator*(const MatrixBase<MatrixDerived> &matrix) const;

    inline const DiagonalWrapper<CwiseUnaryOp<internal::scalar_inverse_op<Scalar>, const DiagonalVectorType> >
    inverse() const
    {
      return diagonal().cwiseInverse();
    }
# 93 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DiagonalMatrix.h"
};

template<typename Derived>
template<typename DenseDerived>
void DiagonalBase<Derived>::evalTo(MatrixBase<DenseDerived> &other) const
{
  other.setZero();
  other.diagonal() = diagonal();
}
# 117 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DiagonalMatrix.h"
namespace internal {
template<typename _Scalar, int SizeAtCompileTime, int MaxSizeAtCompileTime>
struct traits<DiagonalMatrix<_Scalar,SizeAtCompileTime,MaxSizeAtCompileTime> >
 : traits<Matrix<_Scalar,SizeAtCompileTime,SizeAtCompileTime,0,MaxSizeAtCompileTime,MaxSizeAtCompileTime> >
{
  typedef Matrix<_Scalar,SizeAtCompileTime,1,0,MaxSizeAtCompileTime,1> DiagonalVectorType;
  typedef Dense StorageKind;
  typedef DenseIndex Index;
  enum {
    Flags = LvalueBit
  };
};
}
template<typename _Scalar, int SizeAtCompileTime, int MaxSizeAtCompileTime>
class DiagonalMatrix
  : public DiagonalBase<DiagonalMatrix<_Scalar,SizeAtCompileTime,MaxSizeAtCompileTime> >
{
  public:

    typedef typename internal::traits<DiagonalMatrix>::DiagonalVectorType DiagonalVectorType;
    typedef const DiagonalMatrix& Nested;
    typedef _Scalar Scalar;
    typedef typename internal::traits<DiagonalMatrix>::StorageKind StorageKind;
    typedef typename internal::traits<DiagonalMatrix>::Index Index;


  protected:

    DiagonalVectorType m_diagonal;

  public:


    inline const DiagonalVectorType& diagonal() const { return m_diagonal; }

    inline DiagonalVectorType& diagonal() { return m_diagonal; }


    inline DiagonalMatrix() {}


    inline DiagonalMatrix(Index dim) : m_diagonal(dim) {}


    inline DiagonalMatrix(const Scalar& x, const Scalar& y) : m_diagonal(x,y) {}


    inline DiagonalMatrix(const Scalar& x, const Scalar& y, const Scalar& z) : m_diagonal(x,y,z) {}


    template<typename OtherDerived>
    inline DiagonalMatrix(const DiagonalBase<OtherDerived>& other) : m_diagonal(other.diagonal()) {}



    inline DiagonalMatrix(const DiagonalMatrix& other) : m_diagonal(other.diagonal()) {}



    template<typename OtherDerived>
    explicit inline DiagonalMatrix(const MatrixBase<OtherDerived>& other) : m_diagonal(other)
    {}


    template<typename OtherDerived>
    DiagonalMatrix& operator=(const DiagonalBase<OtherDerived>& other)
    {
      m_diagonal = other.diagonal();
      return *this;
    }





    DiagonalMatrix& operator=(const DiagonalMatrix& other)
    {
      m_diagonal = other.diagonal();
      return *this;
    }



    inline void resize(Index size) { m_diagonal.resize(size); }

    inline void setZero() { m_diagonal.setZero(); }

    inline void setZero(Index size) { m_diagonal.setZero(size); }

    inline void setIdentity() { m_diagonal.setOnes(); }

    inline void setIdentity(Index size) { m_diagonal.setOnes(size); }
};
# 225 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DiagonalMatrix.h"
namespace internal {
template<typename _DiagonalVectorType>
struct traits<DiagonalWrapper<_DiagonalVectorType> >
{
  typedef _DiagonalVectorType DiagonalVectorType;
  typedef typename DiagonalVectorType::Scalar Scalar;
  typedef typename DiagonalVectorType::Index Index;
  typedef typename DiagonalVectorType::StorageKind StorageKind;
  enum {
    RowsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,
    ColsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,
    MaxRowsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,
    MaxColsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,
    Flags = traits<DiagonalVectorType>::Flags & LvalueBit
  };
};
}

template<typename _DiagonalVectorType>
class DiagonalWrapper
  : public DiagonalBase<DiagonalWrapper<_DiagonalVectorType> >, internal::no_assignment_operator
{
  public:

    typedef _DiagonalVectorType DiagonalVectorType;
    typedef DiagonalWrapper Nested;



    inline DiagonalWrapper(const DiagonalVectorType& diagonal) : m_diagonal(diagonal) {}


    const DiagonalVectorType& diagonal() const { return m_diagonal; }

  protected:
    const typename DiagonalVectorType::Nested m_diagonal;
};
# 272 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DiagonalMatrix.h"
template<typename Derived>
inline const DiagonalWrapper<const Derived>
MatrixBase<Derived>::asDiagonal() const
{
  return derived();
}
# 287 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DiagonalMatrix.h"
template<typename Derived>
bool MatrixBase<Derived>::isDiagonal(RealScalar prec) const
{
  if(cols() != rows()) return false;
  RealScalar maxAbsOnDiagonal = static_cast<RealScalar>(-1);
  for(Index j = 0; j < cols(); ++j)
  {
    RealScalar absOnDiagonal = internal::abs(coeff(j,j));
    if(absOnDiagonal > maxAbsOnDiagonal) maxAbsOnDiagonal = absOnDiagonal;
  }
  for(Index j = 0; j < cols(); ++j)
    for(Index i = 0; i < j; ++i)
    {
      if(!internal::isMuchSmallerThan(coeff(i, j), maxAbsOnDiagonal, prec)) return false;
      if(!internal::isMuchSmallerThan(coeff(j, i), maxAbsOnDiagonal, prec)) return false;
    }
  return true;
}
# 309 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Diagonal.h" 1
# 47 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Diagonal.h"
namespace internal {
template<typename MatrixType, int DiagIndex>
struct traits<Diagonal<MatrixType,DiagIndex> >
 : traits<MatrixType>
{
  typedef typename nested<MatrixType>::type MatrixTypeNested;
  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;
  typedef typename MatrixType::StorageKind StorageKind;
  enum {
    AbsDiagIndex = DiagIndex<0 ? -DiagIndex : DiagIndex,

    RowsAtCompileTime = (int(DiagIndex) == Dynamic || int(MatrixType::SizeAtCompileTime) == Dynamic) ? Dynamic
                      : ((((int)MatrixType::RowsAtCompileTime == 0 || (int)MatrixType::ColsAtCompileTime == 0) ? 0 : ((int)MatrixType::RowsAtCompileTime == 1 || (int)MatrixType::ColsAtCompileTime == 1) ? 1 : ((int)MatrixType::RowsAtCompileTime == Dynamic || (int)MatrixType::ColsAtCompileTime == Dynamic) ? Dynamic : ((int)MatrixType::RowsAtCompileTime <= (int)MatrixType::ColsAtCompileTime) ? (int)MatrixType::RowsAtCompileTime : (int)MatrixType::ColsAtCompileTime) - AbsDiagIndex),

    ColsAtCompileTime = 1,
    MaxRowsAtCompileTime = int(MatrixType::MaxSizeAtCompileTime) == Dynamic ? Dynamic
                         : DiagIndex == Dynamic ? (((int)MatrixType::MaxRowsAtCompileTime == 0 || (int)MatrixType::MaxColsAtCompileTime == 0) ? 0 : ((int)MatrixType::MaxRowsAtCompileTime == 1 || (int)MatrixType::MaxColsAtCompileTime == 1) ? 1 : ((int)MatrixType::MaxRowsAtCompileTime == Dynamic && (int)MatrixType::MaxColsAtCompileTime == Dynamic) ? Dynamic : ((int)MatrixType::MaxRowsAtCompileTime == Dynamic) ? (int)MatrixType::MaxColsAtCompileTime : ((int)MatrixType::MaxColsAtCompileTime == Dynamic) ? (int)MatrixType::MaxRowsAtCompileTime : ((int)MatrixType::MaxRowsAtCompileTime <= (int)MatrixType::MaxColsAtCompileTime) ? (int)MatrixType::MaxRowsAtCompileTime : (int)MatrixType::MaxColsAtCompileTime)

                         : ((((int)MatrixType::MaxRowsAtCompileTime == 0 || (int)MatrixType::MaxColsAtCompileTime == 0) ? 0 : ((int)MatrixType::MaxRowsAtCompileTime == 1 || (int)MatrixType::MaxColsAtCompileTime == 1) ? 1 : ((int)MatrixType::MaxRowsAtCompileTime == Dynamic && (int)MatrixType::MaxColsAtCompileTime == Dynamic) ? Dynamic : ((int)MatrixType::MaxRowsAtCompileTime == Dynamic) ? (int)MatrixType::MaxColsAtCompileTime : ((int)MatrixType::MaxColsAtCompileTime == Dynamic) ? (int)MatrixType::MaxRowsAtCompileTime : ((int)MatrixType::MaxRowsAtCompileTime <= (int)MatrixType::MaxColsAtCompileTime) ? (int)MatrixType::MaxRowsAtCompileTime : (int)MatrixType::MaxColsAtCompileTime) - AbsDiagIndex),
    MaxColsAtCompileTime = 1,
    MaskLvalueBit = is_lvalue<MatrixType>::value ? LvalueBit : 0,
    Flags = (unsigned int)_MatrixTypeNested::Flags & (HereditaryBits | LinearAccessBit | MaskLvalueBit | DirectAccessBit) & ~RowMajorBit,
    CoeffReadCost = _MatrixTypeNested::CoeffReadCost,
    MatrixTypeOuterStride = outer_stride_at_compile_time<MatrixType>::ret,
    InnerStrideAtCompileTime = MatrixTypeOuterStride == Dynamic ? Dynamic : MatrixTypeOuterStride+1,
    OuterStrideAtCompileTime = 0
  };
};
}

template<typename MatrixType, int DiagIndex> class Diagonal
   : public internal::dense_xpr_base< Diagonal<MatrixType,DiagIndex> >::type
{
  public:

    typedef typename internal::dense_xpr_base<Diagonal>::type Base;
    typedef typename Eigen::internal::traits<Diagonal>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<Diagonal>::type Nested; typedef typename Eigen::internal::traits<Diagonal>::StorageKind StorageKind; typedef typename Eigen::internal::traits<Diagonal>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<Diagonal>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<Diagonal>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<Diagonal>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<Diagonal>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<Diagonal>::Flags, CoeffReadCost = Eigen::internal::traits<Diagonal>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived;

    inline Diagonal(MatrixType& matrix, Index index = DiagIndex) : m_matrix(matrix), m_index(index) {}

    using Base::operator =; inline Diagonal& operator=(const Diagonal& other) { Base::operator=(other); return *this; }

    inline Index rows() const
    { return m_index.value()<0 ? (std::min)(m_matrix.cols(),m_matrix.rows()+m_index.value()) : (std::min)(m_matrix.rows(),m_matrix.cols()-m_index.value()); }

    inline Index cols() const { return 1; }

    inline Index innerStride() const
    {
      return m_matrix.outerStride() + 1;
    }

    inline Index outerStride() const
    {
      return 0;
    }

    inline Scalar& coeffRef(Index row, Index)
    {
      if (Eigen::internal::static_assertion<bool(internal::is_lvalue<MatrixType>::value)>::THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY) {}
      return m_matrix.const_cast_derived().coeffRef(row+rowOffset(), row+colOffset());
    }

    inline const Scalar& coeffRef(Index row, Index) const
    {
      return m_matrix.const_cast_derived().coeffRef(row+rowOffset(), row+colOffset());
    }

    inline CoeffReturnType coeff(Index row, Index) const
    {
      return m_matrix.coeff(row+rowOffset(), row+colOffset());
    }

    inline Scalar& coeffRef(Index index)
    {
      if (Eigen::internal::static_assertion<bool(internal::is_lvalue<MatrixType>::value)>::THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY) {}
      return m_matrix.const_cast_derived().coeffRef(index+rowOffset(), index+colOffset());
    }

    inline const Scalar& coeffRef(Index index) const
    {
      return m_matrix.const_cast_derived().coeffRef(index+rowOffset(), index+colOffset());
    }

    inline CoeffReturnType coeff(Index index) const
    {
      return m_matrix.coeff(index+rowOffset(), index+colOffset());
    }

  protected:
    const typename MatrixType::Nested m_matrix;
    const internal::variable_if_dynamic<Index, DiagIndex> m_index;

  private:

    inline Index absDiagIndex() const { return m_index.value()>0 ? m_index.value() : -m_index.value(); }
    inline Index rowOffset() const { return m_index.value()>0 ? 0 : -m_index.value(); }
    inline Index colOffset() const { return m_index.value()>0 ? m_index.value() : 0; }

    template<int LoadMode> typename MatrixType::PacketReturnType packet(Index) const;
    template<int LoadMode> typename MatrixType::PacketReturnType packet(Index,Index) const;
};
# 158 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Diagonal.h"
template<typename Derived>
inline typename MatrixBase<Derived>::DiagonalReturnType
MatrixBase<Derived>::diagonal()
{
  return derived();
}


template<typename Derived>
inline const typename MatrixBase<Derived>::ConstDiagonalReturnType
MatrixBase<Derived>::diagonal() const
{
  return ConstDiagonalReturnType(derived());
}
# 184 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Diagonal.h"
template<typename Derived>
inline typename MatrixBase<Derived>::template DiagonalIndexReturnType<Dynamic>::Type
MatrixBase<Derived>::diagonal(Index index)
{
  return typename DiagonalIndexReturnType<Dynamic>::Type(derived(), index);
}


template<typename Derived>
inline typename MatrixBase<Derived>::template ConstDiagonalIndexReturnType<Dynamic>::Type
MatrixBase<Derived>::diagonal(Index index) const
{
  return typename ConstDiagonalIndexReturnType<Dynamic>::Type(derived(), index);
}
# 210 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Diagonal.h"
template<typename Derived>
template<int Index>
inline typename MatrixBase<Derived>::template DiagonalIndexReturnType<Index>::Type
MatrixBase<Derived>::diagonal()
{
  return derived();
}


template<typename Derived>
template<int Index>
inline typename MatrixBase<Derived>::template ConstDiagonalIndexReturnType<Index>::Type
MatrixBase<Derived>::diagonal() const
{
  return derived();
}
# 310 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DiagonalProduct.h" 1
# 29 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DiagonalProduct.h"
namespace internal {
template<typename MatrixType, typename DiagonalType, int ProductOrder>
struct traits<DiagonalProduct<MatrixType, DiagonalType, ProductOrder> >
 : traits<MatrixType>
{
  typedef typename scalar_product_traits<typename MatrixType::Scalar, typename DiagonalType::Scalar>::ReturnType Scalar;
  enum {
    RowsAtCompileTime = MatrixType::RowsAtCompileTime,
    ColsAtCompileTime = MatrixType::ColsAtCompileTime,
    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,

    _StorageOrder = MatrixType::Flags & RowMajorBit ? RowMajor : ColMajor,
    _PacketOnDiag = !((int(_StorageOrder) == RowMajor && int(ProductOrder) == OnTheLeft)
                    ||(int(_StorageOrder) == ColMajor && int(ProductOrder) == OnTheRight)),
    _SameTypes = is_same<typename MatrixType::Scalar, typename DiagonalType::Scalar>::value,


    _Vectorizable = bool(int(MatrixType::Flags)&PacketAccessBit) && _SameTypes && ((!_PacketOnDiag) || (bool(int(DiagonalType::Flags)&PacketAccessBit))),

    Flags = (HereditaryBits & (unsigned int)(MatrixType::Flags)) | (_Vectorizable ? PacketAccessBit : 0),
    CoeffReadCost = NumTraits<Scalar>::MulCost + MatrixType::CoeffReadCost + DiagonalType::DiagonalVectorType::CoeffReadCost
  };
};
}

template<typename MatrixType, typename DiagonalType, int ProductOrder>
class DiagonalProduct : internal::no_assignment_operator,
                        public MatrixBase<DiagonalProduct<MatrixType, DiagonalType, ProductOrder> >
{
  public:

    typedef MatrixBase<DiagonalProduct> Base;
    typedef typename Eigen::internal::traits<DiagonalProduct>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<DiagonalProduct>::type Nested; typedef typename Eigen::internal::traits<DiagonalProduct>::StorageKind StorageKind; typedef typename Eigen::internal::traits<DiagonalProduct>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<DiagonalProduct>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<DiagonalProduct>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<DiagonalProduct>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<DiagonalProduct>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<DiagonalProduct>::Flags, CoeffReadCost = Eigen::internal::traits<DiagonalProduct>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived;

    inline DiagonalProduct(const MatrixType& matrix, const DiagonalType& diagonal)
      : m_matrix(matrix), m_diagonal(diagonal)
    {
      if( (!Eigen::internal::copy_bool(diagonal.diagonal().size() == (ProductOrder == OnTheLeft ? matrix.rows() : matrix.cols()))) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(diagonal.diagonal().size() == (ProductOrder == OnTheLeft ? matrix.rows() : matrix.cols()))) Eigen::internal::assert_fail("diagonal.diagonal().size() == (ProductOrder == OnTheLeft ? matrix.rows() : matrix.cols())", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/DiagonalProduct.h", 67); } while(false); else throw Eigen::eigen_assert_exception(); };
    }

    inline Index rows() const { return m_matrix.rows(); }
    inline Index cols() const { return m_matrix.cols(); }

    const Scalar coeff(Index row, Index col) const
    {
      return m_diagonal.diagonal().coeff(ProductOrder == OnTheLeft ? row : col) * m_matrix.coeff(row, col);
    }

    template<int LoadMode>
    inline PacketScalar packet(Index row, Index col) const
    {
      enum {
        StorageOrder = Flags & RowMajorBit ? RowMajor : ColMajor
      };
      const Index indexInDiagonalVector = ProductOrder == OnTheLeft ? row : col;

      return packet_impl<LoadMode>(row,col,indexInDiagonalVector,typename internal::conditional<
        ((int(StorageOrder) == RowMajor && int(ProductOrder) == OnTheLeft)
       ||(int(StorageOrder) == ColMajor && int(ProductOrder) == OnTheRight)), internal::true_type, internal::false_type>::type());
    }

  protected:
    template<int LoadMode>
    inline PacketScalar packet_impl(Index row, Index col, Index id, internal::true_type) const
    {
      return internal::pmul(m_matrix.template packet<LoadMode>(row, col),
                     internal::pset1<PacketScalar>(m_diagonal.diagonal().coeff(id)));
    }

    template<int LoadMode>
    inline PacketScalar packet_impl(Index row, Index col, Index id, internal::false_type) const
    {
      enum {
        InnerSize = (MatrixType::Flags & RowMajorBit) ? MatrixType::ColsAtCompileTime : MatrixType::RowsAtCompileTime,
        DiagonalVectorPacketLoadMode = (LoadMode == Aligned && ((InnerSize%16) == 0)) ? Aligned : Unaligned
      };
      return internal::pmul(m_matrix.template packet<LoadMode>(row, col),
                     m_diagonal.diagonal().template packet<DiagonalVectorPacketLoadMode>(id));
    }

    const typename MatrixType::Nested m_matrix;
    const typename DiagonalType::Nested m_diagonal;
};



template<typename Derived>
template<typename DiagonalDerived>
inline const DiagonalProduct<Derived, DiagonalDerived, OnTheRight>
MatrixBase<Derived>::operator*(const DiagonalBase<DiagonalDerived> &diagonal) const
{
  return DiagonalProduct<Derived, DiagonalDerived, OnTheRight>(derived(), diagonal.derived());
}



template<typename DiagonalDerived>
template<typename MatrixDerived>
inline const DiagonalProduct<MatrixDerived, DiagonalDerived, OnTheLeft>
DiagonalBase<DiagonalDerived>::operator*(const MatrixBase<MatrixDerived> &matrix) const
{
  return DiagonalProduct<MatrixDerived, DiagonalDerived, OnTheLeft>(matrix.derived(), derived());
}
# 311 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PermutationMatrix.h" 1
# 29 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PermutationMatrix.h"
template<int RowCol,typename IndicesType,typename MatrixType, typename StorageKind> class PermutedImpl;
# 55 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PermutationMatrix.h"
namespace internal {

template<typename PermutationType, typename MatrixType, int Side, bool Transposed=false>
struct permut_matrix_product_retval;
enum PermPermProduct_t {PermPermProduct};

}

template<typename Derived>
class PermutationBase : public EigenBase<Derived>
{
    typedef internal::traits<Derived> Traits;
    typedef EigenBase<Derived> Base;
  public:


    typedef typename Traits::IndicesType IndicesType;
    enum {
      Flags = Traits::Flags,
      CoeffReadCost = Traits::CoeffReadCost,
      RowsAtCompileTime = Traits::RowsAtCompileTime,
      ColsAtCompileTime = Traits::ColsAtCompileTime,
      MaxRowsAtCompileTime = Traits::MaxRowsAtCompileTime,
      MaxColsAtCompileTime = Traits::MaxColsAtCompileTime
    };
    typedef typename Traits::Scalar Scalar;
    typedef typename Traits::Index Index;
    typedef Matrix<Scalar,RowsAtCompileTime,ColsAtCompileTime,0,MaxRowsAtCompileTime,MaxColsAtCompileTime>
            DenseMatrixType;
    typedef PermutationMatrix<IndicesType::SizeAtCompileTime,IndicesType::MaxSizeAtCompileTime,Index>
            PlainPermutationType;
    using Base::derived;



    template<typename OtherDerived>
    Derived& operator=(const PermutationBase<OtherDerived>& other)
    {
      indices() = other.indices();
      return derived();
    }


    template<typename OtherDerived>
    Derived& operator=(const TranspositionsBase<OtherDerived>& tr)
    {
      setIdentity(tr.size());
      for(Index k=size()-1; k>=0; --k)
        applyTranspositionOnTheRight(k,tr.coeff(k));
      return derived();
    }





    Derived& operator=(const PermutationBase& other)
    {
      indices() = other.indices();
      return derived();
    }



    inline Index rows() const { return indices().size(); }


    inline Index cols() const { return indices().size(); }


    inline Index size() const { return indices().size(); }


    template<typename DenseDerived>
    void evalTo(MatrixBase<DenseDerived>& other) const
    {
      other.setZero();
      for (int i=0; i<rows();++i)
        other.coeffRef(indices().coeff(i),i) = typename DenseDerived::Scalar(1);
    }






    DenseMatrixType toDenseMatrix() const
    {
      return derived();
    }


    const IndicesType& indices() const { return derived().indices(); }

    IndicesType& indices() { return derived().indices(); }



    inline void resize(Index size)
    {
      indices().resize(size);
    }


    void setIdentity()
    {
      for(Index i = 0; i < size(); ++i)
        indices().coeffRef(i) = i;
    }



    void setIdentity(Index size)
    {
      resize(size);
      setIdentity();
    }
# 182 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PermutationMatrix.h"
    Derived& applyTranspositionOnTheLeft(Index i, Index j)
    {
      if( (!Eigen::internal::copy_bool(i>=0 && j>=0 && i<size() && j<size())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(i>=0 && j>=0 && i<size() && j<size())) Eigen::internal::assert_fail("i>=0 && j>=0 && i<size() && j<size()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PermutationMatrix.h", 184); } while(false); else throw Eigen::eigen_assert_exception(); };
      for(Index k = 0; k < size(); ++k)
      {
        if(indices().coeff(k) == i) indices().coeffRef(k) = j;
        else if(indices().coeff(k) == j) indices().coeffRef(k) = i;
      }
      return derived();
    }
# 201 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PermutationMatrix.h"
    Derived& applyTranspositionOnTheRight(Index i, Index j)
    {
      if( (!Eigen::internal::copy_bool(i>=0 && j>=0 && i<size() && j<size())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(i>=0 && j>=0 && i<size() && j<size())) Eigen::internal::assert_fail("i>=0 && j>=0 && i<size() && j<size()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PermutationMatrix.h", 203); } while(false); else throw Eigen::eigen_assert_exception(); };
      std::swap(indices().coeffRef(i), indices().coeffRef(j));
      return derived();
    }





    inline Transpose<PermutationBase> inverse() const
    { return derived(); }




    inline Transpose<PermutationBase> transpose() const
    { return derived(); }





  protected:
    template<typename OtherDerived>
    void assignTranspose(const PermutationBase<OtherDerived>& other)
    {
      for (int i=0; i<rows();++i) indices().coeffRef(other.indices().coeff(i)) = i;
    }
    template<typename Lhs,typename Rhs>
    void assignProduct(const Lhs& lhs, const Rhs& rhs)
    {
      if( (!Eigen::internal::copy_bool(lhs.cols() == rhs.rows())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(lhs.cols() == rhs.rows())) Eigen::internal::assert_fail("lhs.cols() == rhs.rows()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PermutationMatrix.h", 234); } while(false); else throw Eigen::eigen_assert_exception(); };
      for (int i=0; i<rows();++i) indices().coeffRef(i) = lhs.indices().coeff(rhs.indices().coeff(i));
    }


  public:





    template<typename Other>
    inline PlainPermutationType operator*(const PermutationBase<Other>& other) const
    { return PlainPermutationType(internal::PermPermProduct, derived(), other.derived()); }





    template<typename Other>
    inline PlainPermutationType operator*(const Transpose<PermutationBase<Other> >& other) const
    { return PlainPermutationType(internal::PermPermProduct, *this, other.eval()); }





    template<typename Other> friend
    inline PlainPermutationType operator*(const Transpose<PermutationBase<Other> >& other, const PermutationBase& perm)
    { return PlainPermutationType(internal::PermPermProduct, other.eval(), perm); }

  protected:

};
# 283 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PermutationMatrix.h"
namespace internal {
template<int SizeAtCompileTime, int MaxSizeAtCompileTime, typename IndexType>
struct traits<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType> >
 : traits<Matrix<IndexType,SizeAtCompileTime,SizeAtCompileTime,0,MaxSizeAtCompileTime,MaxSizeAtCompileTime> >
{
  typedef IndexType Index;
  typedef Matrix<IndexType, SizeAtCompileTime, 1, 0, MaxSizeAtCompileTime, 1> IndicesType;
};
}

template<int SizeAtCompileTime, int MaxSizeAtCompileTime, typename IndexType>
class PermutationMatrix : public PermutationBase<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType> >
{
    typedef PermutationBase<PermutationMatrix> Base;
    typedef internal::traits<PermutationMatrix> Traits;
  public:


    typedef typename Traits::IndicesType IndicesType;


    inline PermutationMatrix()
    {}



    inline PermutationMatrix(int size) : m_indices(size)
    {}


    template<typename OtherDerived>
    inline PermutationMatrix(const PermutationBase<OtherDerived>& other)
      : m_indices(other.indices()) {}




    inline PermutationMatrix(const PermutationMatrix& other) : m_indices(other.indices()) {}
# 330 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PermutationMatrix.h"
    template<typename Other>
    explicit inline PermutationMatrix(const MatrixBase<Other>& indices) : m_indices(indices)
    {}


    template<typename Other>
    explicit PermutationMatrix(const TranspositionsBase<Other>& tr)
      : m_indices(tr.size())
    {
      *this = tr;
    }


    template<typename Other>
    PermutationMatrix& operator=(const PermutationBase<Other>& other)
    {
      m_indices = other.indices();
      return *this;
    }


    template<typename Other>
    PermutationMatrix& operator=(const TranspositionsBase<Other>& tr)
    {
      return Base::operator=(tr.derived());
    }





    PermutationMatrix& operator=(const PermutationMatrix& other)
    {
      m_indices = other.m_indices;
      return *this;
    }



    const IndicesType& indices() const { return m_indices; }

    IndicesType& indices() { return m_indices; }





    template<typename Other>
    PermutationMatrix(const Transpose<PermutationBase<Other> >& other)
      : m_indices(other.nestedPermutation().size())
    {
      for (int i=0; i<m_indices.size();++i) m_indices.coeffRef(other.nestedPermutation().indices().coeff(i)) = i;
    }
    template<typename Lhs,typename Rhs>
    PermutationMatrix(internal::PermPermProduct_t, const Lhs& lhs, const Rhs& rhs)
      : m_indices(lhs.indices().size())
    {
      Base::assignProduct(lhs,rhs);
    }


  protected:

    IndicesType m_indices;
};


namespace internal {
template<int SizeAtCompileTime, int MaxSizeAtCompileTime, typename IndexType, int _PacketAccess>
struct traits<Map<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType>,_PacketAccess> >
 : traits<Matrix<IndexType,SizeAtCompileTime,SizeAtCompileTime,0,MaxSizeAtCompileTime,MaxSizeAtCompileTime> >
{
  typedef IndexType Index;
  typedef Map<const Matrix<IndexType, SizeAtCompileTime, 1, 0, MaxSizeAtCompileTime, 1>, _PacketAccess> IndicesType;
};
}

template<int SizeAtCompileTime, int MaxSizeAtCompileTime, typename IndexType, int _PacketAccess>
class Map<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType>,_PacketAccess>
  : public PermutationBase<Map<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType>,_PacketAccess> >
{
    typedef PermutationBase<Map> Base;
    typedef internal::traits<Map> Traits;
  public:


    typedef typename Traits::IndicesType IndicesType;
    typedef typename IndicesType::Scalar Index;


    inline Map(const Index* indices)
      : m_indices(indices)
    {}

    inline Map(const Index* indices, Index size)
      : m_indices(indices,size)
    {}


    template<typename Other>
    Map& operator=(const PermutationBase<Other>& other)
    { return Base::operator=(other.derived()); }


    template<typename Other>
    Map& operator=(const TranspositionsBase<Other>& tr)
    { return Base::operator=(tr.derived()); }





    Map& operator=(const Map& other)
    {
      m_indices = other.m_indices;
      return *this;
    }



    const IndicesType& indices() const { return m_indices; }

    IndicesType& indices() { return m_indices; }

  protected:

    IndicesType m_indices;
};
# 471 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/PermutationMatrix.h"
struct PermutationStorage {};

template<typename _IndicesType> class TranspositionsWrapper;
namespace internal {
template<typename _IndicesType>
struct traits<PermutationWrapper<_IndicesType> >
{
  typedef PermutationStorage StorageKind;
  typedef typename _IndicesType::Scalar Scalar;
  typedef typename _IndicesType::Scalar Index;
  typedef _IndicesType IndicesType;
  enum {
    RowsAtCompileTime = _IndicesType::SizeAtCompileTime,
    ColsAtCompileTime = _IndicesType::SizeAtCompileTime,
    MaxRowsAtCompileTime = IndicesType::MaxRowsAtCompileTime,
    MaxColsAtCompileTime = IndicesType::MaxColsAtCompileTime,
    Flags = 0,
    CoeffReadCost = _IndicesType::CoeffReadCost
  };
};
}

template<typename _IndicesType>
class PermutationWrapper : public PermutationBase<PermutationWrapper<_IndicesType> >
{
    typedef PermutationBase<PermutationWrapper> Base;
    typedef internal::traits<PermutationWrapper> Traits;
  public:


    typedef typename Traits::IndicesType IndicesType;


    inline PermutationWrapper(const IndicesType& indices)
      : m_indices(indices)
    {}


    const typename internal::remove_all<typename IndicesType::Nested>::type&
    indices() const { return m_indices; }

  protected:

    const typename IndicesType::Nested m_indices;
};



template<typename Derived, typename PermutationDerived>
inline const internal::permut_matrix_product_retval<PermutationDerived, Derived, OnTheRight>
operator*(const MatrixBase<Derived>& matrix,
          const PermutationBase<PermutationDerived> &permutation)
{
  return internal::permut_matrix_product_retval
           <PermutationDerived, Derived, OnTheRight>
           (permutation.derived(), matrix.derived());
}



template<typename Derived, typename PermutationDerived>
inline const internal::permut_matrix_product_retval
               <PermutationDerived, Derived, OnTheLeft>
operator*(const PermutationBase<PermutationDerived> &permutation,
          const MatrixBase<Derived>& matrix)
{
  return internal::permut_matrix_product_retval
           <PermutationDerived, Derived, OnTheLeft>
           (permutation.derived(), matrix.derived());
}

namespace internal {

template<typename PermutationType, typename MatrixType, int Side, bool Transposed>
struct traits<permut_matrix_product_retval<PermutationType, MatrixType, Side, Transposed> >
{
  typedef typename MatrixType::PlainObject ReturnType;
};

template<typename PermutationType, typename MatrixType, int Side, bool Transposed>
struct permut_matrix_product_retval
 : public ReturnByValue<permut_matrix_product_retval<PermutationType, MatrixType, Side, Transposed> >
{
    typedef typename remove_all<typename MatrixType::Nested>::type MatrixTypeNestedCleaned;

    permut_matrix_product_retval(const PermutationType& perm, const MatrixType& matrix)
      : m_permutation(perm), m_matrix(matrix)
    {}

    inline int rows() const { return m_matrix.rows(); }
    inline int cols() const { return m_matrix.cols(); }

    template<typename Dest> inline void evalTo(Dest& dst) const
    {
      const int n = Side==OnTheLeft ? rows() : cols();

      if(is_same<MatrixTypeNestedCleaned,Dest>::value && extract_data(dst) == extract_data(m_matrix))
      {

        Matrix<bool,PermutationType::RowsAtCompileTime,1,0,PermutationType::MaxRowsAtCompileTime> mask(m_permutation.size());
        mask.fill(false);
        int r = 0;
        while(r < m_permutation.size())
        {

          while(r<m_permutation.size() && mask[r]) r++;
          if(r>=m_permutation.size())
            break;

          int k0 = r++;
          int kPrev = k0;
          mask.coeffRef(k0) = true;
          for(int k=m_permutation.indices().coeff(k0); k!=k0; k=m_permutation.indices().coeff(k))
          {
                  Block<Dest, Side==OnTheLeft ? 1 : Dest::RowsAtCompileTime, Side==OnTheRight ? 1 : Dest::ColsAtCompileTime>(dst, k)
            .swap(Block<Dest, Side==OnTheLeft ? 1 : Dest::RowsAtCompileTime, Side==OnTheRight ? 1 : Dest::ColsAtCompileTime>
                       (dst,((Side==OnTheLeft) ^ Transposed) ? k0 : kPrev));

            mask.coeffRef(k) = true;
            kPrev = k;
          }
        }
      }
      else
      {
        for(int i = 0; i < n; ++i)
        {
          Block<Dest, Side==OnTheLeft ? 1 : Dest::RowsAtCompileTime, Side==OnTheRight ? 1 : Dest::ColsAtCompileTime>
               (dst, ((Side==OnTheLeft) ^ Transposed) ? m_permutation.indices().coeff(i) : i)

          =

          Block<const MatrixTypeNestedCleaned,Side==OnTheLeft ? 1 : MatrixType::RowsAtCompileTime,Side==OnTheRight ? 1 : MatrixType::ColsAtCompileTime>
               (m_matrix, ((Side==OnTheRight) ^ Transposed) ? m_permutation.indices().coeff(i) : i);
        }
      }
    }

  protected:
    const PermutationType& m_permutation;
    const typename MatrixType::Nested m_matrix;
};



template<typename Derived>
struct traits<Transpose<PermutationBase<Derived> > >
 : traits<Derived>
{};

}

template<typename Derived>
class Transpose<PermutationBase<Derived> >
  : public EigenBase<Transpose<PermutationBase<Derived> > >
{
    typedef Derived PermutationType;
    typedef typename PermutationType::IndicesType IndicesType;
    typedef typename PermutationType::PlainPermutationType PlainPermutationType;
  public:


    typedef internal::traits<PermutationType> Traits;
    typedef typename Derived::DenseMatrixType DenseMatrixType;
    enum {
      Flags = Traits::Flags,
      CoeffReadCost = Traits::CoeffReadCost,
      RowsAtCompileTime = Traits::RowsAtCompileTime,
      ColsAtCompileTime = Traits::ColsAtCompileTime,
      MaxRowsAtCompileTime = Traits::MaxRowsAtCompileTime,
      MaxColsAtCompileTime = Traits::MaxColsAtCompileTime
    };
    typedef typename Traits::Scalar Scalar;


    Transpose(const PermutationType& p) : m_permutation(p) {}

    inline int rows() const { return m_permutation.rows(); }
    inline int cols() const { return m_permutation.cols(); }


    template<typename DenseDerived>
    void evalTo(MatrixBase<DenseDerived>& other) const
    {
      other.setZero();
      for (int i=0; i<rows();++i)
        other.coeffRef(i, m_permutation.indices().coeff(i)) = typename DenseDerived::Scalar(1);
    }



    PlainPermutationType eval() const { return *this; }

    DenseMatrixType toDenseMatrix() const { return *this; }



    template<typename OtherDerived> friend
    inline const internal::permut_matrix_product_retval<PermutationType, OtherDerived, OnTheRight, true>
    operator*(const MatrixBase<OtherDerived>& matrix, const Transpose& trPerm)
    {
      return internal::permut_matrix_product_retval<PermutationType, OtherDerived, OnTheRight, true>(trPerm.m_permutation, matrix.derived());
    }



    template<typename OtherDerived>
    inline const internal::permut_matrix_product_retval<PermutationType, OtherDerived, OnTheLeft, true>
    operator*(const MatrixBase<OtherDerived>& matrix) const
    {
      return internal::permut_matrix_product_retval<PermutationType, OtherDerived, OnTheLeft, true>(m_permutation, matrix.derived());
    }

    const PermutationType& nestedPermutation() const { return m_permutation; }

  protected:
    const PermutationType& m_permutation;
};

template<typename Derived>
const PermutationWrapper<const Derived> MatrixBase<Derived>::asPermutation() const
{
  return derived();
}
# 312 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Transpositions.h" 1
# 57 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Transpositions.h"
namespace internal {
template<typename TranspositionType, typename MatrixType, int Side, bool Transposed=false> struct transposition_matrix_product_retval;
}

template<typename Derived>
class TranspositionsBase
{
    typedef internal::traits<Derived> Traits;

  public:

    typedef typename Traits::IndicesType IndicesType;
    typedef typename IndicesType::Scalar Index;

    Derived& derived() { return *static_cast<Derived*>(this); }
    const Derived& derived() const { return *static_cast<const Derived*>(this); }


    template<typename OtherDerived>
    Derived& operator=(const TranspositionsBase<OtherDerived>& other)
    {
      indices() = other.indices();
      return derived();
    }





    Derived& operator=(const TranspositionsBase& other)
    {
      indices() = other.indices();
      return derived();
    }



    inline Index size() const { return indices().size(); }


    inline const Index& coeff(Index i) const { return indices().coeff(i); }

    inline Index& coeffRef(Index i) { return indices().coeffRef(i); }

    inline const Index& operator()(Index i) const { return indices()(i); }

    inline Index& operator()(Index i) { return indices()(i); }

    inline const Index& operator[](Index i) const { return indices()(i); }

    inline Index& operator[](Index i) { return indices()(i); }


    const IndicesType& indices() const { return derived().indices(); }

    IndicesType& indices() { return derived().indices(); }


    inline void resize(int size)
    {
      indices().resize(size);
    }


    void setIdentity()
    {
      for(int i = 0; i < indices().size(); ++i)
        coeffRef(i) = i;
    }
# 149 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Transpositions.h"
    inline Transpose<TranspositionsBase> inverse() const
    { return Transpose<TranspositionsBase>(derived()); }


    inline Transpose<TranspositionsBase> transpose() const
    { return Transpose<TranspositionsBase>(derived()); }

  protected:
};

namespace internal {
template<int SizeAtCompileTime, int MaxSizeAtCompileTime, typename IndexType>
struct traits<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType> >
{
  typedef IndexType Index;
  typedef Matrix<Index, SizeAtCompileTime, 1, 0, MaxSizeAtCompileTime, 1> IndicesType;
};
}

template<int SizeAtCompileTime, int MaxSizeAtCompileTime, typename IndexType>
class Transpositions : public TranspositionsBase<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType> >
{
    typedef internal::traits<Transpositions> Traits;
  public:

    typedef TranspositionsBase<Transpositions> Base;
    typedef typename Traits::IndicesType IndicesType;
    typedef typename IndicesType::Scalar Index;

    inline Transpositions() {}


    template<typename OtherDerived>
    inline Transpositions(const TranspositionsBase<OtherDerived>& other)
      : m_indices(other.indices()) {}




    inline Transpositions(const Transpositions& other) : m_indices(other.indices()) {}



    template<typename Other>
    explicit inline Transpositions(const MatrixBase<Other>& indices) : m_indices(indices)
    {}


    template<typename OtherDerived>
    Transpositions& operator=(const TranspositionsBase<OtherDerived>& other)
    {
      return Base::operator=(other);
    }





    Transpositions& operator=(const Transpositions& other)
    {
      m_indices = other.m_indices;
      return *this;
    }




    inline Transpositions(Index size) : m_indices(size)
    {}


    const IndicesType& indices() const { return m_indices; }

    IndicesType& indices() { return m_indices; }

  protected:

    IndicesType m_indices;
};


namespace internal {
template<int SizeAtCompileTime, int MaxSizeAtCompileTime, typename IndexType, int _PacketAccess>
struct traits<Map<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType>,_PacketAccess> >
{
  typedef IndexType Index;
  typedef Map<const Matrix<Index,SizeAtCompileTime,1,0,MaxSizeAtCompileTime,1>, _PacketAccess> IndicesType;
};
}

template<int SizeAtCompileTime, int MaxSizeAtCompileTime, typename IndexType, int PacketAccess>
class Map<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType>,PacketAccess>
 : public TranspositionsBase<Map<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType>,PacketAccess> >
{
    typedef internal::traits<Map> Traits;
  public:

    typedef TranspositionsBase<Map> Base;
    typedef typename Traits::IndicesType IndicesType;
    typedef typename IndicesType::Scalar Index;

    inline Map(const Index* indices)
      : m_indices(indices)
    {}

    inline Map(const Index* indices, Index size)
      : m_indices(indices,size)
    {}


    template<typename OtherDerived>
    Map& operator=(const TranspositionsBase<OtherDerived>& other)
    {
      return Base::operator=(other);
    }





    Map& operator=(const Map& other)
    {
      m_indices = other.m_indices;
      return *this;
    }



    const IndicesType& indices() const { return m_indices; }


    IndicesType& indices() { return m_indices; }

  protected:

    IndicesType m_indices;
};

namespace internal {
template<typename _IndicesType>
struct traits<TranspositionsWrapper<_IndicesType> >
{
  typedef typename _IndicesType::Scalar Index;
  typedef _IndicesType IndicesType;
};
}

template<typename _IndicesType>
class TranspositionsWrapper
 : public TranspositionsBase<TranspositionsWrapper<_IndicesType> >
{
    typedef internal::traits<TranspositionsWrapper> Traits;
  public:

    typedef TranspositionsBase<TranspositionsWrapper> Base;
    typedef typename Traits::IndicesType IndicesType;
    typedef typename IndicesType::Scalar Index;

    inline TranspositionsWrapper(IndicesType& indices)
      : m_indices(indices)
    {}


    template<typename OtherDerived>
    TranspositionsWrapper& operator=(const TranspositionsBase<OtherDerived>& other)
    {
      return Base::operator=(other);
    }





    TranspositionsWrapper& operator=(const TranspositionsWrapper& other)
    {
      m_indices = other.m_indices;
      return *this;
    }



    const IndicesType& indices() const { return m_indices; }


    IndicesType& indices() { return m_indices; }

  protected:

    const typename IndicesType::Nested m_indices;
};



template<typename Derived, typename TranspositionsDerived>
inline const internal::transposition_matrix_product_retval<TranspositionsDerived, Derived, OnTheRight>
operator*(const MatrixBase<Derived>& matrix,
          const TranspositionsBase<TranspositionsDerived> &transpositions)
{
  return internal::transposition_matrix_product_retval
           <TranspositionsDerived, Derived, OnTheRight>
           (transpositions.derived(), matrix.derived());
}



template<typename Derived, typename TranspositionDerived>
inline const internal::transposition_matrix_product_retval
               <TranspositionDerived, Derived, OnTheLeft>
operator*(const TranspositionsBase<TranspositionDerived> &transpositions,
          const MatrixBase<Derived>& matrix)
{
  return internal::transposition_matrix_product_retval
           <TranspositionDerived, Derived, OnTheLeft>
           (transpositions.derived(), matrix.derived());
}

namespace internal {

template<typename TranspositionType, typename MatrixType, int Side, bool Transposed>
struct traits<transposition_matrix_product_retval<TranspositionType, MatrixType, Side, Transposed> >
{
  typedef typename MatrixType::PlainObject ReturnType;
};

template<typename TranspositionType, typename MatrixType, int Side, bool Transposed>
struct transposition_matrix_product_retval
 : public ReturnByValue<transposition_matrix_product_retval<TranspositionType, MatrixType, Side, Transposed> >
{
    typedef typename remove_all<typename MatrixType::Nested>::type MatrixTypeNestedCleaned;
    typedef typename TranspositionType::Index Index;

    transposition_matrix_product_retval(const TranspositionType& tr, const MatrixType& matrix)
      : m_transpositions(tr), m_matrix(matrix)
    {}

    inline int rows() const { return m_matrix.rows(); }
    inline int cols() const { return m_matrix.cols(); }

    template<typename Dest> inline void evalTo(Dest& dst) const
    {
      const int size = m_transpositions.size();
      Index j = 0;

      if(!(is_same<MatrixTypeNestedCleaned,Dest>::value && extract_data(dst) == extract_data(m_matrix)))
        dst = m_matrix;

      for(int k=(Transposed?size-1:0) ; Transposed?k>=0:k<size ; Transposed?--k:++k)
        if((j=m_transpositions.coeff(k))!=k)
        {
          if(Side==OnTheLeft)
            dst.row(k).swap(dst.row(j));
          else if(Side==OnTheRight)
            dst.col(k).swap(dst.col(j));
        }
    }

  protected:
    const TranspositionType& m_transpositions;
    const typename MatrixType::Nested m_matrix;
};

}



template<typename TranspositionsDerived>
class Transpose<TranspositionsBase<TranspositionsDerived> >
{
    typedef TranspositionsDerived TranspositionType;
    typedef typename TranspositionType::IndicesType IndicesType;
  public:

    Transpose(const TranspositionType& t) : m_transpositions(t) {}

    inline int size() const { return m_transpositions.size(); }



    template<typename Derived> friend
    inline const internal::transposition_matrix_product_retval<TranspositionType, Derived, OnTheRight, true>
    operator*(const MatrixBase<Derived>& matrix, const Transpose& trt)
    {
      return internal::transposition_matrix_product_retval<TranspositionType, Derived, OnTheRight, true>(trt.m_transpositions, matrix.derived());
    }



    template<typename Derived>
    inline const internal::transposition_matrix_product_retval<TranspositionType, Derived, OnTheLeft, true>
    operator*(const MatrixBase<Derived>& matrix) const
    {
      return internal::transposition_matrix_product_retval<TranspositionType, Derived, OnTheLeft, true>(m_transpositions, matrix.derived());
    }

  protected:
    const TranspositionType& m_transpositions;
};
# 313 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Redux.h" 1
# 29 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Redux.h"
namespace internal {
# 39 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Redux.h"
template<typename Func, typename Derived>
struct redux_traits
{
public:
  enum {
    PacketSize = packet_traits<typename Derived::Scalar>::size,
    InnerMaxSize = int(Derived::IsRowMajor)
                 ? Derived::MaxColsAtCompileTime
                 : Derived::MaxRowsAtCompileTime
  };

  enum {
    MightVectorize = (int(Derived::Flags)&ActualPacketAccessBit)
                  && (functor_traits<Func>::PacketAccess),
    MayLinearVectorize = MightVectorize && (int(Derived::Flags)&LinearAccessBit),
    MaySliceVectorize = MightVectorize && int(InnerMaxSize)>=3*PacketSize
  };

public:
  enum {
    Traversal = int(MayLinearVectorize) ? int(LinearVectorizedTraversal)
              : int(MaySliceVectorize) ? int(SliceVectorizedTraversal)
                                        : int(DefaultTraversal)
  };

public:
  enum {
    Cost = ( Derived::SizeAtCompileTime == Dynamic
           || Derived::CoeffReadCost == Dynamic
           || (Derived::SizeAtCompileTime!=1 && functor_traits<Func>::Cost == Dynamic)
           ) ? Dynamic
           : Derived::SizeAtCompileTime * Derived::CoeffReadCost
               + (Derived::SizeAtCompileTime-1) * functor_traits<Func>::Cost,
    UnrollingLimit = 100 * (int(Traversal) == int(DefaultTraversal) ? 1 : int(PacketSize))
  };

public:
  enum {
    Unrolling = Cost != Dynamic && Cost <= UnrollingLimit
              ? CompleteUnrolling
              : NoUnrolling
  };
};







template<typename Func, typename Derived, int Start, int Length>
struct redux_novec_unroller
{
  enum {
    HalfLength = Length/2
  };

  typedef typename Derived::Scalar Scalar;

  inline static Scalar run(const Derived &mat, const Func& func)
  {
    return func(redux_novec_unroller<Func, Derived, Start, HalfLength>::run(mat,func),
                redux_novec_unroller<Func, Derived, Start+HalfLength, Length-HalfLength>::run(mat,func));
  }
};

template<typename Func, typename Derived, int Start>
struct redux_novec_unroller<Func, Derived, Start, 1>
{
  enum {
    outer = Start / Derived::InnerSizeAtCompileTime,
    inner = Start % Derived::InnerSizeAtCompileTime
  };

  typedef typename Derived::Scalar Scalar;

  inline static Scalar run(const Derived &mat, const Func&)
  {
    return mat.coeffByOuterInner(outer, inner);
  }
};




template<typename Func, typename Derived, int Start>
struct redux_novec_unroller<Func, Derived, Start, 0>
{
  typedef typename Derived::Scalar Scalar;
  inline static Scalar run(const Derived&, const Func&) { return Scalar(); }
};



template<typename Func, typename Derived, int Start, int Length>
struct redux_vec_unroller
{
  enum {
    PacketSize = packet_traits<typename Derived::Scalar>::size,
    HalfLength = Length/2
  };

  typedef typename Derived::Scalar Scalar;
  typedef typename packet_traits<Scalar>::type PacketScalar;

  inline static PacketScalar run(const Derived &mat, const Func& func)
  {
    return func.packetOp(
            redux_vec_unroller<Func, Derived, Start, HalfLength>::run(mat,func),
            redux_vec_unroller<Func, Derived, Start+HalfLength, Length-HalfLength>::run(mat,func) );
  }
};

template<typename Func, typename Derived, int Start>
struct redux_vec_unroller<Func, Derived, Start, 1>
{
  enum {
    index = Start * packet_traits<typename Derived::Scalar>::size,
    outer = index / int(Derived::InnerSizeAtCompileTime),
    inner = index % int(Derived::InnerSizeAtCompileTime),
    alignment = (Derived::Flags & AlignedBit) ? Aligned : Unaligned
  };

  typedef typename Derived::Scalar Scalar;
  typedef typename packet_traits<Scalar>::type PacketScalar;

  inline static PacketScalar run(const Derived &mat, const Func&)
  {
    return mat.template packetByOuterInner<alignment>(outer, inner);
  }
};





template<typename Func, typename Derived,
         int Traversal = redux_traits<Func, Derived>::Traversal,
         int Unrolling = redux_traits<Func, Derived>::Unrolling
>
struct redux_impl;

template<typename Func, typename Derived>
struct redux_impl<Func, Derived, DefaultTraversal, NoUnrolling>
{
  typedef typename Derived::Scalar Scalar;
  typedef typename Derived::Index Index;
  static inline Scalar run(const Derived& mat, const Func& func)
  {
    if( (!Eigen::internal::copy_bool(mat.rows()>0 && mat.cols()>0 && "you are using an empty matrix")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(mat.rows()>0 && mat.cols()>0 && "you are using an empty matrix")) Eigen::internal::assert_fail("mat.rows()>0 && mat.cols()>0 && \"you are using an empty matrix\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Redux.h", 188); } while(false); else throw Eigen::eigen_assert_exception(); };
    Scalar res;
    res = mat.coeffByOuterInner(0, 0);
    for(Index i = 1; i < mat.innerSize(); ++i)
      res = func(res, mat.coeffByOuterInner(0, i));
    for(Index i = 1; i < mat.outerSize(); ++i)
      for(Index j = 0; j < mat.innerSize(); ++j)
        res = func(res, mat.coeffByOuterInner(i, j));
    return res;
  }
};

template<typename Func, typename Derived>
struct redux_impl<Func,Derived, DefaultTraversal, CompleteUnrolling>
  : public redux_novec_unroller<Func,Derived, 0, Derived::SizeAtCompileTime>
{};

template<typename Func, typename Derived>
struct redux_impl<Func, Derived, LinearVectorizedTraversal, NoUnrolling>
{
  typedef typename Derived::Scalar Scalar;
  typedef typename packet_traits<Scalar>::type PacketScalar;
  typedef typename Derived::Index Index;

  static Scalar run(const Derived& mat, const Func& func)
  {
    const Index size = mat.size();
    if( (!Eigen::internal::copy_bool(size && "you are using an empty matrix")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(size && "you are using an empty matrix")) Eigen::internal::assert_fail("size && \"you are using an empty matrix\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Redux.h", 215); } while(false); else throw Eigen::eigen_assert_exception(); };
    const Index packetSize = packet_traits<Scalar>::size;
    const Index alignedStart = first_aligned(mat);
    enum {
      alignment = bool(Derived::Flags & DirectAccessBit) || bool(Derived::Flags & AlignedBit)
                ? Aligned : Unaligned
    };
    const Index alignedSize = ((size-alignedStart)/packetSize)*packetSize;
    const Index alignedEnd = alignedStart + alignedSize;
    Scalar res;
    if(alignedSize)
    {
      PacketScalar packet_res = mat.template packet<alignment>(alignedStart);
      for(Index index = alignedStart + packetSize; index < alignedEnd; index += packetSize)
        packet_res = func.packetOp(packet_res, mat.template packet<alignment>(index));
      res = func.predux(packet_res);

      for(Index index = 0; index < alignedStart; ++index)
        res = func(res,mat.coeff(index));

      for(Index index = alignedEnd; index < size; ++index)
        res = func(res,mat.coeff(index));
    }
    else

    {
      res = mat.coeff(0);
      for(Index index = 1; index < size; ++index)
        res = func(res,mat.coeff(index));
    }

    return res;
  }
};

template<typename Func, typename Derived>
struct redux_impl<Func, Derived, SliceVectorizedTraversal, NoUnrolling>
{
  typedef typename Derived::Scalar Scalar;
  typedef typename packet_traits<Scalar>::type PacketScalar;
  typedef typename Derived::Index Index;

  static Scalar run(const Derived& mat, const Func& func)
  {
    if( (!Eigen::internal::copy_bool(mat.rows()>0 && mat.cols()>0 && "you are using an empty matrix")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(mat.rows()>0 && mat.cols()>0 && "you are using an empty matrix")) Eigen::internal::assert_fail("mat.rows()>0 && mat.cols()>0 && \"you are using an empty matrix\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Redux.h", 259); } while(false); else throw Eigen::eigen_assert_exception(); };
    const Index innerSize = mat.innerSize();
    const Index outerSize = mat.outerSize();
    enum {
      packetSize = packet_traits<Scalar>::size
    };
    const Index packetedInnerSize = ((innerSize)/packetSize)*packetSize;
    Scalar res;
    if(packetedInnerSize)
    {
      PacketScalar packet_res = mat.template packet<Unaligned>(0,0);
      for(Index j=0; j<outerSize; ++j)
        for(Index i=(j==0?packetSize:0); i<packetedInnerSize; i+=Index(packetSize))
          packet_res = func.packetOp(packet_res, mat.template packetByOuterInner<Unaligned>(j,i));

      res = func.predux(packet_res);
      for(Index j=0; j<outerSize; ++j)
        for(Index i=packetedInnerSize; i<innerSize; ++i)
          res = func(res, mat.coeffByOuterInner(j,i));
    }
    else

    {
      res = redux_impl<Func, Derived, DefaultTraversal, NoUnrolling>::run(mat, func);
    }

    return res;
  }
};

template<typename Func, typename Derived>
struct redux_impl<Func, Derived, LinearVectorizedTraversal, CompleteUnrolling>
{
  typedef typename Derived::Scalar Scalar;
  typedef typename packet_traits<Scalar>::type PacketScalar;
  enum {
    PacketSize = packet_traits<Scalar>::size,
    Size = Derived::SizeAtCompileTime,
    VectorizedSize = (Size / PacketSize) * PacketSize
  };
  inline static Scalar run(const Derived& mat, const Func& func)
  {
    if( (!Eigen::internal::copy_bool(mat.rows()>0 && mat.cols()>0 && "you are using an empty matrix")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(mat.rows()>0 && mat.cols()>0 && "you are using an empty matrix")) Eigen::internal::assert_fail("mat.rows()>0 && mat.cols()>0 && \"you are using an empty matrix\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Redux.h", 301); } while(false); else throw Eigen::eigen_assert_exception(); };
    Scalar res = func.predux(redux_vec_unroller<Func, Derived, 0, Size / PacketSize>::run(mat,func));
    if (VectorizedSize != Size)
      res = func(res,redux_novec_unroller<Func, Derived, VectorizedSize, Size-VectorizedSize>::run(mat,func));
    return res;
  }
};

}
# 323 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Redux.h"
template<typename Derived>
template<typename Func>
inline typename internal::result_of<Func(typename internal::traits<Derived>::Scalar)>::type
DenseBase<Derived>::redux(const Func& func) const
{
  typedef typename internal::remove_all<typename Derived::Nested>::type ThisNested;
  return internal::redux_impl<Func, ThisNested>
            ::run(derived(), func);
}



template<typename Derived>
inline typename internal::traits<Derived>::Scalar
DenseBase<Derived>::minCoeff() const
{
  return this->redux(Eigen::internal::scalar_min_op<Scalar>());
}



template<typename Derived>
inline typename internal::traits<Derived>::Scalar
DenseBase<Derived>::maxCoeff() const
{
  return this->redux(Eigen::internal::scalar_max_op<Scalar>());
}





template<typename Derived>
inline typename internal::traits<Derived>::Scalar
DenseBase<Derived>::sum() const
{
  if(SizeAtCompileTime==0 || (SizeAtCompileTime==Dynamic && size()==0))
    return Scalar(0);
  return this->redux(Eigen::internal::scalar_sum_op<Scalar>());
}





template<typename Derived>
inline typename internal::traits<Derived>::Scalar
DenseBase<Derived>::mean() const
{
  return Scalar(this->redux(Eigen::internal::scalar_sum_op<Scalar>())) / Scalar(this->size());
}
# 382 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Redux.h"
template<typename Derived>
inline typename internal::traits<Derived>::Scalar
DenseBase<Derived>::prod() const
{
  if(SizeAtCompileTime==0 || (SizeAtCompileTime==Dynamic && size()==0))
    return Scalar(1);
  return this->redux(Eigen::internal::scalar_product_op<Scalar>());
}







template<typename Derived>
inline typename internal::traits<Derived>::Scalar
MatrixBase<Derived>::trace() const
{
  return derived().diagonal().sum();
}
# 314 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Visitor.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Visitor.h"
namespace internal {

template<typename Visitor, typename Derived, int UnrollCount>
struct visitor_impl
{
  enum {
    col = (UnrollCount-1) / Derived::RowsAtCompileTime,
    row = (UnrollCount-1) % Derived::RowsAtCompileTime
  };

  inline static void run(const Derived &mat, Visitor& visitor)
  {
    visitor_impl<Visitor, Derived, UnrollCount-1>::run(mat, visitor);
    visitor(mat.coeff(row, col), row, col);
  }
};

template<typename Visitor, typename Derived>
struct visitor_impl<Visitor, Derived, 1>
{
  inline static void run(const Derived &mat, Visitor& visitor)
  {
    return visitor.init(mat.coeff(0, 0), 0, 0);
  }
};

template<typename Visitor, typename Derived>
struct visitor_impl<Visitor, Derived, Dynamic>
{
  typedef typename Derived::Index Index;
  inline static void run(const Derived& mat, Visitor& visitor)
  {
    visitor.init(mat.coeff(0,0), 0, 0);
    for(Index i = 1; i < mat.rows(); ++i)
      visitor(mat.coeff(i, 0), i, 0);
    for(Index j = 1; j < mat.cols(); ++j)
      for(Index i = 0; i < mat.rows(); ++i)
        visitor(mat.coeff(i, j), i, j);
  }
};

}
# 88 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Visitor.h"
template<typename Derived>
template<typename Visitor>
void DenseBase<Derived>::visit(Visitor& visitor) const
{
  enum { unroll = SizeAtCompileTime != Dynamic
                   && CoeffReadCost != Dynamic
                   && (SizeAtCompileTime == 1 || internal::functor_traits<Visitor>::Cost != Dynamic)
                   && SizeAtCompileTime * CoeffReadCost + (SizeAtCompileTime-1) * internal::functor_traits<Visitor>::Cost
                      <= 100 };
  return internal::visitor_impl<Visitor, Derived,
      unroll ? int(SizeAtCompileTime) : Dynamic
    >::run(derived(), visitor);
}

namespace internal {




template <typename Derived>
struct coeff_visitor
{
  typedef typename Derived::Index Index;
  typedef typename Derived::Scalar Scalar;
  Index row, col;
  Scalar res;
  inline void init(const Scalar& value, Index i, Index j)
  {
    res = value;
    row = i;
    col = j;
  }
};






template <typename Derived>
struct min_coeff_visitor : coeff_visitor<Derived>
{
  typedef typename Derived::Index Index;
  typedef typename Derived::Scalar Scalar;
  void operator() (const Scalar& value, Index i, Index j)
  {
    if(value < this->res)
    {
      this->res = value;
      this->row = i;
      this->col = j;
    }
  }
};

template<typename Scalar>
struct functor_traits<min_coeff_visitor<Scalar> > {
  enum {
    Cost = NumTraits<Scalar>::AddCost
  };
};






template <typename Derived>
struct max_coeff_visitor : coeff_visitor<Derived>
{
  typedef typename Derived::Index Index;
  typedef typename Derived::Scalar Scalar;
  void operator() (const Scalar& value, Index i, Index j)
  {
    if(value > this->res)
    {
      this->res = value;
      this->row = i;
      this->col = j;
    }
  }
};

template<typename Scalar>
struct functor_traits<max_coeff_visitor<Scalar> > {
  enum {
    Cost = NumTraits<Scalar>::AddCost
  };
};

}






template<typename Derived>
template<typename IndexType>
typename internal::traits<Derived>::Scalar
DenseBase<Derived>::minCoeff(IndexType* row, IndexType* col) const
{
  internal::min_coeff_visitor<Derived> minVisitor;
  this->visit(minVisitor);
  *row = minVisitor.row;
  if (col) *col = minVisitor.col;
  return minVisitor.res;
}






template<typename Derived>
template<typename IndexType>
typename internal::traits<Derived>::Scalar
DenseBase<Derived>::minCoeff(IndexType* index) const
{
  if (Eigen::internal::static_assertion<bool(Derived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
  internal::min_coeff_visitor<Derived> minVisitor;
  this->visit(minVisitor);
  *index = (RowsAtCompileTime==1) ? minVisitor.col : minVisitor.row;
  return minVisitor.res;
}






template<typename Derived>
template<typename IndexType>
typename internal::traits<Derived>::Scalar
DenseBase<Derived>::maxCoeff(IndexType* row, IndexType* col) const
{
  internal::max_coeff_visitor<Derived> maxVisitor;
  this->visit(maxVisitor);
  *row = maxVisitor.row;
  if (col) *col = maxVisitor.col;
  return maxVisitor.res;
}






template<typename Derived>
template<typename IndexType>
typename internal::traits<Derived>::Scalar
DenseBase<Derived>::maxCoeff(IndexType* index) const
{
  if (Eigen::internal::static_assertion<bool(Derived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
  internal::max_coeff_visitor<Derived> maxVisitor;
  this->visit(maxVisitor);
  *index = (RowsAtCompileTime==1) ? maxVisitor.col : maxVisitor.row;
  return maxVisitor.res;
}
# 315 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Fuzzy.h" 1
# 29 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Fuzzy.h"
namespace internal
{

template<typename Derived, typename OtherDerived, bool is_integer = NumTraits<typename Derived::Scalar>::IsInteger>
struct isApprox_selector
{
  static bool run(const Derived& x, const OtherDerived& y, typename Derived::RealScalar prec)
  {
    using std::min;
    const typename internal::nested<Derived,2>::type nested(x);
    const typename internal::nested<OtherDerived,2>::type otherNested(y);
    return (nested - otherNested).cwiseAbs2().sum() <= prec * prec * (min)(nested.cwiseAbs2().sum(), otherNested.cwiseAbs2().sum());
  }
};

template<typename Derived, typename OtherDerived>
struct isApprox_selector<Derived, OtherDerived, true>
{
  static bool run(const Derived& x, const OtherDerived& y, typename Derived::RealScalar)
  {
    return x.matrix() == y.matrix();
  }
};

template<typename Derived, typename OtherDerived, bool is_integer = NumTraits<typename Derived::Scalar>::IsInteger>
struct isMuchSmallerThan_object_selector
{
  static bool run(const Derived& x, const OtherDerived& y, typename Derived::RealScalar prec)
  {
    return x.cwiseAbs2().sum() <= abs2(prec) * y.cwiseAbs2().sum();
  }
};

template<typename Derived, typename OtherDerived>
struct isMuchSmallerThan_object_selector<Derived, OtherDerived, true>
{
  static bool run(const Derived& x, const OtherDerived&, typename Derived::RealScalar)
  {
    return x.matrix() == Derived::Zero(x.rows(), x.cols()).matrix();
  }
};

template<typename Derived, bool is_integer = NumTraits<typename Derived::Scalar>::IsInteger>
struct isMuchSmallerThan_scalar_selector
{
  static bool run(const Derived& x, const typename Derived::RealScalar& y, typename Derived::RealScalar prec)
  {
    return x.cwiseAbs2().sum() <= abs2(prec * y);
  }
};

template<typename Derived>
struct isMuchSmallerThan_scalar_selector<Derived, true>
{
  static bool run(const Derived& x, const typename Derived::RealScalar&, typename Derived::RealScalar)
  {
    return x.matrix() == Derived::Zero(x.rows(), x.cols()).matrix();
  }
};

}
# 109 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Fuzzy.h"
template<typename Derived>
template<typename OtherDerived>
bool DenseBase<Derived>::isApprox(
  const DenseBase<OtherDerived>& other,
  RealScalar prec
) const
{
  return internal::isApprox_selector<Derived, OtherDerived>::run(derived(), other.derived(), prec);
}
# 132 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Fuzzy.h"
template<typename Derived>
bool DenseBase<Derived>::isMuchSmallerThan(
  const typename NumTraits<Scalar>::Real& other,
  RealScalar prec
) const
{
  return internal::isMuchSmallerThan_scalar_selector<Derived>::run(derived(), other, prec);
}
# 151 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Fuzzy.h"
template<typename Derived>
template<typename OtherDerived>
bool DenseBase<Derived>::isMuchSmallerThan(
  const DenseBase<OtherDerived>& other,
  RealScalar prec
) const
{
  return internal::isMuchSmallerThan_object_selector<Derived, OtherDerived>::run(derived(), other.derived(), prec);
}
# 316 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/IO.h" 1
# 29 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/IO.h"
enum { DontAlignCols = 1 };
enum { StreamPrecision = -1,
       FullPrecision = -2 };

namespace internal {
template<typename Derived>
std::ostream & print_matrix(std::ostream & s, const Derived& _m, const IOFormat& fmt);
}
# 63 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/IO.h"
struct IOFormat
{

  IOFormat(int _precision = StreamPrecision, int _flags = 0,
    const std::string& _coeffSeparator = " ",
    const std::string& _rowSeparator = "\n", const std::string& _rowPrefix="", const std::string& _rowSuffix="",
    const std::string& _matPrefix="", const std::string& _matSuffix="")
  : matPrefix(_matPrefix), matSuffix(_matSuffix), rowPrefix(_rowPrefix), rowSuffix(_rowSuffix), rowSeparator(_rowSeparator),
    coeffSeparator(_coeffSeparator), precision(_precision), flags(_flags)
  {
    rowSpacer = "";
    int i = int(matSuffix.length())-1;
    while (i>=0 && matSuffix[i]!='\n')
    {
      rowSpacer += ' ';
      i--;
    }
  }
  std::string matPrefix, matSuffix;
  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;
  std::string coeffSeparator;
  int precision;
  int flags;
};
# 103 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/IO.h"
template<typename ExpressionType>
class WithFormat
{
  public:

    WithFormat(const ExpressionType& matrix, const IOFormat& format)
      : m_matrix(matrix), m_format(format)
    {}

    friend std::ostream & operator << (std::ostream & s, const WithFormat& wf)
    {
      return internal::print_matrix(s, wf.m_matrix.eval(), wf.m_format);
    }

  protected:
    const typename ExpressionType::Nested m_matrix;
    IOFormat m_format;
};
# 129 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/IO.h"
template<typename Derived>
inline const WithFormat<Derived>
DenseBase<Derived>::format(const IOFormat& fmt) const
{
  return WithFormat<Derived>(derived(), fmt);
}

namespace internal {

template<typename Scalar, bool IsInteger>
struct significant_decimals_default_impl
{
  typedef typename NumTraits<Scalar>::Real RealScalar;
  static inline int run()
  {
    using std::ceil;
    return cast<RealScalar,int>(ceil(-log(NumTraits<RealScalar>::epsilon())/log(RealScalar(10))));
  }
};

template<typename Scalar>
struct significant_decimals_default_impl<Scalar, true>
{
  static inline int run()
  {
    return 0;
  }
};

template<typename Scalar>
struct significant_decimals_impl
  : significant_decimals_default_impl<Scalar, NumTraits<Scalar>::IsInteger>
{};



template<typename Derived>
std::ostream & print_matrix(std::ostream & s, const Derived& _m, const IOFormat& fmt)
{
  if(_m.size() == 0)
  {
    s << fmt.matPrefix << fmt.matSuffix;
    return s;
  }

  const typename Derived::Nested m = _m;
  typedef typename Derived::Scalar Scalar;
  typedef typename Derived::Index Index;

  Index width = 0;

  std::streamsize explicit_precision;
  if(fmt.precision == StreamPrecision)
  {
    explicit_precision = 0;
  }
  else if(fmt.precision == FullPrecision)
  {
    if (NumTraits<Scalar>::IsInteger)
    {
      explicit_precision = 0;
    }
    else
    {
      explicit_precision = significant_decimals_impl<Scalar>::run();
    }
  }
  else
  {
    explicit_precision = fmt.precision;
  }

  bool align_cols = !(fmt.flags & DontAlignCols);
  if(align_cols)
  {

    for(Index j = 1; j < m.cols(); ++j)
      for(Index i = 0; i < m.rows(); ++i)
      {
        std::stringstream sstr;
        if(explicit_precision) sstr.precision(explicit_precision);
        sstr << m.coeff(i,j);
        width = std::max<Index>(width, Index(sstr.str().length()));
      }
  }
  std::streamsize old_precision = 0;
  if(explicit_precision) old_precision = s.precision(explicit_precision);
  s << fmt.matPrefix;
  for(Index i = 0; i < m.rows(); ++i)
  {
    if (i)
      s << fmt.rowSpacer;
    s << fmt.rowPrefix;
    if(width) s.width(width);
    s << m.coeff(i, 0);
    for(Index j = 1; j < m.cols(); ++j)
    {
      s << fmt.coeffSeparator;
      if (width) s.width(width);
      s << m.coeff(i, j);
    }
    s << fmt.rowSuffix;
    if( i < m.rows() - 1)
      s << fmt.rowSeparator;
  }
  s << fmt.matSuffix;
  if(explicit_precision) s.precision(old_precision);
  return s;
}

}
# 252 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/IO.h"
template<typename Derived>
std::ostream & operator <<
(std::ostream & s,
 const DenseBase<Derived> & m)
{
  return internal::print_matrix(s, m.eval(), IOFormat(4, 0, "  ", "\n", "", "", "", ""));
}
# 317 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Swap.h" 1
# 35 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Swap.h"
namespace internal {
template<typename ExpressionType>
struct traits<SwapWrapper<ExpressionType> > : traits<ExpressionType> {};
}

template<typename ExpressionType> class SwapWrapper
  : public internal::dense_xpr_base<SwapWrapper<ExpressionType> >::type
{
  public:

    typedef typename internal::dense_xpr_base<SwapWrapper>::type Base;
    typedef typename Eigen::internal::traits<SwapWrapper>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<SwapWrapper>::type Nested; typedef typename Eigen::internal::traits<SwapWrapper>::StorageKind StorageKind; typedef typename Eigen::internal::traits<SwapWrapper>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<SwapWrapper>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<SwapWrapper>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<SwapWrapper>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<SwapWrapper>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<SwapWrapper>::Flags, CoeffReadCost = Eigen::internal::traits<SwapWrapper>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived;
    typedef typename internal::packet_traits<Scalar>::type Packet;

    inline SwapWrapper(ExpressionType& xpr) : m_expression(xpr) {}

    inline Index rows() const { return m_expression.rows(); }
    inline Index cols() const { return m_expression.cols(); }
    inline Index outerStride() const { return m_expression.outerStride(); }
    inline Index innerStride() const { return m_expression.innerStride(); }

    inline Scalar& coeffRef(Index row, Index col)
    {
      return m_expression.const_cast_derived().coeffRef(row, col);
    }

    inline Scalar& coeffRef(Index index)
    {
      return m_expression.const_cast_derived().coeffRef(index);
    }

    inline Scalar& coeffRef(Index row, Index col) const
    {
      return m_expression.coeffRef(row, col);
    }

    inline Scalar& coeffRef(Index index) const
    {
      return m_expression.coeffRef(index);
    }

    template<typename OtherDerived>
    void copyCoeff(Index row, Index col, const DenseBase<OtherDerived>& other)
    {
      OtherDerived& _other = other.const_cast_derived();
      if( (!Eigen::internal::copy_bool(row >= 0 && row < rows() && col >= 0 && col < cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(row >= 0 && row < rows() && col >= 0 && col < cols())) Eigen::internal::assert_fail("row >= 0 && row < rows() && col >= 0 && col < cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Swap.h", 81); } while(false); else throw Eigen::eigen_assert_exception(); };

      Scalar tmp = m_expression.coeff(row, col);
      m_expression.coeffRef(row, col) = _other.coeff(row, col);
      _other.coeffRef(row, col) = tmp;
    }

    template<typename OtherDerived>
    void copyCoeff(Index index, const DenseBase<OtherDerived>& other)
    {
      OtherDerived& _other = other.const_cast_derived();
      if( (!Eigen::internal::copy_bool(index >= 0 && index < m_expression.size())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(index >= 0 && index < m_expression.size())) Eigen::internal::assert_fail("index >= 0 && index < m_expression.size()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Swap.h", 91); } while(false); else throw Eigen::eigen_assert_exception(); };
      Scalar tmp = m_expression.coeff(index);
      m_expression.coeffRef(index) = _other.coeff(index);
      _other.coeffRef(index) = tmp;
    }

    template<typename OtherDerived, int StoreMode, int LoadMode>
    void copyPacket(Index row, Index col, const DenseBase<OtherDerived>& other)
    {
      OtherDerived& _other = other.const_cast_derived();
      if( (!Eigen::internal::copy_bool(row >= 0 && row < rows() && col >= 0 && col < cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(row >= 0 && row < rows() && col >= 0 && col < cols())) Eigen::internal::assert_fail("row >= 0 && row < rows() && col >= 0 && col < cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Swap.h", 102); } while(false); else throw Eigen::eigen_assert_exception(); };

      Packet tmp = m_expression.template packet<StoreMode>(row, col);
      m_expression.template writePacket<StoreMode>(row, col,
        _other.template packet<LoadMode>(row, col)
      );
      _other.template writePacket<LoadMode>(row, col, tmp);
    }

    template<typename OtherDerived, int StoreMode, int LoadMode>
    void copyPacket(Index index, const DenseBase<OtherDerived>& other)
    {
      OtherDerived& _other = other.const_cast_derived();
      if( (!Eigen::internal::copy_bool(index >= 0 && index < m_expression.size())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(index >= 0 && index < m_expression.size())) Eigen::internal::assert_fail("index >= 0 && index < m_expression.size()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Swap.h", 114); } while(false); else throw Eigen::eigen_assert_exception(); };
      Packet tmp = m_expression.template packet<StoreMode>(index);
      m_expression.template writePacket<StoreMode>(index,
        _other.template packet<LoadMode>(index)
      );
      _other.template writePacket<LoadMode>(index, tmp);
    }

  protected:
    ExpressionType& m_expression;
};
# 318 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CommaInitializer.h" 1
# 40 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CommaInitializer.h"
template<typename XprType>
struct CommaInitializer
{
  typedef typename XprType::Scalar Scalar;
  typedef typename XprType::Index Index;

  inline CommaInitializer(XprType& xpr, const Scalar& s)
    : m_xpr(xpr), m_row(0), m_col(1), m_currentBlockRows(1)
  {
    m_xpr.coeffRef(0,0) = s;
  }

  template<typename OtherDerived>
  inline CommaInitializer(XprType& xpr, const DenseBase<OtherDerived>& other)
    : m_xpr(xpr), m_row(0), m_col(other.cols()), m_currentBlockRows(other.rows())
  {
    m_xpr.block(0, 0, other.rows(), other.cols()) = other;
  }


  CommaInitializer& operator,(const Scalar& s)
  {
    if (m_col==m_xpr.cols())
    {
      m_row+=m_currentBlockRows;
      m_col = 0;
      m_currentBlockRows = 1;
      if( (!Eigen::internal::copy_bool(m_row<m_xpr.rows() && "Too many rows passed to comma initializer (operator<<)")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_row<m_xpr.rows() && "Too many rows passed to comma initializer (operator<<)")) Eigen::internal::assert_fail("m_row<m_xpr.rows() && \"Too many rows passed to comma initializer (operator<<)\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CommaInitializer.h", 68); } while(false); else throw Eigen::eigen_assert_exception(); };

    }
    if( (!Eigen::internal::copy_bool(m_col<m_xpr.cols() && "Too many coefficients passed to comma initializer (operator<<)")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_col<m_xpr.cols() && "Too many coefficients passed to comma initializer (operator<<)")) Eigen::internal::assert_fail("m_col<m_xpr.cols() && \"Too many coefficients passed to comma initializer (operator<<)\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CommaInitializer.h", 71); } while(false); else throw Eigen::eigen_assert_exception(); };

    if( (!Eigen::internal::copy_bool(m_currentBlockRows==1)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_currentBlockRows==1)) Eigen::internal::assert_fail("m_currentBlockRows==1", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CommaInitializer.h", 72); } while(false); else throw Eigen::eigen_assert_exception(); };
    m_xpr.coeffRef(m_row, m_col++) = s;
    return *this;
  }


  template<typename OtherDerived>
  CommaInitializer& operator,(const DenseBase<OtherDerived>& other)
  {
    if (m_col==m_xpr.cols())
    {
      m_row+=m_currentBlockRows;
      m_col = 0;
      m_currentBlockRows = other.rows();
      if( (!Eigen::internal::copy_bool(m_row+m_currentBlockRows<=m_xpr.rows() && "Too many rows passed to comma initializer (operator<<)")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_row+m_currentBlockRows<=m_xpr.rows() && "Too many rows passed to comma initializer (operator<<)")) Eigen::internal::assert_fail("m_row+m_currentBlockRows<=m_xpr.rows() && \"Too many rows passed to comma initializer (operator<<)\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CommaInitializer.h", 87); } while(false); else throw Eigen::eigen_assert_exception(); };

    }
    if( (!Eigen::internal::copy_bool(m_col<m_xpr.cols() && "Too many coefficients passed to comma initializer (operator<<)")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_col<m_xpr.cols() && "Too many coefficients passed to comma initializer (operator<<)")) Eigen::internal::assert_fail("m_col<m_xpr.cols() && \"Too many coefficients passed to comma initializer (operator<<)\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CommaInitializer.h", 90); } while(false); else throw Eigen::eigen_assert_exception(); };

    if( (!Eigen::internal::copy_bool(m_currentBlockRows==other.rows())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_currentBlockRows==other.rows())) Eigen::internal::assert_fail("m_currentBlockRows==other.rows()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CommaInitializer.h", 91); } while(false); else throw Eigen::eigen_assert_exception(); };
    if (OtherDerived::SizeAtCompileTime != Dynamic)
      m_xpr.template block<OtherDerived::RowsAtCompileTime != Dynamic ? OtherDerived::RowsAtCompileTime : 1,
                              OtherDerived::ColsAtCompileTime != Dynamic ? OtherDerived::ColsAtCompileTime : 1>
                    (m_row, m_col) = other;
    else
      m_xpr.block(m_row, m_col, other.rows(), other.cols()) = other;
    m_col += other.cols();
    return *this;
  }

  inline ~CommaInitializer()
  {
    if( (!Eigen::internal::copy_bool((m_row+m_currentBlockRows) == m_xpr.rows() && m_col == m_xpr.cols() && "Too few coefficients passed to comma initializer (operator<<)")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool((m_row+m_currentBlockRows) == m_xpr.rows() && m_col == m_xpr.cols() && "Too few coefficients passed to comma initializer (operator<<)")) Eigen::internal::assert_fail("(m_row+m_currentBlockRows) == m_xpr.rows() && m_col == m_xpr.cols() && \"Too few coefficients passed to comma initializer (operator<<)\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CommaInitializer.h", 106); } while(false); else throw Eigen::eigen_assert_exception(); };


  }
# 116 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CommaInitializer.h"
  inline XprType& finished() { return m_xpr; }

  XprType& m_xpr;
  Index m_row;
  Index m_col;
  Index m_currentBlockRows;
};
# 135 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/CommaInitializer.h"
template<typename Derived>
inline CommaInitializer<Derived> DenseBase<Derived>::operator<< (const Scalar& s)
{
  return CommaInitializer<Derived>(*static_cast<Derived*>(this), s);
}


template<typename Derived>
template<typename OtherDerived>
inline CommaInitializer<Derived>
DenseBase<Derived>::operator<<(const DenseBase<OtherDerived>& other)
{
  return CommaInitializer<Derived>(*static_cast<Derived *>(this), other);
}
# 319 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Flagged.h" 1
# 44 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Flagged.h"
namespace internal {
template<typename ExpressionType, unsigned int Added, unsigned int Removed>
struct traits<Flagged<ExpressionType, Added, Removed> > : traits<ExpressionType>
{
  enum { Flags = (ExpressionType::Flags | Added) & ~Removed };
};
}

template<typename ExpressionType, unsigned int Added, unsigned int Removed> class Flagged
  : public MatrixBase<Flagged<ExpressionType, Added, Removed> >
{
  public:

    typedef MatrixBase<Flagged> Base;

    typedef typename Eigen::internal::traits<Flagged>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<Flagged>::type Nested; typedef typename Eigen::internal::traits<Flagged>::StorageKind StorageKind; typedef typename Eigen::internal::traits<Flagged>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<Flagged>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<Flagged>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<Flagged>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<Flagged>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<Flagged>::Flags, CoeffReadCost = Eigen::internal::traits<Flagged>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived;
    typedef typename internal::conditional<internal::must_nest_by_value<ExpressionType>::ret,
        ExpressionType, const ExpressionType&>::type ExpressionTypeNested;
    typedef typename ExpressionType::InnerIterator InnerIterator;

    inline Flagged(const ExpressionType& matrix) : m_matrix(matrix) {}

    inline Index rows() const { return m_matrix.rows(); }
    inline Index cols() const { return m_matrix.cols(); }
    inline Index outerStride() const { return m_matrix.outerStride(); }
    inline Index innerStride() const { return m_matrix.innerStride(); }

    inline CoeffReturnType coeff(Index row, Index col) const
    {
      return m_matrix.coeff(row, col);
    }

    inline CoeffReturnType coeff(Index index) const
    {
      return m_matrix.coeff(index);
    }

    inline const Scalar& coeffRef(Index row, Index col) const
    {
      return m_matrix.const_cast_derived().coeffRef(row, col);
    }

    inline const Scalar& coeffRef(Index index) const
    {
      return m_matrix.const_cast_derived().coeffRef(index);
    }

    inline Scalar& coeffRef(Index row, Index col)
    {
      return m_matrix.const_cast_derived().coeffRef(row, col);
    }

    inline Scalar& coeffRef(Index index)
    {
      return m_matrix.const_cast_derived().coeffRef(index);
    }

    template<int LoadMode>
    inline const PacketScalar packet(Index row, Index col) const
    {
      return m_matrix.template packet<LoadMode>(row, col);
    }

    template<int LoadMode>
    inline void writePacket(Index row, Index col, const PacketScalar& x)
    {
      m_matrix.const_cast_derived().template writePacket<LoadMode>(row, col, x);
    }

    template<int LoadMode>
    inline const PacketScalar packet(Index index) const
    {
      return m_matrix.template packet<LoadMode>(index);
    }

    template<int LoadMode>
    inline void writePacket(Index index, const PacketScalar& x)
    {
      m_matrix.const_cast_derived().template writePacket<LoadMode>(index, x);
    }

    const ExpressionType& _expression() const { return m_matrix; }

    template<typename OtherDerived>
    typename ExpressionType::PlainObject solveTriangular(const MatrixBase<OtherDerived>& other) const;

    template<typename OtherDerived>
    void solveTriangularInPlace(const MatrixBase<OtherDerived>& other) const;

  protected:
    ExpressionTypeNested m_matrix;
};







template<typename Derived>
template<unsigned int Added,unsigned int Removed>
inline const Flagged<Derived, Added, Removed>
DenseBase<Derived>::flagged() const
{
  return derived();
}
# 320 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/ProductBase.h" 1
# 33 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/ProductBase.h"
namespace internal {
template<typename Derived, typename _Lhs, typename _Rhs>
struct traits<ProductBase<Derived,_Lhs,_Rhs> >
{
  typedef MatrixXpr XprKind;
  typedef typename remove_all<_Lhs>::type Lhs;
  typedef typename remove_all<_Rhs>::type Rhs;
  typedef typename scalar_product_traits<typename Lhs::Scalar, typename Rhs::Scalar>::ReturnType Scalar;
  typedef typename promote_storage_type<typename traits<Lhs>::StorageKind,
                                           typename traits<Rhs>::StorageKind>::ret StorageKind;
  typedef typename promote_index_type<typename traits<Lhs>::Index,
                                         typename traits<Rhs>::Index>::type Index;
  enum {
    RowsAtCompileTime = traits<Lhs>::RowsAtCompileTime,
    ColsAtCompileTime = traits<Rhs>::ColsAtCompileTime,
    MaxRowsAtCompileTime = traits<Lhs>::MaxRowsAtCompileTime,
    MaxColsAtCompileTime = traits<Rhs>::MaxColsAtCompileTime,
    Flags = (MaxRowsAtCompileTime==1 ? RowMajorBit : 0)
          | EvalBeforeNestingBit | EvalBeforeAssigningBit | NestByRefBit,


    CoeffReadCost = 0
  };
};
}
# 75 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/ProductBase.h"
template<typename Derived, typename Lhs, typename Rhs>
class ProductBase : public MatrixBase<Derived>
{
  public:
    typedef MatrixBase<Derived> Base;
    typedef typename Eigen::internal::traits<ProductBase>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<ProductBase>::type Nested; typedef typename Eigen::internal::traits<ProductBase>::StorageKind StorageKind; typedef typename Eigen::internal::traits<ProductBase>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<ProductBase>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<ProductBase>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<ProductBase>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<ProductBase>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<ProductBase>::Flags, CoeffReadCost = Eigen::internal::traits<ProductBase>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived;

    typedef typename Lhs::Nested LhsNested;
    typedef typename internal::remove_all<LhsNested>::type _LhsNested;
    typedef internal::blas_traits<_LhsNested> LhsBlasTraits;
    typedef typename LhsBlasTraits::DirectLinearAccessType ActualLhsType;
    typedef typename internal::remove_all<ActualLhsType>::type _ActualLhsType;
    typedef typename internal::traits<Lhs>::Scalar LhsScalar;

    typedef typename Rhs::Nested RhsNested;
    typedef typename internal::remove_all<RhsNested>::type _RhsNested;
    typedef internal::blas_traits<_RhsNested> RhsBlasTraits;
    typedef typename RhsBlasTraits::DirectLinearAccessType ActualRhsType;
    typedef typename internal::remove_all<ActualRhsType>::type _ActualRhsType;
    typedef typename internal::traits<Rhs>::Scalar RhsScalar;


    typedef CoeffBasedProduct<LhsNested, RhsNested, 0> FullyLazyCoeffBaseProductType;

  public:

    typedef typename Base::PlainObject PlainObject;

    ProductBase(const Lhs& lhs, const Rhs& rhs)
      : m_lhs(lhs), m_rhs(rhs)
    {
      if( (!Eigen::internal::copy_bool(lhs.cols() == rhs.rows() && "invalid matrix product" && "if you wanted a coeff-wise or a dot product use the respective explicit functions")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(lhs.cols() == rhs.rows() && "invalid matrix product" && "if you wanted a coeff-wise or a dot product use the respective explicit functions")) Eigen::internal::assert_fail("lhs.cols() == rhs.rows() && \"invalid matrix product\" && \"if you wanted a coeff-wise or a dot product use the respective explicit functions\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/ProductBase.h", 108); } while(false); else throw Eigen::eigen_assert_exception(); };


    }

    inline Index rows() const { return m_lhs.rows(); }
    inline Index cols() const { return m_rhs.cols(); }

    template<typename Dest>
    inline void evalTo(Dest& dst) const { dst.setZero(); scaleAndAddTo(dst,Scalar(1)); }

    template<typename Dest>
    inline void addTo(Dest& dst) const { scaleAndAddTo(dst,1); }

    template<typename Dest>
    inline void subTo(Dest& dst) const { scaleAndAddTo(dst,-1); }

    template<typename Dest>
    inline void scaleAndAddTo(Dest& dst,Scalar alpha) const { derived().scaleAndAddTo(dst,alpha); }

    const _LhsNested& lhs() const { return m_lhs; }
    const _RhsNested& rhs() const { return m_rhs; }


    operator const PlainObject& () const
    {
      m_result.resize(m_lhs.rows(), m_rhs.cols());
      derived().evalTo(m_result);
      return m_result;
    }

    const Diagonal<const FullyLazyCoeffBaseProductType,0> diagonal() const
    { return FullyLazyCoeffBaseProductType(m_lhs, m_rhs); }

    template<int Index>
    const Diagonal<FullyLazyCoeffBaseProductType,Index> diagonal() const
    { return FullyLazyCoeffBaseProductType(m_lhs, m_rhs); }

    const Diagonal<FullyLazyCoeffBaseProductType,Dynamic> diagonal(Index index) const
    { return FullyLazyCoeffBaseProductType(m_lhs, m_rhs).diagonal(index); }


    typename Base::CoeffReturnType coeff(Index row, Index col) const
    {



      if (Eigen::internal::static_assertion<bool((Derived::RowsAtCompileTime == 1 || Derived::RowsAtCompileTime == Dynamic) && (Derived::ColsAtCompileTime == 1 || Derived::ColsAtCompileTime == Dynamic))>::THIS_METHOD_IS_ONLY_FOR_1x1_EXPRESSIONS) {}
      if( (!Eigen::internal::copy_bool(this->rows() == 1 && this->cols() == 1)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(this->rows() == 1 && this->cols() == 1)) Eigen::internal::assert_fail("this->rows() == 1 && this->cols() == 1", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/ProductBase.h", 154); } while(false); else throw Eigen::eigen_assert_exception(); };
      return derived().coeff(row,col);

    }

    typename Base::CoeffReturnType coeff(Index i) const
    {
      if (Eigen::internal::static_assertion<bool((Derived::RowsAtCompileTime == 1 || Derived::RowsAtCompileTime == Dynamic) && (Derived::ColsAtCompileTime == 1 || Derived::ColsAtCompileTime == Dynamic))>::THIS_METHOD_IS_ONLY_FOR_1x1_EXPRESSIONS) {}
      if( (!Eigen::internal::copy_bool(this->rows() == 1 && this->cols() == 1)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(this->rows() == 1 && this->cols() == 1)) Eigen::internal::assert_fail("this->rows() == 1 && this->cols() == 1", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/ProductBase.h", 162); } while(false); else throw Eigen::eigen_assert_exception(); };
      return derived().coeff(i);
    }

    const Scalar& coeffRef(Index row, Index col) const
    {
      if (Eigen::internal::static_assertion<bool((Derived::RowsAtCompileTime == 1 || Derived::RowsAtCompileTime == Dynamic) && (Derived::ColsAtCompileTime == 1 || Derived::ColsAtCompileTime == Dynamic))>::THIS_METHOD_IS_ONLY_FOR_1x1_EXPRESSIONS) {}
      if( (!Eigen::internal::copy_bool(this->rows() == 1 && this->cols() == 1)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(this->rows() == 1 && this->cols() == 1)) Eigen::internal::assert_fail("this->rows() == 1 && this->cols() == 1", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/ProductBase.h", 169); } while(false); else throw Eigen::eigen_assert_exception(); };
      return derived().coeffRef(row,col);
    }

    const Scalar& coeffRef(Index i) const
    {
      if (Eigen::internal::static_assertion<bool((Derived::RowsAtCompileTime == 1 || Derived::RowsAtCompileTime == Dynamic) && (Derived::ColsAtCompileTime == 1 || Derived::ColsAtCompileTime == Dynamic))>::THIS_METHOD_IS_ONLY_FOR_1x1_EXPRESSIONS) {}
      if( (!Eigen::internal::copy_bool(this->rows() == 1 && this->cols() == 1)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(this->rows() == 1 && this->cols() == 1)) Eigen::internal::assert_fail("this->rows() == 1 && this->cols() == 1", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/ProductBase.h", 176); } while(false); else throw Eigen::eigen_assert_exception(); };
      return derived().coeffRef(i);
    }

  protected:

    const LhsNested m_lhs;
    const RhsNested m_rhs;

    mutable PlainObject m_result;
};



namespace internal {
template<typename Lhs, typename Rhs, int Mode, int N, typename PlainObject>
struct nested<GeneralProduct<Lhs,Rhs,Mode>, N, PlainObject>
{
  typedef PlainObject const& type;
};
}

template<typename NestedProduct>
class ScaledProduct;







template<typename Derived,typename Lhs,typename Rhs>
const ScaledProduct<Derived>
operator*(const ProductBase<Derived,Lhs,Rhs>& prod, typename Derived::Scalar x)
{ return ScaledProduct<Derived>(prod.derived(), x); }

template<typename Derived,typename Lhs,typename Rhs>
typename internal::enable_if<!internal::is_same<typename Derived::Scalar,typename Derived::RealScalar>::value,
                      const ScaledProduct<Derived> >::type
operator*(const ProductBase<Derived,Lhs,Rhs>& prod, typename Derived::RealScalar x)
{ return ScaledProduct<Derived>(prod.derived(), x); }


template<typename Derived,typename Lhs,typename Rhs>
const ScaledProduct<Derived>
operator*(typename Derived::Scalar x,const ProductBase<Derived,Lhs,Rhs>& prod)
{ return ScaledProduct<Derived>(prod.derived(), x); }

template<typename Derived,typename Lhs,typename Rhs>
typename internal::enable_if<!internal::is_same<typename Derived::Scalar,typename Derived::RealScalar>::value,
                      const ScaledProduct<Derived> >::type
operator*(typename Derived::RealScalar x,const ProductBase<Derived,Lhs,Rhs>& prod)
{ return ScaledProduct<Derived>(prod.derived(), x); }

namespace internal {
template<typename NestedProduct>
struct traits<ScaledProduct<NestedProduct> >
 : traits<ProductBase<ScaledProduct<NestedProduct>,
                         typename NestedProduct::_LhsNested,
                         typename NestedProduct::_RhsNested> >
{
  typedef typename traits<NestedProduct>::StorageKind StorageKind;
};
}

template<typename NestedProduct>
class ScaledProduct
  : public ProductBase<ScaledProduct<NestedProduct>,
                       typename NestedProduct::_LhsNested,
                       typename NestedProduct::_RhsNested>
{
  public:
    typedef ProductBase<ScaledProduct<NestedProduct>,
                       typename NestedProduct::_LhsNested,
                       typename NestedProduct::_RhsNested> Base;
    typedef typename Base::Scalar Scalar;
    typedef typename Base::PlainObject PlainObject;


    ScaledProduct(const NestedProduct& prod, Scalar x)
    : Base(prod.lhs(),prod.rhs()), m_prod(prod), m_alpha(x) {}

    template<typename Dest>
    inline void evalTo(Dest& dst) const { dst.setZero(); scaleAndAddTo(dst, Scalar(1)); }

    template<typename Dest>
    inline void addTo(Dest& dst) const { scaleAndAddTo(dst, Scalar(1)); }

    template<typename Dest>
    inline void subTo(Dest& dst) const { scaleAndAddTo(dst, Scalar(-1)); }

    template<typename Dest>
    inline void scaleAndAddTo(Dest& dst,Scalar alpha) const { m_prod.derived().scaleAndAddTo(dst,alpha * m_alpha); }

    const Scalar& alpha() const { return m_alpha; }

  protected:
    const NestedProduct& m_prod;
    Scalar m_alpha;
};



template<typename Derived>
template<typename ProductDerived, typename Lhs, typename Rhs>
Derived& MatrixBase<Derived>::lazyAssign(const ProductBase<ProductDerived, Lhs,Rhs>& other)
{
  other.derived().evalTo(derived());
  return derived();
}
# 321 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Product.h" 1
# 48 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Product.h"
template<typename Lhs, typename Rhs, int ProductType = internal::product_type<Lhs,Rhs>::value>
class GeneralProduct;

enum {
  Large = 2,
  Small = 3
};

namespace internal {

template<int Rows, int Cols, int Depth> struct product_type_selector;

template<int Size, int MaxSize> struct product_size_category
{
  enum { is_large = MaxSize == Dynamic ||
                    Size >= 8,
         value = is_large ? Large
               : Size == 1 ? 1
                           : Small
  };
};

template<typename Lhs, typename Rhs> struct product_type
{
  typedef typename remove_all<Lhs>::type _Lhs;
  typedef typename remove_all<Rhs>::type _Rhs;
  enum {
    MaxRows = _Lhs::MaxRowsAtCompileTime,
    Rows = _Lhs::RowsAtCompileTime,
    MaxCols = _Rhs::MaxColsAtCompileTime,
    Cols = _Rhs::ColsAtCompileTime,
    MaxDepth = (((int)_Lhs::MaxColsAtCompileTime == 0 || (int)_Rhs::MaxRowsAtCompileTime == 0) ? 0 : ((int)_Lhs::MaxColsAtCompileTime == 1 || (int)_Rhs::MaxRowsAtCompileTime == 1) ? 1 : ((int)_Lhs::MaxColsAtCompileTime == Dynamic && (int)_Rhs::MaxRowsAtCompileTime == Dynamic) ? Dynamic : ((int)_Lhs::MaxColsAtCompileTime == Dynamic) ? (int)_Rhs::MaxRowsAtCompileTime : ((int)_Rhs::MaxRowsAtCompileTime == Dynamic) ? (int)_Lhs::MaxColsAtCompileTime : ((int)_Lhs::MaxColsAtCompileTime <= (int)_Rhs::MaxRowsAtCompileTime) ? (int)_Lhs::MaxColsAtCompileTime : (int)_Rhs::MaxRowsAtCompileTime),

    Depth = (((int)_Lhs::ColsAtCompileTime == 0 || (int)_Rhs::RowsAtCompileTime == 0) ? 0 : ((int)_Lhs::ColsAtCompileTime == 1 || (int)_Rhs::RowsAtCompileTime == 1) ? 1 : ((int)_Lhs::ColsAtCompileTime == Dynamic && (int)_Rhs::RowsAtCompileTime == Dynamic) ? Dynamic : ((int)_Lhs::ColsAtCompileTime == Dynamic) ? (int)_Rhs::RowsAtCompileTime : ((int)_Rhs::RowsAtCompileTime == Dynamic) ? (int)_Lhs::ColsAtCompileTime : ((int)_Lhs::ColsAtCompileTime <= (int)_Rhs::RowsAtCompileTime) ? (int)_Lhs::ColsAtCompileTime : (int)_Rhs::RowsAtCompileTime),

    LargeThreshold = 8
  };



private:
  enum {
    rows_select = product_size_category<Rows,MaxRows>::value,
    cols_select = product_size_category<Cols,MaxCols>::value,
    depth_select = product_size_category<Depth,MaxDepth>::value
  };
  typedef product_type_selector<rows_select, cols_select, depth_select> selector;

public:
  enum {
    value = selector::ret
  };
# 112 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Product.h"
};






template<int M, int N> struct product_type_selector<M,N,1> { enum { ret = OuterProduct }; };
template<int Depth> struct product_type_selector<1, 1, Depth> { enum { ret = InnerProduct }; };
template<> struct product_type_selector<1, 1, 1> { enum { ret = InnerProduct }; };
template<> struct product_type_selector<Small,1, Small> { enum { ret = CoeffBasedProductMode }; };
template<> struct product_type_selector<1, Small,Small> { enum { ret = CoeffBasedProductMode }; };
template<> struct product_type_selector<Small,Small,Small> { enum { ret = CoeffBasedProductMode }; };
template<> struct product_type_selector<Small, Small, 1> { enum { ret = LazyCoeffBasedProductMode }; };
template<> struct product_type_selector<Small, Large, 1> { enum { ret = LazyCoeffBasedProductMode }; };
template<> struct product_type_selector<Large, Small, 1> { enum { ret = LazyCoeffBasedProductMode }; };
template<> struct product_type_selector<1, Large,Small> { enum { ret = CoeffBasedProductMode }; };
template<> struct product_type_selector<1, Large,Large> { enum { ret = GemvProduct }; };
template<> struct product_type_selector<1, Small,Large> { enum { ret = CoeffBasedProductMode }; };
template<> struct product_type_selector<Large,1, Small> { enum { ret = CoeffBasedProductMode }; };
template<> struct product_type_selector<Large,1, Large> { enum { ret = GemvProduct }; };
template<> struct product_type_selector<Small,1, Large> { enum { ret = CoeffBasedProductMode }; };
template<> struct product_type_selector<Small,Small,Large> { enum { ret = GemmProduct }; };
template<> struct product_type_selector<Large,Small,Large> { enum { ret = GemmProduct }; };
template<> struct product_type_selector<Small,Large,Large> { enum { ret = GemmProduct }; };
template<> struct product_type_selector<Large,Large,Large> { enum { ret = GemmProduct }; };
template<> struct product_type_selector<Large,Small,Small> { enum { ret = GemmProduct }; };
template<> struct product_type_selector<Small,Large,Small> { enum { ret = GemmProduct }; };
template<> struct product_type_selector<Large,Large,Small> { enum { ret = GemmProduct }; };

}
# 161 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Product.h"
template<typename Lhs, typename Rhs, int ProductType>
struct ProductReturnType
{




  typedef GeneralProduct<Lhs , Rhs , ProductType> Type;
};

template<typename Lhs, typename Rhs>
struct ProductReturnType<Lhs,Rhs,CoeffBasedProductMode>
{
  typedef typename internal::nested<Lhs, Rhs::ColsAtCompileTime, typename internal::plain_matrix_type<Lhs>::type >::type LhsNested;
  typedef typename internal::nested<Rhs, Lhs::RowsAtCompileTime, typename internal::plain_matrix_type<Rhs>::type >::type RhsNested;
  typedef CoeffBasedProduct<LhsNested, RhsNested, EvalBeforeAssigningBit | EvalBeforeNestingBit> Type;
};

template<typename Lhs, typename Rhs>
struct ProductReturnType<Lhs,Rhs,LazyCoeffBasedProductMode>
{
  typedef typename internal::nested<Lhs, Rhs::ColsAtCompileTime, typename internal::plain_matrix_type<Lhs>::type >::type LhsNested;
  typedef typename internal::nested<Rhs, Lhs::RowsAtCompileTime, typename internal::plain_matrix_type<Rhs>::type >::type RhsNested;
  typedef CoeffBasedProduct<LhsNested, RhsNested, NestByRefBit> Type;
};


template<typename Lhs, typename Rhs>
struct LazyProductReturnType : public ProductReturnType<Lhs,Rhs,LazyCoeffBasedProductMode>
{};
# 203 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Product.h"
namespace internal {

template<typename Lhs, typename Rhs>
struct traits<GeneralProduct<Lhs,Rhs,InnerProduct> >
 : traits<Matrix<typename scalar_product_traits<typename Lhs::Scalar, typename Rhs::Scalar>::ReturnType,1,1> >
{};

}

template<typename Lhs, typename Rhs>
class GeneralProduct<Lhs, Rhs, InnerProduct>
  : internal::no_assignment_operator,
    public Matrix<typename internal::scalar_product_traits<typename Lhs::Scalar, typename Rhs::Scalar>::ReturnType,1,1>
{
    typedef Matrix<typename internal::scalar_product_traits<typename Lhs::Scalar, typename Rhs::Scalar>::ReturnType,1,1> Base;
  public:
    GeneralProduct(const Lhs& lhs, const Rhs& rhs)
    {
      if (Eigen::internal::static_assertion<bool((internal::is_same<typename Lhs::RealScalar, typename Rhs::RealScalar>::value))>::YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY) {}


      Base::coeffRef(0,0) = (lhs.transpose().cwiseProduct(rhs)).sum();
    }


    operator const typename Base::Scalar() const {
      return Base::coeff(0,0);
    }
};





namespace internal {
template<int StorageOrder> struct outer_product_selector;

template<typename Lhs, typename Rhs>
struct traits<GeneralProduct<Lhs,Rhs,OuterProduct> >
 : traits<ProductBase<GeneralProduct<Lhs,Rhs,OuterProduct>, Lhs, Rhs> >
{};

}

template<typename Lhs, typename Rhs>
class GeneralProduct<Lhs, Rhs, OuterProduct>
  : public ProductBase<GeneralProduct<Lhs,Rhs,OuterProduct>, Lhs, Rhs>
{
  public:
    typedef ProductBase<GeneralProduct, Lhs, Rhs > Base; typedef typename Eigen::internal::traits<GeneralProduct>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<GeneralProduct>::type Nested; typedef typename Eigen::internal::traits<GeneralProduct>::StorageKind StorageKind; typedef typename Eigen::internal::traits<GeneralProduct>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<GeneralProduct>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<GeneralProduct>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<GeneralProduct>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<GeneralProduct>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<GeneralProduct>::Flags, CoeffReadCost = Eigen::internal::traits<GeneralProduct>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived; typedef typename Base::LhsNested LhsNested; typedef typename Base::_LhsNested _LhsNested; typedef typename Base::LhsBlasTraits LhsBlasTraits; typedef typename Base::ActualLhsType ActualLhsType; typedef typename Base::_ActualLhsType _ActualLhsType; typedef typename Base::RhsNested RhsNested; typedef typename Base::_RhsNested _RhsNested; typedef typename Base::RhsBlasTraits RhsBlasTraits; typedef typename Base::ActualRhsType ActualRhsType; typedef typename Base::_ActualRhsType _ActualRhsType; using Base::m_lhs; using Base::m_rhs;

    GeneralProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)
    {
      if (Eigen::internal::static_assertion<bool((internal::is_same<typename Lhs::RealScalar, typename Rhs::RealScalar>::value))>::YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY) {}

    }

    template<typename Dest> void scaleAndAddTo(Dest& dest, Scalar alpha) const
    {
      internal::outer_product_selector<(int(Dest::Flags)&RowMajorBit) ? RowMajor : ColMajor>::run(*this, dest, alpha);
    }
};

namespace internal {

template<> struct outer_product_selector<ColMajor> {
  template<typename ProductType, typename Dest>
  static __attribute__((noinline)) void run(const ProductType& prod, Dest& dest, typename ProductType::Scalar alpha) {
    typedef typename Dest::Index Index;


    const Index cols = dest.cols();
    for (Index j=0; j<cols; ++j)
      dest.col(j) += (alpha * prod.rhs().coeff(j)) * prod.lhs();
  }
};

template<> struct outer_product_selector<RowMajor> {
  template<typename ProductType, typename Dest>
  static __attribute__((noinline)) void run(const ProductType& prod, Dest& dest, typename ProductType::Scalar alpha) {
    typedef typename Dest::Index Index;


    const Index rows = dest.rows();
    for (Index i=0; i<rows; ++i)
      dest.row(i) += (alpha * prod.lhs().coeff(i)) * prod.rhs();
  }
};

}
# 305 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Product.h"
namespace internal {

template<typename Lhs, typename Rhs>
struct traits<GeneralProduct<Lhs,Rhs,GemvProduct> >
 : traits<ProductBase<GeneralProduct<Lhs,Rhs,GemvProduct>, Lhs, Rhs> >
{};

template<int Side, int StorageOrder, bool BlasCompatible>
struct gemv_selector;

}

template<typename Lhs, typename Rhs>
class GeneralProduct<Lhs, Rhs, GemvProduct>
  : public ProductBase<GeneralProduct<Lhs,Rhs,GemvProduct>, Lhs, Rhs>
{
  public:
    typedef ProductBase<GeneralProduct, Lhs, Rhs > Base; typedef typename Eigen::internal::traits<GeneralProduct>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<GeneralProduct>::type Nested; typedef typename Eigen::internal::traits<GeneralProduct>::StorageKind StorageKind; typedef typename Eigen::internal::traits<GeneralProduct>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<GeneralProduct>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<GeneralProduct>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<GeneralProduct>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<GeneralProduct>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<GeneralProduct>::Flags, CoeffReadCost = Eigen::internal::traits<GeneralProduct>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived; typedef typename Base::LhsNested LhsNested; typedef typename Base::_LhsNested _LhsNested; typedef typename Base::LhsBlasTraits LhsBlasTraits; typedef typename Base::ActualLhsType ActualLhsType; typedef typename Base::_ActualLhsType _ActualLhsType; typedef typename Base::RhsNested RhsNested; typedef typename Base::_RhsNested _RhsNested; typedef typename Base::RhsBlasTraits RhsBlasTraits; typedef typename Base::ActualRhsType ActualRhsType; typedef typename Base::_ActualRhsType _ActualRhsType; using Base::m_lhs; using Base::m_rhs;

    typedef typename Lhs::Scalar LhsScalar;
    typedef typename Rhs::Scalar RhsScalar;

    GeneralProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)
    {


    }

    enum { Side = Lhs::IsVectorAtCompileTime ? OnTheLeft : OnTheRight };
    typedef typename internal::conditional<int(Side)==OnTheRight,_LhsNested,_RhsNested>::type MatrixType;

    template<typename Dest> void scaleAndAddTo(Dest& dst, Scalar alpha) const
    {
      if( (!Eigen::internal::copy_bool(m_lhs.rows() == dst.rows() && m_rhs.cols() == dst.cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_lhs.rows() == dst.rows() && m_rhs.cols() == dst.cols())) Eigen::internal::assert_fail("m_lhs.rows() == dst.rows() && m_rhs.cols() == dst.cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Product.h", 338); } while(false); else throw Eigen::eigen_assert_exception(); };
      internal::gemv_selector<Side,(int(MatrixType::Flags)&RowMajorBit) ? RowMajor : ColMajor,
                       bool(internal::blas_traits<MatrixType>::HasUsableDirectAccess)>::run(*this, dst, alpha);
    }
};

namespace internal {


template<int StorageOrder, bool BlasCompatible>
struct gemv_selector<OnTheLeft,StorageOrder,BlasCompatible>
{
  template<typename ProductType, typename Dest>
  static void run(const ProductType& prod, Dest& dest, typename ProductType::Scalar alpha)
  {
    Transpose<Dest> destT(dest);
    enum { OtherStorageOrder = StorageOrder == RowMajor ? ColMajor : RowMajor };
    gemv_selector<OnTheRight,OtherStorageOrder,BlasCompatible>
      ::run(GeneralProduct<Transpose<const typename ProductType::_RhsNested>,Transpose<const typename ProductType::_LhsNested>, GemvProduct>
        (prod.rhs().transpose(), prod.lhs().transpose()), destT, alpha);
  }
};

template<typename Scalar,int Size,int MaxSize,bool Cond> struct gemv_static_vector_if;

template<typename Scalar,int Size,int MaxSize>
struct gemv_static_vector_if<Scalar,Size,MaxSize,false>
{
  inline Scalar* data() { if( (!Eigen::internal::copy_bool(false && "should never be called")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(false && "should never be called")) Eigen::internal::assert_fail("false && \"should never be called\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Product.h", 366); } while(false); else throw Eigen::eigen_assert_exception(); }; return 0; }
};

template<typename Scalar,int Size>
struct gemv_static_vector_if<Scalar,Size,Dynamic,true>
{
  inline Scalar* data() { return 0; }
};

template<typename Scalar,int Size,int MaxSize>
struct gemv_static_vector_if<Scalar,Size,MaxSize,true>
{

  internal::plain_array<Scalar,(((int)Size == 0 || (int)MaxSize == 0) ? 0 : ((int)Size == 1 || (int)MaxSize == 1) ? 1 : ((int)Size == Dynamic && (int)MaxSize == Dynamic) ? Dynamic : ((int)Size == Dynamic) ? (int)MaxSize : ((int)MaxSize == Dynamic) ? (int)Size : ((int)Size <= (int)MaxSize) ? (int)Size : (int)MaxSize),0> m_data;
  inline Scalar* data() { return m_data.array; }
# 395 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Product.h"
};

template<> struct gemv_selector<OnTheRight,ColMajor,true>
{
  template<typename ProductType, typename Dest>
  static inline void run(const ProductType& prod, Dest& dest, typename ProductType::Scalar alpha)
  {
    typedef typename ProductType::Index Index;
    typedef typename ProductType::LhsScalar LhsScalar;
    typedef typename ProductType::RhsScalar RhsScalar;
    typedef typename ProductType::Scalar ResScalar;
    typedef typename ProductType::RealScalar RealScalar;
    typedef typename ProductType::ActualLhsType ActualLhsType;
    typedef typename ProductType::ActualRhsType ActualRhsType;
    typedef typename ProductType::LhsBlasTraits LhsBlasTraits;
    typedef typename ProductType::RhsBlasTraits RhsBlasTraits;
    typedef Map<Matrix<ResScalar,Dynamic,1>, Aligned> MappedDest;

    const ActualLhsType actualLhs = LhsBlasTraits::extract(prod.lhs());
    const ActualRhsType actualRhs = RhsBlasTraits::extract(prod.rhs());

    ResScalar actualAlpha = alpha * LhsBlasTraits::extractScalarFactor(prod.lhs())
                                  * RhsBlasTraits::extractScalarFactor(prod.rhs());

    enum {


      EvalToDestAtCompileTime = Dest::InnerStrideAtCompileTime==1,
      ComplexByReal = (NumTraits<LhsScalar>::IsComplex) && (!NumTraits<RhsScalar>::IsComplex),
      MightCannotUseDest = (Dest::InnerStrideAtCompileTime!=1) || ComplexByReal
    };

    gemv_static_vector_if<ResScalar,Dest::SizeAtCompileTime,Dest::MaxSizeAtCompileTime,MightCannotUseDest> static_dest;


    bool alphaIsCompatible = (!ComplexByReal) ? true : (imag(actualAlpha)==RealScalar(0));
    bool evalToDest = EvalToDestAtCompileTime && alphaIsCompatible;

    RhsScalar compatibleAlpha = get_factor<ResScalar,RhsScalar>::run(actualAlpha);

    ResScalar* actualDestPtr = (evalToDest ? dest.data() : static_dest.data())!=0 ? (evalToDest ? dest.data() : static_dest.data()) : reinterpret_cast<ResScalar*>( (sizeof(ResScalar)*dest.size()<=0) ? __builtin_alloca (sizeof(ResScalar)*dest.size()) : Eigen::internal::aligned_malloc(sizeof(ResScalar)*dest.size()) ); Eigen::internal::aligned_stack_memory_handler<ResScalar> actualDestPtr_stack_memory_destructor((evalToDest ? dest.data() : static_dest.data())==0 ? actualDestPtr : 0,dest.size(),sizeof(ResScalar)*dest.size()>0);


    if(!evalToDest)
    {




      if(!alphaIsCompatible)
      {
        MappedDest(actualDestPtr, dest.size()).setZero();
        compatibleAlpha = RhsScalar(1);
      }
      else
        MappedDest(actualDestPtr, dest.size()) = dest;
    }

    general_matrix_vector_product
      <Index,LhsScalar,ColMajor,LhsBlasTraits::NeedToConjugate,RhsScalar,RhsBlasTraits::NeedToConjugate>::run(
        actualLhs.rows(), actualLhs.cols(),
        &actualLhs.coeffRef(0,0), actualLhs.outerStride(),
        actualRhs.data(), actualRhs.innerStride(),
        actualDestPtr, 1,
        compatibleAlpha);

    if (!evalToDest)
    {
      if(!alphaIsCompatible)
        dest += actualAlpha * MappedDest(actualDestPtr, dest.size());
      else
        dest = MappedDest(actualDestPtr, dest.size());
    }
  }
};

template<> struct gemv_selector<OnTheRight,RowMajor,true>
{
  template<typename ProductType, typename Dest>
  static void run(const ProductType& prod, Dest& dest, typename ProductType::Scalar alpha)
  {
    typedef typename ProductType::LhsScalar LhsScalar;
    typedef typename ProductType::RhsScalar RhsScalar;
    typedef typename ProductType::Scalar ResScalar;
    typedef typename ProductType::Index Index;
    typedef typename ProductType::ActualLhsType ActualLhsType;
    typedef typename ProductType::ActualRhsType ActualRhsType;
    typedef typename ProductType::_ActualRhsType _ActualRhsType;
    typedef typename ProductType::LhsBlasTraits LhsBlasTraits;
    typedef typename ProductType::RhsBlasTraits RhsBlasTraits;

    typename add_const<ActualLhsType>::type actualLhs = LhsBlasTraits::extract(prod.lhs());
    typename add_const<ActualRhsType>::type actualRhs = RhsBlasTraits::extract(prod.rhs());

    ResScalar actualAlpha = alpha * LhsBlasTraits::extractScalarFactor(prod.lhs())
                                  * RhsBlasTraits::extractScalarFactor(prod.rhs());

    enum {


      DirectlyUseRhs = _ActualRhsType::InnerStrideAtCompileTime==1
    };

    gemv_static_vector_if<RhsScalar,_ActualRhsType::SizeAtCompileTime,_ActualRhsType::MaxSizeAtCompileTime,!DirectlyUseRhs> static_rhs;

    RhsScalar* actualRhsPtr = (DirectlyUseRhs ? const_cast<RhsScalar*>(actualRhs.data()) : static_rhs.data())!=0 ? (DirectlyUseRhs ? const_cast<RhsScalar*>(actualRhs.data()) : static_rhs.data()) : reinterpret_cast<RhsScalar*>( (sizeof(RhsScalar)*actualRhs.size()<=0) ? __builtin_alloca (sizeof(RhsScalar)*actualRhs.size()) : Eigen::internal::aligned_malloc(sizeof(RhsScalar)*actualRhs.size()) ); Eigen::internal::aligned_stack_memory_handler<RhsScalar> actualRhsPtr_stack_memory_destructor((DirectlyUseRhs ? const_cast<RhsScalar*>(actualRhs.data()) : static_rhs.data())==0 ? actualRhsPtr : 0,actualRhs.size(),sizeof(RhsScalar)*actualRhs.size()>0);


    if(!DirectlyUseRhs)
    {




      Map<typename _ActualRhsType::PlainObject>(actualRhsPtr, actualRhs.size()) = actualRhs;
    }

    general_matrix_vector_product
      <Index,LhsScalar,RowMajor,LhsBlasTraits::NeedToConjugate,RhsScalar,RhsBlasTraits::NeedToConjugate>::run(
        actualLhs.rows(), actualLhs.cols(),
        &actualLhs.coeffRef(0,0), actualLhs.outerStride(),
        actualRhsPtr, 1,
        &dest.coeffRef(0,0), dest.innerStride(),
        actualAlpha);
  }
};

template<> struct gemv_selector<OnTheRight,ColMajor,false>
{
  template<typename ProductType, typename Dest>
  static void run(const ProductType& prod, Dest& dest, typename ProductType::Scalar alpha)
  {
    typedef typename Dest::Index Index;

    const Index size = prod.rhs().rows();
    for(Index k=0; k<size; ++k)
      dest += (alpha*prod.rhs().coeff(k)) * prod.lhs().col(k);
  }
};

template<> struct gemv_selector<OnTheRight,RowMajor,false>
{
  template<typename ProductType, typename Dest>
  static void run(const ProductType& prod, Dest& dest, typename ProductType::Scalar alpha)
  {
    typedef typename Dest::Index Index;

    const Index rows = prod.rows();
    for(Index i=0; i<rows; ++i)
      dest.coeffRef(i) += alpha * (prod.lhs().row(i).cwiseProduct(prod.rhs().transpose())).sum();
  }
};

}
# 560 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Product.h"
template<typename Derived>
template<typename OtherDerived>
inline const typename ProductReturnType<Derived,OtherDerived>::Type
MatrixBase<Derived>::operator*(const MatrixBase<OtherDerived> &other) const
{




  enum {
    ProductIsValid = Derived::ColsAtCompileTime==Dynamic
                   || OtherDerived::RowsAtCompileTime==Dynamic
                   || int(Derived::ColsAtCompileTime)==int(OtherDerived::RowsAtCompileTime),
    AreVectors = Derived::IsVectorAtCompileTime && OtherDerived::IsVectorAtCompileTime,
    SameSizes = ( (int(Derived::SizeAtCompileTime)==0 && int(OtherDerived::SizeAtCompileTime)==0) || ( (int(Derived::RowsAtCompileTime)==Eigen::Dynamic || int(OtherDerived::RowsAtCompileTime)==Eigen::Dynamic || int(Derived::RowsAtCompileTime)==int(OtherDerived::RowsAtCompileTime)) && (int(Derived::ColsAtCompileTime)==Eigen::Dynamic || int(OtherDerived::ColsAtCompileTime)==Eigen::Dynamic || int(Derived::ColsAtCompileTime)==int(OtherDerived::ColsAtCompileTime)) ) )
  };



  if (Eigen::internal::static_assertion<bool(ProductIsValid || !(AreVectors && SameSizes))>::INVALID_VECTOR_VECTOR_PRODUCT__IF_YOU_WANTED_A_DOT_OR_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTIONS) {}

  if (Eigen::internal::static_assertion<bool(ProductIsValid || !(SameSizes && !AreVectors))>::INVALID_MATRIX_PRODUCT__IF_YOU_WANTED_A_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTION) {}

  if (Eigen::internal::static_assertion<bool(ProductIsValid || SameSizes)>::INVALID_MATRIX_PRODUCT) {}



  return typename ProductReturnType<Derived,OtherDerived>::Type(derived(), other.derived());
}
# 601 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Product.h"
template<typename Derived>
template<typename OtherDerived>
const typename LazyProductReturnType<Derived,OtherDerived>::Type
MatrixBase<Derived>::lazyProduct(const MatrixBase<OtherDerived> &other) const
{
  enum {
    ProductIsValid = Derived::ColsAtCompileTime==Dynamic
                   || OtherDerived::RowsAtCompileTime==Dynamic
                   || int(Derived::ColsAtCompileTime)==int(OtherDerived::RowsAtCompileTime),
    AreVectors = Derived::IsVectorAtCompileTime && OtherDerived::IsVectorAtCompileTime,
    SameSizes = ( (int(Derived::SizeAtCompileTime)==0 && int(OtherDerived::SizeAtCompileTime)==0) || ( (int(Derived::RowsAtCompileTime)==Eigen::Dynamic || int(OtherDerived::RowsAtCompileTime)==Eigen::Dynamic || int(Derived::RowsAtCompileTime)==int(OtherDerived::RowsAtCompileTime)) && (int(Derived::ColsAtCompileTime)==Eigen::Dynamic || int(OtherDerived::ColsAtCompileTime)==Eigen::Dynamic || int(Derived::ColsAtCompileTime)==int(OtherDerived::ColsAtCompileTime)) ) )
  };



  if (Eigen::internal::static_assertion<bool(ProductIsValid || !(AreVectors && SameSizes))>::INVALID_VECTOR_VECTOR_PRODUCT__IF_YOU_WANTED_A_DOT_OR_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTIONS) {}

  if (Eigen::internal::static_assertion<bool(ProductIsValid || !(SameSizes && !AreVectors))>::INVALID_MATRIX_PRODUCT__IF_YOU_WANTED_A_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTION) {}

  if (Eigen::internal::static_assertion<bool(ProductIsValid || SameSizes)>::INVALID_MATRIX_PRODUCT) {}

  return typename LazyProductReturnType<Derived,OtherDerived>::Type(derived(), other.derived());
}
# 322 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/TriangularMatrix.h" 1
# 29 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/TriangularMatrix.h"
namespace internal {

template<int Side, typename TriangularType, typename Rhs> struct triangular_solve_retval;

}
# 42 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/TriangularMatrix.h"
template<typename Derived> class TriangularBase : public EigenBase<Derived>
{
  public:

    enum {
      Mode = internal::traits<Derived>::Mode,
      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,
      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,
      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,
      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,
      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime
    };
    typedef typename internal::traits<Derived>::Scalar Scalar;
    typedef typename internal::traits<Derived>::StorageKind StorageKind;
    typedef typename internal::traits<Derived>::Index Index;
    typedef typename internal::traits<Derived>::DenseMatrixType DenseMatrixType;
    typedef DenseMatrixType DenseType;

    inline TriangularBase() { if( (!Eigen::internal::copy_bool(!((Mode&UnitDiag) && (Mode&ZeroDiag)))) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(!((Mode&UnitDiag) && (Mode&ZeroDiag)))) Eigen::internal::assert_fail("!((Mode&UnitDiag) && (Mode&ZeroDiag))", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/TriangularMatrix.h", 60); } while(false); else throw Eigen::eigen_assert_exception(); }; }

    inline Index rows() const { return derived().rows(); }
    inline Index cols() const { return derived().cols(); }
    inline Index outerStride() const { return derived().outerStride(); }
    inline Index innerStride() const { return derived().innerStride(); }

    inline Scalar coeff(Index row, Index col) const { return derived().coeff(row,col); }
    inline Scalar& coeffRef(Index row, Index col) { return derived().coeffRef(row,col); }



    template<typename Other>
    inline void copyCoeff(Index row, Index col, Other& other)
    {
      derived().coeffRef(row, col) = other.coeff(row, col);
    }

    inline Scalar operator()(Index row, Index col) const
    {
      check_coordinates(row, col);
      return coeff(row,col);
    }
    inline Scalar& operator()(Index row, Index col)
    {
      check_coordinates(row, col);
      return coeffRef(row,col);
    }


    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }
    inline Derived& derived() { return *static_cast<Derived*>(this); }


    template<typename DenseDerived>
    void evalTo(MatrixBase<DenseDerived> &other) const;
    template<typename DenseDerived>
    void evalToLazy(MatrixBase<DenseDerived> &other) const;

    DenseMatrixType toDenseMatrix() const
    {
      DenseMatrixType res(rows(), cols());
      evalToLazy(res);
      return res;
    }

  protected:

    void check_coordinates(Index row, Index col) const
    {
                                    ;
                                    ;
      if( (!Eigen::internal::copy_bool(col>=0 && col<cols() && row>=0 && row<rows())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(col>=0 && col<cols() && row>=0 && row<rows())) Eigen::internal::assert_fail("col>=0 && col<cols() && row>=0 && row<rows()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/TriangularMatrix.h", 112); } while(false); else throw Eigen::eigen_assert_exception(); };
      const int mode = int(Mode) & ~SelfAdjoint;
                                     ;
      if( (!Eigen::internal::copy_bool((mode==Upper && col>=row) || (mode==Lower && col<=row) || ((mode==StrictlyUpper || mode==UnitUpper) && col>row) || ((mode==StrictlyLower || mode==UnitLower) && col<row))) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool((mode==Upper && col>=row) || (mode==Lower && col<=row) || ((mode==StrictlyUpper || mode==UnitUpper) && col>row) || ((mode==StrictlyLower || mode==UnitLower) && col<row))) Eigen::internal::assert_fail("(mode==Upper && col>=row) || (mode==Lower && col<=row) || ((mode==StrictlyUpper || mode==UnitUpper) && col>row) || ((mode==StrictlyLower || mode==UnitLower) && col<row)", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/TriangularMatrix.h", 118); } while(false); else throw Eigen::eigen_assert_exception(); };



    }


    void check_coordinates_internal(Index row, Index col) const
    {
      check_coordinates(row, col);
    }




};
# 149 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/TriangularMatrix.h"
namespace internal {
template<typename MatrixType, unsigned int _Mode>
struct traits<TriangularView<MatrixType, _Mode> > : traits<MatrixType>
{
  typedef typename nested<MatrixType>::type MatrixTypeNested;
  typedef typename remove_reference<MatrixTypeNested>::type MatrixTypeNestedNonRef;
  typedef typename remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;
  typedef MatrixType ExpressionType;
  typedef typename MatrixType::PlainObject DenseMatrixType;
  enum {
    Mode = _Mode,
    Flags = (MatrixTypeNestedCleaned::Flags & (HereditaryBits) & (~(PacketAccessBit | DirectAccessBit | LinearAccessBit))) | Mode,
    CoeffReadCost = MatrixTypeNestedCleaned::CoeffReadCost
  };
};
}

template<int Mode, bool LhsIsTriangular,
         typename Lhs, bool LhsIsVector,
         typename Rhs, bool RhsIsVector>
struct TriangularProduct;

template<typename _MatrixType, unsigned int _Mode> class TriangularView
  : public TriangularBase<TriangularView<_MatrixType, _Mode> >
{
  public:

    typedef TriangularBase<TriangularView> Base;
    typedef typename internal::traits<TriangularView>::Scalar Scalar;

    typedef _MatrixType MatrixType;
    typedef typename internal::traits<TriangularView>::DenseMatrixType DenseMatrixType;
    typedef DenseMatrixType PlainObject;

  protected:
    typedef typename internal::traits<TriangularView>::MatrixTypeNested MatrixTypeNested;
    typedef typename internal::traits<TriangularView>::MatrixTypeNestedNonRef MatrixTypeNestedNonRef;
    typedef typename internal::traits<TriangularView>::MatrixTypeNestedCleaned MatrixTypeNestedCleaned;

    typedef typename internal::remove_all<typename MatrixType::ConjugateReturnType>::type MatrixConjugateReturnType;

  public:
    using Base::evalToLazy;


    typedef typename internal::traits<TriangularView>::StorageKind StorageKind;
    typedef typename internal::traits<TriangularView>::Index Index;

    enum {
      Mode = _Mode,
      TransposeMode = (Mode & Upper ? Lower : 0)
                    | (Mode & Lower ? Upper : 0)
                    | (Mode & (UnitDiag))
                    | (Mode & (ZeroDiag))
    };

    inline TriangularView(const MatrixType& matrix) : m_matrix(matrix)
    {}

    inline Index rows() const { return m_matrix.rows(); }
    inline Index cols() const { return m_matrix.cols(); }
    inline Index outerStride() const { return m_matrix.outerStride(); }
    inline Index innerStride() const { return m_matrix.innerStride(); }


    template<typename Other> TriangularView& operator+=(const DenseBase<Other>& other) { return *this = m_matrix + other.derived(); }

    template<typename Other> TriangularView& operator-=(const DenseBase<Other>& other) { return *this = m_matrix - other.derived(); }

    TriangularView& operator*=(const typename internal::traits<MatrixType>::Scalar& other) { return *this = m_matrix * other; }

    TriangularView& operator/=(const typename internal::traits<MatrixType>::Scalar& other) { return *this = m_matrix / other; }


    void fill(const Scalar& value) { setConstant(value); }

    TriangularView& setConstant(const Scalar& value)
    { return *this = MatrixType::Constant(rows(), cols(), value); }

    TriangularView& setZero() { return setConstant(Scalar(0)); }

    TriangularView& setOnes() { return setConstant(Scalar(1)); }




    inline Scalar coeff(Index row, Index col) const
    {
      Base::check_coordinates_internal(row, col);
      return m_matrix.coeff(row, col);
    }




    inline Scalar& coeffRef(Index row, Index col)
    {
      Base::check_coordinates_internal(row, col);
      return m_matrix.const_cast_derived().coeffRef(row, col);
    }

    const MatrixTypeNestedCleaned& nestedExpression() const { return m_matrix; }
    MatrixTypeNestedCleaned& nestedExpression() { return *const_cast<MatrixTypeNestedCleaned*>(&m_matrix); }


    template<typename OtherDerived>
    TriangularView& operator=(const TriangularBase<OtherDerived>& other);

    template<typename OtherDerived>
    TriangularView& operator=(const MatrixBase<OtherDerived>& other);

    TriangularView& operator=(const TriangularView& other)
    { return *this = other.nestedExpression(); }

    template<typename OtherDerived>
    void lazyAssign(const TriangularBase<OtherDerived>& other);

    template<typename OtherDerived>
    void lazyAssign(const MatrixBase<OtherDerived>& other);


    inline TriangularView<MatrixConjugateReturnType,Mode> conjugate()
    { return m_matrix.conjugate(); }

    inline const TriangularView<MatrixConjugateReturnType,Mode> conjugate() const
    { return m_matrix.conjugate(); }


    inline TriangularView<typename MatrixType::AdjointReturnType,TransposeMode> adjoint()
    { return m_matrix.adjoint(); }

    inline const TriangularView<typename MatrixType::AdjointReturnType,TransposeMode> adjoint() const
    { return m_matrix.adjoint(); }


    inline TriangularView<Transpose<MatrixType>,TransposeMode> transpose()
    {
      if (Eigen::internal::static_assertion<bool(internal::is_lvalue<MatrixType>::value)>::THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY) {}
      return m_matrix.const_cast_derived().transpose();
    }

    inline const TriangularView<Transpose<MatrixType>,TransposeMode> transpose() const
    { return m_matrix.transpose(); }


    template<typename OtherDerived>
    TriangularProduct<Mode,true,MatrixType,false,OtherDerived,OtherDerived::IsVectorAtCompileTime>
    operator*(const MatrixBase<OtherDerived>& rhs) const
    {
      return TriangularProduct
              <Mode,true,MatrixType,false,OtherDerived,OtherDerived::IsVectorAtCompileTime>
              (m_matrix, rhs.derived());
    }


    template<typename OtherDerived> friend
    TriangularProduct<Mode,false,OtherDerived,OtherDerived::IsVectorAtCompileTime,MatrixType,false>
    operator*(const MatrixBase<OtherDerived>& lhs, const TriangularView& rhs)
    {
      return TriangularProduct
              <Mode,false,OtherDerived,OtherDerived::IsVectorAtCompileTime,MatrixType,false>
              (lhs.derived(),rhs.m_matrix);
    }
# 342 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/TriangularMatrix.h"
    template<int Side, typename Other>
    inline const internal::triangular_solve_retval<Side,TriangularView, Other>
    solve(const MatrixBase<Other>& other) const;

    template<int Side, typename OtherDerived>
    void solveInPlace(const MatrixBase<OtherDerived>& other) const;

    template<typename Other>
    inline const internal::triangular_solve_retval<OnTheLeft,TriangularView, Other>
    solve(const MatrixBase<Other>& other) const
    { return solve<OnTheLeft>(other); }

    template<typename OtherDerived>
    void solveInPlace(const MatrixBase<OtherDerived>& other) const
    { return solveInPlace<OnTheLeft>(other); }

    const SelfAdjointView<MatrixTypeNestedNonRef,Mode> selfadjointView() const
    {
      if (Eigen::internal::static_assertion<bool((Mode&UnitDiag)==0)>::PROGRAMMING_ERROR) {};
      return SelfAdjointView<MatrixTypeNestedNonRef,Mode>(m_matrix);
    }
    SelfAdjointView<MatrixTypeNestedNonRef,Mode> selfadjointView()
    {
      if (Eigen::internal::static_assertion<bool((Mode&UnitDiag)==0)>::PROGRAMMING_ERROR) {};
      return SelfAdjointView<MatrixTypeNestedNonRef,Mode>(m_matrix);
    }

    template<typename OtherDerived>
    void swap(TriangularBase<OtherDerived> const & other)
    {
      TriangularView<SwapWrapper<MatrixType>,Mode>(const_cast<MatrixType&>(m_matrix)).lazyAssign(other.derived());
    }

    template<typename OtherDerived>
    void swap(MatrixBase<OtherDerived> const & other)
    {
      TriangularView<SwapWrapper<MatrixType>,Mode>(const_cast<MatrixType&>(m_matrix)).lazyAssign(other.derived());
    }

    Scalar determinant() const
    {
      if (Mode & UnitDiag)
        return 1;
      else if (Mode & ZeroDiag)
        return 0;
      else
        return m_matrix.diagonal().prod();
    }


    template<typename ProductDerived, typename Lhs, typename Rhs>
    inline TriangularView& operator=(const ProductBase<ProductDerived, Lhs,Rhs>& other)
    {
      setZero();
      return assignProduct(other,1);
    }

    template<typename ProductDerived, typename Lhs, typename Rhs>
    inline TriangularView& operator+=(const ProductBase<ProductDerived, Lhs,Rhs>& other)
    {
      return assignProduct(other,1);
    }

    template<typename ProductDerived, typename Lhs, typename Rhs>
    inline TriangularView& operator-=(const ProductBase<ProductDerived, Lhs,Rhs>& other)
    {
      return assignProduct(other,-1);
    }


    template<typename ProductDerived>
    inline TriangularView& operator=(const ScaledProduct<ProductDerived>& other)
    {
      setZero();
      return assignProduct(other,other.alpha());
    }

    template<typename ProductDerived>
    inline TriangularView& operator+=(const ScaledProduct<ProductDerived>& other)
    {
      return assignProduct(other,other.alpha());
    }

    template<typename ProductDerived>
    inline TriangularView& operator-=(const ScaledProduct<ProductDerived>& other)
    {
      return assignProduct(other,-other.alpha());
    }

  protected:

    template<typename ProductDerived, typename Lhs, typename Rhs>
    inline TriangularView& assignProduct(const ProductBase<ProductDerived, Lhs,Rhs>& prod, const Scalar& alpha);

    const MatrixTypeNested m_matrix;
};





namespace internal {

template<typename Derived1, typename Derived2, unsigned int Mode, int UnrollCount, bool ClearOpposite>
struct triangular_assignment_selector
{
  enum {
    col = (UnrollCount-1) / Derived1::RowsAtCompileTime,
    row = (UnrollCount-1) % Derived1::RowsAtCompileTime
  };

  typedef typename Derived1::Scalar Scalar;

  inline static void run(Derived1 &dst, const Derived2 &src)
  {
    triangular_assignment_selector<Derived1, Derived2, Mode, UnrollCount-1, ClearOpposite>::run(dst, src);

    if( (!Eigen::internal::copy_bool(Mode == Upper || Mode == Lower || Mode == StrictlyUpper || Mode == StrictlyLower || Mode == UnitUpper || Mode == UnitLower)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(Mode == Upper || Mode == Lower || Mode == StrictlyUpper || Mode == StrictlyLower || Mode == UnitUpper || Mode == UnitLower)) Eigen::internal::assert_fail("Mode == Upper || Mode == Lower || Mode == StrictlyUpper || Mode == StrictlyLower || Mode == UnitUpper || Mode == UnitLower", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/TriangularMatrix.h", 461); } while(false); else throw Eigen::eigen_assert_exception(); };


    if((Mode == Upper && row <= col)
    || (Mode == Lower && row >= col)
    || (Mode == StrictlyUpper && row < col)
    || (Mode == StrictlyLower && row > col)
    || (Mode == UnitUpper && row < col)
    || (Mode == UnitLower && row > col))
      dst.copyCoeff(row, col, src);
    else if(ClearOpposite)
    {
      if (Mode&UnitDiag && row==col)
        dst.coeffRef(row, col) = Scalar(1);
      else
        dst.coeffRef(row, col) = Scalar(0);
    }
  }
};


template<typename Derived1, typename Derived2, unsigned int Mode, bool ClearOpposite>
struct triangular_assignment_selector<Derived1, Derived2, Mode, 0, ClearOpposite>
{
  inline static void run(Derived1 &, const Derived2 &) {}
};

template<typename Derived1, typename Derived2, bool ClearOpposite>
struct triangular_assignment_selector<Derived1, Derived2, Upper, Dynamic, ClearOpposite>
{
  typedef typename Derived1::Index Index;
  typedef typename Derived1::Scalar Scalar;
  inline static void run(Derived1 &dst, const Derived2 &src)
  {
    for(Index j = 0; j < dst.cols(); ++j)
    {
      Index maxi = (std::min)(j, dst.rows()-1);
      for(Index i = 0; i <= maxi; ++i)
        dst.copyCoeff(i, j, src);
      if (ClearOpposite)
        for(Index i = maxi+1; i < dst.rows(); ++i)
          dst.coeffRef(i, j) = Scalar(0);
    }
  }
};

template<typename Derived1, typename Derived2, bool ClearOpposite>
struct triangular_assignment_selector<Derived1, Derived2, Lower, Dynamic, ClearOpposite>
{
  typedef typename Derived1::Index Index;
  inline static void run(Derived1 &dst, const Derived2 &src)
  {
    for(Index j = 0; j < dst.cols(); ++j)
    {
      for(Index i = j; i < dst.rows(); ++i)
        dst.copyCoeff(i, j, src);
      Index maxi = (std::min)(j, dst.rows());
      if (ClearOpposite)
        for(Index i = 0; i < maxi; ++i)
          dst.coeffRef(i, j) = static_cast<typename Derived1::Scalar>(0);
    }
  }
};

template<typename Derived1, typename Derived2, bool ClearOpposite>
struct triangular_assignment_selector<Derived1, Derived2, StrictlyUpper, Dynamic, ClearOpposite>
{
  typedef typename Derived1::Index Index;
  inline static void run(Derived1 &dst, const Derived2 &src)
  {
    for(Index j = 0; j < dst.cols(); ++j)
    {
      Index maxi = (std::min)(j, dst.rows());
      for(Index i = 0; i < maxi; ++i)
        dst.copyCoeff(i, j, src);
      if (ClearOpposite)
        for(Index i = maxi; i < dst.rows(); ++i)
          dst.coeffRef(i, j) = 0;
    }
  }
};

template<typename Derived1, typename Derived2, bool ClearOpposite>
struct triangular_assignment_selector<Derived1, Derived2, StrictlyLower, Dynamic, ClearOpposite>
{
  typedef typename Derived1::Index Index;
  inline static void run(Derived1 &dst, const Derived2 &src)
  {
    for(Index j = 0; j < dst.cols(); ++j)
    {
      for(Index i = j+1; i < dst.rows(); ++i)
        dst.copyCoeff(i, j, src);
      Index maxi = (std::min)(j, dst.rows()-1);
      if (ClearOpposite)
        for(Index i = 0; i <= maxi; ++i)
          dst.coeffRef(i, j) = static_cast<typename Derived1::Scalar>(0);
    }
  }
};

template<typename Derived1, typename Derived2, bool ClearOpposite>
struct triangular_assignment_selector<Derived1, Derived2, UnitUpper, Dynamic, ClearOpposite>
{
  typedef typename Derived1::Index Index;
  inline static void run(Derived1 &dst, const Derived2 &src)
  {
    for(Index j = 0; j < dst.cols(); ++j)
    {
      Index maxi = (std::min)(j, dst.rows());
      for(Index i = 0; i < maxi; ++i)
        dst.copyCoeff(i, j, src);
      if (ClearOpposite)
      {
        for(Index i = maxi+1; i < dst.rows(); ++i)
          dst.coeffRef(i, j) = 0;
      }
    }
    dst.diagonal().setOnes();
  }
};
template<typename Derived1, typename Derived2, bool ClearOpposite>
struct triangular_assignment_selector<Derived1, Derived2, UnitLower, Dynamic, ClearOpposite>
{
  typedef typename Derived1::Index Index;
  inline static void run(Derived1 &dst, const Derived2 &src)
  {
    for(Index j = 0; j < dst.cols(); ++j)
    {
      Index maxi = (std::min)(j, dst.rows());
      for(Index i = maxi+1; i < dst.rows(); ++i)
        dst.copyCoeff(i, j, src);
      if (ClearOpposite)
      {
        for(Index i = 0; i < maxi; ++i)
          dst.coeffRef(i, j) = 0;
      }
    }
    dst.diagonal().setOnes();
  }
};

}


template<typename MatrixType, unsigned int Mode>
template<typename OtherDerived>
inline TriangularView<MatrixType, Mode>&
TriangularView<MatrixType, Mode>::operator=(const MatrixBase<OtherDerived>& other)
{
  if(OtherDerived::Flags & EvalBeforeAssigningBit)
  {
    typename internal::plain_matrix_type<OtherDerived>::type other_evaluated(other.rows(), other.cols());
    other_evaluated.template triangularView<Mode>().lazyAssign(other.derived());
    lazyAssign(other_evaluated);
  }
  else
    lazyAssign(other.derived());
  return *this;
}


template<typename MatrixType, unsigned int Mode>
template<typename OtherDerived>
void TriangularView<MatrixType, Mode>::lazyAssign(const MatrixBase<OtherDerived>& other)
{
  enum {
    unroll = MatrixType::SizeAtCompileTime != Dynamic
          && internal::traits<OtherDerived>::CoeffReadCost != Dynamic
          && MatrixType::SizeAtCompileTime*internal::traits<OtherDerived>::CoeffReadCost/2 <= 100
  };
  if( (!Eigen::internal::copy_bool(m_matrix.rows() == other.rows() && m_matrix.cols() == other.cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_matrix.rows() == other.rows() && m_matrix.cols() == other.cols())) Eigen::internal::assert_fail("m_matrix.rows() == other.rows() && m_matrix.cols() == other.cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/TriangularMatrix.h", 629); } while(false); else throw Eigen::eigen_assert_exception(); };

  internal::triangular_assignment_selector
    <MatrixType, OtherDerived, int(Mode),
    unroll ? int(MatrixType::SizeAtCompileTime) : Dynamic,
    false
    >::run(m_matrix.const_cast_derived(), other.derived());
}



template<typename MatrixType, unsigned int Mode>
template<typename OtherDerived>
inline TriangularView<MatrixType, Mode>&
TriangularView<MatrixType, Mode>::operator=(const TriangularBase<OtherDerived>& other)
{
  if( (!Eigen::internal::copy_bool(Mode == int(OtherDerived::Mode))) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(Mode == int(OtherDerived::Mode))) Eigen::internal::assert_fail("Mode == int(OtherDerived::Mode)", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/TriangularMatrix.h", 645); } while(false); else throw Eigen::eigen_assert_exception(); };
  if(internal::traits<OtherDerived>::Flags & EvalBeforeAssigningBit)
  {
    typename OtherDerived::DenseMatrixType other_evaluated(other.rows(), other.cols());
    other_evaluated.template triangularView<Mode>().lazyAssign(other.derived().nestedExpression());
    lazyAssign(other_evaluated);
  }
  else
    lazyAssign(other.derived().nestedExpression());
  return *this;
}

template<typename MatrixType, unsigned int Mode>
template<typename OtherDerived>
void TriangularView<MatrixType, Mode>::lazyAssign(const TriangularBase<OtherDerived>& other)
{
  enum {
    unroll = MatrixType::SizeAtCompileTime != Dynamic
                   && internal::traits<OtherDerived>::CoeffReadCost != Dynamic
                   && MatrixType::SizeAtCompileTime * internal::traits<OtherDerived>::CoeffReadCost / 2
                        <= 100
  };
  if( (!Eigen::internal::copy_bool(m_matrix.rows() == other.rows() && m_matrix.cols() == other.cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_matrix.rows() == other.rows() && m_matrix.cols() == other.cols())) Eigen::internal::assert_fail("m_matrix.rows() == other.rows() && m_matrix.cols() == other.cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/TriangularMatrix.h", 667); } while(false); else throw Eigen::eigen_assert_exception(); };

  internal::triangular_assignment_selector
    <MatrixType, OtherDerived, int(Mode),
    unroll ? int(MatrixType::SizeAtCompileTime) : Dynamic,
    false
    >::run(m_matrix.const_cast_derived(), other.derived().nestedExpression());
}







template<typename Derived>
template<typename DenseDerived>
void TriangularBase<Derived>::evalTo(MatrixBase<DenseDerived> &other) const
{
  if(internal::traits<Derived>::Flags & EvalBeforeAssigningBit)
  {
    typename internal::plain_matrix_type<Derived>::type other_evaluated(rows(), cols());
    evalToLazy(other_evaluated);
    other.derived().swap(other_evaluated);
  }
  else
    evalToLazy(other.derived());
}



template<typename Derived>
template<typename DenseDerived>
void TriangularBase<Derived>::evalToLazy(MatrixBase<DenseDerived> &other) const
{
  enum {
    unroll = DenseDerived::SizeAtCompileTime != Dynamic
                   && internal::traits<Derived>::CoeffReadCost != Dynamic
                   && DenseDerived::SizeAtCompileTime * internal::traits<Derived>::CoeffReadCost / 2
                        <= 100
  };
  other.derived().resize(this->rows(), this->cols());

  internal::triangular_assignment_selector
    <DenseDerived, typename internal::traits<Derived>::MatrixTypeNestedCleaned, Derived::Mode,
    unroll ? int(DenseDerived::SizeAtCompileTime) : Dynamic,
    true
    >::run(other.derived(), derived().nestedExpression());
}
# 771 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/TriangularMatrix.h"
template<typename Derived>
template<unsigned int Mode>
typename MatrixBase<Derived>::template TriangularViewReturnType<Mode>::Type
MatrixBase<Derived>::triangularView()
{
  return derived();
}


template<typename Derived>
template<unsigned int Mode>
typename MatrixBase<Derived>::template ConstTriangularViewReturnType<Mode>::Type
MatrixBase<Derived>::triangularView() const
{
  return derived();
}






template<typename Derived>
bool MatrixBase<Derived>::isUpperTriangular(RealScalar prec) const
{
  RealScalar maxAbsOnUpperPart = static_cast<RealScalar>(-1);
  for(Index j = 0; j < cols(); ++j)
  {
    Index maxi = (std::min)(j, rows()-1);
    for(Index i = 0; i <= maxi; ++i)
    {
      RealScalar absValue = internal::abs(coeff(i,j));
      if(absValue > maxAbsOnUpperPart) maxAbsOnUpperPart = absValue;
    }
  }
  RealScalar threshold = maxAbsOnUpperPart * prec;
  for(Index j = 0; j < cols(); ++j)
    for(Index i = j+1; i < rows(); ++i)
      if(internal::abs(coeff(i, j)) > threshold) return false;
  return true;
}






template<typename Derived>
bool MatrixBase<Derived>::isLowerTriangular(RealScalar prec) const
{
  RealScalar maxAbsOnLowerPart = static_cast<RealScalar>(-1);
  for(Index j = 0; j < cols(); ++j)
    for(Index i = j; i < rows(); ++i)
    {
      RealScalar absValue = internal::abs(coeff(i,j));
      if(absValue > maxAbsOnLowerPart) maxAbsOnLowerPart = absValue;
    }
  RealScalar threshold = maxAbsOnLowerPart * prec;
  for(Index j = 1; j < cols(); ++j)
  {
    Index maxi = (std::min)(j, rows()-1);
    for(Index i = 0; i < maxi; ++i)
      if(internal::abs(coeff(i, j)) > threshold) return false;
  }
  return true;
}
# 323 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/SelfAdjointView.h" 1
# 44 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/SelfAdjointView.h"
namespace internal {
template<typename MatrixType, unsigned int UpLo>
struct traits<SelfAdjointView<MatrixType, UpLo> > : traits<MatrixType>
{
  typedef typename nested<MatrixType>::type MatrixTypeNested;
  typedef typename remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;
  typedef MatrixType ExpressionType;
  typedef typename MatrixType::PlainObject DenseMatrixType;
  enum {
    Mode = UpLo | SelfAdjoint,
    Flags = MatrixTypeNestedCleaned::Flags & (HereditaryBits)
           & (~(PacketAccessBit | DirectAccessBit | LinearAccessBit)),
    CoeffReadCost = MatrixTypeNestedCleaned::CoeffReadCost
  };
};
}

template <typename Lhs, int LhsMode, bool LhsIsVector,
          typename Rhs, int RhsMode, bool RhsIsVector>
struct SelfadjointProductMatrix;


template<typename MatrixType, unsigned int UpLo> class SelfAdjointView
  : public TriangularBase<SelfAdjointView<MatrixType, UpLo> >
{
  public:

    typedef TriangularBase<SelfAdjointView> Base;
    typedef typename internal::traits<SelfAdjointView>::MatrixTypeNested MatrixTypeNested;
    typedef typename internal::traits<SelfAdjointView>::MatrixTypeNestedCleaned MatrixTypeNestedCleaned;


    typedef typename internal::traits<SelfAdjointView>::Scalar Scalar;

    typedef typename MatrixType::Index Index;

    enum {
      Mode = internal::traits<SelfAdjointView>::Mode
    };
    typedef typename MatrixType::PlainObject PlainObject;

    inline SelfAdjointView(const MatrixType& matrix) : m_matrix(matrix)
    {}

    inline Index rows() const { return m_matrix.rows(); }
    inline Index cols() const { return m_matrix.cols(); }
    inline Index outerStride() const { return m_matrix.outerStride(); }
    inline Index innerStride() const { return m_matrix.innerStride(); }




    inline Scalar coeff(Index row, Index col) const
    {
      Base::check_coordinates_internal(row, col);
      return m_matrix.coeff(row, col);
    }




    inline Scalar& coeffRef(Index row, Index col)
    {
      Base::check_coordinates_internal(row, col);
      return m_matrix.const_cast_derived().coeffRef(row, col);
    }


    const MatrixTypeNestedCleaned& _expression() const { return m_matrix; }

    const MatrixTypeNestedCleaned& nestedExpression() const { return m_matrix; }
    MatrixTypeNestedCleaned& nestedExpression() { return *const_cast<MatrixTypeNestedCleaned*>(&m_matrix); }


    template<typename OtherDerived>
    SelfadjointProductMatrix<MatrixType,Mode,false,OtherDerived,0,OtherDerived::IsVectorAtCompileTime>
    operator*(const MatrixBase<OtherDerived>& rhs) const
    {
      return SelfadjointProductMatrix
              <MatrixType,Mode,false,OtherDerived,0,OtherDerived::IsVectorAtCompileTime>
              (m_matrix, rhs.derived());
    }


    template<typename OtherDerived> friend
    SelfadjointProductMatrix<OtherDerived,0,OtherDerived::IsVectorAtCompileTime,MatrixType,Mode,false>
    operator*(const MatrixBase<OtherDerived>& lhs, const SelfAdjointView& rhs)
    {
      return SelfadjointProductMatrix
              <OtherDerived,0,OtherDerived::IsVectorAtCompileTime,MatrixType,Mode,false>
              (lhs.derived(),rhs.m_matrix);
    }
# 147 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/SelfAdjointView.h"
    template<typename DerivedU, typename DerivedV>
    SelfAdjointView& rankUpdate(const MatrixBase<DerivedU>& u, const MatrixBase<DerivedV>& v, Scalar alpha = Scalar(1));
# 160 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/SelfAdjointView.h"
    template<typename DerivedU>
    SelfAdjointView& rankUpdate(const MatrixBase<DerivedU>& u, Scalar alpha = Scalar(1));



    const LLT<PlainObject, UpLo> llt() const;
    const LDLT<PlainObject, UpLo> ldlt() const;




    typedef typename NumTraits<Scalar>::Real RealScalar;

    typedef Matrix<RealScalar, internal::traits<MatrixType>::ColsAtCompileTime, 1> EigenvaluesReturnType;

    EigenvaluesReturnType eigenvalues() const;
    RealScalar operatorNorm() const;
# 201 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/SelfAdjointView.h"
  protected:
    const MatrixTypeNested m_matrix;
};
# 215 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/SelfAdjointView.h"
namespace internal {

template<typename Derived1, typename Derived2, int UnrollCount, bool ClearOpposite>
struct triangular_assignment_selector<Derived1, Derived2, (SelfAdjoint|Upper), UnrollCount, ClearOpposite>
{
  enum {
    col = (UnrollCount-1) / Derived1::RowsAtCompileTime,
    row = (UnrollCount-1) % Derived1::RowsAtCompileTime
  };

  inline static void run(Derived1 &dst, const Derived2 &src)
  {
    triangular_assignment_selector<Derived1, Derived2, (SelfAdjoint|Upper), UnrollCount-1, ClearOpposite>::run(dst, src);

    if(row == col)
      dst.coeffRef(row, col) = real(src.coeff(row, col));
    else if(row < col)
      dst.coeffRef(col, row) = conj(dst.coeffRef(row, col) = src.coeff(row, col));
  }
};

template<typename Derived1, typename Derived2, bool ClearOpposite>
struct triangular_assignment_selector<Derived1, Derived2, SelfAdjoint|Upper, 0, ClearOpposite>
{
  inline static void run(Derived1 &, const Derived2 &) {}
};

template<typename Derived1, typename Derived2, int UnrollCount, bool ClearOpposite>
struct triangular_assignment_selector<Derived1, Derived2, (SelfAdjoint|Lower), UnrollCount, ClearOpposite>
{
  enum {
    col = (UnrollCount-1) / Derived1::RowsAtCompileTime,
    row = (UnrollCount-1) % Derived1::RowsAtCompileTime
  };

  inline static void run(Derived1 &dst, const Derived2 &src)
  {
    triangular_assignment_selector<Derived1, Derived2, (SelfAdjoint|Lower), UnrollCount-1, ClearOpposite>::run(dst, src);

    if(row == col)
      dst.coeffRef(row, col) = real(src.coeff(row, col));
    else if(row > col)
      dst.coeffRef(col, row) = conj(dst.coeffRef(row, col) = src.coeff(row, col));
  }
};

template<typename Derived1, typename Derived2, bool ClearOpposite>
struct triangular_assignment_selector<Derived1, Derived2, SelfAdjoint|Lower, 0, ClearOpposite>
{
  inline static void run(Derived1 &, const Derived2 &) {}
};

template<typename Derived1, typename Derived2, bool ClearOpposite>
struct triangular_assignment_selector<Derived1, Derived2, SelfAdjoint|Upper, Dynamic, ClearOpposite>
{
  typedef typename Derived1::Index Index;
  inline static void run(Derived1 &dst, const Derived2 &src)
  {
    for(Index j = 0; j < dst.cols(); ++j)
    {
      for(Index i = 0; i < j; ++i)
      {
        dst.copyCoeff(i, j, src);
        dst.coeffRef(j,i) = conj(dst.coeff(i,j));
      }
      dst.copyCoeff(j, j, src);
    }
  }
};

template<typename Derived1, typename Derived2, bool ClearOpposite>
struct triangular_assignment_selector<Derived1, Derived2, SelfAdjoint|Lower, Dynamic, ClearOpposite>
{
  inline static void run(Derived1 &dst, const Derived2 &src)
  {
  typedef typename Derived1::Index Index;
    for(Index i = 0; i < dst.rows(); ++i)
    {
      for(Index j = 0; j < i; ++j)
      {
        dst.copyCoeff(i, j, src);
        dst.coeffRef(j,i) = conj(dst.coeff(i,j));
      }
      dst.copyCoeff(i, i, src);
    }
  }
};

}





template<typename Derived>
template<unsigned int UpLo>
typename MatrixBase<Derived>::template ConstSelfAdjointViewReturnType<UpLo>::Type
MatrixBase<Derived>::selfadjointView() const
{
  return derived();
}

template<typename Derived>
template<unsigned int UpLo>
typename MatrixBase<Derived>::template SelfAdjointViewReturnType<UpLo>::Type
MatrixBase<Derived>::selfadjointView()
{
  return derived();
}
# 324 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/SolveTriangular.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/SolveTriangular.h"
namespace internal {



template<typename LhsScalar, typename RhsScalar, typename Index, int Side, int Mode, bool Conjugate, int StorageOrder>
struct triangular_solve_vector;

template <typename Scalar, typename Index, int Side, int Mode, bool Conjugate, int TriStorageOrder, int OtherStorageOrder>
struct triangular_solve_matrix;


template<typename Lhs, typename Rhs, int Side>
class trsolve_traits
{
  private:
    enum {
      RhsIsVectorAtCompileTime = (Side==OnTheLeft ? Rhs::ColsAtCompileTime : Rhs::RowsAtCompileTime)==1
    };
  public:
    enum {
      Unrolling = (RhsIsVectorAtCompileTime && Rhs::SizeAtCompileTime != Dynamic && Rhs::SizeAtCompileTime <= 8)
                  ? CompleteUnrolling : NoUnrolling,
      RhsVectors = RhsIsVectorAtCompileTime ? 1 : Dynamic
    };
};

template<typename Lhs, typename Rhs,
  int Side,
  int Mode,
  int Unrolling = trsolve_traits<Lhs,Rhs,Side>::Unrolling,
  int RhsVectors = trsolve_traits<Lhs,Rhs,Side>::RhsVectors
  >
struct triangular_solver_selector;

template<typename Lhs, typename Rhs, int Side, int Mode>
struct triangular_solver_selector<Lhs,Rhs,Side,Mode,NoUnrolling,1>
{
  typedef typename Lhs::Scalar LhsScalar;
  typedef typename Rhs::Scalar RhsScalar;
  typedef blas_traits<Lhs> LhsProductTraits;
  typedef typename LhsProductTraits::ExtractType ActualLhsType;
  typedef Map<Matrix<RhsScalar,Dynamic,1>, Aligned> MappedRhs;
  static void run(const Lhs& lhs, Rhs& rhs)
  {
    ActualLhsType actualLhs = LhsProductTraits::extract(lhs);



    bool useRhsDirectly = Rhs::InnerStrideAtCompileTime==1 || rhs.innerStride()==1;

    RhsScalar* actualRhs = ((useRhsDirectly ? rhs.data() : 0))!=0 ? ((useRhsDirectly ? rhs.data() : 0)) : reinterpret_cast<RhsScalar*>( (sizeof(RhsScalar)*rhs.size()<=0) ? __builtin_alloca (sizeof(RhsScalar)*rhs.size()) : Eigen::internal::aligned_malloc(sizeof(RhsScalar)*rhs.size()) ); Eigen::internal::aligned_stack_memory_handler<RhsScalar> actualRhs_stack_memory_destructor(((useRhsDirectly ? rhs.data() : 0))==0 ? actualRhs : 0,rhs.size(),sizeof(RhsScalar)*rhs.size()>0);


    if(!useRhsDirectly)
      MappedRhs(actualRhs,rhs.size()) = rhs;

    triangular_solve_vector<LhsScalar, RhsScalar, typename Lhs::Index, Side, Mode, LhsProductTraits::NeedToConjugate,
                            (int(Lhs::Flags) & RowMajorBit) ? RowMajor : ColMajor>
      ::run(actualLhs.cols(), actualLhs.data(), actualLhs.outerStride(), actualRhs);

    if(!useRhsDirectly)
      rhs = MappedRhs(actualRhs, rhs.size());
  }
};


template<typename Lhs, typename Rhs, int Side, int Mode>
struct triangular_solver_selector<Lhs,Rhs,Side,Mode,NoUnrolling,Dynamic>
{
  typedef typename Rhs::Scalar Scalar;
  typedef typename Rhs::Index Index;
  typedef blas_traits<Lhs> LhsProductTraits;
  typedef typename LhsProductTraits::DirectLinearAccessType ActualLhsType;
  static void run(const Lhs& lhs, Rhs& rhs)
  {
    const ActualLhsType actualLhs = LhsProductTraits::extract(lhs);
    triangular_solve_matrix<Scalar,Index,Side,Mode,LhsProductTraits::NeedToConjugate,(int(Lhs::Flags) & RowMajorBit) ? RowMajor : ColMajor,
                               (Rhs::Flags&RowMajorBit) ? RowMajor : ColMajor>
      ::run(lhs.rows(), Side==OnTheLeft? rhs.cols() : rhs.rows(), &actualLhs.coeffRef(0,0), actualLhs.outerStride(), &rhs.coeffRef(0,0), rhs.outerStride());
  }
};





template<typename Lhs, typename Rhs, int Mode, int Index, int Size,
         bool Stop = Index==Size>
struct triangular_solver_unroller;

template<typename Lhs, typename Rhs, int Mode, int Index, int Size>
struct triangular_solver_unroller<Lhs,Rhs,Mode,Index,Size,false> {
  enum {
    IsLower = ((Mode&Lower)==Lower),
    I = IsLower ? Index : Size - Index - 1,
    S = IsLower ? 0 : I+1
  };
  static void run(const Lhs& lhs, Rhs& rhs)
  {
    if (Index>0)
      rhs.coeffRef(I) -= lhs.row(I).template segment<Index>(S).transpose()
                         .cwiseProduct(rhs.template segment<Index>(S)).sum();

    if(!(Mode & UnitDiag))
      rhs.coeffRef(I) /= lhs.coeff(I,I);

    triangular_solver_unroller<Lhs,Rhs,Mode,Index+1,Size>::run(lhs,rhs);
  }
};

template<typename Lhs, typename Rhs, int Mode, int Index, int Size>
struct triangular_solver_unroller<Lhs,Rhs,Mode,Index,Size,true> {
  static void run(const Lhs&, Rhs&) {}
};

template<typename Lhs, typename Rhs, int Mode>
struct triangular_solver_selector<Lhs,Rhs,OnTheLeft,Mode,CompleteUnrolling,1> {
  static void run(const Lhs& lhs, Rhs& rhs)
  { triangular_solver_unroller<Lhs,Rhs,Mode,0,Rhs::SizeAtCompileTime>::run(lhs,rhs); }
};

template<typename Lhs, typename Rhs, int Mode>
struct triangular_solver_selector<Lhs,Rhs,OnTheRight,Mode,CompleteUnrolling,1> {
  static void run(const Lhs& lhs, Rhs& rhs)
  {
    Transpose<const Lhs> trLhs(lhs);
    Transpose<Rhs> trRhs(rhs);

    triangular_solver_unroller<Transpose<const Lhs>,Transpose<Rhs>,
                              ((Mode&Upper)==Upper ? Lower : Upper) | (Mode&UnitDiag),
                              0,Rhs::SizeAtCompileTime>::run(trLhs,trRhs);
  }
};

}
# 175 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/SolveTriangular.h"
template<typename MatrixType, unsigned int Mode>
template<int Side, typename OtherDerived>
void TriangularView<MatrixType,Mode>::solveInPlace(const MatrixBase<OtherDerived>& _other) const
{
  OtherDerived& other = _other.const_cast_derived();
  if( (!Eigen::internal::copy_bool(cols() == rows())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(cols() == rows())) Eigen::internal::assert_fail("cols() == rows()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/SolveTriangular.h", 180); } while(false); else throw Eigen::eigen_assert_exception(); };
  if( (!Eigen::internal::copy_bool((Side==OnTheLeft && cols() == other.rows()) || (Side==OnTheRight && cols() == other.cols()))) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool((Side==OnTheLeft && cols() == other.rows()) || (Side==OnTheRight && cols() == other.cols()))) Eigen::internal::assert_fail("(Side==OnTheLeft && cols() == other.rows()) || (Side==OnTheRight && cols() == other.cols())", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/SolveTriangular.h", 181); } while(false); else throw Eigen::eigen_assert_exception(); };
  if( (!Eigen::internal::copy_bool(!(Mode & ZeroDiag))) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(!(Mode & ZeroDiag))) Eigen::internal::assert_fail("!(Mode & ZeroDiag)", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/SolveTriangular.h", 182); } while(false); else throw Eigen::eigen_assert_exception(); };
  if( (!Eigen::internal::copy_bool((Mode & (Upper|Lower)) != 0)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool((Mode & (Upper|Lower)) != 0)) Eigen::internal::assert_fail("(Mode & (Upper|Lower)) != 0", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/SolveTriangular.h", 183); } while(false); else throw Eigen::eigen_assert_exception(); };

  enum { copy = internal::traits<OtherDerived>::Flags & RowMajorBit && OtherDerived::IsVectorAtCompileTime };
  typedef typename internal::conditional<copy,
    typename internal::plain_matrix_type_column_major<OtherDerived>::type, OtherDerived&>::type OtherCopy;
  OtherCopy otherCopy(other);

  internal::triangular_solver_selector<MatrixType, typename internal::remove_reference<OtherCopy>::type,
    Side, Mode>::run(nestedExpression(), otherCopy);

  if (copy)
    other = otherCopy;
}
# 218 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/SolveTriangular.h"
template<typename Derived, unsigned int Mode>
template<int Side, typename Other>
const internal::triangular_solve_retval<Side,TriangularView<Derived,Mode>,Other>
TriangularView<Derived,Mode>::solve(const MatrixBase<Other>& other) const
{
  return internal::triangular_solve_retval<Side,TriangularView,Other>(*this, other.derived());
}

namespace internal {


template<int Side, typename TriangularType, typename Rhs>
struct traits<triangular_solve_retval<Side, TriangularType, Rhs> >
{
  typedef typename internal::plain_matrix_type_column_major<Rhs>::type ReturnType;
};

template<int Side, typename TriangularType, typename Rhs> struct triangular_solve_retval
 : public ReturnByValue<triangular_solve_retval<Side, TriangularType, Rhs> >
{
  typedef typename remove_all<typename Rhs::Nested>::type RhsNestedCleaned;
  typedef ReturnByValue<triangular_solve_retval> Base;
  typedef typename Base::Index Index;

  triangular_solve_retval(const TriangularType& tri, const Rhs& rhs)
    : m_triangularMatrix(tri), m_rhs(rhs)
  {}

  inline Index rows() const { return m_rhs.rows(); }
  inline Index cols() const { return m_rhs.cols(); }

  template<typename Dest> inline void evalTo(Dest& dst) const
  {
    if(!(is_same<RhsNestedCleaned,Dest>::value && extract_data(dst) == extract_data(m_rhs)))
      dst = m_rhs;
    m_triangularMatrix.template solveInPlace<Side>(dst);
  }

  protected:
    const TriangularType& m_triangularMatrix;
    const typename Rhs::Nested m_rhs;
};

}
# 325 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/Parallelizer.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/Parallelizer.h"
namespace internal {


inline void manage_multi_threading(Action action, int* v)
{
  static __attribute__((unused)) int m_maxThreads = -1;

  if(action==SetAction)
  {
    if( (!Eigen::internal::copy_bool(v!=0)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(v!=0)) Eigen::internal::assert_fail("v!=0", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/Parallelizer.h", 37); } while(false); else throw Eigen::eigen_assert_exception(); };
    m_maxThreads = *v;
  }
  else if(action==GetAction)
  {
    if( (!Eigen::internal::copy_bool(v!=0)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(v!=0)) Eigen::internal::assert_fail("v!=0", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/Parallelizer.h", 42); } while(false); else throw Eigen::eigen_assert_exception(); };






    *v = 1;

  }
  else
  {
    if( (!Eigen::internal::copy_bool(false)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(false)) Eigen::internal::assert_fail("false", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/Parallelizer.h", 54); } while(false); else throw Eigen::eigen_assert_exception(); };
  }
}



inline int nbThreads()
{
  int ret;
  manage_multi_threading(GetAction, &ret);
  return ret;
}



inline void setNbThreads(int v)
{
  manage_multi_threading(SetAction, &v);
}

template<typename Index> struct GemmParallelInfo
{
  GemmParallelInfo() : sync(-1), users(0), rhs_start(0), rhs_length(0) {}

  int volatile sync;
  int volatile users;

  Index rhs_start;
  Index rhs_length;
};

template<bool Condition, typename Functor, typename Index>
void parallelize_gemm(const Functor& func, Index rows, Index cols, bool transpose)
{





  (void)transpose;;
  func(0,rows, 0,cols);
# 150 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/Parallelizer.h"
}

}
# 326 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/CoeffBasedProduct.h" 1
# 29 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/CoeffBasedProduct.h"
namespace internal {
# 44 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/CoeffBasedProduct.h"
template<int Traversal, int UnrollingIndex, typename Lhs, typename Rhs, typename RetScalar>
struct product_coeff_impl;

template<int StorageOrder, int UnrollingIndex, typename Lhs, typename Rhs, typename Packet, int LoadMode>
struct product_packet_impl;

template<typename LhsNested, typename RhsNested, int NestingFlags>
struct traits<CoeffBasedProduct<LhsNested,RhsNested,NestingFlags> >
{
  typedef MatrixXpr XprKind;
  typedef typename remove_all<LhsNested>::type _LhsNested;
  typedef typename remove_all<RhsNested>::type _RhsNested;
  typedef typename scalar_product_traits<typename _LhsNested::Scalar, typename _RhsNested::Scalar>::ReturnType Scalar;
  typedef typename promote_storage_type<typename traits<_LhsNested>::StorageKind,
                                           typename traits<_RhsNested>::StorageKind>::ret StorageKind;
  typedef typename promote_index_type<typename traits<_LhsNested>::Index,
                                         typename traits<_RhsNested>::Index>::type Index;

  enum {
      LhsCoeffReadCost = _LhsNested::CoeffReadCost,
      RhsCoeffReadCost = _RhsNested::CoeffReadCost,
      LhsFlags = _LhsNested::Flags,
      RhsFlags = _RhsNested::Flags,

      RowsAtCompileTime = _LhsNested::RowsAtCompileTime,
      ColsAtCompileTime = _RhsNested::ColsAtCompileTime,
      InnerSize = (((int)_LhsNested::ColsAtCompileTime == 0 || (int)_RhsNested::RowsAtCompileTime == 0) ? 0 : ((int)_LhsNested::ColsAtCompileTime == 1 || (int)_RhsNested::RowsAtCompileTime == 1) ? 1 : ((int)_LhsNested::ColsAtCompileTime == Dynamic && (int)_RhsNested::RowsAtCompileTime == Dynamic) ? Dynamic : ((int)_LhsNested::ColsAtCompileTime == Dynamic) ? (int)_RhsNested::RowsAtCompileTime : ((int)_RhsNested::RowsAtCompileTime == Dynamic) ? (int)_LhsNested::ColsAtCompileTime : ((int)_LhsNested::ColsAtCompileTime <= (int)_RhsNested::RowsAtCompileTime) ? (int)_LhsNested::ColsAtCompileTime : (int)_RhsNested::RowsAtCompileTime),

      MaxRowsAtCompileTime = _LhsNested::MaxRowsAtCompileTime,
      MaxColsAtCompileTime = _RhsNested::MaxColsAtCompileTime,

      LhsRowMajor = LhsFlags & RowMajorBit,
      RhsRowMajor = RhsFlags & RowMajorBit,

      SameType = is_same<typename _LhsNested::Scalar,typename _RhsNested::Scalar>::value,

      CanVectorizeRhs = RhsRowMajor && (RhsFlags & PacketAccessBit)
                      && (ColsAtCompileTime == Dynamic
                          || ( (ColsAtCompileTime % packet_traits<Scalar>::size) == 0
                              && (RhsFlags&AlignedBit)
                             )
                         ),

      CanVectorizeLhs = (!LhsRowMajor) && (LhsFlags & PacketAccessBit)
                      && (RowsAtCompileTime == Dynamic
                          || ( (RowsAtCompileTime % packet_traits<Scalar>::size) == 0
                              && (LhsFlags&AlignedBit)
                             )
                         ),

      EvalToRowMajor = (MaxRowsAtCompileTime==1&&MaxColsAtCompileTime!=1) ? 1
                     : (MaxColsAtCompileTime==1&&MaxRowsAtCompileTime!=1) ? 0
                     : (RhsRowMajor && !CanVectorizeLhs),

      Flags = ((unsigned int)(LhsFlags | RhsFlags) & HereditaryBits & ~RowMajorBit)
            | (EvalToRowMajor ? RowMajorBit : 0)
            | NestingFlags
            | (LhsFlags & RhsFlags & AlignedBit)

            | (SameType && (CanVectorizeLhs || CanVectorizeRhs) ? PacketAccessBit : 0),

      CoeffReadCost = InnerSize == Dynamic ? Dynamic
                    : InnerSize * (NumTraits<Scalar>::MulCost + LhsCoeffReadCost + RhsCoeffReadCost)
                      + (InnerSize - 1) * NumTraits<Scalar>::AddCost,






      CanVectorizeInner = SameType
                          && LhsRowMajor
                          && (!RhsRowMajor)
                          && (LhsFlags & RhsFlags & ActualPacketAccessBit)
                          && (LhsFlags & RhsFlags & AlignedBit)
                          && (InnerSize % packet_traits<Scalar>::size == 0)
    };
};

}

template<typename LhsNested, typename RhsNested, int NestingFlags>
class CoeffBasedProduct
  : internal::no_assignment_operator,
    public MatrixBase<CoeffBasedProduct<LhsNested, RhsNested, NestingFlags> >
{
  public:

    typedef MatrixBase<CoeffBasedProduct> Base;
    typedef typename Eigen::internal::traits<CoeffBasedProduct>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<CoeffBasedProduct>::type Nested; typedef typename Eigen::internal::traits<CoeffBasedProduct>::StorageKind StorageKind; typedef typename Eigen::internal::traits<CoeffBasedProduct>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<CoeffBasedProduct>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<CoeffBasedProduct>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<CoeffBasedProduct>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<CoeffBasedProduct>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<CoeffBasedProduct>::Flags, CoeffReadCost = Eigen::internal::traits<CoeffBasedProduct>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived;
    typedef typename Base::PlainObject PlainObject;

  private:

    typedef typename internal::traits<CoeffBasedProduct>::_LhsNested _LhsNested;
    typedef typename internal::traits<CoeffBasedProduct>::_RhsNested _RhsNested;

    enum {
      PacketSize = internal::packet_traits<Scalar>::size,
      InnerSize = internal::traits<CoeffBasedProduct>::InnerSize,
      Unroll = CoeffReadCost != Dynamic && CoeffReadCost <= 100,
      CanVectorizeInner = internal::traits<CoeffBasedProduct>::CanVectorizeInner
    };

    typedef internal::product_coeff_impl<CanVectorizeInner ? InnerVectorizedTraversal : DefaultTraversal,
                                   Unroll ? InnerSize-1 : Dynamic,
                                   _LhsNested, _RhsNested, Scalar> ScalarCoeffImpl;

    typedef CoeffBasedProduct<LhsNested,RhsNested,NestByRefBit> LazyCoeffBasedProductType;

  public:

    inline CoeffBasedProduct(const CoeffBasedProduct& other)
      : Base(), m_lhs(other.m_lhs), m_rhs(other.m_rhs)
    {}

    template<typename Lhs, typename Rhs>
    inline CoeffBasedProduct(const Lhs& lhs, const Rhs& rhs)
      : m_lhs(lhs), m_rhs(rhs)
    {


      if (Eigen::internal::static_assertion<bool((internal::is_same<typename Lhs::RealScalar, typename Rhs::RealScalar>::value))>::YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY) {}

      if( (!Eigen::internal::copy_bool(lhs.cols() == rhs.rows() && "invalid matrix product" && "if you wanted a coeff-wise or a dot product use the respective explicit functions")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(lhs.cols() == rhs.rows() && "invalid matrix product" && "if you wanted a coeff-wise or a dot product use the respective explicit functions")) Eigen::internal::assert_fail("lhs.cols() == rhs.rows() && \"invalid matrix product\" && \"if you wanted a coeff-wise or a dot product use the respective explicit functions\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/CoeffBasedProduct.h", 170); } while(false); else throw Eigen::eigen_assert_exception(); };


    }

    inline Index rows() const { return m_lhs.rows(); }
    inline Index cols() const { return m_rhs.cols(); }

    inline const Scalar coeff(Index row, Index col) const
    {
      Scalar res;
      ScalarCoeffImpl::run(row, col, m_lhs, m_rhs, res);
      return res;
    }




    inline const Scalar coeff(Index index) const
    {
      Scalar res;
      const Index row = RowsAtCompileTime == 1 ? 0 : index;
      const Index col = RowsAtCompileTime == 1 ? index : 0;
      ScalarCoeffImpl::run(row, col, m_lhs, m_rhs, res);
      return res;
    }

    template<int LoadMode>
    inline const PacketScalar packet(Index row, Index col) const
    {
      PacketScalar res;
      internal::product_packet_impl<Flags&RowMajorBit ? RowMajor : ColMajor,
                              Unroll ? InnerSize-1 : Dynamic,
                              _LhsNested, _RhsNested, PacketScalar, LoadMode>
        ::run(row, col, m_lhs, m_rhs, res);
      return res;
    }


    inline operator const PlainObject& () const
    {
      m_result.lazyAssign(*this);
      return m_result;
    }

    const _LhsNested& lhs() const { return m_lhs; }
    const _RhsNested& rhs() const { return m_rhs; }

    const Diagonal<const LazyCoeffBasedProductType,0> diagonal() const
    { return reinterpret_cast<const LazyCoeffBasedProductType&>(*this); }

    template<int DiagonalIndex>
    const Diagonal<const LazyCoeffBasedProductType,DiagonalIndex> diagonal() const
    { return reinterpret_cast<const LazyCoeffBasedProductType&>(*this); }

    const Diagonal<const LazyCoeffBasedProductType,Dynamic> diagonal(Index index) const
    { return reinterpret_cast<const LazyCoeffBasedProductType&>(*this).diagonal(index); }

  protected:
    const LhsNested m_lhs;
    const RhsNested m_rhs;

    mutable PlainObject m_result;
};

namespace internal {



template<typename Lhs, typename Rhs, int N, typename PlainObject>
struct nested<CoeffBasedProduct<Lhs,Rhs,EvalBeforeNestingBit|EvalBeforeAssigningBit>, N, PlainObject>
{
  typedef PlainObject const& type;
};
# 251 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/CoeffBasedProduct.h"
template<int UnrollingIndex, typename Lhs, typename Rhs, typename RetScalar>
struct product_coeff_impl<DefaultTraversal, UnrollingIndex, Lhs, Rhs, RetScalar>
{
  typedef typename Lhs::Index Index;
  inline static void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, RetScalar &res)
  {
    product_coeff_impl<DefaultTraversal, UnrollingIndex-1, Lhs, Rhs, RetScalar>::run(row, col, lhs, rhs, res);
    res += lhs.coeff(row, UnrollingIndex) * rhs.coeff(UnrollingIndex, col);
  }
};

template<typename Lhs, typename Rhs, typename RetScalar>
struct product_coeff_impl<DefaultTraversal, 0, Lhs, Rhs, RetScalar>
{
  typedef typename Lhs::Index Index;
  inline static void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, RetScalar &res)
  {
    res = lhs.coeff(row, 0) * rhs.coeff(0, col);
  }
};

template<typename Lhs, typename Rhs, typename RetScalar>
struct product_coeff_impl<DefaultTraversal, Dynamic, Lhs, Rhs, RetScalar>
{
  typedef typename Lhs::Index Index;
  inline static void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, RetScalar& res)
  {
    if( (!Eigen::internal::copy_bool(lhs.cols()>0 && "you are using a non initialized matrix")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(lhs.cols()>0 && "you are using a non initialized matrix")) Eigen::internal::assert_fail("lhs.cols()>0 && \"you are using a non initialized matrix\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/CoeffBasedProduct.h", 278); } while(false); else throw Eigen::eigen_assert_exception(); };
    res = lhs.coeff(row, 0) * rhs.coeff(0, col);
      for(Index i = 1; i < lhs.cols(); ++i)
        res += lhs.coeff(row, i) * rhs.coeff(i, col);
  }
};





template<int UnrollingIndex, typename Lhs, typename Rhs, typename Packet>
struct product_coeff_vectorized_unroller
{
  typedef typename Lhs::Index Index;
  enum { PacketSize = packet_traits<typename Lhs::Scalar>::size };
  inline static void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::PacketScalar &pres)
  {
    product_coeff_vectorized_unroller<UnrollingIndex-PacketSize, Lhs, Rhs, Packet>::run(row, col, lhs, rhs, pres);
    pres = padd(pres, pmul( lhs.template packet<Aligned>(row, UnrollingIndex) , rhs.template packet<Aligned>(UnrollingIndex, col) ));
  }
};

template<typename Lhs, typename Rhs, typename Packet>
struct product_coeff_vectorized_unroller<0, Lhs, Rhs, Packet>
{
  typedef typename Lhs::Index Index;
  inline static void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::PacketScalar &pres)
  {
    pres = pmul(lhs.template packet<Aligned>(row, 0) , rhs.template packet<Aligned>(0, col));
  }
};

template<int UnrollingIndex, typename Lhs, typename Rhs, typename RetScalar>
struct product_coeff_impl<InnerVectorizedTraversal, UnrollingIndex, Lhs, Rhs, RetScalar>
{
  typedef typename Lhs::PacketScalar Packet;
  typedef typename Lhs::Index Index;
  enum { PacketSize = packet_traits<typename Lhs::Scalar>::size };
  inline static void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, RetScalar &res)
  {
    Packet pres;
    product_coeff_vectorized_unroller<UnrollingIndex+1-PacketSize, Lhs, Rhs, Packet>::run(row, col, lhs, rhs, pres);
    product_coeff_impl<DefaultTraversal,UnrollingIndex,Lhs,Rhs,RetScalar>::run(row, col, lhs, rhs, res);
    res = predux(pres);
  }
};

template<typename Lhs, typename Rhs, int LhsRows = Lhs::RowsAtCompileTime, int RhsCols = Rhs::ColsAtCompileTime>
struct product_coeff_vectorized_dyn_selector
{
  typedef typename Lhs::Index Index;
  inline static void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)
  {
    res = lhs.row(row).transpose().cwiseProduct(rhs.col(col)).sum();
  }
};



template<typename Lhs, typename Rhs, int RhsCols>
struct product_coeff_vectorized_dyn_selector<Lhs,Rhs,1,RhsCols>
{
  typedef typename Lhs::Index Index;
  inline static void run(Index , Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)
  {
    res = lhs.transpose().cwiseProduct(rhs.col(col)).sum();
  }
};

template<typename Lhs, typename Rhs, int LhsRows>
struct product_coeff_vectorized_dyn_selector<Lhs,Rhs,LhsRows,1>
{
  typedef typename Lhs::Index Index;
  inline static void run(Index row, Index , const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)
  {
    res = lhs.row(row).transpose().cwiseProduct(rhs).sum();
  }
};

template<typename Lhs, typename Rhs>
struct product_coeff_vectorized_dyn_selector<Lhs,Rhs,1,1>
{
  typedef typename Lhs::Index Index;
  inline static void run(Index , Index , const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)
  {
    res = lhs.transpose().cwiseProduct(rhs).sum();
  }
};

template<typename Lhs, typename Rhs, typename RetScalar>
struct product_coeff_impl<InnerVectorizedTraversal, Dynamic, Lhs, Rhs, RetScalar>
{
  typedef typename Lhs::Index Index;
  inline static void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)
  {
    product_coeff_vectorized_dyn_selector<Lhs,Rhs>::run(row, col, lhs, rhs, res);
  }
};





template<int UnrollingIndex, typename Lhs, typename Rhs, typename Packet, int LoadMode>
struct product_packet_impl<RowMajor, UnrollingIndex, Lhs, Rhs, Packet, LoadMode>
{
  typedef typename Lhs::Index Index;
  inline static void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Packet &res)
  {
    product_packet_impl<RowMajor, UnrollingIndex-1, Lhs, Rhs, Packet, LoadMode>::run(row, col, lhs, rhs, res);
    res = pmadd(pset1<Packet>(lhs.coeff(row, UnrollingIndex)), rhs.template packet<LoadMode>(UnrollingIndex, col), res);
  }
};

template<int UnrollingIndex, typename Lhs, typename Rhs, typename Packet, int LoadMode>
struct product_packet_impl<ColMajor, UnrollingIndex, Lhs, Rhs, Packet, LoadMode>
{
  typedef typename Lhs::Index Index;
  inline static void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Packet &res)
  {
    product_packet_impl<ColMajor, UnrollingIndex-1, Lhs, Rhs, Packet, LoadMode>::run(row, col, lhs, rhs, res);
    res = pmadd(lhs.template packet<LoadMode>(row, UnrollingIndex), pset1<Packet>(rhs.coeff(UnrollingIndex, col)), res);
  }
};

template<typename Lhs, typename Rhs, typename Packet, int LoadMode>
struct product_packet_impl<RowMajor, 0, Lhs, Rhs, Packet, LoadMode>
{
  typedef typename Lhs::Index Index;
  inline static void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Packet &res)
  {
    res = pmul(pset1<Packet>(lhs.coeff(row, 0)),rhs.template packet<LoadMode>(0, col));
  }
};

template<typename Lhs, typename Rhs, typename Packet, int LoadMode>
struct product_packet_impl<ColMajor, 0, Lhs, Rhs, Packet, LoadMode>
{
  typedef typename Lhs::Index Index;
  inline static void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Packet &res)
  {
    res = pmul(lhs.template packet<LoadMode>(row, 0), pset1<Packet>(rhs.coeff(0, col)));
  }
};

template<typename Lhs, typename Rhs, typename Packet, int LoadMode>
struct product_packet_impl<RowMajor, Dynamic, Lhs, Rhs, Packet, LoadMode>
{
  typedef typename Lhs::Index Index;
  inline static void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Packet& res)
  {
    if( (!Eigen::internal::copy_bool(lhs.cols()>0 && "you are using a non initialized matrix")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(lhs.cols()>0 && "you are using a non initialized matrix")) Eigen::internal::assert_fail("lhs.cols()>0 && \"you are using a non initialized matrix\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/CoeffBasedProduct.h", 430); } while(false); else throw Eigen::eigen_assert_exception(); };
    res = pmul(pset1<Packet>(lhs.coeff(row, 0)),rhs.template packet<LoadMode>(0, col));
      for(Index i = 1; i < lhs.cols(); ++i)
        res = pmadd(pset1<Packet>(lhs.coeff(row, i)), rhs.template packet<LoadMode>(i, col), res);
  }
};

template<typename Lhs, typename Rhs, typename Packet, int LoadMode>
struct product_packet_impl<ColMajor, Dynamic, Lhs, Rhs, Packet, LoadMode>
{
  typedef typename Lhs::Index Index;
  inline static void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Packet& res)
  {
    if( (!Eigen::internal::copy_bool(lhs.cols()>0 && "you are using a non initialized matrix")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(lhs.cols()>0 && "you are using a non initialized matrix")) Eigen::internal::assert_fail("lhs.cols()>0 && \"you are using a non initialized matrix\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/CoeffBasedProduct.h", 443); } while(false); else throw Eigen::eigen_assert_exception(); };
    res = pmul(lhs.template packet<LoadMode>(row, 0), pset1<Packet>(rhs.coeff(0, col)));
      for(Index i = 1; i < lhs.cols(); ++i)
        res = pmadd(lhs.template packet<LoadMode>(row, i), pset1<Packet>(rhs.coeff(i, col)), res);
  }
};

}
# 327 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralBlockPanelKernel.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralBlockPanelKernel.h"
namespace internal {

template<typename _LhsScalar, typename _RhsScalar, bool _ConjLhs=false, bool _ConjRhs=false>
class gebp_traits;


inline void manage_caching_sizes(Action action, std::ptrdiff_t* l1=0, std::ptrdiff_t* l2=0)
{
  static std::ptrdiff_t m_l1CacheSize = 0;
  static std::ptrdiff_t m_l2CacheSize = 0;
  if(m_l1CacheSize==0)
  {
    m_l1CacheSize = queryL1CacheSize();
    m_l2CacheSize = queryTopLevelCacheSize();

    if(m_l1CacheSize<=0) m_l1CacheSize = 8 * 1024;
    if(m_l2CacheSize<=0) m_l2CacheSize = 1 * 1024 * 1024;
  }

  if(action==SetAction)
  {

    if( (!Eigen::internal::copy_bool(l1!=0 && l2!=0)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(l1!=0 && l2!=0)) Eigen::internal::assert_fail("l1!=0 && l2!=0", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralBlockPanelKernel.h", 50); } while(false); else throw Eigen::eigen_assert_exception(); };
    m_l1CacheSize = *l1;
    m_l2CacheSize = *l2;
  }
  else if(action==GetAction)
  {
    if( (!Eigen::internal::copy_bool(l1!=0 && l2!=0)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(l1!=0 && l2!=0)) Eigen::internal::assert_fail("l1!=0 && l2!=0", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralBlockPanelKernel.h", 56); } while(false); else throw Eigen::eigen_assert_exception(); };
    *l1 = m_l1CacheSize;
    *l2 = m_l2CacheSize;
  }
  else
  {
    if( (!Eigen::internal::copy_bool(false)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(false)) Eigen::internal::assert_fail("false", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralBlockPanelKernel.h", 62); } while(false); else throw Eigen::eigen_assert_exception(); };
  }
}
# 81 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralBlockPanelKernel.h"
template<typename LhsScalar, typename RhsScalar, int KcFactor>
void computeProductBlockingSizes(std::ptrdiff_t& k, std::ptrdiff_t& m, std::ptrdiff_t& n)
{
  (void)n;;







  std::ptrdiff_t l1, l2;

  typedef gebp_traits<LhsScalar,RhsScalar> Traits;
  enum {
    kdiv = KcFactor * 2 * Traits::nr
         * Traits::RhsProgress * sizeof(RhsScalar),
    mr = gebp_traits<LhsScalar,RhsScalar>::mr,
    mr_mask = (0xffffffff/mr)*mr
  };

  manage_caching_sizes(GetAction, &l1, &l2);
  k = std::min<std::ptrdiff_t>(k, l1/kdiv);
  std::ptrdiff_t _m = k>0 ? l2/(4 * sizeof(LhsScalar) * k) : 0;
  if(_m<m) m = _m & mr_mask;
}

template<typename LhsScalar, typename RhsScalar>
inline void computeProductBlockingSizes(std::ptrdiff_t& k, std::ptrdiff_t& m, std::ptrdiff_t& n)
{
  computeProductBlockingSizes<LhsScalar,RhsScalar,1>(k, m, n);
}







  template<typename CJ, typename A, typename B, typename C, typename T> struct gebp_madd_selector {
    inline __attribute__((always_inline)) static void run(const CJ& cj, A& a, B& b, C& c, T& )
    {
      c = cj.pmadd(a,b,c);
    }
  };

  template<typename CJ, typename T> struct gebp_madd_selector<CJ,T,T,T,T> {
    inline __attribute__((always_inline)) static void run(const CJ& cj, T& a, T& b, T& c, T& t)
    {
      t = b; t = cj.pmul(a,t); c = padd(c,t);
    }
  };

  template<typename CJ, typename A, typename B, typename C, typename T>
  inline void gebp_madd(const CJ& cj, A& a, B& b, C& c, T& t)
  {
    gebp_madd_selector<CJ,A,B,C,T>::run(cj,a,b,c,t);
  }
# 154 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralBlockPanelKernel.h"
template<typename _LhsScalar, typename _RhsScalar, bool _ConjLhs, bool _ConjRhs>
class gebp_traits
{
public:
  typedef _LhsScalar LhsScalar;
  typedef _RhsScalar RhsScalar;
  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;

  enum {
    ConjLhs = _ConjLhs,
    ConjRhs = _ConjRhs,
    Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable,
    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,
    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,
    ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1,

    NumberOfRegisters = (2*sizeof(void*)),


    nr = NumberOfRegisters/4,


    mr = 2 * LhsPacketSize,

    WorkSpaceFactor = nr * RhsPacketSize,

    LhsProgress = LhsPacketSize,
    RhsProgress = RhsPacketSize
  };

  typedef typename packet_traits<LhsScalar>::type _LhsPacket;
  typedef typename packet_traits<RhsScalar>::type _RhsPacket;
  typedef typename packet_traits<ResScalar>::type _ResPacket;

  typedef typename conditional<Vectorizable,_LhsPacket,LhsScalar>::type LhsPacket;
  typedef typename conditional<Vectorizable,_RhsPacket,RhsScalar>::type RhsPacket;
  typedef typename conditional<Vectorizable,_ResPacket,ResScalar>::type ResPacket;

  typedef ResPacket AccPacket;

  inline void initAcc(AccPacket& p)
  {
    p = pset1<ResPacket>(ResScalar(0));
  }

  inline void unpackRhs(DenseIndex n, const RhsScalar* rhs, RhsScalar* b)
  {
    for(DenseIndex k=0; k<n; k++)
      pstore1<RhsPacket>(&b[k*RhsPacketSize], rhs[k]);
  }

  inline void loadRhs(const RhsScalar* b, RhsPacket& dest) const
  {
    dest = pload<RhsPacket>(b);
  }

  inline void loadLhs(const LhsScalar* a, LhsPacket& dest) const
  {
    dest = pload<LhsPacket>(a);
  }

  inline void madd(const LhsPacket& a, const RhsPacket& b, AccPacket& c, AccPacket& tmp) const
  {
    tmp = b; tmp = pmul(a,tmp); c = padd(c,tmp);
  }

  inline void acc(const AccPacket& c, const ResPacket& alpha, ResPacket& r) const
  {
    r = pmadd(c,alpha,r);
  }

protected:


};

template<typename RealScalar, bool _ConjLhs>
class gebp_traits<std::complex<RealScalar>, RealScalar, _ConjLhs, false>
{
public:
  typedef std::complex<RealScalar> LhsScalar;
  typedef RealScalar RhsScalar;
  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;

  enum {
    ConjLhs = _ConjLhs,
    ConjRhs = false,
    Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable,
    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,
    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,
    ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1,

    NumberOfRegisters = (2*sizeof(void*)),
    nr = NumberOfRegisters/4,
    mr = 2 * LhsPacketSize,
    WorkSpaceFactor = nr*RhsPacketSize,

    LhsProgress = LhsPacketSize,
    RhsProgress = RhsPacketSize
  };

  typedef typename packet_traits<LhsScalar>::type _LhsPacket;
  typedef typename packet_traits<RhsScalar>::type _RhsPacket;
  typedef typename packet_traits<ResScalar>::type _ResPacket;

  typedef typename conditional<Vectorizable,_LhsPacket,LhsScalar>::type LhsPacket;
  typedef typename conditional<Vectorizable,_RhsPacket,RhsScalar>::type RhsPacket;
  typedef typename conditional<Vectorizable,_ResPacket,ResScalar>::type ResPacket;

  typedef ResPacket AccPacket;

  inline void initAcc(AccPacket& p)
  {
    p = pset1<ResPacket>(ResScalar(0));
  }

  inline void unpackRhs(DenseIndex n, const RhsScalar* rhs, RhsScalar* b)
  {
    for(DenseIndex k=0; k<n; k++)
      pstore1<RhsPacket>(&b[k*RhsPacketSize], rhs[k]);
  }

  inline void loadRhs(const RhsScalar* b, RhsPacket& dest) const
  {
    dest = pload<RhsPacket>(b);
  }

  inline void loadLhs(const LhsScalar* a, LhsPacket& dest) const
  {
    dest = pload<LhsPacket>(a);
  }

  inline void madd(const LhsPacket& a, const RhsPacket& b, AccPacket& c, RhsPacket& tmp) const
  {
    madd_impl(a, b, c, tmp, typename conditional<Vectorizable,true_type,false_type>::type());
  }

  inline void madd_impl(const LhsPacket& a, const RhsPacket& b, AccPacket& c, RhsPacket& tmp, const true_type&) const
  {
    tmp = b; tmp = pmul(a.v,tmp); c.v = padd(c.v,tmp);
  }

  inline void madd_impl(const LhsScalar& a, const RhsScalar& b, ResScalar& c, RhsScalar& , const false_type&) const
  {
    c += a * b;
  }

  inline void acc(const AccPacket& c, const ResPacket& alpha, ResPacket& r) const
  {
    r = cj.pmadd(c,alpha,r);
  }

protected:
  conj_helper<ResPacket,ResPacket,ConjLhs,false> cj;
};

template<typename RealScalar, bool _ConjLhs, bool _ConjRhs>
class gebp_traits<std::complex<RealScalar>, std::complex<RealScalar>, _ConjLhs, _ConjRhs >
{
public:
  typedef std::complex<RealScalar> Scalar;
  typedef std::complex<RealScalar> LhsScalar;
  typedef std::complex<RealScalar> RhsScalar;
  typedef std::complex<RealScalar> ResScalar;

  enum {
    ConjLhs = _ConjLhs,
    ConjRhs = _ConjRhs,
    Vectorizable = packet_traits<RealScalar>::Vectorizable
                && packet_traits<Scalar>::Vectorizable,
    RealPacketSize = Vectorizable ? packet_traits<RealScalar>::size : 1,
    ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1,

    nr = 2,
    mr = 2 * ResPacketSize,
    WorkSpaceFactor = Vectorizable ? 2*nr*RealPacketSize : nr,

    LhsProgress = ResPacketSize,
    RhsProgress = Vectorizable ? 2*ResPacketSize : 1
  };

  typedef typename packet_traits<RealScalar>::type RealPacket;
  typedef typename packet_traits<Scalar>::type ScalarPacket;
  struct DoublePacket
  {
    RealPacket first;
    RealPacket second;
  };

  typedef typename conditional<Vectorizable,RealPacket, Scalar>::type LhsPacket;
  typedef typename conditional<Vectorizable,DoublePacket,Scalar>::type RhsPacket;
  typedef typename conditional<Vectorizable,ScalarPacket,Scalar>::type ResPacket;
  typedef typename conditional<Vectorizable,DoublePacket,Scalar>::type AccPacket;

  inline void initAcc(Scalar& p) { p = Scalar(0); }

  inline void initAcc(DoublePacket& p)
  {
    p.first = pset1<RealPacket>(RealScalar(0));
    p.second = pset1<RealPacket>(RealScalar(0));
  }





  inline void unpackRhs(DenseIndex n, const Scalar* rhs, Scalar* b)
  {
    for(DenseIndex k=0; k<n; k++)
    {
      if(Vectorizable)
      {
        pstore1<RealPacket>((RealScalar*)&b[k*ResPacketSize*2+0], real(rhs[k]));
        pstore1<RealPacket>((RealScalar*)&b[k*ResPacketSize*2+ResPacketSize], imag(rhs[k]));
      }
      else
        b[k] = rhs[k];
    }
  }

  inline void loadRhs(const RhsScalar* b, ResPacket& dest) const { dest = *b; }

  inline void loadRhs(const RhsScalar* b, DoublePacket& dest) const
  {
    dest.first = pload<RealPacket>((const RealScalar*)b);
    dest.second = pload<RealPacket>((const RealScalar*)(b+ResPacketSize));
  }


  inline void loadLhs(const LhsScalar* a, LhsPacket& dest) const
  {
    dest = pload<LhsPacket>((const typename unpacket_traits<LhsPacket>::type*)(a));
  }

  inline void madd(const LhsPacket& a, const RhsPacket& b, DoublePacket& c, RhsPacket& ) const
  {
    c.first = padd(pmul(a,b.first), c.first);
    c.second = padd(pmul(a,b.second),c.second);
  }

  inline void madd(const LhsPacket& a, const RhsPacket& b, ResPacket& c, RhsPacket& ) const
  {
    c = cj.pmadd(a,b,c);
  }

  inline void acc(const Scalar& c, const Scalar& alpha, Scalar& r) const { r += alpha * c; }

  inline void acc(const DoublePacket& c, const ResPacket& alpha, ResPacket& r) const
  {

    ResPacket tmp;
    if((!ConjLhs)&&(!ConjRhs))
    {
      tmp = pcplxflip(pconj(ResPacket(c.second)));
      tmp = padd(ResPacket(c.first),tmp);
    }
    else if((!ConjLhs)&&(ConjRhs))
    {
      tmp = pconj(pcplxflip(ResPacket(c.second)));
      tmp = padd(ResPacket(c.first),tmp);
    }
    else if((ConjLhs)&&(!ConjRhs))
    {
      tmp = pcplxflip(ResPacket(c.second));
      tmp = padd(pconj(ResPacket(c.first)),tmp);
    }
    else if((ConjLhs)&&(ConjRhs))
    {
      tmp = pcplxflip(ResPacket(c.second));
      tmp = psub(pconj(ResPacket(c.first)),tmp);
    }

    r = pmadd(tmp,alpha,r);
  }

protected:
  conj_helper<LhsScalar,RhsScalar,ConjLhs,ConjRhs> cj;
};

template<typename RealScalar, bool _ConjRhs>
class gebp_traits<RealScalar, std::complex<RealScalar>, false, _ConjRhs >
{
public:
  typedef std::complex<RealScalar> Scalar;
  typedef RealScalar LhsScalar;
  typedef Scalar RhsScalar;
  typedef Scalar ResScalar;

  enum {
    ConjLhs = false,
    ConjRhs = _ConjRhs,
    Vectorizable = packet_traits<RealScalar>::Vectorizable
                && packet_traits<Scalar>::Vectorizable,
    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,
    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,
    ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1,

    NumberOfRegisters = (2*sizeof(void*)),
    nr = 4,
    mr = 2*ResPacketSize,
    WorkSpaceFactor = nr*RhsPacketSize,

    LhsProgress = ResPacketSize,
    RhsProgress = ResPacketSize
  };

  typedef typename packet_traits<LhsScalar>::type _LhsPacket;
  typedef typename packet_traits<RhsScalar>::type _RhsPacket;
  typedef typename packet_traits<ResScalar>::type _ResPacket;

  typedef typename conditional<Vectorizable,_LhsPacket,LhsScalar>::type LhsPacket;
  typedef typename conditional<Vectorizable,_RhsPacket,RhsScalar>::type RhsPacket;
  typedef typename conditional<Vectorizable,_ResPacket,ResScalar>::type ResPacket;

  typedef ResPacket AccPacket;

  inline void initAcc(AccPacket& p)
  {
    p = pset1<ResPacket>(ResScalar(0));
  }

  inline void unpackRhs(DenseIndex n, const RhsScalar* rhs, RhsScalar* b)
  {
    for(DenseIndex k=0; k<n; k++)
      pstore1<RhsPacket>(&b[k*RhsPacketSize], rhs[k]);
  }

  inline void loadRhs(const RhsScalar* b, RhsPacket& dest) const
  {
    dest = pload<RhsPacket>(b);
  }

  inline void loadLhs(const LhsScalar* a, LhsPacket& dest) const
  {
    dest = ploaddup<LhsPacket>(a);
  }

  inline void madd(const LhsPacket& a, const RhsPacket& b, AccPacket& c, RhsPacket& tmp) const
  {
    madd_impl(a, b, c, tmp, typename conditional<Vectorizable,true_type,false_type>::type());
  }

  inline void madd_impl(const LhsPacket& a, const RhsPacket& b, AccPacket& c, RhsPacket& tmp, const true_type&) const
  {
    tmp = b; tmp.v = pmul(a,tmp.v); c = padd(c,tmp);
  }

  inline void madd_impl(const LhsScalar& a, const RhsScalar& b, ResScalar& c, RhsScalar& , const false_type&) const
  {
    c += a * b;
  }

  inline void acc(const AccPacket& c, const ResPacket& alpha, ResPacket& r) const
  {
    r = cj.pmadd(alpha,c,r);
  }

protected:
  conj_helper<ResPacket,ResPacket,false,ConjRhs> cj;
};
# 522 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralBlockPanelKernel.h"
template<typename LhsScalar, typename RhsScalar, typename Index, int mr, int nr, bool ConjugateLhs, bool ConjugateRhs>
struct gebp_kernel
{
  typedef gebp_traits<LhsScalar,RhsScalar,ConjugateLhs,ConjugateRhs> Traits;
  typedef typename Traits::ResScalar ResScalar;
  typedef typename Traits::LhsPacket LhsPacket;
  typedef typename Traits::RhsPacket RhsPacket;
  typedef typename Traits::ResPacket ResPacket;
  typedef typename Traits::AccPacket AccPacket;

  enum {
    Vectorizable = Traits::Vectorizable,
    LhsProgress = Traits::LhsProgress,
    RhsProgress = Traits::RhsProgress,
    ResPacketSize = Traits::ResPacketSize
  };


  void operator()(ResScalar* res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index rows, Index depth, Index cols, ResScalar alpha,
                  Index strideA=-1, Index strideB=-1, Index offsetA=0, Index offsetB=0, RhsScalar* unpackedB = 0)
  {
    Traits traits;

    if(strideA==-1) strideA = depth;
    if(strideB==-1) strideB = depth;
    conj_helper<LhsScalar,RhsScalar,ConjugateLhs,ConjugateRhs> cj;

    Index packet_cols = (cols/nr) * nr;
    const Index peeled_mc = (rows/mr)*mr;

    const Index peeled_mc2 = peeled_mc + (rows-peeled_mc >= LhsProgress ? LhsProgress : 0);
    const Index peeled_kc = (depth/4)*4;

    if(unpackedB==0)
      unpackedB = const_cast<RhsScalar*>(blockB - strideB * nr * RhsProgress);


    for(Index j2=0; j2<packet_cols; j2+=nr)
    {
      traits.unpackRhs(depth*nr,&blockB[j2*strideB+offsetB*nr],unpackedB);




      for(Index i=0; i<peeled_mc; i+=mr)
      {
        const LhsScalar* blA = &blockA[i*strideA+offsetA*mr];
        prefetch(&blA[0]);


        AccPacket C0, C1, C2, C3, C4, C5, C6, C7;
                  traits.initAcc(C0);
                  traits.initAcc(C1);
        if(nr==4) traits.initAcc(C2);
        if(nr==4) traits.initAcc(C3);
                  traits.initAcc(C4);
                  traits.initAcc(C5);
        if(nr==4) traits.initAcc(C6);
        if(nr==4) traits.initAcc(C7);

        ResScalar* r0 = &res[(j2+0)*resStride + i];
        ResScalar* r1 = r0 + resStride;
        ResScalar* r2 = r1 + resStride;
        ResScalar* r3 = r2 + resStride;

        prefetch(r0+16);
        prefetch(r1+16);
        prefetch(r2+16);
        prefetch(r3+16);




        const RhsScalar* blB = unpackedB;
        for(Index k=0; k<peeled_kc; k+=4)
        {
          if(nr==2)
          {
            LhsPacket A0, A1;
            RhsPacket B0;
            RhsPacket T0;

asm("#""mybegin2");
            traits.loadLhs(&blA[0*LhsProgress], A0);
            traits.loadLhs(&blA[1*LhsProgress], A1);
            traits.loadRhs(&blB[0*RhsProgress], B0);
            traits.madd(A0,B0,C0,T0);
            traits.madd(A1,B0,C4,B0);
            traits.loadRhs(&blB[1*RhsProgress], B0);
            traits.madd(A0,B0,C1,T0);
            traits.madd(A1,B0,C5,B0);

            traits.loadLhs(&blA[2*LhsProgress], A0);
            traits.loadLhs(&blA[3*LhsProgress], A1);
            traits.loadRhs(&blB[2*RhsProgress], B0);
            traits.madd(A0,B0,C0,T0);
            traits.madd(A1,B0,C4,B0);
            traits.loadRhs(&blB[3*RhsProgress], B0);
            traits.madd(A0,B0,C1,T0);
            traits.madd(A1,B0,C5,B0);

            traits.loadLhs(&blA[4*LhsProgress], A0);
            traits.loadLhs(&blA[5*LhsProgress], A1);
            traits.loadRhs(&blB[4*RhsProgress], B0);
            traits.madd(A0,B0,C0,T0);
            traits.madd(A1,B0,C4,B0);
            traits.loadRhs(&blB[5*RhsProgress], B0);
            traits.madd(A0,B0,C1,T0);
            traits.madd(A1,B0,C5,B0);

            traits.loadLhs(&blA[6*LhsProgress], A0);
            traits.loadLhs(&blA[7*LhsProgress], A1);
            traits.loadRhs(&blB[6*RhsProgress], B0);
            traits.madd(A0,B0,C0,T0);
            traits.madd(A1,B0,C4,B0);
            traits.loadRhs(&blB[7*RhsProgress], B0);
            traits.madd(A0,B0,C1,T0);
            traits.madd(A1,B0,C5,B0);
asm("#""myend");
          }
          else
          {
asm("#""mybegin4");
            LhsPacket A0, A1;
            RhsPacket B0, B1, B2, B3;
            RhsPacket T0;

            traits.loadLhs(&blA[0*LhsProgress], A0);
            traits.loadLhs(&blA[1*LhsProgress], A1);
            traits.loadRhs(&blB[0*RhsProgress], B0);
            traits.loadRhs(&blB[1*RhsProgress], B1);

            traits.madd(A0,B0,C0,T0);
            traits.loadRhs(&blB[2*RhsProgress], B2);
            traits.madd(A1,B0,C4,B0);
            traits.loadRhs(&blB[3*RhsProgress], B3);
            traits.loadRhs(&blB[4*RhsProgress], B0);
            traits.madd(A0,B1,C1,T0);
            traits.madd(A1,B1,C5,B1);
            traits.loadRhs(&blB[5*RhsProgress], B1);
            traits.madd(A0,B2,C2,T0);
            traits.madd(A1,B2,C6,B2);
            traits.loadRhs(&blB[6*RhsProgress], B2);
            traits.madd(A0,B3,C3,T0);
            traits.loadLhs(&blA[2*LhsProgress], A0);
            traits.madd(A1,B3,C7,B3);
            traits.loadLhs(&blA[3*LhsProgress], A1);
            traits.loadRhs(&blB[7*RhsProgress], B3);
            traits.madd(A0,B0,C0,T0);
            traits.madd(A1,B0,C4,B0);
            traits.loadRhs(&blB[8*RhsProgress], B0);
            traits.madd(A0,B1,C1,T0);
            traits.madd(A1,B1,C5,B1);
            traits.loadRhs(&blB[9*RhsProgress], B1);
            traits.madd(A0,B2,C2,T0);
            traits.madd(A1,B2,C6,B2);
            traits.loadRhs(&blB[10*RhsProgress], B2);
            traits.madd(A0,B3,C3,T0);
            traits.loadLhs(&blA[4*LhsProgress], A0);
            traits.madd(A1,B3,C7,B3);
            traits.loadLhs(&blA[5*LhsProgress], A1);
            traits.loadRhs(&blB[11*RhsProgress], B3);

            traits.madd(A0,B0,C0,T0);
            traits.madd(A1,B0,C4,B0);
            traits.loadRhs(&blB[12*RhsProgress], B0);
            traits.madd(A0,B1,C1,T0);
            traits.madd(A1,B1,C5,B1);
            traits.loadRhs(&blB[13*RhsProgress], B1);
            traits.madd(A0,B2,C2,T0);
            traits.madd(A1,B2,C6,B2);
            traits.loadRhs(&blB[14*RhsProgress], B2);
            traits.madd(A0,B3,C3,T0);
            traits.loadLhs(&blA[6*LhsProgress], A0);
            traits.madd(A1,B3,C7,B3);
            traits.loadLhs(&blA[7*LhsProgress], A1);
            traits.loadRhs(&blB[15*RhsProgress], B3);
            traits.madd(A0,B0,C0,T0);
            traits.madd(A1,B0,C4,B0);
            traits.madd(A0,B1,C1,T0);
            traits.madd(A1,B1,C5,B1);
            traits.madd(A0,B2,C2,T0);
            traits.madd(A1,B2,C6,B2);
            traits.madd(A0,B3,C3,T0);
            traits.madd(A1,B3,C7,B3);
          }

          blB += 4*nr*RhsProgress;
          blA += 4*mr;
        }

        for(Index k=peeled_kc; k<depth; k++)
        {
          if(nr==2)
          {
            LhsPacket A0, A1;
            RhsPacket B0;
            RhsPacket T0;

            traits.loadLhs(&blA[0*LhsProgress], A0);
            traits.loadLhs(&blA[1*LhsProgress], A1);
            traits.loadRhs(&blB[0*RhsProgress], B0);
            traits.madd(A0,B0,C0,T0);
            traits.madd(A1,B0,C4,B0);
            traits.loadRhs(&blB[1*RhsProgress], B0);
            traits.madd(A0,B0,C1,T0);
            traits.madd(A1,B0,C5,B0);
          }
          else
          {
            LhsPacket A0, A1;
            RhsPacket B0, B1, B2, B3;
            RhsPacket T0;

            traits.loadLhs(&blA[0*LhsProgress], A0);
            traits.loadLhs(&blA[1*LhsProgress], A1);
            traits.loadRhs(&blB[0*RhsProgress], B0);
            traits.loadRhs(&blB[1*RhsProgress], B1);

            traits.madd(A0,B0,C0,T0);
            traits.loadRhs(&blB[2*RhsProgress], B2);
            traits.madd(A1,B0,C4,B0);
            traits.loadRhs(&blB[3*RhsProgress], B3);
            traits.madd(A0,B1,C1,T0);
            traits.madd(A1,B1,C5,B1);
            traits.madd(A0,B2,C2,T0);
            traits.madd(A1,B2,C6,B2);
            traits.madd(A0,B3,C3,T0);
            traits.madd(A1,B3,C7,B3);
          }

          blB += nr*RhsProgress;
          blA += mr;
        }

        if(nr==4)
        {
          ResPacket R0, R1, R2, R3, R4, R5, R6;
          ResPacket alphav = pset1<ResPacket>(alpha);

          R0 = ploadu<ResPacket>(r0);
          R1 = ploadu<ResPacket>(r1);
          R2 = ploadu<ResPacket>(r2);
          R3 = ploadu<ResPacket>(r3);
          R4 = ploadu<ResPacket>(r0 + ResPacketSize);
          R5 = ploadu<ResPacket>(r1 + ResPacketSize);
          R6 = ploadu<ResPacket>(r2 + ResPacketSize);
          traits.acc(C0, alphav, R0);
          pstoreu(r0, R0);
          R0 = ploadu<ResPacket>(r3 + ResPacketSize);

          traits.acc(C1, alphav, R1);
          traits.acc(C2, alphav, R2);
          traits.acc(C3, alphav, R3);
          traits.acc(C4, alphav, R4);
          traits.acc(C5, alphav, R5);
          traits.acc(C6, alphav, R6);
          traits.acc(C7, alphav, R0);

          pstoreu(r1, R1);
          pstoreu(r2, R2);
          pstoreu(r3, R3);
          pstoreu(r0 + ResPacketSize, R4);
          pstoreu(r1 + ResPacketSize, R5);
          pstoreu(r2 + ResPacketSize, R6);
          pstoreu(r3 + ResPacketSize, R0);
        }
        else
        {
          ResPacket R0, R1, R4;
          ResPacket alphav = pset1<ResPacket>(alpha);

          R0 = ploadu<ResPacket>(r0);
          R1 = ploadu<ResPacket>(r1);
          R4 = ploadu<ResPacket>(r0 + ResPacketSize);
          traits.acc(C0, alphav, R0);
          pstoreu(r0, R0);
          R0 = ploadu<ResPacket>(r1 + ResPacketSize);
          traits.acc(C1, alphav, R1);
          traits.acc(C4, alphav, R4);
          traits.acc(C5, alphav, R0);
          pstoreu(r1, R1);
          pstoreu(r0 + ResPacketSize, R4);
          pstoreu(r1 + ResPacketSize, R0);
        }

      }

      if(rows-peeled_mc>=LhsProgress)
      {
        Index i = peeled_mc;
        const LhsScalar* blA = &blockA[i*strideA+offsetA*LhsProgress];
        prefetch(&blA[0]);


        AccPacket C0, C1, C2, C3;
                  traits.initAcc(C0);
                  traits.initAcc(C1);
        if(nr==4) traits.initAcc(C2);
        if(nr==4) traits.initAcc(C3);


        const RhsScalar* blB = unpackedB;
        for(Index k=0; k<peeled_kc; k+=4)
        {
          if(nr==2)
          {
            LhsPacket A0;
            RhsPacket B0, B1;

            traits.loadLhs(&blA[0*LhsProgress], A0);
            traits.loadRhs(&blB[0*RhsProgress], B0);
            traits.loadRhs(&blB[1*RhsProgress], B1);
            traits.madd(A0,B0,C0,B0);
            traits.loadRhs(&blB[2*RhsProgress], B0);
            traits.madd(A0,B1,C1,B1);
            traits.loadLhs(&blA[1*LhsProgress], A0);
            traits.loadRhs(&blB[3*RhsProgress], B1);
            traits.madd(A0,B0,C0,B0);
            traits.loadRhs(&blB[4*RhsProgress], B0);
            traits.madd(A0,B1,C1,B1);
            traits.loadLhs(&blA[2*LhsProgress], A0);
            traits.loadRhs(&blB[5*RhsProgress], B1);
            traits.madd(A0,B0,C0,B0);
            traits.loadRhs(&blB[6*RhsProgress], B0);
            traits.madd(A0,B1,C1,B1);
            traits.loadLhs(&blA[3*LhsProgress], A0);
            traits.loadRhs(&blB[7*RhsProgress], B1);
            traits.madd(A0,B0,C0,B0);
            traits.madd(A0,B1,C1,B1);
          }
          else
          {
            LhsPacket A0;
            RhsPacket B0, B1, B2, B3;

            traits.loadLhs(&blA[0*LhsProgress], A0);
            traits.loadRhs(&blB[0*RhsProgress], B0);
            traits.loadRhs(&blB[1*RhsProgress], B1);

            traits.madd(A0,B0,C0,B0);
            traits.loadRhs(&blB[2*RhsProgress], B2);
            traits.loadRhs(&blB[3*RhsProgress], B3);
            traits.loadRhs(&blB[4*RhsProgress], B0);
            traits.madd(A0,B1,C1,B1);
            traits.loadRhs(&blB[5*RhsProgress], B1);
            traits.madd(A0,B2,C2,B2);
            traits.loadRhs(&blB[6*RhsProgress], B2);
            traits.madd(A0,B3,C3,B3);
            traits.loadLhs(&blA[1*LhsProgress], A0);
            traits.loadRhs(&blB[7*RhsProgress], B3);
            traits.madd(A0,B0,C0,B0);
            traits.loadRhs(&blB[8*RhsProgress], B0);
            traits.madd(A0,B1,C1,B1);
            traits.loadRhs(&blB[9*RhsProgress], B1);
            traits.madd(A0,B2,C2,B2);
            traits.loadRhs(&blB[10*RhsProgress], B2);
            traits.madd(A0,B3,C3,B3);
            traits.loadLhs(&blA[2*LhsProgress], A0);
            traits.loadRhs(&blB[11*RhsProgress], B3);

            traits.madd(A0,B0,C0,B0);
            traits.loadRhs(&blB[12*RhsProgress], B0);
            traits.madd(A0,B1,C1,B1);
            traits.loadRhs(&blB[13*RhsProgress], B1);
            traits.madd(A0,B2,C2,B2);
            traits.loadRhs(&blB[14*RhsProgress], B2);
            traits.madd(A0,B3,C3,B3);

            traits.loadLhs(&blA[3*LhsProgress], A0);
            traits.loadRhs(&blB[15*RhsProgress], B3);
            traits.madd(A0,B0,C0,B0);
            traits.madd(A0,B1,C1,B1);
            traits.madd(A0,B2,C2,B2);
            traits.madd(A0,B3,C3,B3);
          }

          blB += nr*4*RhsProgress;
          blA += 4*LhsProgress;
        }

        for(Index k=peeled_kc; k<depth; k++)
        {
          if(nr==2)
          {
            LhsPacket A0;
            RhsPacket B0, B1;

            traits.loadLhs(&blA[0*LhsProgress], A0);
            traits.loadRhs(&blB[0*RhsProgress], B0);
            traits.loadRhs(&blB[1*RhsProgress], B1);
            traits.madd(A0,B0,C0,B0);
            traits.madd(A0,B1,C1,B1);
          }
          else
          {
            LhsPacket A0;
            RhsPacket B0, B1, B2, B3;

            traits.loadLhs(&blA[0*LhsProgress], A0);
            traits.loadRhs(&blB[0*RhsProgress], B0);
            traits.loadRhs(&blB[1*RhsProgress], B1);
            traits.loadRhs(&blB[2*RhsProgress], B2);
            traits.loadRhs(&blB[3*RhsProgress], B3);

            traits.madd(A0,B0,C0,B0);
            traits.madd(A0,B1,C1,B1);
            traits.madd(A0,B2,C2,B2);
            traits.madd(A0,B3,C3,B3);
          }

          blB += nr*RhsProgress;
          blA += LhsProgress;
        }

        ResPacket R0, R1, R2, R3;
        ResPacket alphav = pset1<ResPacket>(alpha);

        ResScalar* r0 = &res[(j2+0)*resStride + i];
        ResScalar* r1 = r0 + resStride;
        ResScalar* r2 = r1 + resStride;
        ResScalar* r3 = r2 + resStride;

                  R0 = ploadu<ResPacket>(r0);
                  R1 = ploadu<ResPacket>(r1);
        if(nr==4) R2 = ploadu<ResPacket>(r2);
        if(nr==4) R3 = ploadu<ResPacket>(r3);

                  traits.acc(C0, alphav, R0);
                  traits.acc(C1, alphav, R1);
        if(nr==4) traits.acc(C2, alphav, R2);
        if(nr==4) traits.acc(C3, alphav, R3);

                  pstoreu(r0, R0);
                  pstoreu(r1, R1);
        if(nr==4) pstoreu(r2, R2);
        if(nr==4) pstoreu(r3, R3);
      }
      for(Index i=peeled_mc2; i<rows; i++)
      {
        const LhsScalar* blA = &blockA[i*strideA+offsetA];
        prefetch(&blA[0]);


        ResScalar C0(0), C1(0), C2(0), C3(0);

        const RhsScalar* blB = &blockB[j2*strideB+offsetB*nr];
        for(Index k=0; k<depth; k++)
        {
          if(nr==2)
          {
            LhsScalar A0;
            RhsScalar B0, B1;

            A0 = blA[k];
            B0 = blB[0];
            B1 = blB[1];
            gebp_madd(cj,A0,B0,C0,B0);;
            gebp_madd(cj,A0,B1,C1,B1);;
          }
          else
          {
            LhsScalar A0;
            RhsScalar B0, B1, B2, B3;

            A0 = blA[k];
            B0 = blB[0];
            B1 = blB[1];
            B2 = blB[2];
            B3 = blB[3];

            gebp_madd(cj,A0,B0,C0,B0);;
            gebp_madd(cj,A0,B1,C1,B1);;
            gebp_madd(cj,A0,B2,C2,B2);;
            gebp_madd(cj,A0,B3,C3,B3);;
          }

          blB += nr;
        }
                  res[(j2+0)*resStride + i] += alpha*C0;
                  res[(j2+1)*resStride + i] += alpha*C1;
        if(nr==4) res[(j2+2)*resStride + i] += alpha*C2;
        if(nr==4) res[(j2+3)*resStride + i] += alpha*C3;
      }
    }


    for(Index j2=packet_cols; j2<cols; j2++)
    {

      traits.unpackRhs(depth, &blockB[j2*strideB+offsetB], unpackedB);

      for(Index i=0; i<peeled_mc; i+=mr)
      {
        const LhsScalar* blA = &blockA[i*strideA+offsetA*mr];
        prefetch(&blA[0]);




        AccPacket C0, C4;
        traits.initAcc(C0);
        traits.initAcc(C4);

        const RhsScalar* blB = unpackedB;
        for(Index k=0; k<depth; k++)
        {
          LhsPacket A0, A1;
          RhsPacket B0;
          RhsPacket T0;

          traits.loadLhs(&blA[0*LhsProgress], A0);
          traits.loadLhs(&blA[1*LhsProgress], A1);
          traits.loadRhs(&blB[0*RhsProgress], B0);
          traits.madd(A0,B0,C0,T0);
          traits.madd(A1,B0,C4,B0);

          blB += RhsProgress;
          blA += 2*LhsProgress;
        }
        ResPacket R0, R4;
        ResPacket alphav = pset1<ResPacket>(alpha);

        ResScalar* r0 = &res[(j2+0)*resStride + i];

        R0 = ploadu<ResPacket>(r0);
        R4 = ploadu<ResPacket>(r0+ResPacketSize);

        traits.acc(C0, alphav, R0);
        traits.acc(C4, alphav, R4);

        pstoreu(r0, R0);
        pstoreu(r0+ResPacketSize, R4);
      }
      if(rows-peeled_mc>=LhsProgress)
      {
        Index i = peeled_mc;
        const LhsScalar* blA = &blockA[i*strideA+offsetA*LhsProgress];
        prefetch(&blA[0]);

        AccPacket C0;
        traits.initAcc(C0);

        const RhsScalar* blB = unpackedB;
        for(Index k=0; k<depth; k++)
        {
          LhsPacket A0;
          RhsPacket B0;
          traits.loadLhs(blA, A0);
          traits.loadRhs(blB, B0);
          traits.madd(A0, B0, C0, B0);
          blB += RhsProgress;
          blA += LhsProgress;
        }

        ResPacket alphav = pset1<ResPacket>(alpha);
        ResPacket R0 = ploadu<ResPacket>(&res[(j2+0)*resStride + i]);
        traits.acc(C0, alphav, R0);
        pstoreu(&res[(j2+0)*resStride + i], R0);
      }
      for(Index i=peeled_mc2; i<rows; i++)
      {
        const LhsScalar* blA = &blockA[i*strideA+offsetA];
        prefetch(&blA[0]);


        ResScalar C0(0);

        const RhsScalar* blB = &blockB[j2*strideB+offsetB];
        for(Index k=0; k<depth; k++)
        {
          LhsScalar A0 = blA[k];
          RhsScalar B0 = blB[k];
          gebp_madd(cj,A0,B0,C0,B0);;
        }
        res[(j2+0)*resStride + i] += alpha*C0;
      }
    }
  }
};
# 1119 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralBlockPanelKernel.h"
template<typename Scalar, typename Index, int Pack1, int Pack2, int StorageOrder, bool Conjugate, bool PanelMode>
struct gemm_pack_lhs
{
  void operator()(Scalar* blockA, const Scalar* __restrict _lhs, Index lhsStride, Index depth, Index rows,
                  Index stride=0, Index offset=0)
  {

    if( (!Eigen::internal::copy_bool(((!PanelMode) && stride==0 && offset==0) || (PanelMode && stride>=depth && offset<=stride))) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(((!PanelMode) && stride==0 && offset==0) || (PanelMode && stride>=depth && offset<=stride))) Eigen::internal::assert_fail("((!PanelMode) && stride==0 && offset==0) || (PanelMode && stride>=depth && offset<=stride)", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralBlockPanelKernel.h", 1126); } while(false); else throw Eigen::eigen_assert_exception(); };
    conj_if<NumTraits<Scalar>::IsComplex && Conjugate> cj;
    const_blas_data_mapper<Scalar, Index, StorageOrder> lhs(_lhs,lhsStride);
    Index count = 0;
    Index peeled_mc = (rows/Pack1)*Pack1;
    for(Index i=0; i<peeled_mc; i+=Pack1)
    {
      if(PanelMode) count += Pack1 * offset;
      for(Index k=0; k<depth; k++)
        for(Index w=0; w<Pack1; w++)
          blockA[count++] = cj(lhs(i+w, k));
      if(PanelMode) count += Pack1 * (stride-offset-depth);
    }
    if(rows-peeled_mc>=Pack2)
    {
      if(PanelMode) count += Pack2*offset;
      for(Index k=0; k<depth; k++)
        for(Index w=0; w<Pack2; w++)
          blockA[count++] = cj(lhs(peeled_mc+w, k));
      if(PanelMode) count += Pack2 * (stride-offset-depth);
      peeled_mc += Pack2;
    }
    for(Index i=peeled_mc; i<rows; i++)
    {
      if(PanelMode) count += offset;
      for(Index k=0; k<depth; k++)
        blockA[count++] = cj(lhs(i, k));
      if(PanelMode) count += (stride-offset-depth);
    }
  }
};
# 1165 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralBlockPanelKernel.h"
template<typename Scalar, typename Index, int nr, bool Conjugate, bool PanelMode>
struct gemm_pack_rhs<Scalar, Index, nr, ColMajor, Conjugate, PanelMode>
{
  typedef typename packet_traits<Scalar>::type Packet;
  enum { PacketSize = packet_traits<Scalar>::size };
  void operator()(Scalar* blockB, const Scalar* rhs, Index rhsStride, Index depth, Index cols,
                  Index stride=0, Index offset=0)
  {
    if( (!Eigen::internal::copy_bool(((!PanelMode) && stride==0 && offset==0) || (PanelMode && stride>=depth && offset<=stride))) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(((!PanelMode) && stride==0 && offset==0) || (PanelMode && stride>=depth && offset<=stride))) Eigen::internal::assert_fail("((!PanelMode) && stride==0 && offset==0) || (PanelMode && stride>=depth && offset<=stride)", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralBlockPanelKernel.h", 1173); } while(false); else throw Eigen::eigen_assert_exception(); };
    conj_if<NumTraits<Scalar>::IsComplex && Conjugate> cj;
    Index packet_cols = (cols/nr) * nr;
    Index count = 0;
    for(Index j2=0; j2<packet_cols; j2+=nr)
    {

      if(PanelMode) count += nr * offset;
      const Scalar* b0 = &rhs[(j2+0)*rhsStride];
      const Scalar* b1 = &rhs[(j2+1)*rhsStride];
      const Scalar* b2 = &rhs[(j2+2)*rhsStride];
      const Scalar* b3 = &rhs[(j2+3)*rhsStride];
      for(Index k=0; k<depth; k++)
      {
                  blockB[count+0] = cj(b0[k]);
                  blockB[count+1] = cj(b1[k]);
        if(nr==4) blockB[count+2] = cj(b2[k]);
        if(nr==4) blockB[count+3] = cj(b3[k]);
        count += nr;
      }

      if(PanelMode) count += nr * (stride-offset-depth);
    }


    for(Index j2=packet_cols; j2<cols; ++j2)
    {
      if(PanelMode) count += offset;
      const Scalar* b0 = &rhs[(j2+0)*rhsStride];
      for(Index k=0; k<depth; k++)
      {
        blockB[count] = cj(b0[k]);
        count += 1;
      }
      if(PanelMode) count += (stride-offset-depth);
    }
  }
};


template<typename Scalar, typename Index, int nr, bool Conjugate, bool PanelMode>
struct gemm_pack_rhs<Scalar, Index, nr, RowMajor, Conjugate, PanelMode>
{
  enum { PacketSize = packet_traits<Scalar>::size };
  void operator()(Scalar* blockB, const Scalar* rhs, Index rhsStride, Index depth, Index cols,
                  Index stride=0, Index offset=0)
  {
    if( (!Eigen::internal::copy_bool(((!PanelMode) && stride==0 && offset==0) || (PanelMode && stride>=depth && offset<=stride))) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(((!PanelMode) && stride==0 && offset==0) || (PanelMode && stride>=depth && offset<=stride))) Eigen::internal::assert_fail("((!PanelMode) && stride==0 && offset==0) || (PanelMode && stride>=depth && offset<=stride)", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralBlockPanelKernel.h", 1220); } while(false); else throw Eigen::eigen_assert_exception(); };
    conj_if<NumTraits<Scalar>::IsComplex && Conjugate> cj;
    Index packet_cols = (cols/nr) * nr;
    Index count = 0;
    for(Index j2=0; j2<packet_cols; j2+=nr)
    {

      if(PanelMode) count += nr * offset;
      for(Index k=0; k<depth; k++)
      {
        const Scalar* b0 = &rhs[k*rhsStride + j2];
                  blockB[count+0] = cj(b0[0]);
                  blockB[count+1] = cj(b0[1]);
        if(nr==4) blockB[count+2] = cj(b0[2]);
        if(nr==4) blockB[count+3] = cj(b0[3]);
        count += nr;
      }

      if(PanelMode) count += nr * (stride-offset-depth);
    }

    for(Index j2=packet_cols; j2<cols; ++j2)
    {
      if(PanelMode) count += offset;
      const Scalar* b0 = &rhs[j2];
      for(Index k=0; k<depth; k++)
      {
        blockB[count] = cj(b0[k*rhsStride]);
        count += 1;
      }
      if(PanelMode) count += stride-offset-depth;
    }
  }
};

}



inline std::ptrdiff_t l1CacheSize()
{
  std::ptrdiff_t l1, l2;
  internal::manage_caching_sizes(GetAction, &l1, &l2);
  return l1;
}



inline std::ptrdiff_t l2CacheSize()
{
  std::ptrdiff_t l1, l2;
  internal::manage_caching_sizes(GetAction, &l1, &l2);
  return l2;
}






inline void setCpuCacheSizes(std::ptrdiff_t l1, std::ptrdiff_t l2)
{
  internal::manage_caching_sizes(SetAction, &l1, &l2);
}
# 328 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralMatrixVector.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralMatrixVector.h"
namespace internal {
# 43 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralMatrixVector.h"
template<typename Index, typename LhsScalar, bool ConjugateLhs, typename RhsScalar, bool ConjugateRhs>
struct general_matrix_vector_product<Index,LhsScalar,ColMajor,ConjugateLhs,RhsScalar,ConjugateRhs>
{
typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;

enum {
  Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable
              && int(packet_traits<LhsScalar>::size)==int(packet_traits<RhsScalar>::size),
  LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,
  RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,
  ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1
};

typedef typename packet_traits<LhsScalar>::type _LhsPacket;
typedef typename packet_traits<RhsScalar>::type _RhsPacket;
typedef typename packet_traits<ResScalar>::type _ResPacket;

typedef typename conditional<Vectorizable,_LhsPacket,LhsScalar>::type LhsPacket;
typedef typename conditional<Vectorizable,_RhsPacket,RhsScalar>::type RhsPacket;
typedef typename conditional<Vectorizable,_ResPacket,ResScalar>::type ResPacket;

__attribute__((noinline)) static void run(
  Index rows, Index cols,
  const LhsScalar* lhs, Index lhsStride,
  const RhsScalar* rhs, Index rhsIncr,
  ResScalar* res, Index

    resIncr

  , RhsScalar alpha)
{
  if( (!Eigen::internal::copy_bool(resIncr==1)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(resIncr==1)) Eigen::internal::assert_fail("resIncr==1", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralMatrixVector.h", 74); } while(false); else throw Eigen::eigen_assert_exception(); };
# 87 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralMatrixVector.h"
  conj_helper<LhsScalar,RhsScalar,ConjugateLhs,ConjugateRhs> cj;
  conj_helper<LhsPacket,RhsPacket,ConjugateLhs,ConjugateRhs> pcj;
  if(ConjugateRhs)
    alpha = conj(alpha);

  enum { AllAligned = 0, EvenAligned, FirstAligned, NoneAligned };
  const Index columnsAtOnce = 4;
  const Index peels = 2;
  const Index LhsPacketAlignedMask = LhsPacketSize-1;
  const Index ResPacketAlignedMask = ResPacketSize-1;
  const Index PeelAlignedMask = ResPacketSize*peels-1;
  const Index size = rows;



  Index alignedStart = first_aligned(res,size);
  Index alignedSize = ResPacketSize>1 ? alignedStart + ((size-alignedStart) & ~ResPacketAlignedMask) : 0;
  const Index peeledSize = peels>1 ? alignedStart + ((alignedSize-alignedStart) & ~PeelAlignedMask) : alignedStart;

  const Index alignmentStep = LhsPacketSize>1 ? (LhsPacketSize - lhsStride % LhsPacketSize) & LhsPacketAlignedMask : 0;
  Index alignmentPattern = alignmentStep==0 ? AllAligned
                       : alignmentStep==(LhsPacketSize/2) ? EvenAligned
                       : FirstAligned;


  const Index lhsAlignmentOffset = first_aligned(lhs,size);


  Index skipColumns = 0;

  if( (size_t(lhs)%sizeof(LhsScalar)) || (size_t(res)%sizeof(ResScalar)) )
  {
    alignedSize = 0;
    alignedStart = 0;
  }
  else if (LhsPacketSize>1)
  {
    if( (!Eigen::internal::copy_bool(size_t(lhs+lhsAlignmentOffset)%sizeof(LhsPacket)==0 || size<LhsPacketSize)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(size_t(lhs+lhsAlignmentOffset)%sizeof(LhsPacket)==0 || size<LhsPacketSize)) Eigen::internal::assert_fail("size_t(lhs+lhsAlignmentOffset)%sizeof(LhsPacket)==0 || size<LhsPacketSize", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralMatrixVector.h", 124); } while(false); else throw Eigen::eigen_assert_exception(); };

    while (skipColumns<LhsPacketSize &&
          alignedStart != ((lhsAlignmentOffset + alignmentStep*skipColumns)%LhsPacketSize))
      ++skipColumns;
    if (skipColumns==LhsPacketSize)
    {

      alignmentPattern = NoneAligned;
      skipColumns = 0;
    }
    else
    {
      skipColumns = (std::min)(skipColumns,cols);

    }

    if( (!Eigen::internal::copy_bool((alignmentPattern==NoneAligned) || (skipColumns + columnsAtOnce >= cols) || LhsPacketSize > size || (size_t(lhs+alignedStart+lhsStride*skipColumns)%sizeof(LhsPacket))==0)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool((alignmentPattern==NoneAligned) || (skipColumns + columnsAtOnce >= cols) || LhsPacketSize > size || (size_t(lhs+alignedStart+lhsStride*skipColumns)%sizeof(LhsPacket))==0)) Eigen::internal::assert_fail("(alignmentPattern==NoneAligned) || (skipColumns + columnsAtOnce >= cols) || LhsPacketSize > size || (size_t(lhs+alignedStart+lhsStride*skipColumns)%sizeof(LhsPacket))==0", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralMatrixVector.h", 144); } while(false); else throw Eigen::eigen_assert_exception(); };



  }
  else if(Vectorizable)
  {
    alignedStart = 0;
    alignedSize = size;
    alignmentPattern = AllAligned;
  }

  Index offset1 = (FirstAligned && alignmentStep==1?3:1);
  Index offset3 = (FirstAligned && alignmentStep==1?1:3);

  Index columnBound = ((cols-skipColumns)/columnsAtOnce)*columnsAtOnce + skipColumns;
  for (Index i=skipColumns; i<columnBound; i+=columnsAtOnce)
  {
    RhsPacket ptmp0 = pset1<RhsPacket>(alpha*rhs[i*rhsIncr]),
              ptmp1 = pset1<RhsPacket>(alpha*rhs[(i+offset1)*rhsIncr]),
              ptmp2 = pset1<RhsPacket>(alpha*rhs[(i+2)*rhsIncr]),
              ptmp3 = pset1<RhsPacket>(alpha*rhs[(i+offset3)*rhsIncr]);


    const LhsScalar *lhs0 = lhs + i*lhsStride, *lhs1 = lhs + (i+offset1)*lhsStride,
                    *lhs2 = lhs + (i+2)*lhsStride, *lhs3 = lhs + (i+offset3)*lhsStride;

    if (Vectorizable)
    {


      for (Index j=0; j<alignedStart; ++j)
      {
        res[j] = cj.pmadd(lhs0[j], pfirst(ptmp0), res[j]);
        res[j] = cj.pmadd(lhs1[j], pfirst(ptmp1), res[j]);
        res[j] = cj.pmadd(lhs2[j], pfirst(ptmp2), res[j]);
        res[j] = cj.pmadd(lhs3[j], pfirst(ptmp3), res[j]);
      }

      if (alignedSize>alignedStart)
      {
        switch(alignmentPattern)
        {
          case AllAligned:
            for (Index j = alignedStart; j<alignedSize; j+=ResPacketSize)
              pstore(&res[j], padd(pload<ResPacket>(&res[j]), padd( padd(pcj.pmul(pload<LhsPacket>(&lhs0[j]), ptmp0), pcj.pmul(pload<LhsPacket>(&lhs1[j]), ptmp1)), padd(pcj.pmul(pload<LhsPacket>(&lhs2[j]), ptmp2), pcj.pmul(pload<LhsPacket>(&lhs3[j]), ptmp3)) )));
            break;
          case EvenAligned:
            for (Index j = alignedStart; j<alignedSize; j+=ResPacketSize)
              pstore(&res[j], padd(pload<ResPacket>(&res[j]), padd( padd(pcj.pmul(pload<LhsPacket>(&lhs0[j]), ptmp0), pcj.pmul(ploadu<LhsPacket>(&lhs1[j]), ptmp1)), padd(pcj.pmul(pload<LhsPacket>(&lhs2[j]), ptmp2), pcj.pmul(ploadu<LhsPacket>(&lhs3[j]), ptmp3)) )));
            break;
          case FirstAligned:
            if(peels>1)
            {
              LhsPacket A00, A01, A02, A03, A10, A11, A12, A13;
              ResPacket T0, T1;

              A01 = pload<LhsPacket>(&lhs1[alignedStart-1]);
              A02 = pload<LhsPacket>(&lhs2[alignedStart-2]);
              A03 = pload<LhsPacket>(&lhs3[alignedStart-3]);

              for (Index j = alignedStart; j<peeledSize; j+=peels*ResPacketSize)
              {
                A11 = pload<LhsPacket>(&lhs1[j-1+LhsPacketSize]); palign<1>(A01,A11);
                A12 = pload<LhsPacket>(&lhs2[j-2+LhsPacketSize]); palign<2>(A02,A12);
                A13 = pload<LhsPacket>(&lhs3[j-3+LhsPacketSize]); palign<3>(A03,A13);

                A00 = pload<LhsPacket>(&lhs0[j]);
                A10 = pload<LhsPacket>(&lhs0[j+LhsPacketSize]);
                T0 = pcj.pmadd(A00, ptmp0, pload<ResPacket>(&res[j]));
                T1 = pcj.pmadd(A10, ptmp0, pload<ResPacket>(&res[j+ResPacketSize]));

                T0 = pcj.pmadd(A01, ptmp1, T0);
                A01 = pload<LhsPacket>(&lhs1[j-1+2*LhsPacketSize]); palign<1>(A11,A01);
                T0 = pcj.pmadd(A02, ptmp2, T0);
                A02 = pload<LhsPacket>(&lhs2[j-2+2*LhsPacketSize]); palign<2>(A12,A02);
                T0 = pcj.pmadd(A03, ptmp3, T0);
                pstore(&res[j],T0);
                A03 = pload<LhsPacket>(&lhs3[j-3+2*LhsPacketSize]); palign<3>(A13,A03);
                T1 = pcj.pmadd(A11, ptmp1, T1);
                T1 = pcj.pmadd(A12, ptmp2, T1);
                T1 = pcj.pmadd(A13, ptmp3, T1);
                pstore(&res[j+ResPacketSize],T1);
              }
            }
            for (Index j = peeledSize; j<alignedSize; j+=ResPacketSize)
              pstore(&res[j], padd(pload<ResPacket>(&res[j]), padd( padd(pcj.pmul(pload<LhsPacket>(&lhs0[j]), ptmp0), pcj.pmul(ploadu<LhsPacket>(&lhs1[j]), ptmp1)), padd(pcj.pmul(ploadu<LhsPacket>(&lhs2[j]), ptmp2), pcj.pmul(ploadu<LhsPacket>(&lhs3[j]), ptmp3)) )));
            break;
          default:
            for (Index j = alignedStart; j<alignedSize; j+=ResPacketSize)
              pstore(&res[j], padd(pload<ResPacket>(&res[j]), padd( padd(pcj.pmul(ploadu<LhsPacket>(&lhs0[j]), ptmp0), pcj.pmul(ploadu<LhsPacket>(&lhs1[j]), ptmp1)), padd(pcj.pmul(ploadu<LhsPacket>(&lhs2[j]), ptmp2), pcj.pmul(ploadu<LhsPacket>(&lhs3[j]), ptmp3)) )));
            break;
        }
      }
    }


    for (Index j=alignedSize; j<size; ++j)
    {
      res[j] = cj.pmadd(lhs0[j], pfirst(ptmp0), res[j]);
      res[j] = cj.pmadd(lhs1[j], pfirst(ptmp1), res[j]);
      res[j] = cj.pmadd(lhs2[j], pfirst(ptmp2), res[j]);
      res[j] = cj.pmadd(lhs3[j], pfirst(ptmp3), res[j]);
    }
  }


  Index end = cols;
  Index start = columnBound;
  do
  {
    for (Index k=start; k<end; ++k)
    {
      RhsPacket ptmp0 = pset1<RhsPacket>(alpha*rhs[k*rhsIncr]);
      const LhsScalar* lhs0 = lhs + k*lhsStride;

      if (Vectorizable)
      {


        for (Index j=0; j<alignedStart; ++j)
          res[j] += cj.pmul(lhs0[j], pfirst(ptmp0));

        if ((size_t(lhs0+alignedStart)%sizeof(LhsPacket))==0)
          for (Index i = alignedStart;i<alignedSize;i+=ResPacketSize)
            pstore(&res[i], pcj.pmadd(ploadu<LhsPacket>(&lhs0[i]), ptmp0, pload<ResPacket>(&res[i])));
        else
          for (Index i = alignedStart;i<alignedSize;i+=ResPacketSize)
            pstore(&res[i], pcj.pmadd(ploadu<LhsPacket>(&lhs0[i]), ptmp0, pload<ResPacket>(&res[i])));
      }


      for (Index i=alignedSize; i<size; ++i)
        res[i] += cj.pmul(lhs0[i], pfirst(ptmp0));
    }
    if (skipColumns)
    {
      start = 0;
      end = skipColumns;
      skipColumns = 0;
    }
    else
      break;
  } while(Vectorizable);

}
};
# 299 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralMatrixVector.h"
template<typename Index, typename LhsScalar, bool ConjugateLhs, typename RhsScalar, bool ConjugateRhs>
struct general_matrix_vector_product<Index,LhsScalar,RowMajor,ConjugateLhs,RhsScalar,ConjugateRhs>
{
typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;

enum {
  Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable
              && int(packet_traits<LhsScalar>::size)==int(packet_traits<RhsScalar>::size),
  LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,
  RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,
  ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1
};

typedef typename packet_traits<LhsScalar>::type _LhsPacket;
typedef typename packet_traits<RhsScalar>::type _RhsPacket;
typedef typename packet_traits<ResScalar>::type _ResPacket;

typedef typename conditional<Vectorizable,_LhsPacket,LhsScalar>::type LhsPacket;
typedef typename conditional<Vectorizable,_RhsPacket,RhsScalar>::type RhsPacket;
typedef typename conditional<Vectorizable,_ResPacket,ResScalar>::type ResPacket;

__attribute__((noinline)) static void run(
  Index rows, Index cols,
  const LhsScalar* lhs, Index lhsStride,
  const RhsScalar* rhs, Index rhsIncr,
  ResScalar* res, Index resIncr,
  ResScalar alpha)
{
  (void)rhsIncr;;
  if( (!Eigen::internal::copy_bool(rhsIncr==1)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(rhsIncr==1)) Eigen::internal::assert_fail("rhsIncr==1", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralMatrixVector.h", 328); } while(false); else throw Eigen::eigen_assert_exception(); };
# 340 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralMatrixVector.h"
  conj_helper<LhsScalar,RhsScalar,ConjugateLhs,ConjugateRhs> cj;
  conj_helper<LhsPacket,RhsPacket,ConjugateLhs,ConjugateRhs> pcj;

  enum { AllAligned=0, EvenAligned=1, FirstAligned=2, NoneAligned=3 };
  const Index rowsAtOnce = 4;
  const Index peels = 2;
  const Index RhsPacketAlignedMask = RhsPacketSize-1;
  const Index LhsPacketAlignedMask = LhsPacketSize-1;
  const Index PeelAlignedMask = RhsPacketSize*peels-1;
  const Index depth = cols;




  Index alignedStart = first_aligned(rhs, depth);
  Index alignedSize = RhsPacketSize>1 ? alignedStart + ((depth-alignedStart) & ~RhsPacketAlignedMask) : 0;
  const Index peeledSize = peels>1 ? alignedStart + ((alignedSize-alignedStart) & ~PeelAlignedMask) : alignedStart;

  const Index alignmentStep = LhsPacketSize>1 ? (LhsPacketSize - lhsStride % LhsPacketSize) & LhsPacketAlignedMask : 0;
  Index alignmentPattern = alignmentStep==0 ? AllAligned
                         : alignmentStep==(LhsPacketSize/2) ? EvenAligned
                         : FirstAligned;


  const Index lhsAlignmentOffset = first_aligned(lhs,depth);


  Index skipRows = 0;

  if( (sizeof(LhsScalar)!=sizeof(RhsScalar)) || (size_t(lhs)%sizeof(LhsScalar)) || (size_t(rhs)%sizeof(RhsScalar)) )
  {
    alignedSize = 0;
    alignedStart = 0;
  }
  else if (LhsPacketSize>1)
  {
    if( (!Eigen::internal::copy_bool(size_t(lhs+lhsAlignmentOffset)%sizeof(LhsPacket)==0 || depth<LhsPacketSize)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(size_t(lhs+lhsAlignmentOffset)%sizeof(LhsPacket)==0 || depth<LhsPacketSize)) Eigen::internal::assert_fail("size_t(lhs+lhsAlignmentOffset)%sizeof(LhsPacket)==0 || depth<LhsPacketSize", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralMatrixVector.h", 376); } while(false); else throw Eigen::eigen_assert_exception(); };

    while (skipRows<LhsPacketSize &&
           alignedStart != ((lhsAlignmentOffset + alignmentStep*skipRows)%LhsPacketSize))
      ++skipRows;
    if (skipRows==LhsPacketSize)
    {

      alignmentPattern = NoneAligned;
      skipRows = 0;
    }
    else
    {
      skipRows = (std::min)(skipRows,Index(rows));

    }
    if( (!Eigen::internal::copy_bool(alignmentPattern==NoneAligned || LhsPacketSize==1 || (skipRows + rowsAtOnce >= rows) || LhsPacketSize > depth || (size_t(lhs+alignedStart+lhsStride*skipRows)%sizeof(LhsPacket))==0)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(alignmentPattern==NoneAligned || LhsPacketSize==1 || (skipRows + rowsAtOnce >= rows) || LhsPacketSize > depth || (size_t(lhs+alignedStart+lhsStride*skipRows)%sizeof(LhsPacket))==0)) Eigen::internal::assert_fail("alignmentPattern==NoneAligned || LhsPacketSize==1 || (skipRows + rowsAtOnce >= rows) || LhsPacketSize > depth || (size_t(lhs+alignedStart+lhsStride*skipRows)%sizeof(LhsPacket))==0", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralMatrixVector.h", 396); } while(false); else throw Eigen::eigen_assert_exception(); };




  }
  else if(Vectorizable)
  {
    alignedStart = 0;
    alignedSize = depth;
    alignmentPattern = AllAligned;
  }

  Index offset1 = (FirstAligned && alignmentStep==1?3:1);
  Index offset3 = (FirstAligned && alignmentStep==1?1:3);

  Index rowBound = ((rows-skipRows)/rowsAtOnce)*rowsAtOnce + skipRows;
  for (Index i=skipRows; i<rowBound; i+=rowsAtOnce)
  {
    __attribute__((aligned(16))) ResScalar tmp0 = ResScalar(0);
    ResScalar tmp1 = ResScalar(0), tmp2 = ResScalar(0), tmp3 = ResScalar(0);


    const LhsScalar *lhs0 = lhs + i*lhsStride, *lhs1 = lhs + (i+offset1)*lhsStride,
                    *lhs2 = lhs + (i+2)*lhsStride, *lhs3 = lhs + (i+offset3)*lhsStride;

    if (Vectorizable)
    {

      ResPacket ptmp0 = pset1<ResPacket>(ResScalar(0)), ptmp1 = pset1<ResPacket>(ResScalar(0)),
                ptmp2 = pset1<ResPacket>(ResScalar(0)), ptmp3 = pset1<ResPacket>(ResScalar(0));



      for (Index j=0; j<alignedStart; ++j)
      {
        RhsScalar b = rhs[j];
        tmp0 += cj.pmul(lhs0[j],b); tmp1 += cj.pmul(lhs1[j],b);
        tmp2 += cj.pmul(lhs2[j],b); tmp3 += cj.pmul(lhs3[j],b);
      }

      if (alignedSize>alignedStart)
      {
        switch(alignmentPattern)
        {
          case AllAligned:
            for (Index j = alignedStart; j<alignedSize; j+=RhsPacketSize)
              { RhsPacket b = pload<RhsPacket>(&rhs[j]); ptmp0 = pcj.pmadd(pload <LhsPacket>(&lhs0[j]), b, ptmp0); ptmp1 = pcj.pmadd(pload<LhsPacket>(&lhs1[j]), b, ptmp1); ptmp2 = pcj.pmadd(pload <LhsPacket>(&lhs2[j]), b, ptmp2); ptmp3 = pcj.pmadd(pload<LhsPacket>(&lhs3[j]), b, ptmp3); };
            break;
          case EvenAligned:
            for (Index j = alignedStart; j<alignedSize; j+=RhsPacketSize)
              { RhsPacket b = pload<RhsPacket>(&rhs[j]); ptmp0 = pcj.pmadd(pload <LhsPacket>(&lhs0[j]), b, ptmp0); ptmp1 = pcj.pmadd(ploadu<LhsPacket>(&lhs1[j]), b, ptmp1); ptmp2 = pcj.pmadd(pload <LhsPacket>(&lhs2[j]), b, ptmp2); ptmp3 = pcj.pmadd(ploadu<LhsPacket>(&lhs3[j]), b, ptmp3); };
            break;
          case FirstAligned:
            if (peels>1)
            {






              LhsPacket A01, A02, A03, A11, A12, A13;
              A01 = pload<LhsPacket>(&lhs1[alignedStart-1]);
              A02 = pload<LhsPacket>(&lhs2[alignedStart-2]);
              A03 = pload<LhsPacket>(&lhs3[alignedStart-3]);

              for (Index j = alignedStart; j<peeledSize; j+=peels*RhsPacketSize)
              {
                RhsPacket b = pload<RhsPacket>(&rhs[j]);
                A11 = pload<LhsPacket>(&lhs1[j-1+LhsPacketSize]); palign<1>(A01,A11);
                A12 = pload<LhsPacket>(&lhs2[j-2+LhsPacketSize]); palign<2>(A02,A12);
                A13 = pload<LhsPacket>(&lhs3[j-3+LhsPacketSize]); palign<3>(A03,A13);

                ptmp0 = pcj.pmadd(pload<LhsPacket>(&lhs0[j]), b, ptmp0);
                ptmp1 = pcj.pmadd(A01, b, ptmp1);
                A01 = pload<LhsPacket>(&lhs1[j-1+2*LhsPacketSize]); palign<1>(A11,A01);
                ptmp2 = pcj.pmadd(A02, b, ptmp2);
                A02 = pload<LhsPacket>(&lhs2[j-2+2*LhsPacketSize]); palign<2>(A12,A02);
                ptmp3 = pcj.pmadd(A03, b, ptmp3);
                A03 = pload<LhsPacket>(&lhs3[j-3+2*LhsPacketSize]); palign<3>(A13,A03);

                b = pload<RhsPacket>(&rhs[j+RhsPacketSize]);
                ptmp0 = pcj.pmadd(pload<LhsPacket>(&lhs0[j+LhsPacketSize]), b, ptmp0);
                ptmp1 = pcj.pmadd(A11, b, ptmp1);
                ptmp2 = pcj.pmadd(A12, b, ptmp2);
                ptmp3 = pcj.pmadd(A13, b, ptmp3);
              }
            }
            for (Index j = peeledSize; j<alignedSize; j+=RhsPacketSize)
              { RhsPacket b = pload<RhsPacket>(&rhs[j]); ptmp0 = pcj.pmadd(pload <LhsPacket>(&lhs0[j]), b, ptmp0); ptmp1 = pcj.pmadd(ploadu<LhsPacket>(&lhs1[j]), b, ptmp1); ptmp2 = pcj.pmadd(ploadu <LhsPacket>(&lhs2[j]), b, ptmp2); ptmp3 = pcj.pmadd(ploadu<LhsPacket>(&lhs3[j]), b, ptmp3); };
            break;
          default:
            for (Index j = alignedStart; j<alignedSize; j+=RhsPacketSize)
              { RhsPacket b = pload<RhsPacket>(&rhs[j]); ptmp0 = pcj.pmadd(ploadu <LhsPacket>(&lhs0[j]), b, ptmp0); ptmp1 = pcj.pmadd(ploadu<LhsPacket>(&lhs1[j]), b, ptmp1); ptmp2 = pcj.pmadd(ploadu <LhsPacket>(&lhs2[j]), b, ptmp2); ptmp3 = pcj.pmadd(ploadu<LhsPacket>(&lhs3[j]), b, ptmp3); };
            break;
        }
        tmp0 += predux(ptmp0);
        tmp1 += predux(ptmp1);
        tmp2 += predux(ptmp2);
        tmp3 += predux(ptmp3);
      }
    }



    for (Index j=alignedSize; j<depth; ++j)
    {
      RhsScalar b = rhs[j];
      tmp0 += cj.pmul(lhs0[j],b); tmp1 += cj.pmul(lhs1[j],b);
      tmp2 += cj.pmul(lhs2[j],b); tmp3 += cj.pmul(lhs3[j],b);
    }
    res[i*resIncr] += alpha*tmp0;
    res[(i+offset1)*resIncr] += alpha*tmp1;
    res[(i+2)*resIncr] += alpha*tmp2;
    res[(i+offset3)*resIncr] += alpha*tmp3;
  }


  Index end = rows;
  Index start = rowBound;
  do
  {
    for (Index i=start; i<end; ++i)
    {
      __attribute__((aligned(16))) ResScalar tmp0 = ResScalar(0);
      ResPacket ptmp0 = pset1<ResPacket>(tmp0);
      const LhsScalar* lhs0 = lhs + i*lhsStride;


      for (Index j=0; j<alignedStart; ++j)
        tmp0 += cj.pmul(lhs0[j], rhs[j]);

      if (alignedSize>alignedStart)
      {

        if ((size_t(lhs0+alignedStart)%sizeof(LhsPacket))==0)
          for (Index j = alignedStart;j<alignedSize;j+=RhsPacketSize)
            ptmp0 = pcj.pmadd(pload<LhsPacket>(&lhs0[j]), pload<RhsPacket>(&rhs[j]), ptmp0);
        else
          for (Index j = alignedStart;j<alignedSize;j+=RhsPacketSize)
            ptmp0 = pcj.pmadd(ploadu<LhsPacket>(&lhs0[j]), pload<RhsPacket>(&rhs[j]), ptmp0);
        tmp0 += predux(ptmp0);
      }



      for (Index j=alignedSize; j<depth; ++j)
        tmp0 += cj.pmul(lhs0[j], rhs[j]);
      res[i*resIncr] += alpha*tmp0;
    }
    if (skipRows)
    {
      start = 0;
      end = skipRows;
      skipRows = 0;
    }
    else
      break;
  } while(Vectorizable);


}
};

}
# 329 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralMatrixMatrix.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralMatrixMatrix.h"
namespace internal {

template<typename _LhsScalar, typename _RhsScalar> class level3_blocking;


template<
  typename Index,
  typename LhsScalar, int LhsStorageOrder, bool ConjugateLhs,
  typename RhsScalar, int RhsStorageOrder, bool ConjugateRhs>
struct general_matrix_matrix_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,RowMajor>
{
  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;
  static inline void run(
    Index rows, Index cols, Index depth,
    const LhsScalar* lhs, Index lhsStride,
    const RhsScalar* rhs, Index rhsStride,
    ResScalar* res, Index resStride,
    ResScalar alpha,
    level3_blocking<RhsScalar,LhsScalar>& blocking,
    GemmParallelInfo<Index>* info = 0)
  {

    general_matrix_matrix_product<Index,
      RhsScalar, RhsStorageOrder==RowMajor ? ColMajor : RowMajor, ConjugateRhs,
      LhsScalar, LhsStorageOrder==RowMajor ? ColMajor : RowMajor, ConjugateLhs,
      ColMajor>
    ::run(cols,rows,depth,rhs,rhsStride,lhs,lhsStride,res,resStride,alpha,blocking,info);
  }
};



template<
  typename Index,
  typename LhsScalar, int LhsStorageOrder, bool ConjugateLhs,
  typename RhsScalar, int RhsStorageOrder, bool ConjugateRhs>
struct general_matrix_matrix_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,ColMajor>
{
typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;
static void run(Index rows, Index cols, Index depth,
  const LhsScalar* _lhs, Index lhsStride,
  const RhsScalar* _rhs, Index rhsStride,
  ResScalar* res, Index resStride,
  ResScalar alpha,
  level3_blocking<LhsScalar,RhsScalar>& blocking,
  GemmParallelInfo<Index>* info = 0)
{
  const_blas_data_mapper<LhsScalar, Index, LhsStorageOrder> lhs(_lhs,lhsStride);
  const_blas_data_mapper<RhsScalar, Index, RhsStorageOrder> rhs(_rhs,rhsStride);

  typedef gebp_traits<LhsScalar,RhsScalar> Traits;

  Index kc = blocking.kc();
  Index mc = (std::min)(rows,blocking.mc());


  gemm_pack_lhs<LhsScalar, Index, Traits::mr, Traits::LhsProgress, LhsStorageOrder> pack_lhs;
  gemm_pack_rhs<RhsScalar, Index, Traits::nr, RhsStorageOrder> pack_rhs;
  gebp_kernel<LhsScalar, RhsScalar, Index, Traits::mr, Traits::nr, ConjugateLhs, ConjugateRhs> gebp;
# 161 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralMatrixMatrix.h"
  {
    (void)info;;


    std::size_t sizeA = kc*mc;
    std::size_t sizeB = kc*cols;
    std::size_t sizeW = kc*Traits::WorkSpaceFactor;

    LhsScalar* blockA = (blocking.blockA())!=0 ? (blocking.blockA()) : reinterpret_cast<LhsScalar*>( (sizeof(LhsScalar)*sizeA<=0) ? __builtin_alloca (sizeof(LhsScalar)*sizeA) : Eigen::internal::aligned_malloc(sizeof(LhsScalar)*sizeA) ); Eigen::internal::aligned_stack_memory_handler<LhsScalar> blockA_stack_memory_destructor((blocking.blockA())==0 ? blockA : 0,sizeA,sizeof(LhsScalar)*sizeA>0);
    RhsScalar* blockB = (blocking.blockB())!=0 ? (blocking.blockB()) : reinterpret_cast<RhsScalar*>( (sizeof(RhsScalar)*sizeB<=0) ? __builtin_alloca (sizeof(RhsScalar)*sizeB) : Eigen::internal::aligned_malloc(sizeof(RhsScalar)*sizeB) ); Eigen::internal::aligned_stack_memory_handler<RhsScalar> blockB_stack_memory_destructor((blocking.blockB())==0 ? blockB : 0,sizeB,sizeof(RhsScalar)*sizeB>0);
    RhsScalar* blockW = (blocking.blockW())!=0 ? (blocking.blockW()) : reinterpret_cast<RhsScalar*>( (sizeof(RhsScalar)*sizeW<=0) ? __builtin_alloca (sizeof(RhsScalar)*sizeW) : Eigen::internal::aligned_malloc(sizeof(RhsScalar)*sizeW) ); Eigen::internal::aligned_stack_memory_handler<RhsScalar> blockW_stack_memory_destructor((blocking.blockW())==0 ? blockW : 0,sizeW,sizeof(RhsScalar)*sizeW>0);



    for(Index k2=0; k2<depth; k2+=kc)
    {
      const Index actual_kc = (std::min)(k2+kc,depth)-k2;





      pack_rhs(blockB, &rhs(k2,0), rhsStride, actual_kc, cols);




      for(Index i2=0; i2<rows; i2+=mc)
      {
        const Index actual_mc = (std::min)(i2+mc,rows)-i2;




        pack_lhs(blockA, &lhs(i2,k2), lhsStride, actual_kc, actual_mc);


        gebp(res+i2, resStride, blockA, blockB, actual_mc, actual_kc, cols, alpha, -1, -1, 0, 0, blockW);

      }
    }
  }
}

};






template<typename Lhs, typename Rhs>
struct traits<GeneralProduct<Lhs,Rhs,GemmProduct> >
 : traits<ProductBase<GeneralProduct<Lhs,Rhs,GemmProduct>, Lhs, Rhs> >
{};

template<typename Scalar, typename Index, typename Gemm, typename Lhs, typename Rhs, typename Dest, typename BlockingType>
struct gemm_functor
{
  gemm_functor(const Lhs& lhs, const Rhs& rhs, Dest& dest, Scalar actualAlpha,
                  BlockingType& blocking)
    : m_lhs(lhs), m_rhs(rhs), m_dest(dest), m_actualAlpha(actualAlpha), m_blocking(blocking)
  {}

  void initParallelSession() const
  {
    m_blocking.allocateB();
  }

  void operator() (Index row, Index rows, Index col=0, Index cols=-1, GemmParallelInfo<Index>* info=0) const
  {
    if(cols==-1)
      cols = m_rhs.cols();

    Gemm::run(rows, cols, m_lhs.cols(),
                                 &m_lhs.coeffRef(row,0), m_lhs.outerStride(),
                                 &m_rhs.coeffRef(0,col), m_rhs.outerStride(),
              (Scalar*)&(m_dest.coeffRef(row,col)), m_dest.outerStride(),
              m_actualAlpha, m_blocking, info);
  }

  protected:
    const Lhs& m_lhs;
    const Rhs& m_rhs;
    Dest& m_dest;
    Scalar m_actualAlpha;
    BlockingType& m_blocking;
};

template<int StorageOrder, typename LhsScalar, typename RhsScalar, int MaxRows, int MaxCols, int MaxDepth,
bool FiniteAtCompileTime = MaxRows!=Dynamic && MaxCols!=Dynamic && MaxDepth != Dynamic> class gemm_blocking_space;

template<typename _LhsScalar, typename _RhsScalar>
class level3_blocking
{
    typedef _LhsScalar LhsScalar;
    typedef _RhsScalar RhsScalar;

  protected:
    LhsScalar* m_blockA;
    RhsScalar* m_blockB;
    RhsScalar* m_blockW;

    DenseIndex m_mc;
    DenseIndex m_nc;
    DenseIndex m_kc;

  public:

    level3_blocking()
      : m_blockA(0), m_blockB(0), m_blockW(0), m_mc(0), m_nc(0), m_kc(0)
    {}

    inline DenseIndex mc() const { return m_mc; }
    inline DenseIndex nc() const { return m_nc; }
    inline DenseIndex kc() const { return m_kc; }

    inline LhsScalar* blockA() { return m_blockA; }
    inline RhsScalar* blockB() { return m_blockB; }
    inline RhsScalar* blockW() { return m_blockW; }
};

template<int StorageOrder, typename _LhsScalar, typename _RhsScalar, int MaxRows, int MaxCols, int MaxDepth>
class gemm_blocking_space<StorageOrder,_LhsScalar,_RhsScalar,MaxRows, MaxCols, MaxDepth, true>
  : public level3_blocking<
      typename conditional<StorageOrder==RowMajor,_RhsScalar,_LhsScalar>::type,
      typename conditional<StorageOrder==RowMajor,_LhsScalar,_RhsScalar>::type>
{
    enum {
      Transpose = StorageOrder==RowMajor,
      ActualRows = Transpose ? MaxCols : MaxRows,
      ActualCols = Transpose ? MaxRows : MaxCols
    };
    typedef typename conditional<Transpose,_RhsScalar,_LhsScalar>::type LhsScalar;
    typedef typename conditional<Transpose,_LhsScalar,_RhsScalar>::type RhsScalar;
    typedef gebp_traits<LhsScalar,RhsScalar> Traits;
    enum {
      SizeA = ActualRows * MaxDepth,
      SizeB = ActualCols * MaxDepth,
      SizeW = MaxDepth * Traits::WorkSpaceFactor
    };

    __attribute__((aligned(16))) LhsScalar m_staticA[SizeA];
    __attribute__((aligned(16))) RhsScalar m_staticB[SizeB];
    __attribute__((aligned(16))) RhsScalar m_staticW[SizeW];

  public:

    gemm_blocking_space(DenseIndex , DenseIndex , DenseIndex )
    {
      this->m_mc = ActualRows;
      this->m_nc = ActualCols;
      this->m_kc = MaxDepth;
      this->m_blockA = m_staticA;
      this->m_blockB = m_staticB;
      this->m_blockW = m_staticW;
    }

    inline void allocateA() {}
    inline void allocateB() {}
    inline void allocateW() {}
    inline void allocateAll() {}
};

template<int StorageOrder, typename _LhsScalar, typename _RhsScalar, int MaxRows, int MaxCols, int MaxDepth>
class gemm_blocking_space<StorageOrder,_LhsScalar,_RhsScalar,MaxRows, MaxCols, MaxDepth, false>
  : public level3_blocking<
      typename conditional<StorageOrder==RowMajor,_RhsScalar,_LhsScalar>::type,
      typename conditional<StorageOrder==RowMajor,_LhsScalar,_RhsScalar>::type>
{
    enum {
      Transpose = StorageOrder==RowMajor
    };
    typedef typename conditional<Transpose,_RhsScalar,_LhsScalar>::type LhsScalar;
    typedef typename conditional<Transpose,_LhsScalar,_RhsScalar>::type RhsScalar;
    typedef gebp_traits<LhsScalar,RhsScalar> Traits;

    DenseIndex m_sizeA;
    DenseIndex m_sizeB;
    DenseIndex m_sizeW;

  public:

    gemm_blocking_space(DenseIndex rows, DenseIndex cols, DenseIndex depth)
    {
      this->m_mc = Transpose ? cols : rows;
      this->m_nc = Transpose ? rows : cols;
      this->m_kc = depth;

      computeProductBlockingSizes<LhsScalar,RhsScalar>(this->m_kc, this->m_mc, this->m_nc);
      m_sizeA = this->m_mc * this->m_kc;
      m_sizeB = this->m_kc * this->m_nc;
      m_sizeW = this->m_kc*Traits::WorkSpaceFactor;
    }

    void allocateA()
    {
      if(this->m_blockA==0)
        this->m_blockA = aligned_new<LhsScalar>(m_sizeA);
    }

    void allocateB()
    {
      if(this->m_blockB==0)
        this->m_blockB = aligned_new<RhsScalar>(m_sizeB);
    }

    void allocateW()
    {
      if(this->m_blockW==0)
        this->m_blockW = aligned_new<RhsScalar>(m_sizeW);
    }

    void allocateAll()
    {
      allocateA();
      allocateB();
      allocateW();
    }

    ~gemm_blocking_space()
    {
      aligned_delete(this->m_blockA, m_sizeA);
      aligned_delete(this->m_blockB, m_sizeB);
      aligned_delete(this->m_blockW, m_sizeW);
    }
};

}

template<typename Lhs, typename Rhs>
class GeneralProduct<Lhs, Rhs, GemmProduct>
  : public ProductBase<GeneralProduct<Lhs,Rhs,GemmProduct>, Lhs, Rhs>
{
    enum {
      MaxDepthAtCompileTime = (((int)Lhs::MaxColsAtCompileTime == 0 || (int)Rhs::MaxRowsAtCompileTime == 0) ? 0 : ((int)Lhs::MaxColsAtCompileTime == 1 || (int)Rhs::MaxRowsAtCompileTime == 1) ? 1 : ((int)Lhs::MaxColsAtCompileTime == Dynamic && (int)Rhs::MaxRowsAtCompileTime == Dynamic) ? Dynamic : ((int)Lhs::MaxColsAtCompileTime == Dynamic) ? (int)Rhs::MaxRowsAtCompileTime : ((int)Rhs::MaxRowsAtCompileTime == Dynamic) ? (int)Lhs::MaxColsAtCompileTime : ((int)Lhs::MaxColsAtCompileTime <= (int)Rhs::MaxRowsAtCompileTime) ? (int)Lhs::MaxColsAtCompileTime : (int)Rhs::MaxRowsAtCompileTime)
    };
  public:
    typedef ProductBase<GeneralProduct, Lhs, Rhs > Base; typedef typename Eigen::internal::traits<GeneralProduct>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<GeneralProduct>::type Nested; typedef typename Eigen::internal::traits<GeneralProduct>::StorageKind StorageKind; typedef typename Eigen::internal::traits<GeneralProduct>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<GeneralProduct>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<GeneralProduct>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<GeneralProduct>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<GeneralProduct>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<GeneralProduct>::Flags, CoeffReadCost = Eigen::internal::traits<GeneralProduct>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived; typedef typename Base::LhsNested LhsNested; typedef typename Base::_LhsNested _LhsNested; typedef typename Base::LhsBlasTraits LhsBlasTraits; typedef typename Base::ActualLhsType ActualLhsType; typedef typename Base::_ActualLhsType _ActualLhsType; typedef typename Base::RhsNested RhsNested; typedef typename Base::_RhsNested _RhsNested; typedef typename Base::RhsBlasTraits RhsBlasTraits; typedef typename Base::ActualRhsType ActualRhsType; typedef typename Base::_ActualRhsType _ActualRhsType; using Base::m_lhs; using Base::m_rhs;

    typedef typename Lhs::Scalar LhsScalar;
    typedef typename Rhs::Scalar RhsScalar;
    typedef Scalar ResScalar;

    GeneralProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)
    {
      typedef internal::scalar_product_op<LhsScalar,RhsScalar> BinOp;
      if (Eigen::internal::static_assertion<bool((internal::functor_allows_mixing_real_and_complex<BinOp>::ret ? int(internal::is_same<typename NumTraits<LhsScalar>::Real, typename NumTraits<RhsScalar>::Real>::value) : int(internal::is_same<LhsScalar, RhsScalar>::value)))>::YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY) {};
    }

    template<typename Dest> void scaleAndAddTo(Dest& dst, Scalar alpha) const
    {
      if( (!Eigen::internal::copy_bool(dst.rows()==m_lhs.rows() && dst.cols()==m_rhs.cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(dst.rows()==m_lhs.rows() && dst.cols()==m_rhs.cols())) Eigen::internal::assert_fail("dst.rows()==m_lhs.rows() && dst.cols()==m_rhs.cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralMatrixMatrix.h", 413); } while(false); else throw Eigen::eigen_assert_exception(); };

      const ActualLhsType lhs = LhsBlasTraits::extract(m_lhs);
      const ActualRhsType rhs = RhsBlasTraits::extract(m_rhs);

      Scalar actualAlpha = alpha * LhsBlasTraits::extractScalarFactor(m_lhs)
                                 * RhsBlasTraits::extractScalarFactor(m_rhs);

      typedef internal::gemm_blocking_space<(Dest::Flags&RowMajorBit) ? RowMajor : ColMajor,LhsScalar,RhsScalar,
              Dest::MaxRowsAtCompileTime,Dest::MaxColsAtCompileTime,MaxDepthAtCompileTime> BlockingType;

      typedef internal::gemm_functor<
        Scalar, Index,
        internal::general_matrix_matrix_product<
          Index,
          LhsScalar, (_ActualLhsType::Flags&RowMajorBit) ? RowMajor : ColMajor, bool(LhsBlasTraits::NeedToConjugate),
          RhsScalar, (_ActualRhsType::Flags&RowMajorBit) ? RowMajor : ColMajor, bool(RhsBlasTraits::NeedToConjugate),
          (Dest::Flags&RowMajorBit) ? RowMajor : ColMajor>,
        _ActualLhsType, _ActualRhsType, Dest, BlockingType> GemmFunctor;

      BlockingType blocking(dst.rows(), dst.cols(), lhs.cols());

      internal::parallelize_gemm<(Dest::MaxRowsAtCompileTime>32 || Dest::MaxRowsAtCompileTime==Dynamic)>(GemmFunctor(lhs, rhs, dst, actualAlpha, blocking), this->rows(), this->cols(), Dest::Flags&RowMajorBit);
    }
};
# 330 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h"
namespace internal {
# 38 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h"
template<typename LhsScalar, typename RhsScalar, typename Index, int mr, int nr, bool ConjLhs, bool ConjRhs, int UpLo>
struct tribb_kernel;


template <typename Index,
          typename LhsScalar, int LhsStorageOrder, bool ConjugateLhs,
          typename RhsScalar, int RhsStorageOrder, bool ConjugateRhs,
                              int ResStorageOrder, int UpLo>
struct general_matrix_matrix_triangular_product;


template <typename Index, typename LhsScalar, int LhsStorageOrder, bool ConjugateLhs,
                          typename RhsScalar, int RhsStorageOrder, bool ConjugateRhs, int UpLo>
struct general_matrix_matrix_triangular_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,RowMajor,UpLo>
{
  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;
  static inline void run(Index size, Index depth,const LhsScalar* lhs, Index lhsStride,
                                      const RhsScalar* rhs, Index rhsStride, ResScalar* res, Index resStride, ResScalar alpha)
  {
    general_matrix_matrix_triangular_product<Index,
        RhsScalar, RhsStorageOrder==RowMajor ? ColMajor : RowMajor, ConjugateRhs,
        LhsScalar, LhsStorageOrder==RowMajor ? ColMajor : RowMajor, ConjugateLhs,
        ColMajor, UpLo==Lower?Upper:Lower>
      ::run(size,depth,rhs,rhsStride,lhs,lhsStride,res,resStride,alpha);
  }
};

template <typename Index, typename LhsScalar, int LhsStorageOrder, bool ConjugateLhs,
                          typename RhsScalar, int RhsStorageOrder, bool ConjugateRhs, int UpLo>
struct general_matrix_matrix_triangular_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,ColMajor,UpLo>
{
  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;
  static inline void run(Index size, Index depth,const LhsScalar* _lhs, Index lhsStride,
                                      const RhsScalar* _rhs, Index rhsStride, ResScalar* res, Index resStride, ResScalar alpha)
  {
    const_blas_data_mapper<LhsScalar, Index, LhsStorageOrder> lhs(_lhs,lhsStride);
    const_blas_data_mapper<RhsScalar, Index, RhsStorageOrder> rhs(_rhs,rhsStride);

    typedef gebp_traits<LhsScalar,RhsScalar> Traits;

    Index kc = depth;
    Index mc = size;
    Index nc = size;
    computeProductBlockingSizes<LhsScalar,RhsScalar>(kc, mc, nc);

    if(mc > Traits::nr)
      mc = (mc/Traits::nr)*Traits::nr;

    std::size_t sizeW = kc*Traits::WorkSpaceFactor;
    std::size_t sizeB = sizeW + kc*size;
    LhsScalar* blockA = (0)!=0 ? (0) : reinterpret_cast<LhsScalar*>( (sizeof(LhsScalar)*kc*mc<=0) ? __builtin_alloca (sizeof(LhsScalar)*kc*mc) : Eigen::internal::aligned_malloc(sizeof(LhsScalar)*kc*mc) ); Eigen::internal::aligned_stack_memory_handler<LhsScalar> blockA_stack_memory_destructor((0)==0 ? blockA : 0,kc*mc,sizeof(LhsScalar)*kc*mc>0);
    RhsScalar* allocatedBlockB = (0)!=0 ? (0) : reinterpret_cast<RhsScalar*>( (sizeof(RhsScalar)*sizeB<=0) ? __builtin_alloca (sizeof(RhsScalar)*sizeB) : Eigen::internal::aligned_malloc(sizeof(RhsScalar)*sizeB) ); Eigen::internal::aligned_stack_memory_handler<RhsScalar> allocatedBlockB_stack_memory_destructor((0)==0 ? allocatedBlockB : 0,sizeB,sizeof(RhsScalar)*sizeB>0);
    RhsScalar* blockB = allocatedBlockB + sizeW;

    gemm_pack_lhs<LhsScalar, Index, Traits::mr, Traits::LhsProgress, LhsStorageOrder> pack_lhs;
    gemm_pack_rhs<RhsScalar, Index, Traits::nr, RhsStorageOrder> pack_rhs;
    gebp_kernel <LhsScalar, RhsScalar, Index, Traits::mr, Traits::nr, ConjugateLhs, ConjugateRhs> gebp;
    tribb_kernel<LhsScalar, RhsScalar, Index, Traits::mr, Traits::nr, ConjugateLhs, ConjugateRhs, UpLo> sybb;

    for(Index k2=0; k2<depth; k2+=kc)
    {
      const Index actual_kc = (std::min)(k2+kc,depth)-k2;


      pack_rhs(blockB, &rhs(k2,0), rhsStride, actual_kc, size);

      for(Index i2=0; i2<size; i2+=mc)
      {
        const Index actual_mc = (std::min)(i2+mc,size)-i2;

        pack_lhs(blockA, &lhs(i2, k2), lhsStride, actual_kc, actual_mc);





        if (UpLo==Lower)
          gebp(res+i2, resStride, blockA, blockB, actual_mc, actual_kc, (std::min)(size,i2), alpha,
               -1, -1, 0, 0, allocatedBlockB);

        sybb(res+resStride*i2 + i2, resStride, blockA, blockB + actual_kc*i2, actual_mc, actual_kc, alpha, allocatedBlockB);

        if (UpLo==Upper)
        {
          Index j2 = i2+actual_mc;
          gebp(res+resStride*j2+i2, resStride, blockA, blockB+actual_kc*j2, actual_mc, actual_kc, (std::max)(Index(0), size-j2), alpha,
               -1, -1, 0, 0, allocatedBlockB);
        }
      }
    }
  }
};
# 140 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h"
template<typename LhsScalar, typename RhsScalar, typename Index, int mr, int nr, bool ConjLhs, bool ConjRhs, int UpLo>
struct tribb_kernel
{
  typedef gebp_traits<LhsScalar,RhsScalar,ConjLhs,ConjRhs> Traits;
  typedef typename Traits::ResScalar ResScalar;

  enum {
    BlockSize = (((int)mr >= (int)nr) ? (int)mr : (int)nr)
  };
  void operator()(ResScalar* res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index size, Index depth, ResScalar alpha, RhsScalar* workspace)
  {
    gebp_kernel<LhsScalar, RhsScalar, Index, mr, nr, ConjLhs, ConjRhs> gebp_kernel;
    Matrix<ResScalar,BlockSize,BlockSize,ColMajor> buffer;



    for (Index j=0; j<size; j+=BlockSize)
    {
      Index actualBlockSize = std::min<Index>(BlockSize,size - j);
      const RhsScalar* actual_b = blockB+j*depth;

      if(UpLo==Upper)
        gebp_kernel(res+j*resStride, resStride, blockA, actual_b, j, depth, actualBlockSize, alpha,
                    -1, -1, 0, 0, workspace);


      {
        Index i = j;
        buffer.setZero();

        gebp_kernel(buffer.data(), BlockSize, blockA+depth*i, actual_b, actualBlockSize, depth, actualBlockSize, alpha,
                    -1, -1, 0, 0, workspace);

        for(Index j1=0; j1<actualBlockSize; ++j1)
        {
          ResScalar* r = res + (j+j1)*resStride + i;
          for(Index i1=UpLo==Lower ? j1 : 0;
              UpLo==Lower ? i1<actualBlockSize : i1<=j1; ++i1)
            r[i1] += buffer(i1,j1);
        }
      }

      if(UpLo==Lower)
      {
        Index i = j+actualBlockSize;
        gebp_kernel(res+j*resStride+i, resStride, blockA+depth*i, actual_b, size-i, depth, actualBlockSize, alpha,
                    -1, -1, 0, 0, workspace);
      }
    }
  }
};

}



template<typename MatrixType, unsigned int UpLo>
template<typename ProductDerived, typename _Lhs, typename _Rhs>
TriangularView<MatrixType,UpLo>& TriangularView<MatrixType,UpLo>::assignProduct(const ProductBase<ProductDerived, _Lhs,_Rhs>& prod, const Scalar& alpha)
{
  typedef typename internal::remove_all<typename ProductDerived::LhsNested>::type Lhs;
  typedef internal::blas_traits<Lhs> LhsBlasTraits;
  typedef typename LhsBlasTraits::DirectLinearAccessType ActualLhs;
  typedef typename internal::remove_all<ActualLhs>::type _ActualLhs;
  const ActualLhs actualLhs = LhsBlasTraits::extract(prod.lhs());

  typedef typename internal::remove_all<typename ProductDerived::RhsNested>::type Rhs;
  typedef internal::blas_traits<Rhs> RhsBlasTraits;
  typedef typename RhsBlasTraits::DirectLinearAccessType ActualRhs;
  typedef typename internal::remove_all<ActualRhs>::type _ActualRhs;
  const ActualRhs actualRhs = RhsBlasTraits::extract(prod.rhs());

  typename ProductDerived::Scalar actualAlpha = alpha * LhsBlasTraits::extractScalarFactor(prod.lhs().derived()) * RhsBlasTraits::extractScalarFactor(prod.rhs().derived());

  internal::general_matrix_matrix_triangular_product<Index,
    typename Lhs::Scalar, _ActualLhs::Flags&RowMajorBit ? RowMajor : ColMajor, LhsBlasTraits::NeedToConjugate,
    typename Rhs::Scalar, _ActualRhs::Flags&RowMajorBit ? RowMajor : ColMajor, RhsBlasTraits::NeedToConjugate,
    MatrixType::Flags&RowMajorBit ? RowMajor : ColMajor, UpLo>
    ::run(m_matrix.cols(), actualLhs.cols(),
          &actualLhs.coeffRef(0,0), actualLhs.outerStride(), &actualRhs.coeffRef(0,0), actualRhs.outerStride(),
          const_cast<Scalar*>(m_matrix.data()), m_matrix.outerStride(), actualAlpha);

  return *this;
}
# 331 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/SelfadjointMatrixVector.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/SelfadjointMatrixVector.h"
namespace internal {






template<typename Scalar, typename Index, int StorageOrder, int UpLo, bool ConjugateLhs, bool ConjugateRhs>
static __attribute__((noinline)) void product_selfadjoint_vector(
  Index size,
  const Scalar* lhs, Index lhsStride,
  const Scalar* _rhs, Index rhsIncr,
  Scalar* res,
  Scalar alpha)
{
  typedef typename packet_traits<Scalar>::type Packet;
  typedef typename NumTraits<Scalar>::Real RealScalar;
  const Index PacketSize = sizeof(Packet)/sizeof(Scalar);

  enum {
    IsRowMajor = StorageOrder==RowMajor ? 1 : 0,
    IsLower = UpLo == Lower ? 1 : 0,
    FirstTriangular = IsRowMajor == IsLower
  };

  conj_helper<Scalar,Scalar,NumTraits<Scalar>::IsComplex && (((ConjugateLhs) || (IsRowMajor)) && !((ConjugateLhs) && (IsRowMajor))), ConjugateRhs> cj0;
  conj_helper<Scalar,Scalar,NumTraits<Scalar>::IsComplex && (((ConjugateLhs) || (!IsRowMajor)) && !((ConjugateLhs) && (!IsRowMajor))), ConjugateRhs> cj1;
  conj_helper<Scalar,Scalar,NumTraits<Scalar>::IsComplex, ConjugateRhs> cjd;

  conj_helper<Packet,Packet,NumTraits<Scalar>::IsComplex && (((ConjugateLhs) || (IsRowMajor)) && !((ConjugateLhs) && (IsRowMajor))), ConjugateRhs> pcj0;
  conj_helper<Packet,Packet,NumTraits<Scalar>::IsComplex && (((ConjugateLhs) || (!IsRowMajor)) && !((ConjugateLhs) && (!IsRowMajor))), ConjugateRhs> pcj1;

  Scalar cjAlpha = ConjugateRhs ? conj(alpha) : alpha;




  Scalar* rhs = (rhsIncr==1 ? const_cast<Scalar*>(_rhs) : 0)!=0 ? (rhsIncr==1 ? const_cast<Scalar*>(_rhs) : 0) : reinterpret_cast<Scalar*>( (sizeof(Scalar)*size<=0) ? __builtin_alloca (sizeof(Scalar)*size) : Eigen::internal::aligned_malloc(sizeof(Scalar)*size) ); Eigen::internal::aligned_stack_memory_handler<Scalar> rhs_stack_memory_destructor((rhsIncr==1 ? const_cast<Scalar*>(_rhs) : 0)==0 ? rhs : 0,size,sizeof(Scalar)*size>0);
  if (rhsIncr!=1)
  {
    const Scalar* it = _rhs;
    for (Index i=0; i<size; ++i, it+=rhsIncr)
      rhs[i] = *it;
  }

  Index bound = (std::max)(Index(0),size-8) & 0xfffffffe;
  if (FirstTriangular)
    bound = size - bound;

  for (Index j=FirstTriangular ? bound : 0;
       j<(FirstTriangular ? size : bound);j+=2)
  {
    register const Scalar* __restrict A0 = lhs + j*lhsStride;
    register const Scalar* __restrict A1 = lhs + (j+1)*lhsStride;

    Scalar t0 = cjAlpha * rhs[j];
    Packet ptmp0 = pset1<Packet>(t0);
    Scalar t1 = cjAlpha * rhs[j+1];
    Packet ptmp1 = pset1<Packet>(t1);

    Scalar t2 = 0;
    Packet ptmp2 = pset1<Packet>(t2);
    Scalar t3 = 0;
    Packet ptmp3 = pset1<Packet>(t3);

    size_t starti = FirstTriangular ? 0 : j+2;
    size_t endi = FirstTriangular ? j : size;
    size_t alignedStart = (starti) + first_aligned(&res[starti], endi-starti);
    size_t alignedEnd = alignedStart + ((endi-alignedStart)/(PacketSize))*(PacketSize);


    res[j] += cjd.pmul(internal::real(A0[j]), t0);
    res[j+1] += cjd.pmul(internal::real(A1[j+1]), t1);
    if(FirstTriangular)
    {
      res[j] += cj0.pmul(A1[j], t1);
      t3 += cj1.pmul(A1[j], rhs[j]);
    }
    else
    {
      res[j+1] += cj0.pmul(A0[j+1],t0);
      t2 += cj1.pmul(A0[j+1], rhs[j+1]);
    }

    for (size_t i=starti; i<alignedStart; ++i)
    {
      res[i] += t0 * A0[i] + t1 * A1[i];
      t2 += conj(A0[i]) * rhs[i];
      t3 += conj(A1[i]) * rhs[i];
    }


    const Scalar* __restrict a0It = A0 + alignedStart;
    const Scalar* __restrict a1It = A1 + alignedStart;
    const Scalar* __restrict rhsIt = rhs + alignedStart;
          Scalar* __restrict resIt = res + alignedStart;
    for (size_t i=alignedStart; i<alignedEnd; i+=PacketSize)
    {
      Packet A0i = ploadu<Packet>(a0It); a0It += PacketSize;
      Packet A1i = ploadu<Packet>(a1It); a1It += PacketSize;
      Packet Bi = ploadu<Packet>(rhsIt); rhsIt += PacketSize;
      Packet Xi = pload <Packet>(resIt);

      Xi = pcj0.pmadd(A0i,ptmp0, pcj0.pmadd(A1i,ptmp1,Xi));
      ptmp2 = pcj1.pmadd(A0i, Bi, ptmp2);
      ptmp3 = pcj1.pmadd(A1i, Bi, ptmp3);
      pstore(resIt,Xi); resIt += PacketSize;
    }
    for (size_t i=alignedEnd; i<endi; i++)
    {
      res[i] += cj0.pmul(A0[i], t0) + cj0.pmul(A1[i],t1);
      t2 += cj1.pmul(A0[i], rhs[i]);
      t3 += cj1.pmul(A1[i], rhs[i]);
    }

    res[j] += alpha * (t2 + predux(ptmp2));
    res[j+1] += alpha * (t3 + predux(ptmp3));
  }
  for (Index j=FirstTriangular ? 0 : bound;j<(FirstTriangular ? bound : size);j++)
  {
    register const Scalar* __restrict A0 = lhs + j*lhsStride;

    Scalar t1 = cjAlpha * rhs[j];
    Scalar t2 = 0;

    res[j] += cjd.pmul(internal::real(A0[j]), t1);
    for (Index i=FirstTriangular ? 0 : j+1; i<(FirstTriangular ? j : size); i++)
    {
      res[i] += cj0.pmul(A0[i], t1);
      t2 += cj1.pmul(A0[i], rhs[i]);
    }
    res[j] += alpha * t2;
  }
}

}





namespace internal {
template<typename Lhs, int LhsMode, typename Rhs>
struct traits<SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,0,true> >
  : traits<ProductBase<SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,0,true>, Lhs, Rhs> >
{};
}

template<typename Lhs, int LhsMode, typename Rhs>
struct SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,0,true>
  : public ProductBase<SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,0,true>, Lhs, Rhs >
{
  typedef ProductBase<SelfadjointProductMatrix, Lhs, Rhs > Base; typedef typename Eigen::internal::traits<SelfadjointProductMatrix>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<SelfadjointProductMatrix>::type Nested; typedef typename Eigen::internal::traits<SelfadjointProductMatrix>::StorageKind StorageKind; typedef typename Eigen::internal::traits<SelfadjointProductMatrix>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<SelfadjointProductMatrix>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<SelfadjointProductMatrix>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<SelfadjointProductMatrix>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<SelfadjointProductMatrix>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<SelfadjointProductMatrix>::Flags, CoeffReadCost = Eigen::internal::traits<SelfadjointProductMatrix>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived; typedef typename Base::LhsNested LhsNested; typedef typename Base::_LhsNested _LhsNested; typedef typename Base::LhsBlasTraits LhsBlasTraits; typedef typename Base::ActualLhsType ActualLhsType; typedef typename Base::_ActualLhsType _ActualLhsType; typedef typename Base::RhsNested RhsNested; typedef typename Base::_RhsNested _RhsNested; typedef typename Base::RhsBlasTraits RhsBlasTraits; typedef typename Base::ActualRhsType ActualRhsType; typedef typename Base::_ActualRhsType _ActualRhsType; using Base::m_lhs; using Base::m_rhs;

  enum {
    LhsUpLo = LhsMode&(Upper|Lower)
  };

  SelfadjointProductMatrix(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}

  template<typename Dest> void scaleAndAddTo(Dest& dest, Scalar alpha) const
  {
    typedef typename Dest::Scalar ResScalar;
    typedef typename Base::RhsScalar RhsScalar;
    typedef Map<Matrix<ResScalar,Dynamic,1>, Aligned> MappedDest;

    if( (!Eigen::internal::copy_bool(dest.rows()==m_lhs.rows() && dest.cols()==m_rhs.cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(dest.rows()==m_lhs.rows() && dest.cols()==m_rhs.cols())) Eigen::internal::assert_fail("dest.rows()==m_lhs.rows() && dest.cols()==m_rhs.cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/SelfadjointMatrixVector.h", 194); } while(false); else throw Eigen::eigen_assert_exception(); };

    const ActualLhsType lhs = LhsBlasTraits::extract(m_lhs);
    const ActualRhsType rhs = RhsBlasTraits::extract(m_rhs);

    Scalar actualAlpha = alpha * LhsBlasTraits::extractScalarFactor(m_lhs)
                               * RhsBlasTraits::extractScalarFactor(m_rhs);

    enum {
      EvalToDest = (Dest::InnerStrideAtCompileTime==1),
      UseRhs = (_ActualRhsType::InnerStrideAtCompileTime==1)
    };

    internal::gemv_static_vector_if<ResScalar,Dest::SizeAtCompileTime,Dest::MaxSizeAtCompileTime,!EvalToDest> static_dest;
    internal::gemv_static_vector_if<RhsScalar,_ActualRhsType::SizeAtCompileTime,_ActualRhsType::MaxSizeAtCompileTime,!UseRhs> static_rhs;

    ResScalar* actualDestPtr = (EvalToDest ? dest.data() : static_dest.data())!=0 ? (EvalToDest ? dest.data() : static_dest.data()) : reinterpret_cast<ResScalar*>( (sizeof(ResScalar)*dest.size()<=0) ? __builtin_alloca (sizeof(ResScalar)*dest.size()) : Eigen::internal::aligned_malloc(sizeof(ResScalar)*dest.size()) ); Eigen::internal::aligned_stack_memory_handler<ResScalar> actualDestPtr_stack_memory_destructor((EvalToDest ? dest.data() : static_dest.data())==0 ? actualDestPtr : 0,dest.size(),sizeof(ResScalar)*dest.size()>0);


    RhsScalar* actualRhsPtr = (UseRhs ? const_cast<RhsScalar*>(rhs.data()) : static_rhs.data())!=0 ? (UseRhs ? const_cast<RhsScalar*>(rhs.data()) : static_rhs.data()) : reinterpret_cast<RhsScalar*>( (sizeof(RhsScalar)*rhs.size()<=0) ? __builtin_alloca (sizeof(RhsScalar)*rhs.size()) : Eigen::internal::aligned_malloc(sizeof(RhsScalar)*rhs.size()) ); Eigen::internal::aligned_stack_memory_handler<RhsScalar> actualRhsPtr_stack_memory_destructor((UseRhs ? const_cast<RhsScalar*>(rhs.data()) : static_rhs.data())==0 ? actualRhsPtr : 0,rhs.size(),sizeof(RhsScalar)*rhs.size()>0);


    if(!EvalToDest)
    {




      MappedDest(actualDestPtr, dest.size()) = dest;
    }

    if(!UseRhs)
    {




      Map<typename _ActualRhsType::PlainObject>(actualRhsPtr, rhs.size()) = rhs;
    }


    internal::product_selfadjoint_vector<Scalar, Index, (internal::traits<_ActualLhsType>::Flags&RowMajorBit) ? RowMajor : ColMajor, int(LhsUpLo), bool(LhsBlasTraits::NeedToConjugate), bool(RhsBlasTraits::NeedToConjugate)>
      (
        lhs.rows(),
        &lhs.coeffRef(0,0), lhs.outerStride(),
        actualRhsPtr, 1,
        actualDestPtr,
        actualAlpha
      );

    if(!EvalToDest)
      dest = MappedDest(actualDestPtr, dest.size());
  }
};

namespace internal {
template<typename Lhs, typename Rhs, int RhsMode>
struct traits<SelfadjointProductMatrix<Lhs,0,true,Rhs,RhsMode,false> >
  : traits<ProductBase<SelfadjointProductMatrix<Lhs,0,true,Rhs,RhsMode,false>, Lhs, Rhs> >
{};
}

template<typename Lhs, typename Rhs, int RhsMode>
struct SelfadjointProductMatrix<Lhs,0,true,Rhs,RhsMode,false>
  : public ProductBase<SelfadjointProductMatrix<Lhs,0,true,Rhs,RhsMode,false>, Lhs, Rhs >
{
  typedef ProductBase<SelfadjointProductMatrix, Lhs, Rhs > Base; typedef typename Eigen::internal::traits<SelfadjointProductMatrix>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<SelfadjointProductMatrix>::type Nested; typedef typename Eigen::internal::traits<SelfadjointProductMatrix>::StorageKind StorageKind; typedef typename Eigen::internal::traits<SelfadjointProductMatrix>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<SelfadjointProductMatrix>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<SelfadjointProductMatrix>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<SelfadjointProductMatrix>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<SelfadjointProductMatrix>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<SelfadjointProductMatrix>::Flags, CoeffReadCost = Eigen::internal::traits<SelfadjointProductMatrix>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived; typedef typename Base::LhsNested LhsNested; typedef typename Base::_LhsNested _LhsNested; typedef typename Base::LhsBlasTraits LhsBlasTraits; typedef typename Base::ActualLhsType ActualLhsType; typedef typename Base::_ActualLhsType _ActualLhsType; typedef typename Base::RhsNested RhsNested; typedef typename Base::_RhsNested _RhsNested; typedef typename Base::RhsBlasTraits RhsBlasTraits; typedef typename Base::ActualRhsType ActualRhsType; typedef typename Base::_ActualRhsType _ActualRhsType; using Base::m_lhs; using Base::m_rhs;

  enum {
    RhsUpLo = RhsMode&(Upper|Lower)
  };

  SelfadjointProductMatrix(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}

  template<typename Dest> void scaleAndAddTo(Dest& dest, Scalar alpha) const
  {

    Transpose<Dest> destT(dest);
    SelfadjointProductMatrix<Transpose<const Rhs>, int(RhsUpLo)==Upper ? Lower : Upper, false,
                             Transpose<const Lhs>, 0, true>(m_rhs.transpose(), m_lhs.transpose()).scaleAndAddTo(destT, alpha);
  }
};
# 332 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/SelfadjointMatrixMatrix.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/SelfadjointMatrixMatrix.h"
namespace internal {


template<typename Scalar, typename Index, int Pack1, int Pack2, int StorageOrder>
struct symm_pack_lhs
{
  template<int BlockRows> inline
  void pack(Scalar* blockA, const const_blas_data_mapper<Scalar,Index,StorageOrder>& lhs, Index cols, Index i, Index& count)
  {

    for(Index k=0; k<i; k++)
      for(Index w=0; w<BlockRows; w++)
        blockA[count++] = lhs(i+w,k);

    Index h = 0;
    for(Index k=i; k<i+BlockRows; k++)
    {
      for(Index w=0; w<h; w++)
        blockA[count++] = conj(lhs(k, i+w));

      blockA[count++] = real(lhs(k,k));

      for(Index w=h+1; w<BlockRows; w++)
        blockA[count++] = lhs(i+w, k);
      ++h;
    }

    for(Index k=i+BlockRows; k<cols; k++)
      for(Index w=0; w<BlockRows; w++)
        blockA[count++] = conj(lhs(k, i+w));
  }
  void operator()(Scalar* blockA, const Scalar* _lhs, Index lhsStride, Index cols, Index rows)
  {
    const_blas_data_mapper<Scalar,Index,StorageOrder> lhs(_lhs,lhsStride);
    Index count = 0;
    Index peeled_mc = (rows/Pack1)*Pack1;
    for(Index i=0; i<peeled_mc; i+=Pack1)
    {
      pack<Pack1>(blockA, lhs, cols, i, count);
    }

    if(rows-peeled_mc>=Pack2)
    {
      pack<Pack2>(blockA, lhs, cols, peeled_mc, count);
      peeled_mc += Pack2;
    }


    for(Index i=peeled_mc; i<rows; i++)
    {
      for(Index k=0; k<i; k++)
        blockA[count++] = lhs(i, k);

      blockA[count++] = real(lhs(i, i));

      for(Index k=i+1; k<cols; k++)
        blockA[count++] = conj(lhs(k, i));
    }
  }
};

template<typename Scalar, typename Index, int nr, int StorageOrder>
struct symm_pack_rhs
{
  enum { PacketSize = packet_traits<Scalar>::size };
  void operator()(Scalar* blockB, const Scalar* _rhs, Index rhsStride, Index rows, Index cols, Index k2)
  {
    Index end_k = k2 + rows;
    Index count = 0;
    const_blas_data_mapper<Scalar,Index,StorageOrder> rhs(_rhs,rhsStride);
    Index packet_cols = (cols/nr)*nr;


    for(Index j2=0; j2<k2; j2+=nr)
    {
      for(Index k=k2; k<end_k; k++)
      {
        blockB[count+0] = rhs(k,j2+0);
        blockB[count+1] = rhs(k,j2+1);
        if (nr==4)
        {
          blockB[count+2] = rhs(k,j2+2);
          blockB[count+3] = rhs(k,j2+3);
        }
        count += nr;
      }
    }


    for(Index j2=k2; j2<(std::min)(k2+rows,packet_cols); j2+=nr)
    {


      for(Index k=k2; k<j2; k++)
      {
        blockB[count+0] = conj(rhs(j2+0,k));
        blockB[count+1] = conj(rhs(j2+1,k));
        if (nr==4)
        {
          blockB[count+2] = conj(rhs(j2+2,k));
          blockB[count+3] = conj(rhs(j2+3,k));
        }
        count += nr;
      }

      Index h = 0;
      for(Index k=j2; k<j2+nr; k++)
      {

        for (Index w=0 ; w<h; ++w)
          blockB[count+w] = rhs(k,j2+w);

        blockB[count+h] = real(rhs(k,k));


        for (Index w=h+1 ; w<nr; ++w)
          blockB[count+w] = conj(rhs(j2+w,k));
        count += nr;
        ++h;
      }

      for(Index k=j2+nr; k<end_k; k++)
      {
        blockB[count+0] = rhs(k,j2+0);
        blockB[count+1] = rhs(k,j2+1);
        if (nr==4)
        {
          blockB[count+2] = rhs(k,j2+2);
          blockB[count+3] = rhs(k,j2+3);
        }
        count += nr;
      }
    }


    for(Index j2=k2+rows; j2<packet_cols; j2+=nr)
    {
      for(Index k=k2; k<end_k; k++)
      {
        blockB[count+0] = conj(rhs(j2+0,k));
        blockB[count+1] = conj(rhs(j2+1,k));
        if (nr==4)
        {
          blockB[count+2] = conj(rhs(j2+2,k));
          blockB[count+3] = conj(rhs(j2+3,k));
        }
        count += nr;
      }
    }


    for(Index j2=packet_cols; j2<cols; ++j2)
    {

      Index half = (std::min)(end_k,j2);
      for(Index k=k2; k<half; k++)
      {
        blockB[count] = conj(rhs(j2,k));
        count += 1;
      }

      if(half==j2 && half<k2+rows)
      {
        blockB[count] = real(rhs(j2,j2));
        count += 1;
      }
      else
        half--;


      for(Index k=half+1; k<k2+rows; k++)
      {
        blockB[count] = rhs(k,j2);
        count += 1;
      }
    }
  }
};




template <typename Scalar, typename Index,
          int LhsStorageOrder, bool LhsSelfAdjoint, bool ConjugateLhs,
          int RhsStorageOrder, bool RhsSelfAdjoint, bool ConjugateRhs,
          int ResStorageOrder>
struct product_selfadjoint_matrix;

template <typename Scalar, typename Index,
          int LhsStorageOrder, bool LhsSelfAdjoint, bool ConjugateLhs,
          int RhsStorageOrder, bool RhsSelfAdjoint, bool ConjugateRhs>
struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,LhsSelfAdjoint,ConjugateLhs, RhsStorageOrder,RhsSelfAdjoint,ConjugateRhs,RowMajor>
{

  static inline void run(
    Index rows, Index cols,
    const Scalar* lhs, Index lhsStride,
    const Scalar* rhs, Index rhsStride,
    Scalar* res, Index resStride,
    Scalar alpha)
  {
    product_selfadjoint_matrix<Scalar, Index,
      (((RhsSelfAdjoint) || (RhsStorageOrder==RowMajor)) && !((RhsSelfAdjoint) && (RhsStorageOrder==RowMajor))) ? ColMajor : RowMajor,
      RhsSelfAdjoint, NumTraits<Scalar>::IsComplex && (((RhsSelfAdjoint) || (ConjugateRhs)) && !((RhsSelfAdjoint) && (ConjugateRhs))),
      (((LhsSelfAdjoint) || (LhsStorageOrder==RowMajor)) && !((LhsSelfAdjoint) && (LhsStorageOrder==RowMajor))) ? ColMajor : RowMajor,
      LhsSelfAdjoint, NumTraits<Scalar>::IsComplex && (((LhsSelfAdjoint) || (ConjugateLhs)) && !((LhsSelfAdjoint) && (ConjugateLhs))),
      ColMajor>
      ::run(cols, rows, rhs, rhsStride, lhs, lhsStride, res, resStride, alpha);
  }
};

template <typename Scalar, typename Index,
          int LhsStorageOrder, bool ConjugateLhs,
          int RhsStorageOrder, bool ConjugateRhs>
struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,true,ConjugateLhs, RhsStorageOrder,false,ConjugateRhs,ColMajor>
{

  static __attribute__((noinline)) void run(
    Index rows, Index cols,
    const Scalar* _lhs, Index lhsStride,
    const Scalar* _rhs, Index rhsStride,
    Scalar* res, Index resStride,
    Scalar alpha)
  {
    Index size = rows;

    const_blas_data_mapper<Scalar, Index, LhsStorageOrder> lhs(_lhs,lhsStride);
    const_blas_data_mapper<Scalar, Index, RhsStorageOrder> rhs(_rhs,rhsStride);

    typedef gebp_traits<Scalar,Scalar> Traits;

    Index kc = size;
    Index mc = rows;
    Index nc = cols;
    computeProductBlockingSizes<Scalar,Scalar>(kc, mc, nc);

    kc = (std::min)(kc,mc);

    std::size_t sizeW = kc*Traits::WorkSpaceFactor;
    std::size_t sizeB = sizeW + kc*cols;
    Scalar* blockA = (0)!=0 ? (0) : reinterpret_cast<Scalar*>( (sizeof(Scalar)*kc*mc<=0) ? __builtin_alloca (sizeof(Scalar)*kc*mc) : Eigen::internal::aligned_malloc(sizeof(Scalar)*kc*mc) ); Eigen::internal::aligned_stack_memory_handler<Scalar> blockA_stack_memory_destructor((0)==0 ? blockA : 0,kc*mc,sizeof(Scalar)*kc*mc>0);
    Scalar* allocatedBlockB = (0)!=0 ? (0) : reinterpret_cast<Scalar*>( (sizeof(Scalar)*sizeB<=0) ? __builtin_alloca (sizeof(Scalar)*sizeB) : Eigen::internal::aligned_malloc(sizeof(Scalar)*sizeB) ); Eigen::internal::aligned_stack_memory_handler<Scalar> allocatedBlockB_stack_memory_destructor((0)==0 ? allocatedBlockB : 0,sizeB,sizeof(Scalar)*sizeB>0);
    Scalar* blockB = allocatedBlockB + sizeW;

    gebp_kernel<Scalar, Scalar, Index, Traits::mr, Traits::nr, ConjugateLhs, ConjugateRhs> gebp_kernel;
    symm_pack_lhs<Scalar, Index, Traits::mr, Traits::LhsProgress, LhsStorageOrder> pack_lhs;
    gemm_pack_rhs<Scalar, Index, Traits::nr,RhsStorageOrder> pack_rhs;
    gemm_pack_lhs<Scalar, Index, Traits::mr, Traits::LhsProgress, LhsStorageOrder==RowMajor?ColMajor:RowMajor, true> pack_lhs_transposed;

    for(Index k2=0; k2<size; k2+=kc)
    {
      const Index actual_kc = (std::min)(k2+kc,size)-k2;




      pack_rhs(blockB, &rhs(k2,0), rhsStride, actual_kc, cols);





      for(Index i2=0; i2<k2; i2+=mc)
      {
        const Index actual_mc = (std::min)(i2+mc,k2)-i2;

        pack_lhs_transposed(blockA, &lhs(k2, i2), lhsStride, actual_kc, actual_mc);

        gebp_kernel(res+i2, resStride, blockA, blockB, actual_mc, actual_kc, cols, alpha);
      }

      {
        const Index actual_mc = (std::min)(k2+kc,size)-k2;

        pack_lhs(blockA, &lhs(k2,k2), lhsStride, actual_kc, actual_mc);

        gebp_kernel(res+k2, resStride, blockA, blockB, actual_mc, actual_kc, cols, alpha);
      }

      for(Index i2=k2+kc; i2<size; i2+=mc)
      {
        const Index actual_mc = (std::min)(i2+mc,size)-i2;
        gemm_pack_lhs<Scalar, Index, Traits::mr, Traits::LhsProgress, LhsStorageOrder,false>()
          (blockA, &lhs(i2, k2), lhsStride, actual_kc, actual_mc);

        gebp_kernel(res+i2, resStride, blockA, blockB, actual_mc, actual_kc, cols, alpha);
      }
    }
  }
};


template <typename Scalar, typename Index,
          int LhsStorageOrder, bool ConjugateLhs,
          int RhsStorageOrder, bool ConjugateRhs>
struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,false,ConjugateLhs, RhsStorageOrder,true,ConjugateRhs,ColMajor>
{

  static __attribute__((noinline)) void run(
    Index rows, Index cols,
    const Scalar* _lhs, Index lhsStride,
    const Scalar* _rhs, Index rhsStride,
    Scalar* res, Index resStride,
    Scalar alpha)
  {
    Index size = cols;

    const_blas_data_mapper<Scalar, Index, LhsStorageOrder> lhs(_lhs,lhsStride);

    typedef gebp_traits<Scalar,Scalar> Traits;

    Index kc = size;
    Index mc = rows;
    Index nc = cols;
    computeProductBlockingSizes<Scalar,Scalar>(kc, mc, nc);
    std::size_t sizeW = kc*Traits::WorkSpaceFactor;
    std::size_t sizeB = sizeW + kc*cols;
    Scalar* blockA = (0)!=0 ? (0) : reinterpret_cast<Scalar*>( (sizeof(Scalar)*kc*mc<=0) ? __builtin_alloca (sizeof(Scalar)*kc*mc) : Eigen::internal::aligned_malloc(sizeof(Scalar)*kc*mc) ); Eigen::internal::aligned_stack_memory_handler<Scalar> blockA_stack_memory_destructor((0)==0 ? blockA : 0,kc*mc,sizeof(Scalar)*kc*mc>0);
    Scalar* allocatedBlockB = (0)!=0 ? (0) : reinterpret_cast<Scalar*>( (sizeof(Scalar)*sizeB<=0) ? __builtin_alloca (sizeof(Scalar)*sizeB) : Eigen::internal::aligned_malloc(sizeof(Scalar)*sizeB) ); Eigen::internal::aligned_stack_memory_handler<Scalar> allocatedBlockB_stack_memory_destructor((0)==0 ? allocatedBlockB : 0,sizeB,sizeof(Scalar)*sizeB>0);
    Scalar* blockB = allocatedBlockB + sizeW;

    gebp_kernel<Scalar, Scalar, Index, Traits::mr, Traits::nr, ConjugateLhs, ConjugateRhs> gebp_kernel;
    gemm_pack_lhs<Scalar, Index, Traits::mr, Traits::LhsProgress, LhsStorageOrder> pack_lhs;
    symm_pack_rhs<Scalar, Index, Traits::nr,RhsStorageOrder> pack_rhs;

    for(Index k2=0; k2<size; k2+=kc)
    {
      const Index actual_kc = (std::min)(k2+kc,size)-k2;

      pack_rhs(blockB, _rhs, rhsStride, actual_kc, cols, k2);


      for(Index i2=0; i2<rows; i2+=mc)
      {
        const Index actual_mc = (std::min)(i2+mc,rows)-i2;
        pack_lhs(blockA, &lhs(i2, k2), lhsStride, actual_kc, actual_mc);

        gebp_kernel(res+i2, resStride, blockA, blockB, actual_mc, actual_kc, cols, alpha);
      }
    }
  }
};

}





namespace internal {
template<typename Lhs, int LhsMode, typename Rhs, int RhsMode>
struct traits<SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,RhsMode,false> >
  : traits<ProductBase<SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,RhsMode,false>, Lhs, Rhs> >
{};
}

template<typename Lhs, int LhsMode, typename Rhs, int RhsMode>
struct SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,RhsMode,false>
  : public ProductBase<SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,RhsMode,false>, Lhs, Rhs >
{
  typedef ProductBase<SelfadjointProductMatrix, Lhs, Rhs > Base; typedef typename Eigen::internal::traits<SelfadjointProductMatrix>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<SelfadjointProductMatrix>::type Nested; typedef typename Eigen::internal::traits<SelfadjointProductMatrix>::StorageKind StorageKind; typedef typename Eigen::internal::traits<SelfadjointProductMatrix>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<SelfadjointProductMatrix>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<SelfadjointProductMatrix>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<SelfadjointProductMatrix>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<SelfadjointProductMatrix>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<SelfadjointProductMatrix>::Flags, CoeffReadCost = Eigen::internal::traits<SelfadjointProductMatrix>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived; typedef typename Base::LhsNested LhsNested; typedef typename Base::_LhsNested _LhsNested; typedef typename Base::LhsBlasTraits LhsBlasTraits; typedef typename Base::ActualLhsType ActualLhsType; typedef typename Base::_ActualLhsType _ActualLhsType; typedef typename Base::RhsNested RhsNested; typedef typename Base::_RhsNested _RhsNested; typedef typename Base::RhsBlasTraits RhsBlasTraits; typedef typename Base::ActualRhsType ActualRhsType; typedef typename Base::_ActualRhsType _ActualRhsType; using Base::m_lhs; using Base::m_rhs;

  SelfadjointProductMatrix(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}

  enum {
    LhsIsUpper = (LhsMode&(Upper|Lower))==Upper,
    LhsIsSelfAdjoint = (LhsMode&SelfAdjoint)==SelfAdjoint,
    RhsIsUpper = (RhsMode&(Upper|Lower))==Upper,
    RhsIsSelfAdjoint = (RhsMode&SelfAdjoint)==SelfAdjoint
  };

  template<typename Dest> void scaleAndAddTo(Dest& dst, Scalar alpha) const
  {
    if( (!Eigen::internal::copy_bool(dst.rows()==m_lhs.rows() && dst.cols()==m_rhs.cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(dst.rows()==m_lhs.rows() && dst.cols()==m_rhs.cols())) Eigen::internal::assert_fail("dst.rows()==m_lhs.rows() && dst.cols()==m_rhs.cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/SelfadjointMatrixMatrix.h", 401); } while(false); else throw Eigen::eigen_assert_exception(); };

    const ActualLhsType lhs = LhsBlasTraits::extract(m_lhs);
    const ActualRhsType rhs = RhsBlasTraits::extract(m_rhs);

    Scalar actualAlpha = alpha * LhsBlasTraits::extractScalarFactor(m_lhs)
                               * RhsBlasTraits::extractScalarFactor(m_rhs);

    internal::product_selfadjoint_matrix<Scalar, Index,
      (((LhsIsUpper) || (internal::traits<Lhs>::Flags &RowMajorBit)) && !((LhsIsUpper) && (internal::traits<Lhs>::Flags &RowMajorBit))) ? RowMajor : ColMajor, LhsIsSelfAdjoint,

      NumTraits<Scalar>::IsComplex && (((LhsIsUpper) || (bool(LhsBlasTraits::NeedToConjugate))) && !((LhsIsUpper) && (bool(LhsBlasTraits::NeedToConjugate)))),
      (((RhsIsUpper) || (internal::traits<Rhs>::Flags &RowMajorBit)) && !((RhsIsUpper) && (internal::traits<Rhs>::Flags &RowMajorBit))) ? RowMajor : ColMajor, RhsIsSelfAdjoint,

      NumTraits<Scalar>::IsComplex && (((RhsIsUpper) || (bool(RhsBlasTraits::NeedToConjugate))) && !((RhsIsUpper) && (bool(RhsBlasTraits::NeedToConjugate)))),
      internal::traits<Dest>::Flags&RowMajorBit ? RowMajor : ColMajor>
      ::run(
        lhs.rows(), rhs.cols(),
        &lhs.coeffRef(0,0), lhs.outerStride(),
        &rhs.coeffRef(0,0), rhs.outerStride(),
        &dst.coeffRef(0,0), dst.outerStride(),
        actualAlpha
      );
  }
};
# 333 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/SelfadjointProduct.h" 1
# 34 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/SelfadjointProduct.h"
template<typename Scalar, typename Index, int StorageOrder, int UpLo, bool ConjLhs, bool ConjRhs>
struct selfadjoint_rank1_update;

template<typename Scalar, typename Index, int UpLo, bool ConjLhs, bool ConjRhs>
struct selfadjoint_rank1_update<Scalar,Index,ColMajor,UpLo,ConjLhs,ConjRhs>
{
  static void run(Index size, Scalar* mat, Index stride, const Scalar* vec, Scalar alpha)
  {
    internal::conj_if<ConjRhs> cj;
    typedef Map<const Matrix<Scalar,Dynamic,1> > OtherMap;
    typedef typename internal::conditional<ConjLhs,typename OtherMap::ConjugateReturnType,const OtherMap&>::type ConjRhsType;
    for (Index i=0; i<size; ++i)
    {
      Map<Matrix<Scalar,Dynamic,1> >(mat+stride*i+(UpLo==Lower ? i : 0), (UpLo==Lower ? size-i : (i+1)))
          += (alpha * cj(vec[i])) * ConjRhsType(OtherMap(vec+(UpLo==Lower ? i : 0),UpLo==Lower ? size-i : (i+1)));
    }
  }
};

template<typename Scalar, typename Index, int UpLo, bool ConjLhs, bool ConjRhs>
struct selfadjoint_rank1_update<Scalar,Index,RowMajor,UpLo,ConjLhs,ConjRhs>
{
  static void run(Index size, Scalar* mat, Index stride, const Scalar* vec, Scalar alpha)
  {
    selfadjoint_rank1_update<Scalar,Index,ColMajor,UpLo==Lower?Upper:Lower,ConjRhs,ConjLhs>::run(size,mat,stride,vec,alpha);
  }
};

template<typename MatrixType, typename OtherType, int UpLo, bool OtherIsVector = OtherType::IsVectorAtCompileTime>
struct selfadjoint_product_selector;

template<typename MatrixType, typename OtherType, int UpLo>
struct selfadjoint_product_selector<MatrixType,OtherType,UpLo,true>
{
  static void run(MatrixType& mat, const OtherType& other, typename MatrixType::Scalar alpha)
  {
    typedef typename MatrixType::Scalar Scalar;
    typedef typename MatrixType::Index Index;
    typedef internal::blas_traits<OtherType> OtherBlasTraits;
    typedef typename OtherBlasTraits::DirectLinearAccessType ActualOtherType;
    typedef typename internal::remove_all<ActualOtherType>::type _ActualOtherType;
    const ActualOtherType actualOther = OtherBlasTraits::extract(other.derived());

    Scalar actualAlpha = alpha * OtherBlasTraits::extractScalarFactor(other.derived());

    enum {
      StorageOrder = (internal::traits<MatrixType>::Flags&RowMajorBit) ? RowMajor : ColMajor,
      UseOtherDirectly = _ActualOtherType::InnerStrideAtCompileTime==1
    };
    internal::gemv_static_vector_if<Scalar,OtherType::SizeAtCompileTime,OtherType::MaxSizeAtCompileTime,!UseOtherDirectly> static_other;

    Scalar* actualOtherPtr = ((UseOtherDirectly ? const_cast<Scalar*>(actualOther.data()) : static_other.data()))!=0 ? ((UseOtherDirectly ? const_cast<Scalar*>(actualOther.data()) : static_other.data())) : reinterpret_cast<Scalar*>( (sizeof(Scalar)*other.size()<=0) ? __builtin_alloca (sizeof(Scalar)*other.size()) : Eigen::internal::aligned_malloc(sizeof(Scalar)*other.size()) ); Eigen::internal::aligned_stack_memory_handler<Scalar> actualOtherPtr_stack_memory_destructor(((UseOtherDirectly ? const_cast<Scalar*>(actualOther.data()) : static_other.data()))==0 ? actualOtherPtr : 0,other.size(),sizeof(Scalar)*other.size()>0);


    if(!UseOtherDirectly)
      Map<typename _ActualOtherType::PlainObject>(actualOtherPtr, actualOther.size()) = actualOther;

    selfadjoint_rank1_update<Scalar,Index,StorageOrder,UpLo,
                              OtherBlasTraits::NeedToConjugate && NumTraits<Scalar>::IsComplex,
                            (!OtherBlasTraits::NeedToConjugate) && NumTraits<Scalar>::IsComplex>
          ::run(other.size(), mat.data(), mat.outerStride(), actualOtherPtr, actualAlpha);
  }
};

template<typename MatrixType, typename OtherType, int UpLo>
struct selfadjoint_product_selector<MatrixType,OtherType,UpLo,false>
{
  static void run(MatrixType& mat, const OtherType& other, typename MatrixType::Scalar alpha)
  {
    typedef typename MatrixType::Scalar Scalar;
    typedef typename MatrixType::Index Index;
    typedef internal::blas_traits<OtherType> OtherBlasTraits;
    typedef typename OtherBlasTraits::DirectLinearAccessType ActualOtherType;
    typedef typename internal::remove_all<ActualOtherType>::type _ActualOtherType;
    const ActualOtherType actualOther = OtherBlasTraits::extract(other.derived());

    Scalar actualAlpha = alpha * OtherBlasTraits::extractScalarFactor(other.derived());

    enum { IsRowMajor = (internal::traits<MatrixType>::Flags&RowMajorBit) ? 1 : 0 };

    internal::general_matrix_matrix_triangular_product<Index,
      Scalar, _ActualOtherType::Flags&RowMajorBit ? RowMajor : ColMajor, OtherBlasTraits::NeedToConjugate && NumTraits<Scalar>::IsComplex,
      Scalar, _ActualOtherType::Flags&RowMajorBit ? ColMajor : RowMajor, (!OtherBlasTraits::NeedToConjugate) && NumTraits<Scalar>::IsComplex,
      MatrixType::Flags&RowMajorBit ? RowMajor : ColMajor, UpLo>
      ::run(mat.cols(), actualOther.cols(),
            &actualOther.coeffRef(0,0), actualOther.outerStride(), &actualOther.coeffRef(0,0), actualOther.outerStride(),
            mat.data(), mat.outerStride(), actualAlpha);
  }
};



template<typename MatrixType, unsigned int UpLo>
template<typename DerivedU>
SelfAdjointView<MatrixType,UpLo>& SelfAdjointView<MatrixType,UpLo>
::rankUpdate(const MatrixBase<DerivedU>& u, Scalar alpha)
{
  selfadjoint_product_selector<MatrixType,DerivedU,UpLo>::run(_expression().const_cast_derived(), u.derived(), alpha);

  return *this;
}
# 334 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/SelfadjointRank2Update.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/SelfadjointRank2Update.h"
namespace internal {





template<typename Scalar, typename Index, typename UType, typename VType, int UpLo>
struct selfadjoint_rank2_update_selector;

template<typename Scalar, typename Index, typename UType, typename VType>
struct selfadjoint_rank2_update_selector<Scalar,Index,UType,VType,Lower>
{
  static void run(Scalar* mat, Index stride, const UType& u, const VType& v, Scalar alpha)
  {
    const Index size = u.size();
    for (Index i=0; i<size; ++i)
    {
      Map<Matrix<Scalar,Dynamic,1> >(mat+stride*i+i, size-i) +=
                        (conj(alpha) * conj(u.coeff(i))) * v.tail(size-i)
                      + (alpha * conj(v.coeff(i))) * u.tail(size-i);
    }
  }
};

template<typename Scalar, typename Index, typename UType, typename VType>
struct selfadjoint_rank2_update_selector<Scalar,Index,UType,VType,Upper>
{
  static void run(Scalar* mat, Index stride, const UType& u, const VType& v, Scalar alpha)
  {
    const Index size = u.size();
    for (Index i=0; i<size; ++i)
      Map<Matrix<Scalar,Dynamic,1> >(mat+stride*i, i+1) +=
                        (conj(alpha) * conj(u.coeff(i))) * v.head(i+1)
                      + (alpha * conj(v.coeff(i))) * u.head(i+1);
  }
};

template<bool Cond, typename T> struct conj_expr_if
  : conditional<!Cond, const T&,
      CwiseUnaryOp<scalar_conjugate_op<typename traits<T>::Scalar>,T> > {};

}

template<typename MatrixType, unsigned int UpLo>
template<typename DerivedU, typename DerivedV>
SelfAdjointView<MatrixType,UpLo>& SelfAdjointView<MatrixType,UpLo>
::rankUpdate(const MatrixBase<DerivedU>& u, const MatrixBase<DerivedV>& v, Scalar alpha)
{
  typedef internal::blas_traits<DerivedU> UBlasTraits;
  typedef typename UBlasTraits::DirectLinearAccessType ActualUType;
  typedef typename internal::remove_all<ActualUType>::type _ActualUType;
  const ActualUType actualU = UBlasTraits::extract(u.derived());

  typedef internal::blas_traits<DerivedV> VBlasTraits;
  typedef typename VBlasTraits::DirectLinearAccessType ActualVType;
  typedef typename internal::remove_all<ActualVType>::type _ActualVType;
  const ActualVType actualV = VBlasTraits::extract(v.derived());




  enum { IsRowMajor = (internal::traits<MatrixType>::Flags&RowMajorBit) ? 1 : 0 };
  Scalar actualAlpha = alpha * UBlasTraits::extractScalarFactor(u.derived())
                             * internal::conj(VBlasTraits::extractScalarFactor(v.derived()));
  if (IsRowMajor)
    actualAlpha = internal::conj(actualAlpha);

  internal::selfadjoint_rank2_update_selector<Scalar, Index,
    typename internal::remove_all<typename internal::conj_expr_if<IsRowMajor ^ UBlasTraits::NeedToConjugate,_ActualUType>::type>::type,
    typename internal::remove_all<typename internal::conj_expr_if<IsRowMajor ^ VBlasTraits::NeedToConjugate,_ActualVType>::type>::type,
    (IsRowMajor ? int(UpLo==Upper ? Lower : Upper) : UpLo)>
    ::run(_expression().const_cast_derived().data(),_expression().outerStride(),actualU,actualV,actualAlpha);

  return *this;
}
# 335 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/TriangularMatrixVector.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/TriangularMatrixVector.h"
namespace internal {

template<typename Index, int Mode, typename LhsScalar, bool ConjLhs, typename RhsScalar, bool ConjRhs, int StorageOrder>
struct product_triangular_matrix_vector;

template<typename Index, int Mode, typename LhsScalar, bool ConjLhs, typename RhsScalar, bool ConjRhs>
struct product_triangular_matrix_vector<Index,Mode,LhsScalar,ConjLhs,RhsScalar,ConjRhs,ColMajor>
{
  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;
  enum {
    IsLower = ((Mode&Lower)==Lower),
    HasUnitDiag = (Mode & UnitDiag)==UnitDiag
  };
  static __attribute__((noinline)) void run(Index rows, Index cols, const LhsScalar* _lhs, Index lhsStride,
                                     const RhsScalar* _rhs, Index rhsIncr, ResScalar* _res, Index resIncr, ResScalar alpha)
  {
    static const Index PanelWidth = 8;

    typedef Map<const Matrix<LhsScalar,Dynamic,Dynamic,ColMajor>, 0, OuterStride<> > LhsMap;
    const LhsMap lhs(_lhs,rows,cols,OuterStride<>(lhsStride));
    typename conj_expr_if<ConjLhs,LhsMap>::type cjLhs(lhs);

    typedef Map<const Matrix<RhsScalar,Dynamic,1>, 0, InnerStride<> > RhsMap;
    const RhsMap rhs(_rhs,cols,InnerStride<>(rhsIncr));
    typename conj_expr_if<ConjRhs,RhsMap>::type cjRhs(rhs);

    typedef Map<Matrix<ResScalar,Dynamic,1> > ResMap;
    ResMap res(_res,rows);

    for (Index pi=0; pi<cols; pi+=PanelWidth)
    {
      Index actualPanelWidth = (std::min)(PanelWidth, cols-pi);
      for (Index k=0; k<actualPanelWidth; ++k)
      {
        Index i = pi + k;
        Index s = IsLower ? (HasUnitDiag ? i+1 : i ) : pi;
        Index r = IsLower ? actualPanelWidth-k : k+1;
        if ((!HasUnitDiag) || (--r)>0)
          res.segment(s,r) += (alpha * cjRhs.coeff(i)) * cjLhs.col(i).segment(s,r);
        if (HasUnitDiag)
          res.coeffRef(i) += alpha * cjRhs.coeff(i);
      }
      Index r = IsLower ? cols - pi - actualPanelWidth : pi;
      if (r>0)
      {
        Index s = IsLower ? pi+actualPanelWidth : 0;
        general_matrix_vector_product<Index,LhsScalar,ColMajor,ConjLhs,RhsScalar,ConjRhs>::run(
            r, actualPanelWidth,
            &lhs.coeffRef(s,pi), lhsStride,
            &rhs.coeffRef(pi), rhsIncr,
            &res.coeffRef(s), resIncr, alpha);
      }
    }
  }
};

template<typename Index, int Mode, typename LhsScalar, bool ConjLhs, typename RhsScalar, bool ConjRhs>
struct product_triangular_matrix_vector<Index,Mode,LhsScalar,ConjLhs,RhsScalar,ConjRhs,RowMajor>
{
  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;
  enum {
    IsLower = ((Mode&Lower)==Lower),
    HasUnitDiag = (Mode & UnitDiag)==UnitDiag
  };
  static void run(Index rows, Index cols, const LhsScalar* _lhs, Index lhsStride,
                  const RhsScalar* _rhs, Index rhsIncr, ResScalar* _res, Index resIncr, ResScalar alpha)
  {
    static const Index PanelWidth = 8;

    typedef Map<const Matrix<LhsScalar,Dynamic,Dynamic,RowMajor>, 0, OuterStride<> > LhsMap;
    const LhsMap lhs(_lhs,rows,cols,OuterStride<>(lhsStride));
    typename conj_expr_if<ConjLhs,LhsMap>::type cjLhs(lhs);

    typedef Map<const Matrix<RhsScalar,Dynamic,1> > RhsMap;
    const RhsMap rhs(_rhs,cols);
    typename conj_expr_if<ConjRhs,RhsMap>::type cjRhs(rhs);

    typedef Map<Matrix<ResScalar,Dynamic,1>, 0, InnerStride<> > ResMap;
    ResMap res(_res,rows,InnerStride<>(resIncr));

    for (Index pi=0; pi<cols; pi+=PanelWidth)
    {
      Index actualPanelWidth = (std::min)(PanelWidth, cols-pi);
      for (Index k=0; k<actualPanelWidth; ++k)
      {
        Index i = pi + k;
        Index s = IsLower ? pi : (HasUnitDiag ? i+1 : i);
        Index r = IsLower ? k+1 : actualPanelWidth-k;
        if ((!HasUnitDiag) || (--r)>0)
          res.coeffRef(i) += alpha * (cjLhs.row(i).segment(s,r).cwiseProduct(cjRhs.segment(s,r).transpose())).sum();
        if (HasUnitDiag)
          res.coeffRef(i) += alpha * cjRhs.coeff(i);
      }
      Index r = IsLower ? pi : cols - pi - actualPanelWidth;
      if (r>0)
      {
        Index s = IsLower ? 0 : pi + actualPanelWidth;
        general_matrix_vector_product<Index,LhsScalar,RowMajor,ConjLhs,RhsScalar,ConjRhs>::run(
            actualPanelWidth, r,
            &lhs.coeffRef(pi,s), lhsStride,
            &rhs.coeffRef(s), rhsIncr,
            &res.coeffRef(pi), resIncr, alpha);
      }
    }
  }
};





template<int Mode, bool LhsIsTriangular, typename Lhs, typename Rhs>
struct traits<TriangularProduct<Mode,LhsIsTriangular,Lhs,false,Rhs,true> >
 : traits<ProductBase<TriangularProduct<Mode,LhsIsTriangular,Lhs,false,Rhs,true>, Lhs, Rhs> >
{};

template<int Mode, bool LhsIsTriangular, typename Lhs, typename Rhs>
struct traits<TriangularProduct<Mode,LhsIsTriangular,Lhs,true,Rhs,false> >
 : traits<ProductBase<TriangularProduct<Mode,LhsIsTriangular,Lhs,true,Rhs,false>, Lhs, Rhs> >
{};


template<int StorageOrder>
struct trmv_selector;

}

template<int Mode, typename Lhs, typename Rhs>
struct TriangularProduct<Mode,true,Lhs,false,Rhs,true>
  : public ProductBase<TriangularProduct<Mode,true,Lhs,false,Rhs,true>, Lhs, Rhs >
{
  typedef ProductBase<TriangularProduct, Lhs, Rhs > Base; typedef typename Eigen::internal::traits<TriangularProduct>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<TriangularProduct>::type Nested; typedef typename Eigen::internal::traits<TriangularProduct>::StorageKind StorageKind; typedef typename Eigen::internal::traits<TriangularProduct>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<TriangularProduct>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<TriangularProduct>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<TriangularProduct>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<TriangularProduct>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<TriangularProduct>::Flags, CoeffReadCost = Eigen::internal::traits<TriangularProduct>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived; typedef typename Base::LhsNested LhsNested; typedef typename Base::_LhsNested _LhsNested; typedef typename Base::LhsBlasTraits LhsBlasTraits; typedef typename Base::ActualLhsType ActualLhsType; typedef typename Base::_ActualLhsType _ActualLhsType; typedef typename Base::RhsNested RhsNested; typedef typename Base::_RhsNested _RhsNested; typedef typename Base::RhsBlasTraits RhsBlasTraits; typedef typename Base::ActualRhsType ActualRhsType; typedef typename Base::_ActualRhsType _ActualRhsType; using Base::m_lhs; using Base::m_rhs;

  TriangularProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}

  template<typename Dest> void scaleAndAddTo(Dest& dst, Scalar alpha) const
  {
    if( (!Eigen::internal::copy_bool(dst.rows()==m_lhs.rows() && dst.cols()==m_rhs.cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(dst.rows()==m_lhs.rows() && dst.cols()==m_rhs.cols())) Eigen::internal::assert_fail("dst.rows()==m_lhs.rows() && dst.cols()==m_rhs.cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/TriangularMatrixVector.h", 165); } while(false); else throw Eigen::eigen_assert_exception(); };

    internal::trmv_selector<(int(internal::traits<Lhs>::Flags)&RowMajorBit) ? RowMajor : ColMajor>::run(*this, dst, alpha);
  }
};

template<int Mode, typename Lhs, typename Rhs>
struct TriangularProduct<Mode,false,Lhs,true,Rhs,false>
  : public ProductBase<TriangularProduct<Mode,false,Lhs,true,Rhs,false>, Lhs, Rhs >
{
  typedef ProductBase<TriangularProduct, Lhs, Rhs > Base; typedef typename Eigen::internal::traits<TriangularProduct>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<TriangularProduct>::type Nested; typedef typename Eigen::internal::traits<TriangularProduct>::StorageKind StorageKind; typedef typename Eigen::internal::traits<TriangularProduct>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<TriangularProduct>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<TriangularProduct>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<TriangularProduct>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<TriangularProduct>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<TriangularProduct>::Flags, CoeffReadCost = Eigen::internal::traits<TriangularProduct>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived; typedef typename Base::LhsNested LhsNested; typedef typename Base::_LhsNested _LhsNested; typedef typename Base::LhsBlasTraits LhsBlasTraits; typedef typename Base::ActualLhsType ActualLhsType; typedef typename Base::_ActualLhsType _ActualLhsType; typedef typename Base::RhsNested RhsNested; typedef typename Base::_RhsNested _RhsNested; typedef typename Base::RhsBlasTraits RhsBlasTraits; typedef typename Base::ActualRhsType ActualRhsType; typedef typename Base::_ActualRhsType _ActualRhsType; using Base::m_lhs; using Base::m_rhs;

  TriangularProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}

  template<typename Dest> void scaleAndAddTo(Dest& dst, Scalar alpha) const
  {
    if( (!Eigen::internal::copy_bool(dst.rows()==m_lhs.rows() && dst.cols()==m_rhs.cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(dst.rows()==m_lhs.rows() && dst.cols()==m_rhs.cols())) Eigen::internal::assert_fail("dst.rows()==m_lhs.rows() && dst.cols()==m_rhs.cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/TriangularMatrixVector.h", 181); } while(false); else throw Eigen::eigen_assert_exception(); };

    typedef TriangularProduct<(Mode & UnitDiag) | ((Mode & Lower) ? Upper : Lower),true,Transpose<const Rhs>,false,Transpose<const Lhs>,true> TriangularProductTranspose;
    Transpose<Dest> dstT(dst);
    internal::trmv_selector<(int(internal::traits<Rhs>::Flags)&RowMajorBit) ? ColMajor : RowMajor>::run(
      TriangularProductTranspose(m_rhs.transpose(),m_lhs.transpose()), dstT, alpha);
  }
};

namespace internal {



template<> struct trmv_selector<ColMajor>
{
  template<int Mode, typename Lhs, typename Rhs, typename Dest>
  static void run(const TriangularProduct<Mode,true,Lhs,false,Rhs,true>& prod, Dest& dest, typename TriangularProduct<Mode,true,Lhs,false,Rhs,true>::Scalar alpha)
  {
    typedef TriangularProduct<Mode,true,Lhs,false,Rhs,true> ProductType;
    typedef typename ProductType::Index Index;
    typedef typename ProductType::LhsScalar LhsScalar;
    typedef typename ProductType::RhsScalar RhsScalar;
    typedef typename ProductType::Scalar ResScalar;
    typedef typename ProductType::RealScalar RealScalar;
    typedef typename ProductType::ActualLhsType ActualLhsType;
    typedef typename ProductType::ActualRhsType ActualRhsType;
    typedef typename ProductType::LhsBlasTraits LhsBlasTraits;
    typedef typename ProductType::RhsBlasTraits RhsBlasTraits;
    typedef Map<Matrix<ResScalar,Dynamic,1>, Aligned> MappedDest;

    const ActualLhsType actualLhs = LhsBlasTraits::extract(prod.lhs());
    const ActualRhsType actualRhs = RhsBlasTraits::extract(prod.rhs());

    ResScalar actualAlpha = alpha * LhsBlasTraits::extractScalarFactor(prod.lhs())
                                  * RhsBlasTraits::extractScalarFactor(prod.rhs());

    enum {


      EvalToDestAtCompileTime = Dest::InnerStrideAtCompileTime==1,
      ComplexByReal = (NumTraits<LhsScalar>::IsComplex) && (!NumTraits<RhsScalar>::IsComplex),
      MightCannotUseDest = (Dest::InnerStrideAtCompileTime!=1) || ComplexByReal
    };

    gemv_static_vector_if<ResScalar,Dest::SizeAtCompileTime,Dest::MaxSizeAtCompileTime,MightCannotUseDest> static_dest;

    bool alphaIsCompatible = (!ComplexByReal) || (imag(actualAlpha)==RealScalar(0));
    bool evalToDest = EvalToDestAtCompileTime && alphaIsCompatible;

    RhsScalar compatibleAlpha = get_factor<ResScalar,RhsScalar>::run(actualAlpha);

    ResScalar* actualDestPtr = (evalToDest ? dest.data() : static_dest.data())!=0 ? (evalToDest ? dest.data() : static_dest.data()) : reinterpret_cast<ResScalar*>( (sizeof(ResScalar)*dest.size()<=0) ? __builtin_alloca (sizeof(ResScalar)*dest.size()) : Eigen::internal::aligned_malloc(sizeof(ResScalar)*dest.size()) ); Eigen::internal::aligned_stack_memory_handler<ResScalar> actualDestPtr_stack_memory_destructor((evalToDest ? dest.data() : static_dest.data())==0 ? actualDestPtr : 0,dest.size(),sizeof(ResScalar)*dest.size()>0);


    if(!evalToDest)
    {




      if(!alphaIsCompatible)
      {
        MappedDest(actualDestPtr, dest.size()).setZero();
        compatibleAlpha = RhsScalar(1);
      }
      else
        MappedDest(actualDestPtr, dest.size()) = dest;
    }

    internal::product_triangular_matrix_vector
      <Index,Mode,
       LhsScalar, LhsBlasTraits::NeedToConjugate,
       RhsScalar, RhsBlasTraits::NeedToConjugate,
       ColMajor>
      ::run(actualLhs.rows(),actualLhs.cols(),
            actualLhs.data(),actualLhs.outerStride(),
            actualRhs.data(),actualRhs.innerStride(),
            actualDestPtr,1,compatibleAlpha);

    if (!evalToDest)
    {
      if(!alphaIsCompatible)
        dest += actualAlpha * MappedDest(actualDestPtr, dest.size());
      else
        dest = MappedDest(actualDestPtr, dest.size());
    }
  }
};

template<> struct trmv_selector<RowMajor>
{
  template<int Mode, typename Lhs, typename Rhs, typename Dest>
  static void run(const TriangularProduct<Mode,true,Lhs,false,Rhs,true>& prod, Dest& dest, typename TriangularProduct<Mode,true,Lhs,false,Rhs,true>::Scalar alpha)
  {
    typedef TriangularProduct<Mode,true,Lhs,false,Rhs,true> ProductType;
    typedef typename ProductType::LhsScalar LhsScalar;
    typedef typename ProductType::RhsScalar RhsScalar;
    typedef typename ProductType::Scalar ResScalar;
    typedef typename ProductType::Index Index;
    typedef typename ProductType::ActualLhsType ActualLhsType;
    typedef typename ProductType::ActualRhsType ActualRhsType;
    typedef typename ProductType::_ActualRhsType _ActualRhsType;
    typedef typename ProductType::LhsBlasTraits LhsBlasTraits;
    typedef typename ProductType::RhsBlasTraits RhsBlasTraits;

    typename add_const<ActualLhsType>::type actualLhs = LhsBlasTraits::extract(prod.lhs());
    typename add_const<ActualRhsType>::type actualRhs = RhsBlasTraits::extract(prod.rhs());

    ResScalar actualAlpha = alpha * LhsBlasTraits::extractScalarFactor(prod.lhs())
                                  * RhsBlasTraits::extractScalarFactor(prod.rhs());

    enum {
      DirectlyUseRhs = _ActualRhsType::InnerStrideAtCompileTime==1
    };

    gemv_static_vector_if<RhsScalar,_ActualRhsType::SizeAtCompileTime,_ActualRhsType::MaxSizeAtCompileTime,!DirectlyUseRhs> static_rhs;

    RhsScalar* actualRhsPtr = (DirectlyUseRhs ? const_cast<RhsScalar*>(actualRhs.data()) : static_rhs.data())!=0 ? (DirectlyUseRhs ? const_cast<RhsScalar*>(actualRhs.data()) : static_rhs.data()) : reinterpret_cast<RhsScalar*>( (sizeof(RhsScalar)*actualRhs.size()<=0) ? __builtin_alloca (sizeof(RhsScalar)*actualRhs.size()) : Eigen::internal::aligned_malloc(sizeof(RhsScalar)*actualRhs.size()) ); Eigen::internal::aligned_stack_memory_handler<RhsScalar> actualRhsPtr_stack_memory_destructor((DirectlyUseRhs ? const_cast<RhsScalar*>(actualRhs.data()) : static_rhs.data())==0 ? actualRhsPtr : 0,actualRhs.size(),sizeof(RhsScalar)*actualRhs.size()>0);


    if(!DirectlyUseRhs)
    {




      Map<typename _ActualRhsType::PlainObject>(actualRhsPtr, actualRhs.size()) = actualRhs;
    }

    internal::product_triangular_matrix_vector
      <Index,Mode,
       LhsScalar, LhsBlasTraits::NeedToConjugate,
       RhsScalar, RhsBlasTraits::NeedToConjugate,
       RowMajor>
      ::run(actualLhs.rows(),actualLhs.cols(),
            actualLhs.data(),actualLhs.outerStride(),
            actualRhsPtr,1,
            dest.data(),dest.innerStride(),
            actualAlpha);
  }
};

}
# 336 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/TriangularMatrixMatrix.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/TriangularMatrixMatrix.h"
namespace internal {
# 57 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/TriangularMatrixMatrix.h"
template <typename Scalar, typename Index,
          int Mode, bool LhsIsTriangular,
          int LhsStorageOrder, bool ConjugateLhs,
          int RhsStorageOrder, bool ConjugateRhs,
          int ResStorageOrder>
struct product_triangular_matrix_matrix;

template <typename Scalar, typename Index,
          int Mode, bool LhsIsTriangular,
          int LhsStorageOrder, bool ConjugateLhs,
          int RhsStorageOrder, bool ConjugateRhs>
struct product_triangular_matrix_matrix<Scalar,Index,Mode,LhsIsTriangular,
                                           LhsStorageOrder,ConjugateLhs,
                                           RhsStorageOrder,ConjugateRhs,RowMajor>
{
  static inline void run(
    Index rows, Index cols, Index depth,
    const Scalar* lhs, Index lhsStride,
    const Scalar* rhs, Index rhsStride,
    Scalar* res, Index resStride,
    Scalar alpha)
  {
    product_triangular_matrix_matrix<Scalar, Index,
      (Mode&(UnitDiag|ZeroDiag)) | ((Mode&Upper) ? Lower : Upper),
      (!LhsIsTriangular),
      RhsStorageOrder==RowMajor ? ColMajor : RowMajor,
      ConjugateRhs,
      LhsStorageOrder==RowMajor ? ColMajor : RowMajor,
      ConjugateLhs,
      ColMajor>
      ::run(cols, rows, depth, rhs, rhsStride, lhs, lhsStride, res, resStride, alpha);
  }
};


template <typename Scalar, typename Index, int Mode,
          int LhsStorageOrder, bool ConjugateLhs,
          int RhsStorageOrder, bool ConjugateRhs>
struct product_triangular_matrix_matrix<Scalar,Index,Mode,true,
                                           LhsStorageOrder,ConjugateLhs,
                                           RhsStorageOrder,ConjugateRhs,ColMajor>
{

  typedef gebp_traits<Scalar,Scalar> Traits;
  enum {
    SmallPanelWidth = (((int)Traits::mr >= (int)Traits::nr) ? (int)Traits::mr : (int)Traits::nr),
    IsLower = (Mode&Lower) == Lower,
    SetDiag = (Mode&(ZeroDiag|UnitDiag)) ? 0 : 1
  };

  static __attribute__((noinline)) void run(
    Index _rows, Index _cols, Index _depth,
    const Scalar* _lhs, Index lhsStride,
    const Scalar* _rhs, Index rhsStride,
    Scalar* res, Index resStride,
    Scalar alpha)
  {

    Index diagSize = (std::min)(_rows,_depth);
    Index rows = IsLower ? _rows : diagSize;
    Index depth = IsLower ? diagSize : _depth;
    Index cols = _cols;

    const_blas_data_mapper<Scalar, Index, LhsStorageOrder> lhs(_lhs,lhsStride);
    const_blas_data_mapper<Scalar, Index, RhsStorageOrder> rhs(_rhs,rhsStride);

    Index kc = depth;
    Index mc = rows;
    Index nc = cols;
    computeProductBlockingSizes<Scalar,Scalar,4>(kc, mc, nc);
    std::size_t sizeW = kc*Traits::WorkSpaceFactor;
    std::size_t sizeB = sizeW + kc*cols;
    Scalar* blockA = (0)!=0 ? (0) : reinterpret_cast<Scalar*>( (sizeof(Scalar)*kc*mc<=0) ? __builtin_alloca (sizeof(Scalar)*kc*mc) : Eigen::internal::aligned_malloc(sizeof(Scalar)*kc*mc) ); Eigen::internal::aligned_stack_memory_handler<Scalar> blockA_stack_memory_destructor((0)==0 ? blockA : 0,kc*mc,sizeof(Scalar)*kc*mc>0);
    Scalar* allocatedBlockB = (0)!=0 ? (0) : reinterpret_cast<Scalar*>( (sizeof(Scalar)*sizeB<=0) ? __builtin_alloca (sizeof(Scalar)*sizeB) : Eigen::internal::aligned_malloc(sizeof(Scalar)*sizeB) ); Eigen::internal::aligned_stack_memory_handler<Scalar> allocatedBlockB_stack_memory_destructor((0)==0 ? allocatedBlockB : 0,sizeB,sizeof(Scalar)*sizeB>0);
    Scalar* blockB = allocatedBlockB + sizeW;

    Matrix<Scalar,SmallPanelWidth,SmallPanelWidth,LhsStorageOrder> triangularBuffer;
    triangularBuffer.setZero();
    if((Mode&ZeroDiag)==ZeroDiag)
      triangularBuffer.diagonal().setZero();
    else
      triangularBuffer.diagonal().setOnes();

    gebp_kernel<Scalar, Scalar, Index, Traits::mr, Traits::nr, ConjugateLhs, ConjugateRhs> gebp_kernel;
    gemm_pack_lhs<Scalar, Index, Traits::mr, Traits::LhsProgress, LhsStorageOrder> pack_lhs;
    gemm_pack_rhs<Scalar, Index, Traits::nr,RhsStorageOrder> pack_rhs;

    for(Index k2=IsLower ? depth : 0;
        IsLower ? k2>0 : k2<depth;
        IsLower ? k2-=kc : k2+=kc)
    {
      Index actual_kc = (std::min)(IsLower ? k2 : depth-k2, kc);
      Index actual_k2 = IsLower ? k2-actual_kc : k2;


      if((!IsLower)&&(k2<rows)&&(k2+actual_kc>rows))
      {
        actual_kc = rows-k2;
        k2 = k2+actual_kc-kc;
      }

      pack_rhs(blockB, &rhs(actual_k2,0), rhsStride, actual_kc, cols);







      if(IsLower || actual_k2<rows)
      {

        for (Index k1=0; k1<actual_kc; k1+=SmallPanelWidth)
        {
          Index actualPanelWidth = std::min<Index>(actual_kc-k1, SmallPanelWidth);
          Index lengthTarget = IsLower ? actual_kc-k1-actualPanelWidth : k1;
          Index startBlock = actual_k2+k1;
          Index blockBOffset = k1;




          for (Index k=0;k<actualPanelWidth;++k)
          {
            if (SetDiag)
              triangularBuffer.coeffRef(k,k) = lhs(startBlock+k,startBlock+k);
            for (Index i=IsLower ? k+1 : 0; IsLower ? i<actualPanelWidth : i<k; ++i)
              triangularBuffer.coeffRef(i,k) = lhs(startBlock+i,startBlock+k);
          }
          pack_lhs(blockA, triangularBuffer.data(), triangularBuffer.outerStride(), actualPanelWidth, actualPanelWidth);

          gebp_kernel(res+startBlock, resStride, blockA, blockB, actualPanelWidth, actualPanelWidth, cols, alpha,
                      actualPanelWidth, actual_kc, 0, blockBOffset);


          if (lengthTarget>0)
          {
            Index startTarget = IsLower ? actual_k2+k1+actualPanelWidth : actual_k2;

            pack_lhs(blockA, &lhs(startTarget,startBlock), lhsStride, actualPanelWidth, lengthTarget);

            gebp_kernel(res+startTarget, resStride, blockA, blockB, lengthTarget, actualPanelWidth, cols, alpha,
                        actualPanelWidth, actual_kc, 0, blockBOffset);
          }
        }
      }

      {
        Index start = IsLower ? k2 : 0;
        Index end = IsLower ? rows : (std::min)(actual_k2,rows);
        for(Index i2=start; i2<end; i2+=mc)
        {
          const Index actual_mc = (std::min)(i2+mc,end)-i2;
          gemm_pack_lhs<Scalar, Index, Traits::mr,Traits::LhsProgress, LhsStorageOrder,false>()
            (blockA, &lhs(i2, actual_k2), lhsStride, actual_kc, actual_mc);

          gebp_kernel(res+i2, resStride, blockA, blockB, actual_mc, actual_kc, cols, alpha);
        }
      }
    }
  }
};


template <typename Scalar, typename Index, int Mode,
          int LhsStorageOrder, bool ConjugateLhs,
          int RhsStorageOrder, bool ConjugateRhs>
struct product_triangular_matrix_matrix<Scalar,Index,Mode,false,
                                           LhsStorageOrder,ConjugateLhs,
                                           RhsStorageOrder,ConjugateRhs,ColMajor>
{
  typedef gebp_traits<Scalar,Scalar> Traits;
  enum {
    SmallPanelWidth = (((int)Traits::mr >= (int)Traits::nr) ? (int)Traits::mr : (int)Traits::nr),
    IsLower = (Mode&Lower) == Lower,
    SetDiag = (Mode&(ZeroDiag|UnitDiag)) ? 0 : 1
  };

  static __attribute__((noinline)) void run(
    Index _rows, Index _cols, Index _depth,
    const Scalar* _lhs, Index lhsStride,
    const Scalar* _rhs, Index rhsStride,
    Scalar* res, Index resStride,
    Scalar alpha)
  {

    Index diagSize = (std::min)(_cols,_depth);
    Index rows = _rows;
    Index depth = IsLower ? _depth : diagSize;
    Index cols = IsLower ? diagSize : _cols;

    const_blas_data_mapper<Scalar, Index, LhsStorageOrder> lhs(_lhs,lhsStride);
    const_blas_data_mapper<Scalar, Index, RhsStorageOrder> rhs(_rhs,rhsStride);

    Index kc = depth;
    Index mc = rows;
    Index nc = cols;
    computeProductBlockingSizes<Scalar,Scalar,4>(kc, mc, nc);

    std::size_t sizeW = kc*Traits::WorkSpaceFactor;
    std::size_t sizeB = sizeW + kc*cols;
    Scalar* blockA = (0)!=0 ? (0) : reinterpret_cast<Scalar*>( (sizeof(Scalar)*kc*mc<=0) ? __builtin_alloca (sizeof(Scalar)*kc*mc) : Eigen::internal::aligned_malloc(sizeof(Scalar)*kc*mc) ); Eigen::internal::aligned_stack_memory_handler<Scalar> blockA_stack_memory_destructor((0)==0 ? blockA : 0,kc*mc,sizeof(Scalar)*kc*mc>0);
    Scalar* allocatedBlockB = (0)!=0 ? (0) : reinterpret_cast<Scalar*>( (sizeof(Scalar)*sizeB<=0) ? __builtin_alloca (sizeof(Scalar)*sizeB) : Eigen::internal::aligned_malloc(sizeof(Scalar)*sizeB) ); Eigen::internal::aligned_stack_memory_handler<Scalar> allocatedBlockB_stack_memory_destructor((0)==0 ? allocatedBlockB : 0,sizeB,sizeof(Scalar)*sizeB>0);
    Scalar* blockB = allocatedBlockB + sizeW;

    Matrix<Scalar,SmallPanelWidth,SmallPanelWidth,RhsStorageOrder> triangularBuffer;
    triangularBuffer.setZero();
    if((Mode&ZeroDiag)==ZeroDiag)
      triangularBuffer.diagonal().setZero();
    else
      triangularBuffer.diagonal().setOnes();

    gebp_kernel<Scalar, Scalar, Index, Traits::mr, Traits::nr, ConjugateLhs, ConjugateRhs> gebp_kernel;
    gemm_pack_lhs<Scalar, Index, Traits::mr, Traits::LhsProgress, LhsStorageOrder> pack_lhs;
    gemm_pack_rhs<Scalar, Index, Traits::nr,RhsStorageOrder> pack_rhs;
    gemm_pack_rhs<Scalar, Index, Traits::nr,RhsStorageOrder,false,true> pack_rhs_panel;

    for(Index k2=IsLower ? 0 : depth;
        IsLower ? k2<depth : k2>0;
        IsLower ? k2+=kc : k2-=kc)
    {
      Index actual_kc = (std::min)(IsLower ? depth-k2 : k2, kc);
      Index actual_k2 = IsLower ? k2 : k2-actual_kc;


      if(IsLower && (k2<cols) && (actual_k2+actual_kc>cols))
      {
        actual_kc = cols-k2;
        k2 = actual_k2 + actual_kc - kc;
      }


      Index rs = IsLower ? (std::min)(cols,actual_k2) : cols - k2;

      Index ts = (IsLower && actual_k2>=cols) ? 0 : actual_kc;

      Scalar* geb = blockB+ts*ts;

      pack_rhs(geb, &rhs(actual_k2,IsLower ? 0 : k2), rhsStride, actual_kc, rs);


      if(ts>0)
      {
        for (Index j2=0; j2<actual_kc; j2+=SmallPanelWidth)
        {
          Index actualPanelWidth = std::min<Index>(actual_kc-j2, SmallPanelWidth);
          Index actual_j2 = actual_k2 + j2;
          Index panelOffset = IsLower ? j2+actualPanelWidth : 0;
          Index panelLength = IsLower ? actual_kc-j2-actualPanelWidth : j2;

          pack_rhs_panel(blockB+j2*actual_kc,
                         &rhs(actual_k2+panelOffset, actual_j2), rhsStride,
                         panelLength, actualPanelWidth,
                         actual_kc, panelOffset);


          for (Index j=0;j<actualPanelWidth;++j)
          {
            if (SetDiag)
              triangularBuffer.coeffRef(j,j) = rhs(actual_j2+j,actual_j2+j);
            for (Index k=IsLower ? j+1 : 0; IsLower ? k<actualPanelWidth : k<j; ++k)
              triangularBuffer.coeffRef(k,j) = rhs(actual_j2+k,actual_j2+j);
          }

          pack_rhs_panel(blockB+j2*actual_kc,
                         triangularBuffer.data(), triangularBuffer.outerStride(),
                         actualPanelWidth, actualPanelWidth,
                         actual_kc, j2);
        }
      }

      for (Index i2=0; i2<rows; i2+=mc)
      {
        const Index actual_mc = (std::min)(mc,rows-i2);
        pack_lhs(blockA, &lhs(i2, actual_k2), lhsStride, actual_kc, actual_mc);


        if(ts>0)
        {
          for (Index j2=0; j2<actual_kc; j2+=SmallPanelWidth)
          {
            Index actualPanelWidth = std::min<Index>(actual_kc-j2, SmallPanelWidth);
            Index panelLength = IsLower ? actual_kc-j2 : j2+actualPanelWidth;
            Index blockOffset = IsLower ? j2 : 0;

            gebp_kernel(res+i2+(actual_k2+j2)*resStride, resStride,
                        blockA, blockB+j2*actual_kc,
                        actual_mc, panelLength, actualPanelWidth,
                        alpha,
                        actual_kc, actual_kc,
                        blockOffset, blockOffset,
                        allocatedBlockB);
          }
        }
        gebp_kernel(res+i2+(IsLower ? 0 : k2)*resStride, resStride,
                    blockA, geb, actual_mc, actual_kc, rs,
                    alpha,
                    -1, -1, 0, 0, allocatedBlockB);
      }
    }
  }
};





template<int Mode, bool LhsIsTriangular, typename Lhs, typename Rhs>
struct traits<TriangularProduct<Mode,LhsIsTriangular,Lhs,false,Rhs,false> >
  : traits<ProductBase<TriangularProduct<Mode,LhsIsTriangular,Lhs,false,Rhs,false>, Lhs, Rhs> >
{};

}

template<int Mode, bool LhsIsTriangular, typename Lhs, typename Rhs>
struct TriangularProduct<Mode,LhsIsTriangular,Lhs,false,Rhs,false>
  : public ProductBase<TriangularProduct<Mode,LhsIsTriangular,Lhs,false,Rhs,false>, Lhs, Rhs >
{
  typedef ProductBase<TriangularProduct, Lhs, Rhs > Base; typedef typename Eigen::internal::traits<TriangularProduct>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<TriangularProduct>::type Nested; typedef typename Eigen::internal::traits<TriangularProduct>::StorageKind StorageKind; typedef typename Eigen::internal::traits<TriangularProduct>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<TriangularProduct>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<TriangularProduct>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<TriangularProduct>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<TriangularProduct>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<TriangularProduct>::Flags, CoeffReadCost = Eigen::internal::traits<TriangularProduct>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived; typedef typename Base::LhsNested LhsNested; typedef typename Base::_LhsNested _LhsNested; typedef typename Base::LhsBlasTraits LhsBlasTraits; typedef typename Base::ActualLhsType ActualLhsType; typedef typename Base::_ActualLhsType _ActualLhsType; typedef typename Base::RhsNested RhsNested; typedef typename Base::_RhsNested _RhsNested; typedef typename Base::RhsBlasTraits RhsBlasTraits; typedef typename Base::ActualRhsType ActualRhsType; typedef typename Base::_ActualRhsType _ActualRhsType; using Base::m_lhs; using Base::m_rhs;

  TriangularProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}

  template<typename Dest> void scaleAndAddTo(Dest& dst, Scalar alpha) const
  {
    const ActualLhsType lhs = LhsBlasTraits::extract(m_lhs);
    const ActualRhsType rhs = RhsBlasTraits::extract(m_rhs);

    Scalar actualAlpha = alpha * LhsBlasTraits::extractScalarFactor(m_lhs)
                               * RhsBlasTraits::extractScalarFactor(m_rhs);

    internal::product_triangular_matrix_matrix<Scalar, Index,
      Mode, LhsIsTriangular,
      (internal::traits<_ActualLhsType>::Flags&RowMajorBit) ? RowMajor : ColMajor, LhsBlasTraits::NeedToConjugate,
      (internal::traits<_ActualRhsType>::Flags&RowMajorBit) ? RowMajor : ColMajor, RhsBlasTraits::NeedToConjugate,
      (internal::traits<Dest >::Flags&RowMajorBit) ? RowMajor : ColMajor>
      ::run(
        lhs.rows(), rhs.cols(), lhs.cols(),
        &lhs.coeffRef(0,0), lhs.outerStride(),
        &rhs.coeffRef(0,0), rhs.outerStride(),
        &dst.coeffRef(0,0), dst.outerStride(),
        actualAlpha
      );
  }
};
# 337 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/TriangularSolverMatrix.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/TriangularSolverMatrix.h"
namespace internal {


template <typename Scalar, typename Index, int Side, int Mode, bool Conjugate, int TriStorageOrder>
struct triangular_solve_matrix<Scalar,Index,Side,Mode,Conjugate,TriStorageOrder,RowMajor>
{
  static __attribute__((noinline)) void run(
    Index size, Index cols,
    const Scalar* tri, Index triStride,
    Scalar* _other, Index otherStride)
  {
    triangular_solve_matrix<
      Scalar, Index, Side==OnTheLeft?OnTheRight:OnTheLeft,
      (Mode&UnitDiag) | ((Mode&Upper) ? Lower : Upper),
      NumTraits<Scalar>::IsComplex && Conjugate,
      TriStorageOrder==RowMajor ? ColMajor : RowMajor, ColMajor>
      ::run(size, cols, tri, triStride, _other, otherStride);
  }
};



template <typename Scalar, typename Index, int Mode, bool Conjugate, int TriStorageOrder>
struct triangular_solve_matrix<Scalar,Index,OnTheLeft,Mode,Conjugate,TriStorageOrder,ColMajor>
{
  static __attribute__((noinline)) void run(
    Index size, Index otherSize,
    const Scalar* _tri, Index triStride,
    Scalar* _other, Index otherStride)
  {
    Index cols = otherSize;
    const_blas_data_mapper<Scalar, Index, TriStorageOrder> tri(_tri,triStride);
    blas_data_mapper<Scalar, Index, ColMajor> other(_other,otherStride);

    typedef gebp_traits<Scalar,Scalar> Traits;
    enum {
      SmallPanelWidth = (((int)Traits::mr >= (int)Traits::nr) ? (int)Traits::mr : (int)Traits::nr),
      IsLower = (Mode&Lower) == Lower
    };

    Index kc = size;
    Index mc = size;
    Index nc = cols;
    computeProductBlockingSizes<Scalar,Scalar,4>(kc, mc, nc);

    std::size_t sizeW = kc*Traits::WorkSpaceFactor;
    std::size_t sizeB = sizeW + kc*cols;
    Scalar* blockA = (0)!=0 ? (0) : reinterpret_cast<Scalar*>( (sizeof(Scalar)*kc*mc<=0) ? __builtin_alloca (sizeof(Scalar)*kc*mc) : Eigen::internal::aligned_malloc(sizeof(Scalar)*kc*mc) ); Eigen::internal::aligned_stack_memory_handler<Scalar> blockA_stack_memory_destructor((0)==0 ? blockA : 0,kc*mc,sizeof(Scalar)*kc*mc>0);
    Scalar* allocatedBlockB = (0)!=0 ? (0) : reinterpret_cast<Scalar*>( (sizeof(Scalar)*sizeB<=0) ? __builtin_alloca (sizeof(Scalar)*sizeB) : Eigen::internal::aligned_malloc(sizeof(Scalar)*sizeB) ); Eigen::internal::aligned_stack_memory_handler<Scalar> allocatedBlockB_stack_memory_destructor((0)==0 ? allocatedBlockB : 0,sizeB,sizeof(Scalar)*sizeB>0);
    Scalar* blockB = allocatedBlockB + sizeW;

    conj_if<Conjugate> conj;
    gebp_kernel<Scalar, Scalar, Index, Traits::mr, Traits::nr, Conjugate, false> gebp_kernel;
    gemm_pack_lhs<Scalar, Index, Traits::mr, Traits::LhsProgress, TriStorageOrder> pack_lhs;
    gemm_pack_rhs<Scalar, Index, Traits::nr, ColMajor, false, true> pack_rhs;

    for(Index k2=IsLower ? 0 : size;
        IsLower ? k2<size : k2>0;
        IsLower ? k2+=kc : k2-=kc)
    {
      const Index actual_kc = (std::min)(IsLower ? size-k2 : k2, kc);
# 103 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/TriangularSolverMatrix.h"
      {

        for (Index k1=0; k1<actual_kc; k1+=SmallPanelWidth)
        {
          Index actualPanelWidth = std::min<Index>(actual_kc-k1, SmallPanelWidth);

          for (Index k=0; k<actualPanelWidth; ++k)
          {

            Index i = IsLower ? k2+k1+k : k2-k1-k-1;
            Index s = IsLower ? k2+k1 : i+1;
            Index rs = actualPanelWidth - k - 1;

            Scalar a = (Mode & UnitDiag) ? Scalar(1) : Scalar(1)/conj(tri(i,i));
            for (Index j=0; j<cols; ++j)
            {
              if (TriStorageOrder==RowMajor)
              {
                Scalar b = 0;
                const Scalar* l = &tri(i,s);
                Scalar* r = &other(s,j);
                for (Index i3=0; i3<k; ++i3)
                  b += conj(l[i3]) * r[i3];

                other(i,j) = (other(i,j) - b)*a;
              }
              else
              {
                Index s = IsLower ? i+1 : i-rs;
                Scalar b = (other(i,j) *= a);
                Scalar* r = &other(s,j);
                const Scalar* l = &tri(s,i);
                for (Index i3=0;i3<rs;++i3)
                  r[i3] -= b * conj(l[i3]);
              }
            }
          }

          Index lengthTarget = actual_kc-k1-actualPanelWidth;
          Index startBlock = IsLower ? k2+k1 : k2-k1-actualPanelWidth;
          Index blockBOffset = IsLower ? k1 : lengthTarget;


          pack_rhs(blockB, _other+startBlock, otherStride, actualPanelWidth, cols, actual_kc, blockBOffset);


          if (lengthTarget>0)
          {
            Index startTarget = IsLower ? k2+k1+actualPanelWidth : k2-actual_kc;

            pack_lhs(blockA, &tri(startTarget,startBlock), triStride, actualPanelWidth, lengthTarget);

            gebp_kernel(_other+startTarget, otherStride, blockA, blockB, lengthTarget, actualPanelWidth, cols, Scalar(-1),
                        actualPanelWidth, actual_kc, 0, blockBOffset);
          }
        }
      }


      {
        Index start = IsLower ? k2+kc : 0;
        Index end = IsLower ? size : k2-kc;
        for(Index i2=start; i2<end; i2+=mc)
        {
          const Index actual_mc = (std::min)(mc,end-i2);
          if (actual_mc>0)
          {
            pack_lhs(blockA, &tri(i2, IsLower ? k2 : k2-kc), triStride, actual_kc, actual_mc);

            gebp_kernel(_other+i2, otherStride, blockA, blockB, actual_mc, actual_kc, cols, Scalar(-1));
          }
        }
      }
    }
  }
};



template <typename Scalar, typename Index, int Mode, bool Conjugate, int TriStorageOrder>
struct triangular_solve_matrix<Scalar,Index,OnTheRight,Mode,Conjugate,TriStorageOrder,ColMajor>
{
  static __attribute__((noinline)) void run(
    Index size, Index otherSize,
    const Scalar* _tri, Index triStride,
    Scalar* _other, Index otherStride)
  {
    Index rows = otherSize;
    const_blas_data_mapper<Scalar, Index, TriStorageOrder> rhs(_tri,triStride);
    blas_data_mapper<Scalar, Index, ColMajor> lhs(_other,otherStride);

    typedef gebp_traits<Scalar,Scalar> Traits;
    enum {
      RhsStorageOrder = TriStorageOrder,
      SmallPanelWidth = (((int)Traits::mr >= (int)Traits::nr) ? (int)Traits::mr : (int)Traits::nr),
      IsLower = (Mode&Lower) == Lower
    };




    Index kc = size;
    Index mc = size;
    Index nc = rows;
    computeProductBlockingSizes<Scalar,Scalar,4>(kc, mc, nc);

    std::size_t sizeW = kc*Traits::WorkSpaceFactor;
    std::size_t sizeB = sizeW + kc*size;
    Scalar* blockA = (0)!=0 ? (0) : reinterpret_cast<Scalar*>( (sizeof(Scalar)*kc*mc<=0) ? __builtin_alloca (sizeof(Scalar)*kc*mc) : Eigen::internal::aligned_malloc(sizeof(Scalar)*kc*mc) ); Eigen::internal::aligned_stack_memory_handler<Scalar> blockA_stack_memory_destructor((0)==0 ? blockA : 0,kc*mc,sizeof(Scalar)*kc*mc>0);
    Scalar* allocatedBlockB = (0)!=0 ? (0) : reinterpret_cast<Scalar*>( (sizeof(Scalar)*sizeB<=0) ? __builtin_alloca (sizeof(Scalar)*sizeB) : Eigen::internal::aligned_malloc(sizeof(Scalar)*sizeB) ); Eigen::internal::aligned_stack_memory_handler<Scalar> allocatedBlockB_stack_memory_destructor((0)==0 ? allocatedBlockB : 0,sizeB,sizeof(Scalar)*sizeB>0);
    Scalar* blockB = allocatedBlockB + sizeW;

    conj_if<Conjugate> conj;
    gebp_kernel<Scalar,Scalar, Index, Traits::mr, Traits::nr, false, Conjugate> gebp_kernel;
    gemm_pack_rhs<Scalar, Index, Traits::nr,RhsStorageOrder> pack_rhs;
    gemm_pack_rhs<Scalar, Index, Traits::nr,RhsStorageOrder,false,true> pack_rhs_panel;
    gemm_pack_lhs<Scalar, Index, Traits::mr, Traits::LhsProgress, ColMajor, false, true> pack_lhs_panel;

    for(Index k2=IsLower ? size : 0;
        IsLower ? k2>0 : k2<size;
        IsLower ? k2-=kc : k2+=kc)
    {
      const Index actual_kc = (std::min)(IsLower ? k2 : size-k2, kc);
      Index actual_k2 = IsLower ? k2-actual_kc : k2 ;

      Index startPanel = IsLower ? 0 : k2+actual_kc;
      Index rs = IsLower ? actual_k2 : size - actual_k2 - actual_kc;
      Scalar* geb = blockB+actual_kc*actual_kc;

      if (rs>0) pack_rhs(geb, &rhs(actual_k2,startPanel), triStride, actual_kc, rs);



      {
        for (Index j2=0; j2<actual_kc; j2+=SmallPanelWidth)
        {
          Index actualPanelWidth = std::min<Index>(actual_kc-j2, SmallPanelWidth);
          Index actual_j2 = actual_k2 + j2;
          Index panelOffset = IsLower ? j2+actualPanelWidth : 0;
          Index panelLength = IsLower ? actual_kc-j2-actualPanelWidth : j2;

          if (panelLength>0)
          pack_rhs_panel(blockB+j2*actual_kc,
                         &rhs(actual_k2+panelOffset, actual_j2), triStride,
                         panelLength, actualPanelWidth,
                         actual_kc, panelOffset);
        }
      }

      for(Index i2=0; i2<rows; i2+=mc)
      {
        const Index actual_mc = (std::min)(mc,rows-i2);


        {

          for (Index j2 = IsLower
                      ? (actual_kc - ((actual_kc%SmallPanelWidth) ? Index(actual_kc%SmallPanelWidth)
                                                                  : Index(SmallPanelWidth)))
                      : 0;
               IsLower ? j2>=0 : j2<actual_kc;
               IsLower ? j2-=SmallPanelWidth : j2+=SmallPanelWidth)
          {
            Index actualPanelWidth = std::min<Index>(actual_kc-j2, SmallPanelWidth);
            Index absolute_j2 = actual_k2 + j2;
            Index panelOffset = IsLower ? j2+actualPanelWidth : 0;
            Index panelLength = IsLower ? actual_kc - j2 - actualPanelWidth : j2;


            if(panelLength>0)
            {
              gebp_kernel(&lhs(i2,absolute_j2), otherStride,
                          blockA, blockB+j2*actual_kc,
                          actual_mc, panelLength, actualPanelWidth,
                          Scalar(-1),
                          actual_kc, actual_kc,
                          panelOffset, panelOffset,
                          allocatedBlockB);
            }


            for (Index k=0; k<actualPanelWidth; ++k)
            {
              Index j = IsLower ? absolute_j2+actualPanelWidth-k-1 : absolute_j2+k;

              Scalar* r = &lhs(i2,j);
              for (Index k3=0; k3<k; ++k3)
              {
                Scalar b = conj(rhs(IsLower ? j+1+k3 : absolute_j2+k3,j));
                Scalar* a = &lhs(i2,IsLower ? j+1+k3 : absolute_j2+k3);
                for (Index i=0; i<actual_mc; ++i)
                  r[i] -= a[i] * b;
              }
              Scalar b = (Mode & UnitDiag) ? Scalar(1) : Scalar(1)/conj(rhs(j,j));
              for (Index i=0; i<actual_mc; ++i)
                r[i] *= b;
            }


            pack_lhs_panel(blockA, _other+absolute_j2*otherStride+i2, otherStride,
                           actualPanelWidth, actual_mc,
                           actual_kc, j2);
          }
        }

        if (rs>0)
          gebp_kernel(_other+i2+startPanel*otherStride, otherStride, blockA, geb,
                      actual_mc, actual_kc, rs, Scalar(-1),
                      -1, -1, 0, 0, allocatedBlockB);
      }
    }
  }
};

}
# 338 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/TriangularSolverVector.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/products/TriangularSolverVector.h"
namespace internal {

template<typename LhsScalar, typename RhsScalar, typename Index, int Mode, bool Conjugate, int StorageOrder>
struct triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheRight, Mode, Conjugate, StorageOrder>
{
  static void run(Index size, const LhsScalar* _lhs, Index lhsStride, RhsScalar* rhs)
  {
    triangular_solve_vector<LhsScalar,RhsScalar,Index,OnTheLeft,
        ((Mode&Upper)==Upper ? Lower : Upper) | (Mode&UnitDiag),
        Conjugate,StorageOrder==RowMajor?ColMajor:RowMajor
      >::run(size, _lhs, lhsStride, rhs);
  }
};


template<typename LhsScalar, typename RhsScalar, typename Index, int Mode, bool Conjugate>
struct triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheLeft, Mode, Conjugate, RowMajor>
{
  enum {
    IsLower = ((Mode&Lower)==Lower)
  };
  static void run(Index size, const LhsScalar* _lhs, Index lhsStride, RhsScalar* rhs)
  {
    typedef Map<const Matrix<LhsScalar,Dynamic,Dynamic,RowMajor>, 0, OuterStride<> > LhsMap;
    const LhsMap lhs(_lhs,size,size,OuterStride<>(lhsStride));
    typename internal::conditional<
                          Conjugate,
                          const CwiseUnaryOp<typename internal::scalar_conjugate_op<LhsScalar>,LhsMap>,
                          const LhsMap&>
                        ::type cjLhs(lhs);
    static const Index PanelWidth = 8;
    for(Index pi=IsLower ? 0 : size;
        IsLower ? pi<size : pi>0;
        IsLower ? pi+=PanelWidth : pi-=PanelWidth)
    {
      Index actualPanelWidth = (std::min)(IsLower ? size - pi : pi, PanelWidth);

      Index r = IsLower ? pi : size - pi;
      if (r > 0)
      {



        Index startRow = IsLower ? pi : pi-actualPanelWidth;
        Index startCol = IsLower ? 0 : pi;

        general_matrix_vector_product<Index,LhsScalar,RowMajor,Conjugate,RhsScalar,false>::run(
          actualPanelWidth, r,
          &lhs.coeffRef(startRow,startCol), lhsStride,
          rhs + startCol, 1,
          rhs + startRow, 1,
          RhsScalar(-1));
      }

      for(Index k=0; k<actualPanelWidth; ++k)
      {
        Index i = IsLower ? pi+k : pi-k-1;
        Index s = IsLower ? pi : i+1;
        if (k>0)
          rhs[i] -= (cjLhs.row(i).segment(s,k).transpose().cwiseProduct(Map<const Matrix<RhsScalar,Dynamic,1> >(rhs+s,k))).sum();

        if(!(Mode & UnitDiag))
          rhs[i] /= cjLhs(i,i);
      }
    }
  }
};


template<typename LhsScalar, typename RhsScalar, typename Index, int Mode, bool Conjugate>
struct triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheLeft, Mode, Conjugate, ColMajor>
{
  enum {
    IsLower = ((Mode&Lower)==Lower)
  };
  static void run(Index size, const LhsScalar* _lhs, Index lhsStride, RhsScalar* rhs)
  {
    typedef Map<const Matrix<LhsScalar,Dynamic,Dynamic,ColMajor>, 0, OuterStride<> > LhsMap;
    const LhsMap lhs(_lhs,size,size,OuterStride<>(lhsStride));
    typename internal::conditional<Conjugate,
                                   const CwiseUnaryOp<typename internal::scalar_conjugate_op<LhsScalar>,LhsMap>,
                                   const LhsMap&
                                  >::type cjLhs(lhs);
    static const Index PanelWidth = 8;

    for(Index pi=IsLower ? 0 : size;
        IsLower ? pi<size : pi>0;
        IsLower ? pi+=PanelWidth : pi-=PanelWidth)
    {
      Index actualPanelWidth = (std::min)(IsLower ? size - pi : pi, PanelWidth);
      Index startBlock = IsLower ? pi : pi-actualPanelWidth;
      Index endBlock = IsLower ? pi + actualPanelWidth : 0;

      for(Index k=0; k<actualPanelWidth; ++k)
      {
        Index i = IsLower ? pi+k : pi-k-1;
        if(!(Mode & UnitDiag))
          rhs[i] /= cjLhs.coeff(i,i);

        Index r = actualPanelWidth - k - 1;
        Index s = IsLower ? i+1 : i-r;
        if (r>0)
          Map<Matrix<RhsScalar,Dynamic,1> >(rhs+s,r) -= rhs[i] * cjLhs.col(i).segment(s,r);
      }
      Index r = IsLower ? size - endBlock : startBlock;
      if (r > 0)
      {



        general_matrix_vector_product<Index,LhsScalar,ColMajor,Conjugate,RhsScalar,false>::run(
            r, actualPanelWidth,
            &lhs.coeffRef(endBlock,startBlock), lhsStride,
            rhs+startBlock, 1,
            rhs+endBlock, 1, RhsScalar(-1));
      }
    }
  }
};

}
# 339 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/BandMatrix.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/BandMatrix.h"
namespace internal {


template<typename Derived>
class BandMatrixBase : public EigenBase<Derived>
{
  public:

    enum {
      Flags = internal::traits<Derived>::Flags,
      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,
      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,
      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,
      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,
      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime,
      Supers = internal::traits<Derived>::Supers,
      Subs = internal::traits<Derived>::Subs,
      Options = internal::traits<Derived>::Options
    };
    typedef typename internal::traits<Derived>::Scalar Scalar;
    typedef Matrix<Scalar,RowsAtCompileTime,ColsAtCompileTime> DenseMatrixType;
    typedef typename DenseMatrixType::Index Index;
    typedef typename internal::traits<Derived>::CoefficientsType CoefficientsType;
    typedef EigenBase<Derived> Base;

  protected:
    enum {
      DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic))
                            ? 1 + Supers + Subs
                            : Dynamic,
      SizeAtCompileTime = (((int)RowsAtCompileTime == 0 || (int)ColsAtCompileTime == 0) ? 0 : ((int)RowsAtCompileTime == 1 || (int)ColsAtCompileTime == 1) ? 1 : ((int)RowsAtCompileTime == Dynamic || (int)ColsAtCompileTime == Dynamic) ? Dynamic : ((int)RowsAtCompileTime <= (int)ColsAtCompileTime) ? (int)RowsAtCompileTime : (int)ColsAtCompileTime)
    };

  public:

    using Base::derived;
    using Base::rows;
    using Base::cols;


    inline Index supers() const { return derived().supers(); }


    inline Index subs() const { return derived().subs(); }


    inline const CoefficientsType& coeffs() const { return derived().coeffs(); }


    inline CoefficientsType& coeffs() { return derived().coeffs(); }




    inline Block<CoefficientsType,Dynamic,1> col(Index i)
    {
      if (Eigen::internal::static_assertion<bool((Options&RowMajor)==0)>::THIS_METHOD_IS_ONLY_FOR_COLUMN_MAJOR_MATRICES) {};
      Index start = 0;
      Index len = coeffs().rows();
      if (i<=supers())
      {
        start = supers()-i;
        len = (std::min)(rows(),std::max<Index>(0,coeffs().rows() - (supers()-i)));
      }
      else if (i>=rows()-subs())
        len = std::max<Index>(0,coeffs().rows() - (i + 1 - rows() + subs()));
      return Block<CoefficientsType,Dynamic,1>(coeffs(), start, i, len, 1);
    }


    inline Block<CoefficientsType,1,SizeAtCompileTime> diagonal()
    { return Block<CoefficientsType,1,SizeAtCompileTime>(coeffs(),supers(),0,1,(std::min)(rows(),cols())); }


    inline const Block<const CoefficientsType,1,SizeAtCompileTime> diagonal() const
    { return Block<const CoefficientsType,1,SizeAtCompileTime>(coeffs(),supers(),0,1,(std::min)(rows(),cols())); }

    template<int Index> struct DiagonalIntReturnType {
      enum {
        ReturnOpposite = (Options&SelfAdjoint) && (((Index)>0 && Supers==0) || ((Index)<0 && Subs==0)),
        Conjugate = ReturnOpposite && NumTraits<Scalar>::IsComplex,
        ActualIndex = ReturnOpposite ? -Index : Index,
        DiagonalSize = (RowsAtCompileTime==Dynamic || ColsAtCompileTime==Dynamic)
                     ? Dynamic
                     : (ActualIndex<0
                     ? (((int)ColsAtCompileTime == 0 || (int)RowsAtCompileTime + ActualIndex == 0) ? 0 : ((int)ColsAtCompileTime == 1 || (int)RowsAtCompileTime + ActualIndex == 1) ? 1 : ((int)ColsAtCompileTime == Dynamic || (int)RowsAtCompileTime + ActualIndex == Dynamic) ? Dynamic : ((int)ColsAtCompileTime <= (int)RowsAtCompileTime + ActualIndex) ? (int)ColsAtCompileTime : (int)RowsAtCompileTime + ActualIndex)
                     : (((int)RowsAtCompileTime == 0 || (int)ColsAtCompileTime - ActualIndex == 0) ? 0 : ((int)RowsAtCompileTime == 1 || (int)ColsAtCompileTime - ActualIndex == 1) ? 1 : ((int)RowsAtCompileTime == Dynamic || (int)ColsAtCompileTime - ActualIndex == Dynamic) ? Dynamic : ((int)RowsAtCompileTime <= (int)ColsAtCompileTime - ActualIndex) ? (int)RowsAtCompileTime : (int)ColsAtCompileTime - ActualIndex))
      };
      typedef Block<CoefficientsType,1, DiagonalSize> BuildType;
      typedef typename internal::conditional<Conjugate,
                 CwiseUnaryOp<internal::scalar_conjugate_op<Scalar>,BuildType >,
                 BuildType>::type Type;
    };


    template<int N> inline typename DiagonalIntReturnType<N>::Type diagonal()
    {
      return typename DiagonalIntReturnType<N>::BuildType(coeffs(), supers()-N, (std::max)(0,N), 1, diagonalLength(N));
    }


    template<int N> inline const typename DiagonalIntReturnType<N>::Type diagonal() const
    {
      return typename DiagonalIntReturnType<N>::BuildType(coeffs(), supers()-N, (std::max)(0,N), 1, diagonalLength(N));
    }


    inline Block<CoefficientsType,1,Dynamic> diagonal(Index i)
    {
      if( (!Eigen::internal::copy_bool((i<0 && -i<=subs()) || (i>=0 && i<=supers()))) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool((i<0 && -i<=subs()) || (i>=0 && i<=supers()))) Eigen::internal::assert_fail("(i<0 && -i<=subs()) || (i>=0 && i<=supers())", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/BandMatrix.h", 137); } while(false); else throw Eigen::eigen_assert_exception(); };
      return Block<CoefficientsType,1,Dynamic>(coeffs(), supers()-i, std::max<Index>(0,i), 1, diagonalLength(i));
    }


    inline const Block<const CoefficientsType,1,Dynamic> diagonal(Index i) const
    {
      if( (!Eigen::internal::copy_bool((i<0 && -i<=subs()) || (i>=0 && i<=supers()))) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool((i<0 && -i<=subs()) || (i>=0 && i<=supers()))) Eigen::internal::assert_fail("(i<0 && -i<=subs()) || (i>=0 && i<=supers())", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/BandMatrix.h", 144); } while(false); else throw Eigen::eigen_assert_exception(); };
      return Block<const CoefficientsType,1,Dynamic>(coeffs(), supers()-i, std::max<Index>(0,i), 1, diagonalLength(i));
    }

    template<typename Dest> inline void evalTo(Dest& dst) const
    {
      dst.resize(rows(),cols());
      dst.setZero();
      dst.diagonal() = diagonal();
      for (Index i=1; i<=supers();++i)
        dst.diagonal(i) = diagonal(i);
      for (Index i=1; i<=subs();++i)
        dst.diagonal(-i) = diagonal(-i);
    }

    DenseMatrixType toDenseMatrix() const
    {
      DenseMatrixType res(rows(),cols());
      evalTo(res);
      return res;
    }

  protected:

    inline Index diagonalLength(Index i) const
    { return i<0 ? (std::min)(cols(),rows()+i) : (std::min)(rows(),cols()-i); }
};
# 191 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/BandMatrix.h"
template<typename _Scalar, int _Rows, int _Cols, int _Supers, int _Subs, int _Options>
struct traits<BandMatrix<_Scalar,_Rows,_Cols,_Supers,_Subs,_Options> >
{
  typedef _Scalar Scalar;
  typedef Dense StorageKind;
  typedef DenseIndex Index;
  enum {
    CoeffReadCost = NumTraits<Scalar>::ReadCost,
    RowsAtCompileTime = _Rows,
    ColsAtCompileTime = _Cols,
    MaxRowsAtCompileTime = _Rows,
    MaxColsAtCompileTime = _Cols,
    Flags = LvalueBit,
    Supers = _Supers,
    Subs = _Subs,
    Options = _Options,
    DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic)) ? 1 + Supers + Subs : Dynamic
  };
  typedef Matrix<Scalar,DataRowsAtCompileTime,ColsAtCompileTime,Options&RowMajor?RowMajor:ColMajor> CoefficientsType;
};

template<typename _Scalar, int Rows, int Cols, int Supers, int Subs, int Options>
class BandMatrix : public BandMatrixBase<BandMatrix<_Scalar,Rows,Cols,Supers,Subs,Options> >
{
  public:

    typedef typename internal::traits<BandMatrix>::Scalar Scalar;
    typedef typename internal::traits<BandMatrix>::Index Index;
    typedef typename internal::traits<BandMatrix>::CoefficientsType CoefficientsType;

    inline BandMatrix(Index rows=Rows, Index cols=Cols, Index supers=Supers, Index subs=Subs)
      : m_coeffs(1+supers+subs,cols),
        m_rows(rows), m_supers(supers), m_subs(subs)
    {
    }


    inline Index rows() const { return m_rows.value(); }


    inline Index cols() const { return m_coeffs.cols(); }


    inline Index supers() const { return m_supers.value(); }


    inline Index subs() const { return m_subs.value(); }

    inline const CoefficientsType& coeffs() const { return m_coeffs; }
    inline CoefficientsType& coeffs() { return m_coeffs; }

  protected:

    CoefficientsType m_coeffs;
    internal::variable_if_dynamic<Index, Rows> m_rows;
    internal::variable_if_dynamic<Index, Supers> m_supers;
    internal::variable_if_dynamic<Index, Subs> m_subs;
};

template<typename _CoefficientsType,int _Rows, int _Cols, int _Supers, int _Subs,int _Options>
class BandMatrixWrapper;

template<typename _CoefficientsType,int _Rows, int _Cols, int _Supers, int _Subs,int _Options>
struct traits<BandMatrixWrapper<_CoefficientsType,_Rows,_Cols,_Supers,_Subs,_Options> >
{
  typedef typename _CoefficientsType::Scalar Scalar;
  typedef typename _CoefficientsType::StorageKind StorageKind;
  typedef typename _CoefficientsType::Index Index;
  enum {
    CoeffReadCost = internal::traits<_CoefficientsType>::CoeffReadCost,
    RowsAtCompileTime = _Rows,
    ColsAtCompileTime = _Cols,
    MaxRowsAtCompileTime = _Rows,
    MaxColsAtCompileTime = _Cols,
    Flags = LvalueBit,
    Supers = _Supers,
    Subs = _Subs,
    Options = _Options,
    DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic)) ? 1 + Supers + Subs : Dynamic
  };
  typedef _CoefficientsType CoefficientsType;
};

template<typename _CoefficientsType,int _Rows, int _Cols, int _Supers, int _Subs,int _Options>
class BandMatrixWrapper : public BandMatrixBase<BandMatrixWrapper<_CoefficientsType,_Rows,_Cols,_Supers,_Subs,_Options> >
{
  public:

    typedef typename internal::traits<BandMatrixWrapper>::Scalar Scalar;
    typedef typename internal::traits<BandMatrixWrapper>::CoefficientsType CoefficientsType;
    typedef typename internal::traits<BandMatrixWrapper>::Index Index;

    inline BandMatrixWrapper(const CoefficientsType& coeffs, Index rows=_Rows, Index cols=_Cols, Index supers=_Supers, Index subs=_Subs)
      : m_coeffs(coeffs),
        m_rows(rows), m_supers(supers), m_subs(subs)
    {
      (void)cols;;

    }


    inline Index rows() const { return m_rows.value(); }


    inline Index cols() const { return m_coeffs.cols(); }


    inline Index supers() const { return m_supers.value(); }


    inline Index subs() const { return m_subs.value(); }

    inline const CoefficientsType& coeffs() const { return m_coeffs; }

  protected:

    const CoefficientsType& m_coeffs;
    internal::variable_if_dynamic<Index, _Rows> m_rows;
    internal::variable_if_dynamic<Index, _Supers> m_supers;
    internal::variable_if_dynamic<Index, _Subs> m_subs;
};
# 325 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/BandMatrix.h"
template<typename Scalar, int Size, int Options>
class TridiagonalMatrix : public BandMatrix<Scalar,Size,Size,Options&SelfAdjoint?0:1,1,Options|RowMajor>
{
    typedef BandMatrix<Scalar,Size,Size,Options&SelfAdjoint?0:1,1,Options|RowMajor> Base;
    typedef typename Base::Index Index;
  public:
    TridiagonalMatrix(Index size = Size) : Base(size,size,Options&SelfAdjoint?0:1,1) {}

    inline typename Base::template DiagonalIntReturnType<1>::Type super()
    { return Base::template diagonal<1>(); }
    inline const typename Base::template DiagonalIntReturnType<1>::Type super() const
    { return Base::template diagonal<1>(); }
    inline typename Base::template DiagonalIntReturnType<-1>::Type sub()
    { return Base::template diagonal<-1>(); }
    inline const typename Base::template DiagonalIntReturnType<-1>::Type sub() const
    { return Base::template diagonal<-1>(); }
  protected:
};

}
# 340 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2

# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/BooleanRedux.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/BooleanRedux.h"
namespace internal {

template<typename Derived, int UnrollCount>
struct all_unroller
{
  enum {
    col = (UnrollCount-1) / Derived::RowsAtCompileTime,
    row = (UnrollCount-1) % Derived::RowsAtCompileTime
  };

  inline static bool run(const Derived &mat)
  {
    return all_unroller<Derived, UnrollCount-1>::run(mat) && mat.coeff(row, col);
  }
};

template<typename Derived>
struct all_unroller<Derived, 1>
{
  inline static bool run(const Derived &mat) { return mat.coeff(0, 0); }
};

template<typename Derived>
struct all_unroller<Derived, Dynamic>
{
  inline static bool run(const Derived &) { return false; }
};

template<typename Derived, int UnrollCount>
struct any_unroller
{
  enum {
    col = (UnrollCount-1) / Derived::RowsAtCompileTime,
    row = (UnrollCount-1) % Derived::RowsAtCompileTime
  };

  inline static bool run(const Derived &mat)
  {
    return any_unroller<Derived, UnrollCount-1>::run(mat) || mat.coeff(row, col);
  }
};

template<typename Derived>
struct any_unroller<Derived, 1>
{
  inline static bool run(const Derived &mat) { return mat.coeff(0, 0); }
};

template<typename Derived>
struct any_unroller<Derived, Dynamic>
{
  inline static bool run(const Derived &) { return false; }
};

}
# 91 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/BooleanRedux.h"
template<typename Derived>
inline bool DenseBase<Derived>::all() const
{
  enum {
    unroll = SizeAtCompileTime != Dynamic
          && CoeffReadCost != Dynamic
          && NumTraits<Scalar>::AddCost != Dynamic
          && SizeAtCompileTime * (CoeffReadCost + NumTraits<Scalar>::AddCost) <= 100
  };
  if(unroll)
    return internal::all_unroller<Derived,
                           unroll ? int(SizeAtCompileTime) : Dynamic
     >::run(derived());
  else
  {
    for(Index j = 0; j < cols(); ++j)
      for(Index i = 0; i < rows(); ++i)
        if (!coeff(i, j)) return false;
    return true;
  }
}





template<typename Derived>
inline bool DenseBase<Derived>::any() const
{
  enum {
    unroll = SizeAtCompileTime != Dynamic
          && CoeffReadCost != Dynamic
          && NumTraits<Scalar>::AddCost != Dynamic
          && SizeAtCompileTime * (CoeffReadCost + NumTraits<Scalar>::AddCost) <= 100
  };
  if(unroll)
    return internal::any_unroller<Derived,
                           unroll ? int(SizeAtCompileTime) : Dynamic
           >::run(derived());
  else
  {
    for(Index j = 0; j < cols(); ++j)
      for(Index i = 0; i < rows(); ++i)
        if (coeff(i, j)) return true;
    return false;
  }
}





template<typename Derived>
inline typename DenseBase<Derived>::Index DenseBase<Derived>::count() const
{
  return derived().template cast<bool>().template cast<Index>().sum();
}
# 342 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Select.h" 1
# 43 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Select.h"
namespace internal {
template<typename ConditionMatrixType, typename ThenMatrixType, typename ElseMatrixType>
struct traits<Select<ConditionMatrixType, ThenMatrixType, ElseMatrixType> >
 : traits<ThenMatrixType>
{
  typedef typename traits<ThenMatrixType>::Scalar Scalar;
  typedef Dense StorageKind;
  typedef typename traits<ThenMatrixType>::XprKind XprKind;
  typedef typename ConditionMatrixType::Nested ConditionMatrixNested;
  typedef typename ThenMatrixType::Nested ThenMatrixNested;
  typedef typename ElseMatrixType::Nested ElseMatrixNested;
  enum {
    RowsAtCompileTime = ConditionMatrixType::RowsAtCompileTime,
    ColsAtCompileTime = ConditionMatrixType::ColsAtCompileTime,
    MaxRowsAtCompileTime = ConditionMatrixType::MaxRowsAtCompileTime,
    MaxColsAtCompileTime = ConditionMatrixType::MaxColsAtCompileTime,
    Flags = (unsigned int)ThenMatrixType::Flags & ElseMatrixType::Flags & HereditaryBits,
    CoeffReadCost = traits<typename remove_all<ConditionMatrixNested>::type>::CoeffReadCost
                  + (((int)traits<typename remove_all<ThenMatrixNested>::type>::CoeffReadCost == Dynamic || (int)traits<typename remove_all<ElseMatrixNested>::type>::CoeffReadCost == Dynamic) ? Dynamic : ((int)traits<typename remove_all<ThenMatrixNested>::type>::CoeffReadCost >= (int)traits<typename remove_all<ElseMatrixNested>::type>::CoeffReadCost) ? (int)traits<typename remove_all<ThenMatrixNested>::type>::CoeffReadCost : (int)traits<typename remove_all<ElseMatrixNested>::type>::CoeffReadCost)

  };
};
}

template<typename ConditionMatrixType, typename ThenMatrixType, typename ElseMatrixType>
class Select : internal::no_assignment_operator,
  public internal::dense_xpr_base< Select<ConditionMatrixType, ThenMatrixType, ElseMatrixType> >::type
{
  public:

    typedef typename internal::dense_xpr_base<Select>::type Base;
    typedef typename Eigen::internal::traits<Select>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<Select>::type Nested; typedef typename Eigen::internal::traits<Select>::StorageKind StorageKind; typedef typename Eigen::internal::traits<Select>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<Select>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<Select>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<Select>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<Select>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<Select>::Flags, CoeffReadCost = Eigen::internal::traits<Select>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived;

    Select(const ConditionMatrixType& conditionMatrix,
           const ThenMatrixType& thenMatrix,
           const ElseMatrixType& elseMatrix)
      : m_condition(conditionMatrix), m_then(thenMatrix), m_else(elseMatrix)
    {
      if( (!Eigen::internal::copy_bool(m_condition.rows() == m_then.rows() && m_condition.rows() == m_else.rows())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_condition.rows() == m_then.rows() && m_condition.rows() == m_else.rows())) Eigen::internal::assert_fail("m_condition.rows() == m_then.rows() && m_condition.rows() == m_else.rows()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Select.h", 81); } while(false); else throw Eigen::eigen_assert_exception(); };
      if( (!Eigen::internal::copy_bool(m_condition.cols() == m_then.cols() && m_condition.cols() == m_else.cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_condition.cols() == m_then.cols() && m_condition.cols() == m_else.cols())) Eigen::internal::assert_fail("m_condition.cols() == m_then.cols() && m_condition.cols() == m_else.cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Select.h", 82); } while(false); else throw Eigen::eigen_assert_exception(); };
    }

    Index rows() const { return m_condition.rows(); }
    Index cols() const { return m_condition.cols(); }

    const Scalar coeff(Index i, Index j) const
    {
      if (m_condition.coeff(i,j))
        return m_then.coeff(i,j);
      else
        return m_else.coeff(i,j);
    }

    const Scalar coeff(Index i) const
    {
      if (m_condition.coeff(i))
        return m_then.coeff(i);
      else
        return m_else.coeff(i);
    }

  protected:
    const typename ConditionMatrixType::Nested m_condition;
    const typename ThenMatrixType::Nested m_then;
    const typename ElseMatrixType::Nested m_else;
};
# 119 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Select.h"
template<typename Derived>
template<typename ThenDerived,typename ElseDerived>
inline const Select<Derived,ThenDerived,ElseDerived>
DenseBase<Derived>::select(const DenseBase<ThenDerived>& thenMatrix,
                            const DenseBase<ElseDerived>& elseMatrix) const
{
  return Select<Derived,ThenDerived,ElseDerived>(derived(), thenMatrix.derived(), elseMatrix.derived());
}






template<typename Derived>
template<typename ThenDerived>
inline const Select<Derived,ThenDerived, typename ThenDerived::ConstantReturnType>
DenseBase<Derived>::select(const DenseBase<ThenDerived>& thenMatrix,
                            typename ThenDerived::Scalar elseScalar) const
{
  return Select<Derived,ThenDerived,typename ThenDerived::ConstantReturnType>(
    derived(), thenMatrix.derived(), ThenDerived::Constant(rows(),cols(),elseScalar));
}






template<typename Derived>
template<typename ElseDerived>
inline const Select<Derived, typename ElseDerived::ConstantReturnType, ElseDerived >
DenseBase<Derived>::select(typename ElseDerived::Scalar thenScalar,
                            const DenseBase<ElseDerived>& elseMatrix) const
{
  return Select<Derived,typename ElseDerived::ConstantReturnType,ElseDerived>(
    derived(), ElseDerived::Constant(rows(),cols(),thenScalar), elseMatrix.derived());
}
# 343 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/VectorwiseOp.h" 1
# 45 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/VectorwiseOp.h"
template< typename MatrixType, typename MemberOp, int Direction>
class PartialReduxExpr;

namespace internal {
template<typename MatrixType, typename MemberOp, int Direction>
struct traits<PartialReduxExpr<MatrixType, MemberOp, Direction> >
 : traits<MatrixType>
{
  typedef typename MemberOp::result_type Scalar;
  typedef typename traits<MatrixType>::StorageKind StorageKind;
  typedef typename traits<MatrixType>::XprKind XprKind;
  typedef typename MatrixType::Scalar InputScalar;
  typedef typename nested<MatrixType>::type MatrixTypeNested;
  typedef typename remove_all<MatrixTypeNested>::type _MatrixTypeNested;
  enum {
    RowsAtCompileTime = Direction==Vertical ? 1 : MatrixType::RowsAtCompileTime,
    ColsAtCompileTime = Direction==Horizontal ? 1 : MatrixType::ColsAtCompileTime,
    MaxRowsAtCompileTime = Direction==Vertical ? 1 : MatrixType::MaxRowsAtCompileTime,
    MaxColsAtCompileTime = Direction==Horizontal ? 1 : MatrixType::MaxColsAtCompileTime,
    Flags0 = (unsigned int)_MatrixTypeNested::Flags & HereditaryBits,
    Flags = (Flags0 & ~RowMajorBit) | (RowsAtCompileTime == 1 ? RowMajorBit : 0),
    TraversalSize = Direction==Vertical ? RowsAtCompileTime : ColsAtCompileTime
  };

  typedef typename MemberOp::template Cost<InputScalar,int(TraversalSize)> CostOpType;



  enum {
    CoeffReadCost = TraversalSize * traits<_MatrixTypeNested>::CoeffReadCost + int(CostOpType::value)
  };
};
}

template< typename MatrixType, typename MemberOp, int Direction>
class PartialReduxExpr : internal::no_assignment_operator,
  public internal::dense_xpr_base< PartialReduxExpr<MatrixType, MemberOp, Direction> >::type
{
  public:

    typedef typename internal::dense_xpr_base<PartialReduxExpr>::type Base;
    typedef typename Eigen::internal::traits<PartialReduxExpr>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<PartialReduxExpr>::type Nested; typedef typename Eigen::internal::traits<PartialReduxExpr>::StorageKind StorageKind; typedef typename Eigen::internal::traits<PartialReduxExpr>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<PartialReduxExpr>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<PartialReduxExpr>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<PartialReduxExpr>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<PartialReduxExpr>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<PartialReduxExpr>::Flags, CoeffReadCost = Eigen::internal::traits<PartialReduxExpr>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived;
    typedef typename internal::traits<PartialReduxExpr>::MatrixTypeNested MatrixTypeNested;
    typedef typename internal::traits<PartialReduxExpr>::_MatrixTypeNested _MatrixTypeNested;

    PartialReduxExpr(const MatrixType& mat, const MemberOp& func = MemberOp())
      : m_matrix(mat), m_functor(func) {}

    Index rows() const { return (Direction==Vertical ? 1 : m_matrix.rows()); }
    Index cols() const { return (Direction==Horizontal ? 1 : m_matrix.cols()); }

    inline const Scalar coeff(Index i, Index j) const
    {
      if (Direction==Vertical)
        return m_functor(m_matrix.col(j));
      else
        return m_functor(m_matrix.row(i));
    }

    const Scalar coeff(Index index) const
    {
      if (Direction==Vertical)
        return m_functor(m_matrix.col(index));
      else
        return m_functor(m_matrix.row(index));
    }

  protected:
    const MatrixTypeNested m_matrix;
    const MemberOp m_functor;
};
# 129 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/VectorwiseOp.h"
namespace internal {

template <typename ResultType> struct member_squaredNorm { inline member_squaredNorm() {} inline member_squaredNorm(const member_squaredNorm& ) {} typedef ResultType result_type; template<typename Scalar, int Size> struct Cost { enum { value = Size * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost }; }; template<typename XprType> inline ResultType operator()(const XprType& mat) const { return mat.squaredNorm(); } };
template <typename ResultType> struct member_norm { inline member_norm() {} inline member_norm(const member_norm& ) {} typedef ResultType result_type; template<typename Scalar, int Size> struct Cost { enum { value = (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost }; }; template<typename XprType> inline ResultType operator()(const XprType& mat) const { return mat.norm(); } };
template <typename ResultType> struct member_stableNorm { inline member_stableNorm() {} inline member_stableNorm(const member_stableNorm& ) {} typedef ResultType result_type; template<typename Scalar, int Size> struct Cost { enum { value = (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost }; }; template<typename XprType> inline ResultType operator()(const XprType& mat) const { return mat.stableNorm(); } };
template <typename ResultType> struct member_blueNorm { inline member_blueNorm() {} inline member_blueNorm(const member_blueNorm& ) {} typedef ResultType result_type; template<typename Scalar, int Size> struct Cost { enum { value = (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost }; }; template<typename XprType> inline ResultType operator()(const XprType& mat) const { return mat.blueNorm(); } };
template <typename ResultType> struct member_hypotNorm { inline member_hypotNorm() {} inline member_hypotNorm(const member_hypotNorm& ) {} typedef ResultType result_type; template<typename Scalar, int Size> struct Cost { enum { value = (Size-1) * functor_traits<scalar_hypot_op<Scalar> >::Cost }; }; template<typename XprType> inline ResultType operator()(const XprType& mat) const { return mat.hypotNorm(); } };
template <typename ResultType> struct member_sum { inline member_sum() {} inline member_sum(const member_sum& ) {} typedef ResultType result_type; template<typename Scalar, int Size> struct Cost { enum { value = (Size-1)*NumTraits<Scalar>::AddCost }; }; template<typename XprType> inline ResultType operator()(const XprType& mat) const { return mat.sum(); } };
template <typename ResultType> struct member_mean { inline member_mean() {} inline member_mean(const member_mean& ) {} typedef ResultType result_type; template<typename Scalar, int Size> struct Cost { enum { value = (Size-1)*NumTraits<Scalar>::AddCost + NumTraits<Scalar>::MulCost }; }; template<typename XprType> inline ResultType operator()(const XprType& mat) const { return mat.mean(); } };
template <typename ResultType> struct member_minCoeff { inline member_minCoeff() {} inline member_minCoeff(const member_minCoeff& ) {} typedef ResultType result_type; template<typename Scalar, int Size> struct Cost { enum { value = (Size-1)*NumTraits<Scalar>::AddCost }; }; template<typename XprType> inline ResultType operator()(const XprType& mat) const { return mat.minCoeff(); } };
template <typename ResultType> struct member_maxCoeff { inline member_maxCoeff() {} inline member_maxCoeff(const member_maxCoeff& ) {} typedef ResultType result_type; template<typename Scalar, int Size> struct Cost { enum { value = (Size-1)*NumTraits<Scalar>::AddCost }; }; template<typename XprType> inline ResultType operator()(const XprType& mat) const { return mat.maxCoeff(); } };
template <typename ResultType> struct member_all { inline member_all() {} inline member_all(const member_all& ) {} typedef ResultType result_type; template<typename Scalar, int Size> struct Cost { enum { value = (Size-1)*NumTraits<Scalar>::AddCost }; }; template<typename XprType> inline ResultType operator()(const XprType& mat) const { return mat.all(); } };
template <typename ResultType> struct member_any { inline member_any() {} inline member_any(const member_any& ) {} typedef ResultType result_type; template<typename Scalar, int Size> struct Cost { enum { value = (Size-1)*NumTraits<Scalar>::AddCost }; }; template<typename XprType> inline ResultType operator()(const XprType& mat) const { return mat.any(); } };
template <typename ResultType> struct member_count { inline member_count() {} inline member_count(const member_count& ) {} typedef ResultType result_type; template<typename Scalar, int Size> struct Cost { enum { value = (Size-1)*NumTraits<Scalar>::AddCost }; }; template<typename XprType> inline ResultType operator()(const XprType& mat) const { return mat.count(); } };
template <typename ResultType> struct member_prod { inline member_prod() {} inline member_prod(const member_prod& ) {} typedef ResultType result_type; template<typename Scalar, int Size> struct Cost { enum { value = (Size-1)*NumTraits<Scalar>::MulCost }; }; template<typename XprType> inline ResultType operator()(const XprType& mat) const { return mat.prod(); } };


template <typename BinaryOp, typename Scalar>
struct member_redux {
  typedef typename result_of<
                     BinaryOp(Scalar)
                   >::type result_type;
  template<typename _Scalar, int Size> struct Cost
  { enum { value = (Size-1) * functor_traits<BinaryOp>::Cost }; };
  member_redux(const BinaryOp func) : m_functor(func) {}
  template<typename Derived>
  inline result_type operator()(const DenseBase<Derived>& mat) const
  { return mat.redux(m_functor); }
  const BinaryOp m_functor;
};
}
# 178 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/VectorwiseOp.h"
template<typename ExpressionType, int Direction> class VectorwiseOp
{
  public:

    typedef typename ExpressionType::Scalar Scalar;
    typedef typename ExpressionType::RealScalar RealScalar;
    typedef typename ExpressionType::Index Index;
    typedef typename internal::conditional<internal::must_nest_by_value<ExpressionType>::ret,
        ExpressionType, ExpressionType&>::type ExpressionTypeNested;
    typedef typename internal::remove_all<ExpressionTypeNested>::type ExpressionTypeNestedCleaned;

    template<template<typename _Scalar> class Functor,
                      typename Scalar=typename internal::traits<ExpressionType>::Scalar> struct ReturnType
    {
      typedef PartialReduxExpr<ExpressionType,
                               Functor<Scalar>,
                               Direction
                              > Type;
    };

    template<typename BinaryOp> struct ReduxReturnType
    {
      typedef PartialReduxExpr<ExpressionType,
                               internal::member_redux<BinaryOp,typename internal::traits<ExpressionType>::Scalar>,
                               Direction
                              > Type;
    };

    enum {
      IsVertical = (Direction==Vertical) ? 1 : 0,
      IsHorizontal = (Direction==Horizontal) ? 1 : 0
    };

  protected:



    typedef typename internal::conditional<Direction==Vertical,
                               typename ExpressionType::ColXpr,
                               typename ExpressionType::RowXpr>::type SubVector;
    SubVector subVector(Index i)
    {
      return SubVector(m_matrix.derived(),i);
    }



    Index subVectors() const
    { return Direction==Vertical?m_matrix.cols():m_matrix.rows(); }

    template<typename OtherDerived> struct ExtendedType {
      typedef Replicate<OtherDerived,
                        Direction==Vertical ? 1 : ExpressionType::RowsAtCompileTime,
                        Direction==Horizontal ? 1 : ExpressionType::ColsAtCompileTime> Type;
    };



    template<typename OtherDerived>
    typename ExtendedType<OtherDerived>::Type
    extendedTo(const DenseBase<OtherDerived>& other) const
    {
      if (Eigen::internal::static_assertion<bool(OtherDerived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {};
      return typename ExtendedType<OtherDerived>::Type
                      (other.derived(),
                       Direction==Vertical ? 1 : m_matrix.rows(),
                       Direction==Horizontal ? 1 : m_matrix.cols());
    }

  public:

    inline VectorwiseOp(ExpressionType& matrix) : m_matrix(matrix) {}


    inline const ExpressionType& _expression() const { return m_matrix; }
# 261 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/VectorwiseOp.h"
    template<typename BinaryOp>
    const typename ReduxReturnType<BinaryOp>::Type
    redux(const BinaryOp& func = BinaryOp()) const
    { return typename ReduxReturnType<BinaryOp>::Type(_expression(), func); }
# 273 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/VectorwiseOp.h"
    const typename ReturnType<internal::member_minCoeff>::Type minCoeff() const
    { return _expression(); }
# 283 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/VectorwiseOp.h"
    const typename ReturnType<internal::member_maxCoeff>::Type maxCoeff() const
    { return _expression(); }
# 293 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/VectorwiseOp.h"
    const typename ReturnType<internal::member_squaredNorm,RealScalar>::Type squaredNorm() const
    { return _expression(); }
# 303 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/VectorwiseOp.h"
    const typename ReturnType<internal::member_norm,RealScalar>::Type norm() const
    { return _expression(); }







    const typename ReturnType<internal::member_blueNorm,RealScalar>::Type blueNorm() const
    { return _expression(); }







    const typename ReturnType<internal::member_stableNorm,RealScalar>::Type stableNorm() const
    { return _expression(); }







    const typename ReturnType<internal::member_hypotNorm,RealScalar>::Type hypotNorm() const
    { return _expression(); }
# 340 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/VectorwiseOp.h"
    const typename ReturnType<internal::member_sum>::Type sum() const
    { return _expression(); }





    const typename ReturnType<internal::member_mean>::Type mean() const
    { return _expression(); }





    const typename ReturnType<internal::member_all>::Type all() const
    { return _expression(); }





    const typename ReturnType<internal::member_any>::Type any() const
    { return _expression(); }
# 371 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/VectorwiseOp.h"
    const PartialReduxExpr<ExpressionType, internal::member_count<Index>, Direction> count() const
    { return _expression(); }
# 381 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/VectorwiseOp.h"
    const typename ReturnType<internal::member_prod>::Type prod() const
    { return _expression(); }
# 392 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/VectorwiseOp.h"
    const Reverse<ExpressionType, Direction> reverse() const
    { return Reverse<ExpressionType, Direction>( _expression() ); }

    typedef Replicate<ExpressionType,Direction==Vertical?Dynamic:1,Direction==Horizontal?Dynamic:1> ReplicateReturnType;
    const ReplicateReturnType replicate(Index factor) const;
# 407 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/VectorwiseOp.h"
    template<int Factor> const Replicate<ExpressionType,(IsVertical?Factor:1),(IsHorizontal?Factor:1)>
    replicate(Index factor = Factor) const
    {
      return Replicate<ExpressionType,Direction==Vertical?Factor:1,Direction==Horizontal?Factor:1>
          (_expression(),Direction==Vertical?factor:1,Direction==Horizontal?factor:1);
    }




    template<typename OtherDerived>
    ExpressionType& operator=(const DenseBase<OtherDerived>& other)
    {
      if (Eigen::internal::static_assertion<bool(OtherDerived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}

      for(Index j=0; j<subVectors(); ++j)
        subVector(j) = other;
      return const_cast<ExpressionType&>(m_matrix);
    }


    template<typename OtherDerived>
    ExpressionType& operator+=(const DenseBase<OtherDerived>& other)
    {
      if (Eigen::internal::static_assertion<bool(OtherDerived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
      for(Index j=0; j<subVectors(); ++j)
        subVector(j) += other.derived();
      return const_cast<ExpressionType&>(m_matrix);
    }


    template<typename OtherDerived>
    ExpressionType& operator-=(const DenseBase<OtherDerived>& other)
    {
      if (Eigen::internal::static_assertion<bool(OtherDerived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
      for(Index j=0; j<subVectors(); ++j)
        subVector(j) -= other.derived();
      return const_cast<ExpressionType&>(m_matrix);
    }


    template<typename OtherDerived> inline
    CwiseBinaryOp<internal::scalar_sum_op<Scalar>,
                  const ExpressionTypeNestedCleaned,
                  const typename ExtendedType<OtherDerived>::Type>
    operator+(const DenseBase<OtherDerived>& other) const
    {
      if (Eigen::internal::static_assertion<bool(OtherDerived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {};
      return m_matrix + extendedTo(other.derived());
    }


    template<typename OtherDerived>
    CwiseBinaryOp<internal::scalar_difference_op<Scalar>,
                  const ExpressionTypeNestedCleaned,
                  const typename ExtendedType<OtherDerived>::Type>
    operator-(const DenseBase<OtherDerived>& other) const
    {
      if (Eigen::internal::static_assertion<bool(OtherDerived::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {};
      return m_matrix - extendedTo(other.derived());
    }




    Homogeneous<ExpressionType,Direction> homogeneous() const;


    typedef typename ExpressionType::PlainObject CrossReturnType;
    template<typename OtherDerived>
    const CrossReturnType cross(const MatrixBase<OtherDerived>& other) const;

    enum {
      HNormalized_Size = Direction==Vertical ? internal::traits<ExpressionType>::RowsAtCompileTime
                                             : internal::traits<ExpressionType>::ColsAtCompileTime,
      HNormalized_SizeMinusOne = HNormalized_Size==Dynamic ? Dynamic : HNormalized_Size-1
    };
    typedef Block<const ExpressionType,
                  Direction==Vertical ? int(HNormalized_SizeMinusOne)
                                        : int(internal::traits<ExpressionType>::RowsAtCompileTime),
                  Direction==Horizontal ? int(HNormalized_SizeMinusOne)
                                        : int(internal::traits<ExpressionType>::ColsAtCompileTime)>
            HNormalized_Block;
    typedef Block<const ExpressionType,
                  Direction==Vertical ? 1 : int(internal::traits<ExpressionType>::RowsAtCompileTime),
                  Direction==Horizontal ? 1 : int(internal::traits<ExpressionType>::ColsAtCompileTime)>
            HNormalized_Factors;
    typedef CwiseBinaryOp<internal::scalar_quotient_op<typename internal::traits<ExpressionType>::Scalar>,
                const HNormalized_Block,
                const Replicate<HNormalized_Factors,
                  Direction==Vertical ? HNormalized_SizeMinusOne : 1,
                  Direction==Horizontal ? HNormalized_SizeMinusOne : 1> >
            HNormalizedReturnType;

    const HNormalizedReturnType hnormalized() const;

  protected:
    ExpressionTypeNested m_matrix;
};
# 514 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/VectorwiseOp.h"
template<typename Derived>
inline const typename DenseBase<Derived>::ConstColwiseReturnType
DenseBase<Derived>::colwise() const
{
  return derived();
}





template<typename Derived>
inline typename DenseBase<Derived>::ColwiseReturnType
DenseBase<Derived>::colwise()
{
  return derived();
}
# 539 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/VectorwiseOp.h"
template<typename Derived>
inline const typename DenseBase<Derived>::ConstRowwiseReturnType
DenseBase<Derived>::rowwise() const
{
  return derived();
}





template<typename Derived>
inline typename DenseBase<Derived>::RowwiseReturnType
DenseBase<Derived>::rowwise()
{
  return derived();
}
# 344 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Random.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Random.h"
namespace internal {

template<typename Scalar> struct scalar_random_op {
  inline scalar_random_op() {} inline scalar_random_op(const scalar_random_op& ) {}
  template<typename Index>
  inline const Scalar operator() (Index, Index = 0) const { return random<Scalar>(); }
};

template<typename Scalar>
struct functor_traits<scalar_random_op<Scalar> >
{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false, IsRepeatable = false }; };

}
# 60 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Random.h"
template<typename Derived>
inline const CwiseNullaryOp<internal::scalar_random_op<typename internal::traits<Derived>::Scalar>, Derived>
DenseBase<Derived>::Random(Index rows, Index cols)
{
  return NullaryExpr(rows, cols, internal::scalar_random_op<Scalar>());
}
# 87 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Random.h"
template<typename Derived>
inline const CwiseNullaryOp<internal::scalar_random_op<typename internal::traits<Derived>::Scalar>, Derived>
DenseBase<Derived>::Random(Index size)
{
  return NullaryExpr(size, internal::scalar_random_op<Scalar>());
}
# 108 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Random.h"
template<typename Derived>
inline const CwiseNullaryOp<internal::scalar_random_op<typename internal::traits<Derived>::Scalar>, Derived>
DenseBase<Derived>::Random()
{
  return NullaryExpr(RowsAtCompileTime, ColsAtCompileTime, internal::scalar_random_op<Scalar>());
}
# 122 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Random.h"
template<typename Derived>
inline Derived& DenseBase<Derived>::setRandom()
{
  return *this = Random(rows(), cols());
}
# 137 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Random.h"
template<typename Derived>
inline Derived&
PlainObjectBase<Derived>::setRandom(Index size)
{
  resize(size);
  return setRandom();
}
# 155 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Random.h"
template<typename Derived>
inline Derived&
PlainObjectBase<Derived>::setRandom(Index rows, Index cols)
{
  resize(rows, cols);
  return setRandom();
}
# 345 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Replicate.h" 1
# 43 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Replicate.h"
namespace internal {
template<typename MatrixType,int RowFactor,int ColFactor>
struct traits<Replicate<MatrixType,RowFactor,ColFactor> >
 : traits<MatrixType>
{
  typedef typename MatrixType::Scalar Scalar;
  typedef typename traits<MatrixType>::StorageKind StorageKind;
  typedef typename traits<MatrixType>::XprKind XprKind;
  typedef typename nested<MatrixType>::type MatrixTypeNested;
  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;
  enum {
    RowsAtCompileTime = RowFactor==Dynamic || int(MatrixType::RowsAtCompileTime)==Dynamic
                      ? Dynamic
                      : RowFactor * MatrixType::RowsAtCompileTime,
    ColsAtCompileTime = ColFactor==Dynamic || int(MatrixType::ColsAtCompileTime)==Dynamic
                      ? Dynamic
                      : ColFactor * MatrixType::ColsAtCompileTime,

    MaxRowsAtCompileTime = RowsAtCompileTime,
    MaxColsAtCompileTime = ColsAtCompileTime,
    IsRowMajor = MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1 ? 1
               : MaxColsAtCompileTime==1 && MaxRowsAtCompileTime!=1 ? 0
               : (MatrixType::Flags & RowMajorBit) ? 1 : 0,
    Flags = (_MatrixTypeNested::Flags & HereditaryBits & ~RowMajorBit) | (IsRowMajor ? RowMajorBit : 0),
    CoeffReadCost = _MatrixTypeNested::CoeffReadCost
  };
};
}

template<typename MatrixType,int RowFactor,int ColFactor> class Replicate
  : public internal::dense_xpr_base< Replicate<MatrixType,RowFactor,ColFactor> >::type
{
  public:

    typedef typename internal::dense_xpr_base<Replicate>::type Base;
    typedef typename Eigen::internal::traits<Replicate>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<Replicate>::type Nested; typedef typename Eigen::internal::traits<Replicate>::StorageKind StorageKind; typedef typename Eigen::internal::traits<Replicate>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<Replicate>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<Replicate>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<Replicate>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<Replicate>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<Replicate>::Flags, CoeffReadCost = Eigen::internal::traits<Replicate>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived;

    template<typename OriginalMatrixType>
    inline explicit Replicate(const OriginalMatrixType& matrix)
      : m_matrix(matrix), m_rowFactor(RowFactor), m_colFactor(ColFactor)
    {
      if (Eigen::internal::static_assertion<bool((internal::is_same<typename internal::remove_const<MatrixType>::type,OriginalMatrixType>::value))>::THE_MATRIX_OR_EXPRESSION_THAT_YOU_PASSED_DOES_NOT_HAVE_THE_EXPECTED_TYPE) {}

      if( (!Eigen::internal::copy_bool(RowFactor!=Dynamic && ColFactor!=Dynamic)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(RowFactor!=Dynamic && ColFactor!=Dynamic)) Eigen::internal::assert_fail("RowFactor!=Dynamic && ColFactor!=Dynamic", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Replicate.h", 86); } while(false); else throw Eigen::eigen_assert_exception(); };
    }

    template<typename OriginalMatrixType>
    inline Replicate(const OriginalMatrixType& matrix, int rowFactor, int colFactor)
      : m_matrix(matrix), m_rowFactor(rowFactor), m_colFactor(colFactor)
    {
      if (Eigen::internal::static_assertion<bool((internal::is_same<typename internal::remove_const<MatrixType>::type,OriginalMatrixType>::value))>::THE_MATRIX_OR_EXPRESSION_THAT_YOU_PASSED_DOES_NOT_HAVE_THE_EXPECTED_TYPE) {}

    }

    inline Index rows() const { return m_matrix.rows() * m_rowFactor.value(); }
    inline Index cols() const { return m_matrix.cols() * m_colFactor.value(); }

    inline Scalar coeff(Index row, Index col) const
    {

      const Index actual_row = internal::traits<MatrixType>::RowsAtCompileTime==1 ? 0
                            : RowFactor==1 ? row
                            : row%m_matrix.rows();
      const Index actual_col = internal::traits<MatrixType>::ColsAtCompileTime==1 ? 0
                            : ColFactor==1 ? col
                            : col%m_matrix.cols();

      return m_matrix.coeff(actual_row, actual_col);
    }
    template<int LoadMode>
    inline PacketScalar packet(Index row, Index col) const
    {
      const Index actual_row = internal::traits<MatrixType>::RowsAtCompileTime==1 ? 0
                            : RowFactor==1 ? row
                            : row%m_matrix.rows();
      const Index actual_col = internal::traits<MatrixType>::ColsAtCompileTime==1 ? 0
                            : ColFactor==1 ? col
                            : col%m_matrix.cols();

      return m_matrix.template packet<LoadMode>(actual_row, actual_col);
    }


  protected:
    const typename MatrixType::Nested m_matrix;
    const internal::variable_if_dynamic<Index, RowFactor> m_rowFactor;
    const internal::variable_if_dynamic<Index, ColFactor> m_colFactor;
};
# 140 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Replicate.h"
template<typename Derived>
template<int RowFactor, int ColFactor>
inline const Replicate<Derived,RowFactor,ColFactor>
DenseBase<Derived>::replicate() const
{
  return Replicate<Derived,RowFactor,ColFactor>(derived());
}
# 156 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Replicate.h"
template<typename Derived>
inline const Replicate<Derived,Dynamic,Dynamic>
DenseBase<Derived>::replicate(Index rowFactor,Index colFactor) const
{
  return Replicate<Derived,Dynamic,Dynamic>(derived(),rowFactor,colFactor);
}
# 171 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Replicate.h"
template<typename ExpressionType, int Direction>
const typename VectorwiseOp<ExpressionType,Direction>::ReplicateReturnType
VectorwiseOp<ExpressionType,Direction>::replicate(Index factor) const
{
  return typename VectorwiseOp<ExpressionType,Direction>::ReplicateReturnType
          (_expression(),Direction==Vertical?factor:1,Direction==Horizontal?factor:1);
}
# 346 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Reverse.h" 1
# 44 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Reverse.h"
namespace internal {

template<typename MatrixType, int Direction>
struct traits<Reverse<MatrixType, Direction> >
 : traits<MatrixType>
{
  typedef typename MatrixType::Scalar Scalar;
  typedef typename traits<MatrixType>::StorageKind StorageKind;
  typedef typename traits<MatrixType>::XprKind XprKind;
  typedef typename nested<MatrixType>::type MatrixTypeNested;
  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;
  enum {
    RowsAtCompileTime = MatrixType::RowsAtCompileTime,
    ColsAtCompileTime = MatrixType::ColsAtCompileTime,
    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,


    LinearAccess = ( (Direction==BothDirections) && (int(_MatrixTypeNested::Flags)&PacketAccessBit) )
                 ? LinearAccessBit : 0,

    Flags = int(_MatrixTypeNested::Flags) & (HereditaryBits | LvalueBit | PacketAccessBit | LinearAccess),

    CoeffReadCost = _MatrixTypeNested::CoeffReadCost
  };
};

template<typename PacketScalar, bool ReversePacket> struct reverse_packet_cond
{
  static inline PacketScalar run(const PacketScalar& x) { return preverse(x); }
};

template<typename PacketScalar> struct reverse_packet_cond<PacketScalar,false>
{
  static inline PacketScalar run(const PacketScalar& x) { return x; }
};

}

template<typename MatrixType, int Direction> class Reverse
  : public internal::dense_xpr_base< Reverse<MatrixType, Direction> >::type
{
  public:

    typedef typename internal::dense_xpr_base<Reverse>::type Base;
    typedef typename Eigen::internal::traits<Reverse>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<Reverse>::type Nested; typedef typename Eigen::internal::traits<Reverse>::StorageKind StorageKind; typedef typename Eigen::internal::traits<Reverse>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<Reverse>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<Reverse>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<Reverse>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<Reverse>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<Reverse>::Flags, CoeffReadCost = Eigen::internal::traits<Reverse>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived;
    using Base::IsRowMajor;



    using Base::operator();

  protected:
    enum {
      PacketSize = internal::packet_traits<Scalar>::size,
      IsColMajor = !IsRowMajor,
      ReverseRow = (Direction == Vertical) || (Direction == BothDirections),
      ReverseCol = (Direction == Horizontal) || (Direction == BothDirections),
      OffsetRow = ReverseRow && IsColMajor ? PacketSize : 1,
      OffsetCol = ReverseCol && IsRowMajor ? PacketSize : 1,
      ReversePacket = (Direction == BothDirections)
                    || ((Direction == Vertical) && IsColMajor)
                    || ((Direction == Horizontal) && IsRowMajor)
    };
    typedef internal::reverse_packet_cond<PacketScalar,ReversePacket> reverse_packet;
  public:

    inline Reverse(const MatrixType& matrix) : m_matrix(matrix) { }

    using Base::operator =; inline Reverse& operator=(const Reverse& other) { Base::operator=(other); return *this; }

    inline Index rows() const { return m_matrix.rows(); }
    inline Index cols() const { return m_matrix.cols(); }

    inline Index innerStride() const
    {
      return -m_matrix.innerStride();
    }

    inline Scalar& operator()(Index row, Index col)
    {
      if( (!Eigen::internal::copy_bool(row >= 0 && row < rows() && col >= 0 && col < cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(row >= 0 && row < rows() && col >= 0 && col < cols())) Eigen::internal::assert_fail("row >= 0 && row < rows() && col >= 0 && col < cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Reverse.h", 125); } while(false); else throw Eigen::eigen_assert_exception(); };
      return coeffRef(row, col);
    }

    inline Scalar& coeffRef(Index row, Index col)
    {
      return m_matrix.const_cast_derived().coeffRef(ReverseRow ? m_matrix.rows() - row - 1 : row,
                                                    ReverseCol ? m_matrix.cols() - col - 1 : col);
    }

    inline CoeffReturnType coeff(Index row, Index col) const
    {
      return m_matrix.coeff(ReverseRow ? m_matrix.rows() - row - 1 : row,
                            ReverseCol ? m_matrix.cols() - col - 1 : col);
    }

    inline CoeffReturnType coeff(Index index) const
    {
      return m_matrix.coeff(m_matrix.size() - index - 1);
    }

    inline Scalar& coeffRef(Index index)
    {
      return m_matrix.const_cast_derived().coeffRef(m_matrix.size() - index - 1);
    }

    inline Scalar& operator()(Index index)
    {
      if( (!Eigen::internal::copy_bool(index >= 0 && index < m_matrix.size())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(index >= 0 && index < m_matrix.size())) Eigen::internal::assert_fail("index >= 0 && index < m_matrix.size()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Reverse.h", 153); } while(false); else throw Eigen::eigen_assert_exception(); };
      return coeffRef(index);
    }

    template<int LoadMode>
    inline const PacketScalar packet(Index row, Index col) const
    {
      return reverse_packet::run(m_matrix.template packet<LoadMode>(
                                    ReverseRow ? m_matrix.rows() - row - OffsetRow : row,
                                    ReverseCol ? m_matrix.cols() - col - OffsetCol : col));
    }

    template<int LoadMode>
    inline void writePacket(Index row, Index col, const PacketScalar& x)
    {
      m_matrix.const_cast_derived().template writePacket<LoadMode>(
                                      ReverseRow ? m_matrix.rows() - row - OffsetRow : row,
                                      ReverseCol ? m_matrix.cols() - col - OffsetCol : col,
                                      reverse_packet::run(x));
    }

    template<int LoadMode>
    inline const PacketScalar packet(Index index) const
    {
      return internal::preverse(m_matrix.template packet<LoadMode>( m_matrix.size() - index - PacketSize ));
    }

    template<int LoadMode>
    inline void writePacket(Index index, const PacketScalar& x)
    {
      m_matrix.const_cast_derived().template writePacket<LoadMode>(m_matrix.size() - index - PacketSize, internal::preverse(x));
    }

  protected:
    const typename MatrixType::Nested m_matrix;
};







template<typename Derived>
inline typename DenseBase<Derived>::ReverseReturnType
DenseBase<Derived>::reverse()
{
  return derived();
}


template<typename Derived>
inline const typename DenseBase<Derived>::ConstReverseReturnType
DenseBase<Derived>::reverse() const
{
  return derived();
}
# 223 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/Reverse.h"
template<typename Derived>
inline void DenseBase<Derived>::reverseInPlace()
{
  derived() = derived().reverse().eval();
}
# 347 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/ArrayBase.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/ArrayBase.h"
template<typename ExpressionType> class MatrixWrapper;
# 52 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/ArrayBase.h"
template<typename Derived> class ArrayBase
  : public DenseBase<Derived>
{
  public:


    typedef ArrayBase StorageBaseType;

    typedef ArrayBase Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl;

    using internal::special_scalar_op_base<Derived,typename internal::traits<Derived>::Scalar,
                typename NumTraits<typename internal::traits<Derived>::Scalar>::Real>::operator*;

    typedef typename internal::traits<Derived>::StorageKind StorageKind;
    typedef typename internal::traits<Derived>::Index Index;
    typedef typename internal::traits<Derived>::Scalar Scalar;
    typedef typename internal::packet_traits<Scalar>::type PacketScalar;
    typedef typename NumTraits<Scalar>::Real RealScalar;

    typedef DenseBase<Derived> Base;
    using Base::RowsAtCompileTime;
    using Base::ColsAtCompileTime;
    using Base::SizeAtCompileTime;
    using Base::MaxRowsAtCompileTime;
    using Base::MaxColsAtCompileTime;
    using Base::MaxSizeAtCompileTime;
    using Base::IsVectorAtCompileTime;
    using Base::Flags;
    using Base::CoeffReadCost;

    using Base::derived;
    using Base::const_cast_derived;
    using Base::rows;
    using Base::cols;
    using Base::size;
    using Base::coeff;
    using Base::coeffRef;
    using Base::lazyAssign;
    using Base::operator=;
    using Base::operator+=;
    using Base::operator-=;
    using Base::operator*=;
    using Base::operator/=;

    typedef typename Base::CoeffReturnType CoeffReturnType;
# 106 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/ArrayBase.h"
    typedef Array<typename internal::traits<Derived>::Scalar,
                internal::traits<Derived>::RowsAtCompileTime,
                internal::traits<Derived>::ColsAtCompileTime,
                AutoAlign | (internal::traits<Derived>::Flags&RowMajorBit ? RowMajor : ColMajor),
                internal::traits<Derived>::MaxRowsAtCompileTime,
                internal::traits<Derived>::MaxColsAtCompileTime
          > PlainObject;



    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Derived> ConstantReturnType;




# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/CommonCwiseUnaryOps.h" 1
# 31 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/CommonCwiseUnaryOps.h"
typedef CwiseUnaryOp<internal::scalar_multiple_op<Scalar>, const Derived> ScalarMultipleReturnType;

typedef CwiseUnaryOp<internal::scalar_quotient1_op<Scalar>, const Derived> ScalarQuotient1ReturnType;

typedef typename internal::conditional<NumTraits<Scalar>::IsComplex,
                    const CwiseUnaryOp<internal::scalar_conjugate_op<Scalar>, const Derived>,
                    const Derived&
                  >::type ConjugateReturnType;

typedef typename internal::conditional<NumTraits<Scalar>::IsComplex,
                    const CwiseUnaryOp<internal::scalar_real_op<Scalar>, const Derived>,
                    const Derived&
                  >::type RealReturnType;

typedef typename internal::conditional<NumTraits<Scalar>::IsComplex,
                    CwiseUnaryView<internal::scalar_real_ref_op<Scalar>, Derived>,
                    Derived&
                  >::type NonConstRealReturnType;

typedef CwiseUnaryOp<internal::scalar_imag_op<Scalar>, const Derived> ImagReturnType;

typedef CwiseUnaryView<internal::scalar_imag_ref_op<Scalar>, Derived> NonConstImagReturnType;





inline const CwiseUnaryOp<internal::scalar_opposite_op<typename internal::traits<Derived>::Scalar>, const Derived>
operator-() const { return derived(); }



inline const ScalarMultipleReturnType
operator*(const Scalar& scalar) const
{
  return CwiseUnaryOp<internal::scalar_multiple_op<Scalar>, const Derived>
    (derived(), internal::scalar_multiple_op<Scalar>(scalar));
}






inline const CwiseUnaryOp<internal::scalar_quotient1_op<typename internal::traits<Derived>::Scalar>, const Derived>
operator/(const Scalar& scalar) const
{
  return CwiseUnaryOp<internal::scalar_quotient1_op<Scalar>, const Derived>
    (derived(), internal::scalar_quotient1_op<Scalar>(scalar));
}


inline const CwiseUnaryOp<internal::scalar_multiple2_op<Scalar,std::complex<Scalar> >, const Derived>
operator*(const std::complex<Scalar>& scalar) const
{
  return CwiseUnaryOp<internal::scalar_multiple2_op<Scalar,std::complex<Scalar> >, const Derived>
    (*static_cast<const Derived*>(this), internal::scalar_multiple2_op<Scalar,std::complex<Scalar> >(scalar));
}

inline friend const ScalarMultipleReturnType
operator*(const Scalar& scalar, const StorageBaseType& matrix)
{ return matrix*scalar; }

inline friend const CwiseUnaryOp<internal::scalar_multiple2_op<Scalar,std::complex<Scalar> >, const Derived>
operator*(const std::complex<Scalar>& scalar, const StorageBaseType& matrix)
{ return matrix*scalar; }
# 105 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/CommonCwiseUnaryOps.h"
template<typename NewType>
typename internal::cast_return_type<Derived,const CwiseUnaryOp<internal::scalar_cast_op<typename internal::traits<Derived>::Scalar, NewType>, const Derived> >::type
cast() const
{
  return derived();
}




inline ConjugateReturnType
conjugate() const
{
  return ConjugateReturnType(derived());
}




inline RealReturnType
real() const { return derived(); }




inline const ImagReturnType
imag() const { return derived(); }
# 152 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/CommonCwiseUnaryOps.h"
template<typename CustomUnaryOp>
inline const CwiseUnaryOp<CustomUnaryOp, const Derived>
unaryExpr(const CustomUnaryOp& func = CustomUnaryOp()) const
{
  return CwiseUnaryOp<CustomUnaryOp, const Derived>(derived(), func);
}
# 170 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/CommonCwiseUnaryOps.h"
template<typename CustomViewOp>
inline const CwiseUnaryView<CustomViewOp, const Derived>
unaryViewExpr(const CustomViewOp& func = CustomViewOp()) const
{
  return CwiseUnaryView<CustomViewOp, const Derived>(derived(), func);
}




inline NonConstRealReturnType
real() { return derived(); }




inline NonConstImagReturnType
imag() { return derived(); }
# 121 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/ArrayBase.h" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/MatrixCwiseUnaryOps.h" 1
# 35 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/MatrixCwiseUnaryOps.h"
inline const CwiseUnaryOp<internal::scalar_abs_op<Scalar>, const Derived>
cwiseAbs() const { return derived(); }
# 45 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/MatrixCwiseUnaryOps.h"
inline const CwiseUnaryOp<internal::scalar_abs2_op<Scalar>, const Derived>
cwiseAbs2() const { return derived(); }
# 55 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/MatrixCwiseUnaryOps.h"
inline const CwiseUnaryOp<internal::scalar_sqrt_op<Scalar>, const Derived>
cwiseSqrt() const { return derived(); }
# 65 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/MatrixCwiseUnaryOps.h"
inline const CwiseUnaryOp<internal::scalar_inverse_op<Scalar>, const Derived>
cwiseInverse() const { return derived(); }
# 77 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/MatrixCwiseUnaryOps.h"
inline const CwiseUnaryOp<std::binder1st<std::equal_to<Scalar> >, const Derived>
cwiseEqual(const Scalar& s) const
{
  return CwiseUnaryOp<std::binder1st<std::equal_to<Scalar> >,const Derived>
          (derived(), std::bind1st(std::equal_to<Scalar>(), s));
}
# 122 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/ArrayBase.h" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/ArrayCwiseUnaryOps.h" 1
# 10 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/ArrayCwiseUnaryOps.h"
inline const CwiseUnaryOp<internal::scalar_abs_op<Scalar>, const Derived>
abs() const
{
  return derived();
}
# 23 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/ArrayCwiseUnaryOps.h"
inline const CwiseUnaryOp<internal::scalar_abs2_op<Scalar>, const Derived>
abs2() const
{
  return derived();
}
# 36 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/ArrayCwiseUnaryOps.h"
inline const CwiseUnaryOp<internal::scalar_exp_op<Scalar>, const Derived>
exp() const
{
  return derived();
}
# 49 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/ArrayCwiseUnaryOps.h"
inline const CwiseUnaryOp<internal::scalar_log_op<Scalar>, const Derived>
log() const
{
  return derived();
}
# 62 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/ArrayCwiseUnaryOps.h"
inline const CwiseUnaryOp<internal::scalar_sqrt_op<Scalar>, const Derived>
sqrt() const
{
  return derived();
}
# 75 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/ArrayCwiseUnaryOps.h"
inline const CwiseUnaryOp<internal::scalar_cos_op<Scalar>, const Derived>
cos() const
{
  return derived();
}
# 89 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/ArrayCwiseUnaryOps.h"
inline const CwiseUnaryOp<internal::scalar_sin_op<Scalar>, const Derived>
sin() const
{
  return derived();
}
# 102 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/ArrayCwiseUnaryOps.h"
inline const CwiseUnaryOp<internal::scalar_acos_op<Scalar>, const Derived>
acos() const
{
  return derived();
}
# 115 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/ArrayCwiseUnaryOps.h"
inline const CwiseUnaryOp<internal::scalar_asin_op<Scalar>, const Derived>
asin() const
{
  return derived();
}
# 128 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/ArrayCwiseUnaryOps.h"
inline const CwiseUnaryOp<internal::scalar_tan_op<Scalar>, Derived>
tan() const
{
  return derived();
}
# 142 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/ArrayCwiseUnaryOps.h"
inline const CwiseUnaryOp<internal::scalar_pow_op<Scalar>, const Derived>
pow(const Scalar& exponent) const
{
  return CwiseUnaryOp<internal::scalar_pow_op<Scalar>, const Derived>
          (derived(), internal::scalar_pow_op<Scalar>(exponent));
}
# 157 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/ArrayCwiseUnaryOps.h"
inline const CwiseUnaryOp<internal::scalar_inverse_op<Scalar>, const Derived>
inverse() const
{
  return derived();
}
# 170 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/ArrayCwiseUnaryOps.h"
inline const CwiseUnaryOp<internal::scalar_square_op<Scalar>, const Derived>
square() const
{
  return derived();
}
# 183 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/ArrayCwiseUnaryOps.h"
inline const CwiseUnaryOp<internal::scalar_cube_op<Scalar>, const Derived>
cube() const
{
  return derived();
}
# 196 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/ArrayCwiseUnaryOps.h"
inline const CwiseUnaryOp<std::binder2nd<std::equal_to<Scalar> >, const Derived> operator==(const Scalar& s) const { return CwiseUnaryOp<std::binder2nd<std::equal_to<Scalar> >, const Derived> (derived(), std::bind2nd(std::equal_to<Scalar>(), s)); }
inline const CwiseUnaryOp<std::binder2nd<std::not_equal_to<Scalar> >, const Derived> operator!=(const Scalar& s) const { return CwiseUnaryOp<std::binder2nd<std::not_equal_to<Scalar> >, const Derived> (derived(), std::bind2nd(std::not_equal_to<Scalar>(), s)); }
inline const CwiseUnaryOp<std::binder2nd<std::less<Scalar> >, const Derived> operator<(const Scalar& s) const { return CwiseUnaryOp<std::binder2nd<std::less<Scalar> >, const Derived> (derived(), std::bind2nd(std::less<Scalar>(), s)); }
inline const CwiseUnaryOp<std::binder2nd<std::less_equal<Scalar> >, const Derived> operator<=(const Scalar& s) const { return CwiseUnaryOp<std::binder2nd<std::less_equal<Scalar> >, const Derived> (derived(), std::bind2nd(std::less_equal<Scalar>(), s)); }
inline const CwiseUnaryOp<std::binder2nd<std::greater<Scalar> >, const Derived> operator>(const Scalar& s) const { return CwiseUnaryOp<std::binder2nd<std::greater<Scalar> >, const Derived> (derived(), std::bind2nd(std::greater<Scalar>(), s)); }
inline const CwiseUnaryOp<std::binder2nd<std::greater_equal<Scalar> >, const Derived> operator>=(const Scalar& s) const { return CwiseUnaryOp<std::binder2nd<std::greater_equal<Scalar> >, const Derived> (derived(), std::bind2nd(std::greater_equal<Scalar>(), s)); }
# 123 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/ArrayBase.h" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h" 1
# 34 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h"
template<typename OtherDerived> inline const CwiseBinaryOp<internal::scalar_difference_op<Scalar>, const Derived, const OtherDerived> (operator-)(const Eigen::ArrayBase<OtherDerived> &other) const { return CwiseBinaryOp<internal::scalar_difference_op<Scalar>, const Derived, const OtherDerived>(derived(), other.derived()); }







template<typename OtherDerived> inline const CwiseBinaryOp<internal::scalar_sum_op<Scalar>, const Derived, const OtherDerived> (operator+)(const Eigen::ArrayBase<OtherDerived> &other) const { return CwiseBinaryOp<internal::scalar_sum_op<Scalar>, const Derived, const OtherDerived>(derived(), other.derived()); }
# 55 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/CommonCwiseBinaryOps.h"
template<typename CustomBinaryOp, typename OtherDerived>
inline const CwiseBinaryOp<CustomBinaryOp, const Derived, const OtherDerived>
binaryExpr(const Eigen::ArrayBase<OtherDerived> &other, const CustomBinaryOp& func = CustomBinaryOp()) const
{
  return CwiseBinaryOp<CustomBinaryOp, const Derived, const OtherDerived>(derived(), other.derived(), func);
}
# 124 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/ArrayBase.h" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/MatrixCwiseBinaryOps.h" 1
# 35 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/MatrixCwiseBinaryOps.h"
template<typename OtherDerived>
inline const CwiseBinaryOp< internal::scalar_product_op< typename internal::traits<Derived>::Scalar, typename internal::traits<OtherDerived>::Scalar >, const Derived, const OtherDerived >
cwiseProduct(const Eigen::ArrayBase<OtherDerived> &other) const
{
  return CwiseBinaryOp< internal::scalar_product_op< typename internal::traits<Derived>::Scalar, typename internal::traits<OtherDerived>::Scalar >, const Derived, const OtherDerived >(derived(), other.derived());
}
# 54 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/MatrixCwiseBinaryOps.h"
template<typename OtherDerived>
inline const CwiseBinaryOp<std::equal_to<Scalar>, const Derived, const OtherDerived>
cwiseEqual(const Eigen::ArrayBase<OtherDerived> &other) const
{
  return CwiseBinaryOp<std::equal_to<Scalar>, const Derived, const OtherDerived>(derived(), other.derived());
}
# 73 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/MatrixCwiseBinaryOps.h"
template<typename OtherDerived>
inline const CwiseBinaryOp<std::not_equal_to<Scalar>, const Derived, const OtherDerived>
cwiseNotEqual(const Eigen::ArrayBase<OtherDerived> &other) const
{
  return CwiseBinaryOp<std::not_equal_to<Scalar>, const Derived, const OtherDerived>(derived(), other.derived());
}
# 87 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/MatrixCwiseBinaryOps.h"
template<typename OtherDerived>
inline const CwiseBinaryOp<internal::scalar_min_op<Scalar>, const Derived, const OtherDerived>
cwiseMin(const Eigen::ArrayBase<OtherDerived> &other) const
{
  return CwiseBinaryOp<internal::scalar_min_op<Scalar>, const Derived, const OtherDerived>(derived(), other.derived());
}
# 101 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/MatrixCwiseBinaryOps.h"
template<typename OtherDerived>
inline const CwiseBinaryOp<internal::scalar_max_op<Scalar>, const Derived, const OtherDerived>
cwiseMax(const Eigen::ArrayBase<OtherDerived> &other) const
{
  return CwiseBinaryOp<internal::scalar_max_op<Scalar>, const Derived, const OtherDerived>(derived(), other.derived());
}
# 115 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/MatrixCwiseBinaryOps.h"
template<typename OtherDerived>
inline const CwiseBinaryOp<internal::scalar_quotient_op<Scalar>, const Derived, const OtherDerived>
cwiseQuotient(const Eigen::ArrayBase<OtherDerived> &other) const
{
  return CwiseBinaryOp<internal::scalar_quotient_op<Scalar>, const Derived, const OtherDerived>(derived(), other.derived());
}
# 125 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/ArrayBase.h" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/ArrayCwiseBinaryOps.h" 1




template<typename OtherDerived>
inline const CwiseBinaryOp< internal::scalar_product_op< typename internal::traits<Derived>::Scalar, typename internal::traits<OtherDerived>::Scalar >, const Derived, const OtherDerived >
operator*(const Eigen::ArrayBase<OtherDerived> &other) const
{
  return CwiseBinaryOp< internal::scalar_product_op< typename internal::traits<Derived>::Scalar, typename internal::traits<OtherDerived>::Scalar >, const Derived, const OtherDerived >(derived(), other.derived());
}





template<typename OtherDerived>
inline const CwiseBinaryOp<internal::scalar_quotient_op<Scalar>, const Derived, const OtherDerived>
operator/(const Eigen::ArrayBase<OtherDerived> &other) const
{
  return CwiseBinaryOp<internal::scalar_quotient_op<Scalar>, const Derived, const OtherDerived>(derived(), other.derived());
}
# 30 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/ArrayCwiseBinaryOps.h"
template<typename OtherDerived> inline const CwiseBinaryOp<internal::scalar_min_op<Scalar>, const Derived, const OtherDerived> (min)(const Eigen::ArrayBase<OtherDerived> &other) const { return CwiseBinaryOp<internal::scalar_min_op<Scalar>, const Derived, const OtherDerived>(derived(), other.derived()); }
# 39 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/ArrayCwiseBinaryOps.h"
template<typename OtherDerived> inline const CwiseBinaryOp<internal::scalar_max_op<Scalar>, const Derived, const OtherDerived> (max)(const Eigen::ArrayBase<OtherDerived> &other) const { return CwiseBinaryOp<internal::scalar_max_op<Scalar>, const Derived, const OtherDerived>(derived(), other.derived()); }
# 48 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/ArrayCwiseBinaryOps.h"
template<typename OtherDerived> inline const CwiseBinaryOp<std::less<Scalar>, const Derived, const OtherDerived> (operator<)(const Eigen::ArrayBase<OtherDerived> &other) const { return CwiseBinaryOp<std::less<Scalar>, const Derived, const OtherDerived>(derived(), other.derived()); }
# 57 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/ArrayCwiseBinaryOps.h"
template<typename OtherDerived> inline const CwiseBinaryOp<std::less_equal<Scalar>, const Derived, const OtherDerived> (operator<=)(const Eigen::ArrayBase<OtherDerived> &other) const { return CwiseBinaryOp<std::less_equal<Scalar>, const Derived, const OtherDerived>(derived(), other.derived()); }
# 66 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/ArrayCwiseBinaryOps.h"
template<typename OtherDerived> inline const CwiseBinaryOp<std::greater<Scalar>, const Derived, const OtherDerived> (operator>)(const Eigen::ArrayBase<OtherDerived> &other) const { return CwiseBinaryOp<std::greater<Scalar>, const Derived, const OtherDerived>(derived(), other.derived()); }
# 75 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/ArrayCwiseBinaryOps.h"
template<typename OtherDerived> inline const CwiseBinaryOp<std::greater_equal<Scalar>, const Derived, const OtherDerived> (operator>=)(const Eigen::ArrayBase<OtherDerived> &other) const { return CwiseBinaryOp<std::greater_equal<Scalar>, const Derived, const OtherDerived>(derived(), other.derived()); }
# 89 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/ArrayCwiseBinaryOps.h"
template<typename OtherDerived> inline const CwiseBinaryOp<std::equal_to<Scalar>, const Derived, const OtherDerived> (operator==)(const Eigen::ArrayBase<OtherDerived> &other) const { return CwiseBinaryOp<std::equal_to<Scalar>, const Derived, const OtherDerived>(derived(), other.derived()); }
# 103 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/ArrayCwiseBinaryOps.h"
template<typename OtherDerived> inline const CwiseBinaryOp<std::not_equal_to<Scalar>, const Derived, const OtherDerived> (operator!=)(const Eigen::ArrayBase<OtherDerived> &other) const { return CwiseBinaryOp<std::not_equal_to<Scalar>, const Derived, const OtherDerived>(derived(), other.derived()); }
# 114 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/ArrayCwiseBinaryOps.h"
inline const CwiseUnaryOp<internal::scalar_add_op<Scalar>, const Derived>
operator+(const Scalar& scalar) const
{
  return CwiseUnaryOp<internal::scalar_add_op<Scalar>, const Derived>(derived(), internal::scalar_add_op<Scalar>(scalar));
}

friend inline const CwiseUnaryOp<internal::scalar_add_op<Scalar>, const Derived>
operator+(const Scalar& scalar,const Eigen::ArrayBase<Derived>& other)
{
  return other + scalar;
}
# 133 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/../plugins/ArrayCwiseBinaryOps.h"
inline const CwiseUnaryOp<internal::scalar_add_op<Scalar>, const Derived>
operator-(const Scalar& scalar) const
{
  return *this + (-scalar);
}

friend inline const CwiseUnaryOp<internal::scalar_add_op<Scalar>, const CwiseUnaryOp<internal::scalar_opposite_op<Scalar>, const Derived> >
operator-(const Scalar& scalar,const Eigen::ArrayBase<Derived>& other)
{
  return (-other) + scalar;
}
# 126 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/ArrayBase.h" 2








    Derived& operator=(const ArrayBase& other)
    {
      return internal::assign_selector<Derived,Derived>::run(derived(), other.derived());
    }

    Derived& operator+=(const Scalar& scalar)
    { return *this = derived() + scalar; }
    Derived& operator-=(const Scalar& scalar)
    { return *this = derived() - scalar; }

    template<typename OtherDerived>
    Derived& operator+=(const ArrayBase<OtherDerived>& other);
    template<typename OtherDerived>
    Derived& operator-=(const ArrayBase<OtherDerived>& other);

    template<typename OtherDerived>
    Derived& operator*=(const ArrayBase<OtherDerived>& other);

    template<typename OtherDerived>
    Derived& operator/=(const ArrayBase<OtherDerived>& other);

  public:
    ArrayBase<Derived>& array() { return *this; }
    const ArrayBase<Derived>& array() const { return *this; }



    MatrixWrapper<Derived> matrix() { return derived(); }
    const MatrixWrapper<Derived> matrix() const { return derived(); }




  protected:
    ArrayBase() : Base() {}

  private:
    explicit ArrayBase(Index);
    ArrayBase(Index,Index);
    template<typename OtherDerived> explicit ArrayBase(const ArrayBase<OtherDerived>&);
  protected:

    template<typename OtherDerived> Derived& operator+=(const MatrixBase<OtherDerived>& )
    {if (Eigen::internal::static_assertion<bool(sizeof(typename OtherDerived::Scalar)==-1)>::YOU_CANNOT_MIX_ARRAYS_AND_MATRICES) {};}

    template<typename OtherDerived> Derived& operator-=(const MatrixBase<OtherDerived>& )
    {if (Eigen::internal::static_assertion<bool(sizeof(typename OtherDerived::Scalar)==-1)>::YOU_CANNOT_MIX_ARRAYS_AND_MATRICES) {};}
};





template<typename Derived>
template<typename OtherDerived>
inline Derived &
ArrayBase<Derived>::operator-=(const ArrayBase<OtherDerived> &other)
{
  SelfCwiseBinaryOp<internal::scalar_difference_op<Scalar>, Derived, OtherDerived> tmp(derived());
  tmp = other.derived();
  return derived();
}





template<typename Derived>
template<typename OtherDerived>
inline Derived &
ArrayBase<Derived>::operator+=(const ArrayBase<OtherDerived>& other)
{
  SelfCwiseBinaryOp<internal::scalar_sum_op<Scalar>, Derived, OtherDerived> tmp(derived());
  tmp = other.derived();
  return derived();
}





template<typename Derived>
template<typename OtherDerived>
inline Derived &
ArrayBase<Derived>::operator*=(const ArrayBase<OtherDerived>& other)
{
  SelfCwiseBinaryOp<internal::scalar_product_op<Scalar>, Derived, OtherDerived> tmp(derived());
  tmp = other.derived();
  return derived();
}





template<typename Derived>
template<typename OtherDerived>
inline Derived &
ArrayBase<Derived>::operator/=(const ArrayBase<OtherDerived>& other)
{
  SelfCwiseBinaryOp<internal::scalar_quotient_op<Scalar>, Derived, OtherDerived> tmp(derived());
  tmp = other.derived();
  return derived();
}
# 348 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/ArrayWrapper.h" 1
# 39 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/ArrayWrapper.h"
namespace internal {
template<typename ExpressionType>
struct traits<ArrayWrapper<ExpressionType> >
  : public traits<typename remove_all<typename ExpressionType::Nested>::type >
{
  typedef ArrayXpr XprKind;
};
}

template<typename ExpressionType>
class ArrayWrapper : public ArrayBase<ArrayWrapper<ExpressionType> >
{
  public:
    typedef ArrayBase<ArrayWrapper> Base;
    typedef typename Eigen::internal::traits<ArrayWrapper>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<ArrayWrapper>::type Nested; typedef typename Eigen::internal::traits<ArrayWrapper>::StorageKind StorageKind; typedef typename Eigen::internal::traits<ArrayWrapper>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<ArrayWrapper>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<ArrayWrapper>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<ArrayWrapper>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<ArrayWrapper>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<ArrayWrapper>::Flags, CoeffReadCost = Eigen::internal::traits<ArrayWrapper>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived;
    using Base::operator =; inline ArrayWrapper& operator=(const ArrayWrapper& other) { Base::operator=(other); return *this; }

    typedef typename internal::conditional<
                       internal::is_lvalue<ExpressionType>::value,
                       Scalar,
                       const Scalar
                     >::type ScalarWithConstIfNotLvalue;

    typedef typename internal::nested<ExpressionType>::type NestedExpressionType;

    inline ArrayWrapper(const ExpressionType& matrix) : m_expression(matrix) {}

    inline Index rows() const { return m_expression.rows(); }
    inline Index cols() const { return m_expression.cols(); }
    inline Index outerStride() const { return m_expression.outerStride(); }
    inline Index innerStride() const { return m_expression.innerStride(); }

    inline ScalarWithConstIfNotLvalue* data() { return m_expression.data(); }
    inline const Scalar* data() const { return m_expression.data(); }

    inline const CoeffReturnType coeff(Index row, Index col) const
    {
      return m_expression.coeff(row, col);
    }

    inline Scalar& coeffRef(Index row, Index col)
    {
      return m_expression.const_cast_derived().coeffRef(row, col);
    }

    inline const Scalar& coeffRef(Index row, Index col) const
    {
      return m_expression.const_cast_derived().coeffRef(row, col);
    }

    inline const CoeffReturnType coeff(Index index) const
    {
      return m_expression.coeff(index);
    }

    inline Scalar& coeffRef(Index index)
    {
      return m_expression.const_cast_derived().coeffRef(index);
    }

    inline const Scalar& coeffRef(Index index) const
    {
      return m_expression.const_cast_derived().coeffRef(index);
    }

    template<int LoadMode>
    inline const PacketScalar packet(Index row, Index col) const
    {
      return m_expression.template packet<LoadMode>(row, col);
    }

    template<int LoadMode>
    inline void writePacket(Index row, Index col, const PacketScalar& x)
    {
      m_expression.const_cast_derived().template writePacket<LoadMode>(row, col, x);
    }

    template<int LoadMode>
    inline const PacketScalar packet(Index index) const
    {
      return m_expression.template packet<LoadMode>(index);
    }

    template<int LoadMode>
    inline void writePacket(Index index, const PacketScalar& x)
    {
      m_expression.const_cast_derived().template writePacket<LoadMode>(index, x);
    }

    template<typename Dest>
    inline void evalTo(Dest& dst) const { dst = m_expression; }

  protected:
    const NestedExpressionType m_expression;
};
# 146 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/ArrayWrapper.h"
namespace internal {
template<typename ExpressionType>
struct traits<MatrixWrapper<ExpressionType> >
 : public traits<typename remove_all<typename ExpressionType::Nested>::type >
{
  typedef MatrixXpr XprKind;
};
}

template<typename ExpressionType>
class MatrixWrapper : public MatrixBase<MatrixWrapper<ExpressionType> >
{
  public:
    typedef MatrixBase<MatrixWrapper<ExpressionType> > Base;
    typedef typename Eigen::internal::traits<MatrixWrapper>::Scalar Scalar; typedef typename Eigen::NumTraits<Scalar>::Real RealScalar; typedef typename Base::PacketScalar PacketScalar; typedef typename Base::CoeffReturnType CoeffReturnType; typedef typename Eigen::internal::nested<MatrixWrapper>::type Nested; typedef typename Eigen::internal::traits<MatrixWrapper>::StorageKind StorageKind; typedef typename Eigen::internal::traits<MatrixWrapper>::Index Index; enum { RowsAtCompileTime = Eigen::internal::traits<MatrixWrapper>::RowsAtCompileTime, ColsAtCompileTime = Eigen::internal::traits<MatrixWrapper>::ColsAtCompileTime, MaxRowsAtCompileTime = Eigen::internal::traits<MatrixWrapper>::MaxRowsAtCompileTime, MaxColsAtCompileTime = Eigen::internal::traits<MatrixWrapper>::MaxColsAtCompileTime, Flags = Eigen::internal::traits<MatrixWrapper>::Flags, CoeffReadCost = Eigen::internal::traits<MatrixWrapper>::CoeffReadCost, SizeAtCompileTime = Base::SizeAtCompileTime, MaxSizeAtCompileTime = Base::MaxSizeAtCompileTime, IsVectorAtCompileTime = Base::IsVectorAtCompileTime }; using Base::derived; using Base::const_cast_derived;
    using Base::operator =; inline MatrixWrapper& operator=(const MatrixWrapper& other) { Base::operator=(other); return *this; }

    typedef typename internal::conditional<
                       internal::is_lvalue<ExpressionType>::value,
                       Scalar,
                       const Scalar
                     >::type ScalarWithConstIfNotLvalue;

    typedef typename internal::nested<ExpressionType>::type NestedExpressionType;

    inline MatrixWrapper(const ExpressionType& matrix) : m_expression(matrix) {}

    inline Index rows() const { return m_expression.rows(); }
    inline Index cols() const { return m_expression.cols(); }
    inline Index outerStride() const { return m_expression.outerStride(); }
    inline Index innerStride() const { return m_expression.innerStride(); }

    inline ScalarWithConstIfNotLvalue* data() { return m_expression.data(); }
    inline const Scalar* data() const { return m_expression.data(); }

    inline const CoeffReturnType coeff(Index row, Index col) const
    {
      return m_expression.coeff(row, col);
    }

    inline Scalar& coeffRef(Index row, Index col)
    {
      return m_expression.const_cast_derived().coeffRef(row, col);
    }

    inline const Scalar& coeffRef(Index row, Index col) const
    {
      return m_expression.derived().coeffRef(row, col);
    }

    inline const CoeffReturnType coeff(Index index) const
    {
      return m_expression.coeff(index);
    }

    inline Scalar& coeffRef(Index index)
    {
      return m_expression.const_cast_derived().coeffRef(index);
    }

    inline const Scalar& coeffRef(Index index) const
    {
      return m_expression.const_cast_derived().coeffRef(index);
    }

    template<int LoadMode>
    inline const PacketScalar packet(Index row, Index col) const
    {
      return m_expression.template packet<LoadMode>(row, col);
    }

    template<int LoadMode>
    inline void writePacket(Index row, Index col, const PacketScalar& x)
    {
      m_expression.const_cast_derived().template writePacket<LoadMode>(row, col, x);
    }

    template<int LoadMode>
    inline const PacketScalar packet(Index index) const
    {
      return m_expression.template packet<LoadMode>(index);
    }

    template<int LoadMode>
    inline void writePacket(Index index, const PacketScalar& x)
    {
      m_expression.const_cast_derived().template writePacket<LoadMode>(index, x);
    }

  protected:
    const NestedExpressionType m_expression;
};
# 349 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2

}


# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/GlobalFunctions.h" 1
# 53 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/GlobalFunctions.h"
namespace std
{
  template<typename Derived> inline const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<typename Derived::Scalar>, const Derived> real(const Eigen::ArrayBase<Derived>& x) { return x.derived(); }
  template<typename Derived> inline const Eigen::CwiseUnaryOp<Eigen::internal::scalar_imag_op<typename Derived::Scalar>, const Derived> imag(const Eigen::ArrayBase<Derived>& x) { return x.derived(); }
  template<typename Derived> inline const Eigen::CwiseUnaryOp<Eigen::internal::scalar_sin_op<typename Derived::Scalar>, const Derived> sin(const Eigen::ArrayBase<Derived>& x) { return x.derived(); }
  template<typename Derived> inline const Eigen::CwiseUnaryOp<Eigen::internal::scalar_cos_op<typename Derived::Scalar>, const Derived> cos(const Eigen::ArrayBase<Derived>& x) { return x.derived(); }
  template<typename Derived> inline const Eigen::CwiseUnaryOp<Eigen::internal::scalar_asin_op<typename Derived::Scalar>, const Derived> asin(const Eigen::ArrayBase<Derived>& x) { return x.derived(); }
  template<typename Derived> inline const Eigen::CwiseUnaryOp<Eigen::internal::scalar_acos_op<typename Derived::Scalar>, const Derived> acos(const Eigen::ArrayBase<Derived>& x) { return x.derived(); }
  template<typename Derived> inline const Eigen::CwiseUnaryOp<Eigen::internal::scalar_tan_op<typename Derived::Scalar>, const Derived> tan(const Eigen::ArrayBase<Derived>& x) { return x.derived(); }
  template<typename Derived> inline const Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<typename Derived::Scalar>, const Derived> exp(const Eigen::ArrayBase<Derived>& x) { return x.derived(); }
  template<typename Derived> inline const Eigen::CwiseUnaryOp<Eigen::internal::scalar_log_op<typename Derived::Scalar>, const Derived> log(const Eigen::ArrayBase<Derived>& x) { return x.derived(); }
  template<typename Derived> inline const Eigen::CwiseUnaryOp<Eigen::internal::scalar_abs_op<typename Derived::Scalar>, const Derived> abs(const Eigen::ArrayBase<Derived>& x) { return x.derived(); }
  template<typename Derived> inline const Eigen::CwiseUnaryOp<Eigen::internal::scalar_sqrt_op<typename Derived::Scalar>, const Derived> sqrt(const Eigen::ArrayBase<Derived>& x) { return x.derived(); }

  template<typename Derived>
  inline const Eigen::CwiseUnaryOp<Eigen::internal::scalar_pow_op<typename Derived::Scalar>, const Derived>
  pow(const Eigen::ArrayBase<Derived>& x, const typename Derived::Scalar& exponent) { return x.derived().pow(exponent); }


}

namespace Eigen
{
  namespace internal
  {
    template<typename Derived> struct real_retval<ArrayBase<Derived> > { typedef const Eigen::CwiseUnaryOp<Eigen::internal::scalar_real_op<typename Derived::Scalar>, const Derived> type; }; template<typename Derived> struct real_impl<ArrayBase<Derived> > { static inline typename real_retval<ArrayBase<Derived> >::type run(const Eigen::ArrayBase<Derived>& x) { return x.derived(); } };
    template<typename Derived> struct imag_retval<ArrayBase<Derived> > { typedef const Eigen::CwiseUnaryOp<Eigen::internal::scalar_imag_op<typename Derived::Scalar>, const Derived> type; }; template<typename Derived> struct imag_impl<ArrayBase<Derived> > { static inline typename imag_retval<ArrayBase<Derived> >::type run(const Eigen::ArrayBase<Derived>& x) { return x.derived(); } };
    template<typename Derived> struct sin_retval<ArrayBase<Derived> > { typedef const Eigen::CwiseUnaryOp<Eigen::internal::scalar_sin_op<typename Derived::Scalar>, const Derived> type; }; template<typename Derived> struct sin_impl<ArrayBase<Derived> > { static inline typename sin_retval<ArrayBase<Derived> >::type run(const Eigen::ArrayBase<Derived>& x) { return x.derived(); } };
    template<typename Derived> struct cos_retval<ArrayBase<Derived> > { typedef const Eigen::CwiseUnaryOp<Eigen::internal::scalar_cos_op<typename Derived::Scalar>, const Derived> type; }; template<typename Derived> struct cos_impl<ArrayBase<Derived> > { static inline typename cos_retval<ArrayBase<Derived> >::type run(const Eigen::ArrayBase<Derived>& x) { return x.derived(); } };
    template<typename Derived> struct asin_retval<ArrayBase<Derived> > { typedef const Eigen::CwiseUnaryOp<Eigen::internal::scalar_asin_op<typename Derived::Scalar>, const Derived> type; }; template<typename Derived> struct asin_impl<ArrayBase<Derived> > { static inline typename asin_retval<ArrayBase<Derived> >::type run(const Eigen::ArrayBase<Derived>& x) { return x.derived(); } };
    template<typename Derived> struct acos_retval<ArrayBase<Derived> > { typedef const Eigen::CwiseUnaryOp<Eigen::internal::scalar_acos_op<typename Derived::Scalar>, const Derived> type; }; template<typename Derived> struct acos_impl<ArrayBase<Derived> > { static inline typename acos_retval<ArrayBase<Derived> >::type run(const Eigen::ArrayBase<Derived>& x) { return x.derived(); } };
    template<typename Derived> struct tan_retval<ArrayBase<Derived> > { typedef const Eigen::CwiseUnaryOp<Eigen::internal::scalar_tan_op<typename Derived::Scalar>, const Derived> type; }; template<typename Derived> struct tan_impl<ArrayBase<Derived> > { static inline typename tan_retval<ArrayBase<Derived> >::type run(const Eigen::ArrayBase<Derived>& x) { return x.derived(); } };
    template<typename Derived> struct exp_retval<ArrayBase<Derived> > { typedef const Eigen::CwiseUnaryOp<Eigen::internal::scalar_exp_op<typename Derived::Scalar>, const Derived> type; }; template<typename Derived> struct exp_impl<ArrayBase<Derived> > { static inline typename exp_retval<ArrayBase<Derived> >::type run(const Eigen::ArrayBase<Derived>& x) { return x.derived(); } };
    template<typename Derived> struct log_retval<ArrayBase<Derived> > { typedef const Eigen::CwiseUnaryOp<Eigen::internal::scalar_log_op<typename Derived::Scalar>, const Derived> type; }; template<typename Derived> struct log_impl<ArrayBase<Derived> > { static inline typename log_retval<ArrayBase<Derived> >::type run(const Eigen::ArrayBase<Derived>& x) { return x.derived(); } };
    template<typename Derived> struct abs_retval<ArrayBase<Derived> > { typedef const Eigen::CwiseUnaryOp<Eigen::internal::scalar_abs_op<typename Derived::Scalar>, const Derived> type; }; template<typename Derived> struct abs_impl<ArrayBase<Derived> > { static inline typename abs_retval<ArrayBase<Derived> >::type run(const Eigen::ArrayBase<Derived>& x) { return x.derived(); } };
    template<typename Derived> struct abs2_retval<ArrayBase<Derived> > { typedef const Eigen::CwiseUnaryOp<Eigen::internal::scalar_abs2_op<typename Derived::Scalar>, const Derived> type; }; template<typename Derived> struct abs2_impl<ArrayBase<Derived> > { static inline typename abs2_retval<ArrayBase<Derived> >::type run(const Eigen::ArrayBase<Derived>& x) { return x.derived(); } };
    template<typename Derived> struct sqrt_retval<ArrayBase<Derived> > { typedef const Eigen::CwiseUnaryOp<Eigen::internal::scalar_sqrt_op<typename Derived::Scalar>, const Derived> type; }; template<typename Derived> struct sqrt_impl<ArrayBase<Derived> > { static inline typename sqrt_retval<ArrayBase<Derived> >::type run(const Eigen::ArrayBase<Derived>& x) { return x.derived(); } };
  }
}
# 353 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2

# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/ReenableStupidWarnings.h" 1
# 355 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Core" 2
# 5 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/QR" 2

# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/DisableStupidWarnings.h" 1
# 39 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/DisableStupidWarnings.h"
#pragma clang diagnostic ignored "-Wconstant-logical-operand"
# 7 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/QR" 2

# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Cholesky" 1







namespace Eigen {
# 24 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Cholesky"
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/misc/Solve.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/misc/Solve.h"
namespace internal {




template<typename DecompositionType, typename Rhs>
struct traits<solve_retval_base<DecompositionType, Rhs> >
{
  typedef typename DecompositionType::MatrixType MatrixType;
  typedef Matrix<typename Rhs::Scalar,
                 MatrixType::ColsAtCompileTime,
                 Rhs::ColsAtCompileTime,
                 Rhs::PlainObject::Options,
                 MatrixType::MaxColsAtCompileTime,
                 Rhs::MaxColsAtCompileTime> ReturnType;
};

template<typename _DecompositionType, typename Rhs> struct solve_retval_base
 : public ReturnByValue<solve_retval_base<_DecompositionType, Rhs> >
{
  typedef typename remove_all<typename Rhs::Nested>::type RhsNestedCleaned;
  typedef _DecompositionType DecompositionType;
  typedef ReturnByValue<solve_retval_base> Base;
  typedef typename Base::Index Index;

  solve_retval_base(const DecompositionType& dec, const Rhs& rhs)
    : m_dec(dec), m_rhs(rhs)
  {}

  inline Index rows() const { return m_dec.cols(); }
  inline Index cols() const { return m_rhs.cols(); }
  inline const DecompositionType& dec() const { return m_dec; }
  inline const RhsNestedCleaned& rhs() const { return m_rhs; }

  template<typename Dest> inline void evalTo(Dest& dst) const
  {
    static_cast<const solve_retval<DecompositionType,Rhs>*>(this)->evalTo(dst);
  }

  protected:
    const DecompositionType& m_dec;
    const typename Rhs::Nested m_rhs;
};

}
# 25 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Cholesky" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LLT.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LLT.h"
namespace internal{
template<typename MatrixType, int UpLo> struct LLT_Traits;
}
# 58 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LLT.h"
template<typename _MatrixType, int _UpLo> class LLT
{
  public:
    typedef _MatrixType MatrixType;
    enum {
      RowsAtCompileTime = MatrixType::RowsAtCompileTime,
      ColsAtCompileTime = MatrixType::ColsAtCompileTime,
      Options = MatrixType::Options,
      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
    };
    typedef typename MatrixType::Scalar Scalar;
    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;
    typedef typename MatrixType::Index Index;

    enum {
      PacketSize = internal::packet_traits<Scalar>::size,
      AlignmentMask = int(PacketSize)-1,
      UpLo = _UpLo
    };

    typedef internal::LLT_Traits<MatrixType,UpLo> Traits;







    LLT() : m_matrix(), m_isInitialized(false) {}







    LLT(Index size) : m_matrix(size, size),
                    m_isInitialized(false) {}

    LLT(const MatrixType& matrix)
      : m_matrix(matrix.rows(), matrix.cols()),
        m_isInitialized(false)
    {
      compute(matrix);
    }


    inline typename Traits::MatrixU matrixU() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "LLT is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LLT is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LLT is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LLT.h", 107); } while(false); else throw Eigen::eigen_assert_exception(); };
      return Traits::getU(m_matrix);
    }


    inline typename Traits::MatrixL matrixL() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "LLT is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LLT is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LLT is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LLT.h", 114); } while(false); else throw Eigen::eigen_assert_exception(); };
      return Traits::getL(m_matrix);
    }
# 128 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LLT.h"
    template<typename Rhs>
    inline const internal::solve_retval<LLT, Rhs>
    solve(const MatrixBase<Rhs>& b) const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "LLT is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LLT is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LLT is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LLT.h", 132); } while(false); else throw Eigen::eigen_assert_exception(); };
      if( (!Eigen::internal::copy_bool(m_matrix.rows()==b.rows() && "LLT::solve(): invalid number of rows of the right hand side matrix b")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_matrix.rows()==b.rows() && "LLT::solve(): invalid number of rows of the right hand side matrix b")) Eigen::internal::assert_fail("m_matrix.rows()==b.rows() && \"LLT::solve(): invalid number of rows of the right hand side matrix b\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LLT.h", 134); } while(false); else throw Eigen::eigen_assert_exception(); };

      return internal::solve_retval<LLT, Rhs>(*this, b.derived());
    }
# 149 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LLT.h"
    template<typename Derived>
    void solveInPlace(MatrixBase<Derived> &bAndX) const;

    LLT& compute(const MatrixType& matrix);





    inline const MatrixType& matrixLLT() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "LLT is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LLT is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LLT is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LLT.h", 160); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_matrix;
    }

    MatrixType reconstructedMatrix() const;







    ComputationInfo info() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "LLT is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LLT is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LLT is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LLT.h", 174); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_info;
    }

    inline Index rows() const { return m_matrix.rows(); }
    inline Index cols() const { return m_matrix.cols(); }

  protected:




    MatrixType m_matrix;
    bool m_isInitialized;
    ComputationInfo m_info;
};

namespace internal {

template<int UpLo> struct llt_inplace;

template<> struct llt_inplace<Lower>
{
  template<typename MatrixType>
  static typename MatrixType::Index unblocked(MatrixType& mat)
  {
    typedef typename MatrixType::Index Index;
    typedef typename MatrixType::Scalar Scalar;
    typedef typename MatrixType::RealScalar RealScalar;

    if( (!Eigen::internal::copy_bool(mat.rows()==mat.cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(mat.rows()==mat.cols())) Eigen::internal::assert_fail("mat.rows()==mat.cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LLT.h", 204); } while(false); else throw Eigen::eigen_assert_exception(); };
    const Index size = mat.rows();
    for(Index k = 0; k < size; ++k)
    {
      Index rs = size-k-1;

      Block<MatrixType,Dynamic,1> A21(mat,k+1,k,rs,1);
      Block<MatrixType,1,Dynamic> A10(mat,k,0,1,k);
      Block<MatrixType,Dynamic,Dynamic> A20(mat,k+1,0,rs,k);

      RealScalar x = real(mat.coeff(k,k));
      if (k>0) x -= A10.squaredNorm();
      if (x<=RealScalar(0))
        return k;
      mat.coeffRef(k,k) = x = sqrt(x);
      if (k>0 && rs>0) A21.noalias() -= A20 * A10.adjoint();
      if (rs>0) A21 *= RealScalar(1)/x;
    }
    return -1;
  }

  template<typename MatrixType>
  static typename MatrixType::Index blocked(MatrixType& m)
  {
    typedef typename MatrixType::Index Index;
    if( (!Eigen::internal::copy_bool(m.rows()==m.cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m.rows()==m.cols())) Eigen::internal::assert_fail("m.rows()==m.cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LLT.h", 229); } while(false); else throw Eigen::eigen_assert_exception(); };
    Index size = m.rows();
    if(size<32)
      return unblocked(m);

    Index blockSize = size/8;
    blockSize = (blockSize/16)*16;
    blockSize = (std::min)((std::max)(blockSize,Index(8)), Index(128));

    for (Index k=0; k<size; k+=blockSize)
    {




      Index bs = (std::min)(blockSize, size-k);
      Index rs = size - k - bs;
      Block<MatrixType,Dynamic,Dynamic> A11(m,k, k, bs,bs);
      Block<MatrixType,Dynamic,Dynamic> A21(m,k+bs,k, rs,bs);
      Block<MatrixType,Dynamic,Dynamic> A22(m,k+bs,k+bs,rs,rs);

      Index ret;
      if((ret=unblocked(A11))>=0) return k+ret;
      if(rs>0) A11.adjoint().template triangularView<Upper>().template solveInPlace<OnTheRight>(A21);
      if(rs>0) A22.template selfadjointView<Lower>().rankUpdate(A21,-1);
    }
    return -1;
  }
};

template<> struct llt_inplace<Upper>
{
  template<typename MatrixType>
  static inline typename MatrixType::Index unblocked(MatrixType& mat)
  {
    Transpose<MatrixType> matt(mat);
    return llt_inplace<Lower>::unblocked(matt);
  }
  template<typename MatrixType>
  static inline typename MatrixType::Index blocked(MatrixType& mat)
  {
    Transpose<MatrixType> matt(mat);
    return llt_inplace<Lower>::blocked(matt);
  }
};

template<typename MatrixType> struct LLT_Traits<MatrixType,Lower>
{
  typedef TriangularView<MatrixType, Lower> MatrixL;
  typedef TriangularView<typename MatrixType::AdjointReturnType, Upper> MatrixU;
  inline static MatrixL getL(const MatrixType& m) { return m; }
  inline static MatrixU getU(const MatrixType& m) { return m.adjoint(); }
  static bool inplace_decomposition(MatrixType& m)
  { return llt_inplace<Lower>::blocked(m)==-1; }
};

template<typename MatrixType> struct LLT_Traits<MatrixType,Upper>
{
  typedef TriangularView<typename MatrixType::AdjointReturnType, Lower> MatrixL;
  typedef TriangularView<MatrixType, Upper> MatrixU;
  inline static MatrixL getL(const MatrixType& m) { return m.adjoint(); }
  inline static MatrixU getU(const MatrixType& m) { return m; }
  static bool inplace_decomposition(MatrixType& m)
  { return llt_inplace<Upper>::blocked(m)==-1; }
};

}






template<typename MatrixType, int _UpLo>
LLT<MatrixType,_UpLo>& LLT<MatrixType,_UpLo>::compute(const MatrixType& a)
{
  ((a.rows()==a.cols()) ? static_cast<void> (0) : __assert_fail ("a.rows()==a.cols()", "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LLT.h", 305, __PRETTY_FUNCTION__));
  const Index size = a.rows();
  m_matrix.resize(size, size);
  m_matrix = a;

  m_isInitialized = true;
  bool ok = Traits::inplace_decomposition(m_matrix);
  m_info = ok ? Success : NumericalIssue;

  return *this;
}

namespace internal {
template<typename _MatrixType, int UpLo, typename Rhs>
struct solve_retval<LLT<_MatrixType, UpLo>, Rhs>
  : solve_retval_base<LLT<_MatrixType, UpLo>, Rhs>
{
  typedef LLT<_MatrixType,UpLo> LLTType;
  typedef typename LLTType::MatrixType MatrixType; typedef typename MatrixType::Scalar Scalar; typedef typename MatrixType::RealScalar RealScalar; typedef typename MatrixType::Index Index; typedef Eigen::internal::solve_retval_base<LLTType,Rhs> Base; using Base::dec; using Base::rhs; using Base::rows; using Base::cols; solve_retval(const LLTType& dec, const Rhs& rhs) : Base(dec, rhs) {}

  template<typename Dest> void evalTo(Dest& dst) const
  {
    dst = rhs();
    dec().solveInPlace(dst);
  }
};
}
# 346 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LLT.h"
template<typename MatrixType, int _UpLo>
template<typename Derived>
void LLT<MatrixType,_UpLo>::solveInPlace(MatrixBase<Derived> &bAndX) const
{
  if( (!Eigen::internal::copy_bool(m_isInitialized && "LLT is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LLT is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LLT is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LLT.h", 350); } while(false); else throw Eigen::eigen_assert_exception(); };
  if( (!Eigen::internal::copy_bool(m_matrix.rows()==bAndX.rows())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_matrix.rows()==bAndX.rows())) Eigen::internal::assert_fail("m_matrix.rows()==bAndX.rows()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LLT.h", 351); } while(false); else throw Eigen::eigen_assert_exception(); };
  matrixL().solveInPlace(bAndX);
  matrixU().solveInPlace(bAndX);
}




template<typename MatrixType, int _UpLo>
MatrixType LLT<MatrixType,_UpLo>::reconstructedMatrix() const
{
  if( (!Eigen::internal::copy_bool(m_isInitialized && "LLT is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LLT is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LLT is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LLT.h", 362); } while(false); else throw Eigen::eigen_assert_exception(); };
  return matrixL() * matrixL().adjoint().toDenseMatrix();
}




template<typename Derived>
inline const LLT<typename MatrixBase<Derived>::PlainObject>
MatrixBase<Derived>::llt() const
{
  return LLT<PlainObject>(derived());
}




template<typename MatrixType, unsigned int UpLo>
inline const LLT<typename SelfAdjointView<MatrixType, UpLo>::PlainObject, UpLo>
SelfAdjointView<MatrixType, UpLo>::llt() const
{
  return LLT<PlainObject,UpLo>(m_matrix);
}
# 26 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Cholesky" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LDLT.h" 1
# 30 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LDLT.h"
namespace internal {
template<typename MatrixType, int UpLo> struct LDLT_Traits;
}
# 59 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LDLT.h"
template<typename _MatrixType, int _UpLo> class LDLT
{
  public:
    typedef _MatrixType MatrixType;
    enum {
      RowsAtCompileTime = MatrixType::RowsAtCompileTime,
      ColsAtCompileTime = MatrixType::ColsAtCompileTime,
      Options = MatrixType::Options & ~RowMajorBit,
      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,
      UpLo = _UpLo
    };
    typedef typename MatrixType::Scalar Scalar;
    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;
    typedef typename MatrixType::Index Index;
    typedef Matrix<Scalar, RowsAtCompileTime, 1, Options, MaxRowsAtCompileTime, 1> TmpMatrixType;

    typedef Transpositions<RowsAtCompileTime, MaxRowsAtCompileTime> TranspositionType;
    typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationType;

    typedef internal::LDLT_Traits<MatrixType,UpLo> Traits;






    LDLT() : m_matrix(), m_transpositions(), m_isInitialized(false) {}







    LDLT(Index size)
      : m_matrix(size, size),
        m_transpositions(size),
        m_temporary(size),
        m_isInitialized(false)
    {}

    LDLT(const MatrixType& matrix)
      : m_matrix(matrix.rows(), matrix.cols()),
        m_transpositions(matrix.rows()),
        m_temporary(matrix.rows()),
        m_isInitialized(false)
    {
      compute(matrix);
    }


    inline typename Traits::MatrixU matrixU() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "LDLT is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LDLT is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LDLT is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LDLT.h", 113); } while(false); else throw Eigen::eigen_assert_exception(); };
      return Traits::getU(m_matrix);
    }


    inline typename Traits::MatrixL matrixL() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "LDLT is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LDLT is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LDLT is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LDLT.h", 120); } while(false); else throw Eigen::eigen_assert_exception(); };
      return Traits::getL(m_matrix);
    }



    inline const TranspositionType& transpositionsP() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "LDLT is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LDLT is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LDLT is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LDLT.h", 128); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_transpositions;
    }


    inline Diagonal<const MatrixType> vectorD(void) const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "LDLT is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LDLT is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LDLT is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LDLT.h", 135); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_matrix.diagonal();
    }


    inline bool isPositive(void) const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "LDLT is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LDLT is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LDLT is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LDLT.h", 142); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_sign == 1;
    }
# 154 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LDLT.h"
    inline bool isNegative(void) const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "LDLT is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LDLT is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LDLT is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LDLT.h", 156); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_sign == -1;
    }
# 175 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LDLT.h"
    template<typename Rhs>
    inline const internal::solve_retval<LDLT, Rhs>
    solve(const MatrixBase<Rhs>& b) const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "LDLT is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LDLT is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LDLT is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LDLT.h", 179); } while(false); else throw Eigen::eigen_assert_exception(); };
      if( (!Eigen::internal::copy_bool(m_matrix.rows()==b.rows() && "LDLT::solve(): invalid number of rows of the right hand side matrix b")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_matrix.rows()==b.rows() && "LDLT::solve(): invalid number of rows of the right hand side matrix b")) Eigen::internal::assert_fail("m_matrix.rows()==b.rows() && \"LDLT::solve(): invalid number of rows of the right hand side matrix b\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LDLT.h", 181); } while(false); else throw Eigen::eigen_assert_exception(); };

      return internal::solve_retval<LDLT, Rhs>(*this, b.derived());
    }
# 194 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LDLT.h"
    template<typename Derived>
    bool solveInPlace(MatrixBase<Derived> &bAndX) const;

    LDLT& compute(const MatrixType& matrix);





    inline const MatrixType& matrixLDLT() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "LDLT is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LDLT is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LDLT is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LDLT.h", 205); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_matrix;
    }

    MatrixType reconstructedMatrix() const;

    inline Index rows() const { return m_matrix.rows(); }
    inline Index cols() const { return m_matrix.cols(); }

  protected:







    MatrixType m_matrix;
    TranspositionType m_transpositions;
    TmpMatrixType m_temporary;
    int m_sign;
    bool m_isInitialized;
};

namespace internal {

template<int UpLo> struct ldlt_inplace;

template<> struct ldlt_inplace<Lower>
{
  template<typename MatrixType, typename TranspositionType, typename Workspace>
  static bool unblocked(MatrixType& mat, TranspositionType& transpositions, Workspace& temp, int* sign=0)
  {
    typedef typename MatrixType::Scalar Scalar;
    typedef typename MatrixType::RealScalar RealScalar;
    typedef typename MatrixType::Index Index;
    if( (!Eigen::internal::copy_bool(mat.rows()==mat.cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(mat.rows()==mat.cols())) Eigen::internal::assert_fail("mat.rows()==mat.cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LDLT.h", 241); } while(false); else throw Eigen::eigen_assert_exception(); };
    const Index size = mat.rows();

    if (size <= 1)
    {
      transpositions.setIdentity();
      if(sign)
        *sign = real(mat.coeff(0,0))>0 ? 1:-1;
      return true;
    }

    RealScalar cutoff = 0, biggest_in_corner;

    for (Index k = 0; k < size; ++k)
    {

      Index index_of_biggest_in_corner;
      biggest_in_corner = mat.diagonal().tail(size-k).cwiseAbs().maxCoeff(&index_of_biggest_in_corner);
      index_of_biggest_in_corner += k;

      if(k == 0)
      {



        cutoff = abs(NumTraits<Scalar>::epsilon() * biggest_in_corner);

        if(sign)
          *sign = real(mat.diagonal().coeff(index_of_biggest_in_corner)) > 0 ? 1 : -1;
      }


      if(biggest_in_corner < cutoff)
      {
        for(Index i = k; i < size; i++) transpositions.coeffRef(i) = i;
        break;
      }

      transpositions.coeffRef(k) = index_of_biggest_in_corner;
      if(k != index_of_biggest_in_corner)
      {


        Index s = size-index_of_biggest_in_corner-1;
        mat.row(k).head(k).swap(mat.row(index_of_biggest_in_corner).head(k));
        mat.col(k).tail(s).swap(mat.col(index_of_biggest_in_corner).tail(s));
        std::swap(mat.coeffRef(k,k),mat.coeffRef(index_of_biggest_in_corner,index_of_biggest_in_corner));
        for(int i=k+1;i<index_of_biggest_in_corner;++i)
        {
          Scalar tmp = mat.coeffRef(i,k);
          mat.coeffRef(i,k) = conj(mat.coeffRef(index_of_biggest_in_corner,i));
          mat.coeffRef(index_of_biggest_in_corner,i) = conj(tmp);
        }
        if(NumTraits<Scalar>::IsComplex)
          mat.coeffRef(index_of_biggest_in_corner,k) = conj(mat.coeff(index_of_biggest_in_corner,k));
      }





      Index rs = size - k - 1;
      Block<MatrixType,Dynamic,1> A21(mat,k+1,k,rs,1);
      Block<MatrixType,1,Dynamic> A10(mat,k,0,1,k);
      Block<MatrixType,Dynamic,Dynamic> A20(mat,k+1,0,rs,k);

      if(k>0)
      {
        temp.head(k) = mat.diagonal().head(k).asDiagonal() * A10.adjoint();
        mat.coeffRef(k,k) -= (A10 * temp.head(k)).value();
        if(rs>0)
          A21.noalias() -= A20 * temp.head(k);
      }
      if((rs>0) && (abs(mat.coeffRef(k,k)) > cutoff))
        A21 /= mat.coeffRef(k,k);
    }

    return true;
  }
};

template<> struct ldlt_inplace<Upper>
{
  template<typename MatrixType, typename TranspositionType, typename Workspace>
  static inline bool unblocked(MatrixType& mat, TranspositionType& transpositions, Workspace& temp, int* sign=0)
  {
    Transpose<MatrixType> matt(mat);
    return ldlt_inplace<Lower>::unblocked(matt, transpositions, temp, sign);
  }
};

template<typename MatrixType> struct LDLT_Traits<MatrixType,Lower>
{
  typedef TriangularView<MatrixType, UnitLower> MatrixL;
  typedef TriangularView<typename MatrixType::AdjointReturnType, UnitUpper> MatrixU;
  inline static MatrixL getL(const MatrixType& m) { return m; }
  inline static MatrixU getU(const MatrixType& m) { return m.adjoint(); }
};

template<typename MatrixType> struct LDLT_Traits<MatrixType,Upper>
{
  typedef TriangularView<typename MatrixType::AdjointReturnType, UnitLower> MatrixL;
  typedef TriangularView<MatrixType, UnitUpper> MatrixU;
  inline static MatrixL getL(const MatrixType& m) { return m.adjoint(); }
  inline static MatrixU getU(const MatrixType& m) { return m; }
};

}



template<typename MatrixType, int _UpLo>
LDLT<MatrixType,_UpLo>& LDLT<MatrixType,_UpLo>::compute(const MatrixType& a)
{
  if( (!Eigen::internal::copy_bool(a.rows()==a.cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(a.rows()==a.cols())) Eigen::internal::assert_fail("a.rows()==a.cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LDLT.h", 355); } while(false); else throw Eigen::eigen_assert_exception(); };
  const Index size = a.rows();

  m_matrix = a;

  m_transpositions.resize(size);
  m_isInitialized = false;
  m_temporary.resize(size);

  internal::ldlt_inplace<UpLo>::unblocked(m_matrix, m_transpositions, m_temporary, &m_sign);

  m_isInitialized = true;
  return *this;
}

namespace internal {
template<typename _MatrixType, int _UpLo, typename Rhs>
struct solve_retval<LDLT<_MatrixType,_UpLo>, Rhs>
  : solve_retval_base<LDLT<_MatrixType,_UpLo>, Rhs>
{
  typedef LDLT<_MatrixType,_UpLo> LDLTType;
  typedef typename LDLTType::MatrixType MatrixType; typedef typename MatrixType::Scalar Scalar; typedef typename MatrixType::RealScalar RealScalar; typedef typename MatrixType::Index Index; typedef Eigen::internal::solve_retval_base<LDLTType,Rhs> Base; using Base::dec; using Base::rhs; using Base::rows; using Base::cols; solve_retval(const LDLTType& dec, const Rhs& rhs) : Base(dec, rhs) {}

  template<typename Dest> void evalTo(Dest& dst) const
  {
    if( (!Eigen::internal::copy_bool(rhs().rows() == dec().matrixLDLT().rows())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(rhs().rows() == dec().matrixLDLT().rows())) Eigen::internal::assert_fail("rhs().rows() == dec().matrixLDLT().rows()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LDLT.h", 380); } while(false); else throw Eigen::eigen_assert_exception(); };

    dst = dec().transpositionsP() * rhs();


    dec().matrixL().solveInPlace(dst);



    using std::abs;
    using std::max;
    typedef typename LDLTType::MatrixType MatrixType;
    typedef typename LDLTType::Scalar Scalar;
    typedef typename LDLTType::RealScalar RealScalar;
    const Diagonal<const MatrixType> vectorD = dec().vectorD();
    RealScalar tolerance = (max)(vectorD.array().abs().maxCoeff() * NumTraits<Scalar>::epsilon(),
     RealScalar(1) / NumTraits<RealScalar>::highest());
    for (Index i = 0; i < vectorD.size(); ++i) {
      if(abs(vectorD(i)) > tolerance)
 dst.row(i) /= vectorD(i);
      else
 dst.row(i).setZero();
    }


    dec().matrixU().solveInPlace(dst);


    dst = dec().transpositionsP().transpose() * dst;
  }
};
}
# 426 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LDLT.h"
template<typename MatrixType,int _UpLo>
template<typename Derived>
bool LDLT<MatrixType,_UpLo>::solveInPlace(MatrixBase<Derived> &bAndX) const
{
  if( (!Eigen::internal::copy_bool(m_isInitialized && "LDLT is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LDLT is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LDLT is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LDLT.h", 430); } while(false); else throw Eigen::eigen_assert_exception(); };
  const Index size = m_matrix.rows();
  if( (!Eigen::internal::copy_bool(size == bAndX.rows())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(size == bAndX.rows())) Eigen::internal::assert_fail("size == bAndX.rows()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LDLT.h", 432); } while(false); else throw Eigen::eigen_assert_exception(); };

  bAndX = this->solve(bAndX);

  return true;
}




template<typename MatrixType, int _UpLo>
MatrixType LDLT<MatrixType,_UpLo>::reconstructedMatrix() const
{
  if( (!Eigen::internal::copy_bool(m_isInitialized && "LDLT is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LDLT is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LDLT is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Cholesky/LDLT.h", 445); } while(false); else throw Eigen::eigen_assert_exception(); };
  const Index size = m_matrix.rows();
  MatrixType res(size,size);


  res.setIdentity();
  res = transpositionsP() * res;

  res = matrixU() * res;

  res = vectorD().asDiagonal() * res;

  res = matrixL() * res;

  res = transpositionsP().transpose() * res;

  return res;
}




template<typename MatrixType, unsigned int UpLo>
inline const LDLT<typename SelfAdjointView<MatrixType, UpLo>::PlainObject, UpLo>
SelfAdjointView<MatrixType, UpLo>::ldlt() const
{
  return LDLT<PlainObject,UpLo>(m_matrix);
}




template<typename Derived>
inline const LDLT<typename MatrixBase<Derived>::PlainObject>
MatrixBase<Derived>::ldlt() const
{
  return LDLT<PlainObject>(derived());
}
# 27 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Cholesky" 2

}


# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/ReenableStupidWarnings.h" 1
# 31 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Cholesky" 2
# 9 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/QR" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Jacobi" 1





# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/DisableStupidWarnings.h" 1
# 39 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/DisableStupidWarnings.h"
#pragma clang diagnostic ignored "-Wconstant-logical-operand"
# 7 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Jacobi" 2

namespace Eigen {
# 22 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Jacobi"
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Jacobi/Jacobi.h" 1
# 47 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Jacobi/Jacobi.h"
template<typename Scalar> class JacobiRotation
{
  public:
    typedef typename NumTraits<Scalar>::Real RealScalar;


    JacobiRotation() {}


    JacobiRotation(const Scalar& c, const Scalar& s) : m_c(c), m_s(s) {}

    Scalar& c() { return m_c; }
    Scalar c() const { return m_c; }
    Scalar& s() { return m_s; }
    Scalar s() const { return m_s; }


    JacobiRotation operator*(const JacobiRotation& other)
    {
      return JacobiRotation(m_c * other.m_c - internal::conj(m_s) * other.m_s,
                            internal::conj(m_c * internal::conj(other.m_s) + internal::conj(m_s) * internal::conj(other.m_c)));
    }


    JacobiRotation transpose() const { return JacobiRotation(m_c, -internal::conj(m_s)); }


    JacobiRotation adjoint() const { return JacobiRotation(internal::conj(m_c), -m_s); }

    template<typename Derived>
    bool makeJacobi(const MatrixBase<Derived>&, typename Derived::Index p, typename Derived::Index q);
    bool makeJacobi(RealScalar x, Scalar y, RealScalar z);

    void makeGivens(const Scalar& p, const Scalar& q, Scalar* z=0);

  protected:
    void makeGivens(const Scalar& p, const Scalar& q, Scalar* z, internal::true_type);
    void makeGivens(const Scalar& p, const Scalar& q, Scalar* z, internal::false_type);

    Scalar m_c, m_s;
};






template<typename Scalar>
bool JacobiRotation<Scalar>::makeJacobi(RealScalar x, Scalar y, RealScalar z)
{
  typedef typename NumTraits<Scalar>::Real RealScalar;
  if(y == Scalar(0))
  {
    m_c = Scalar(1);
    m_s = Scalar(0);
    return false;
  }
  else
  {
    RealScalar tau = (x-z)/(RealScalar(2)*internal::abs(y));
    RealScalar w = internal::sqrt(internal::abs2(tau) + RealScalar(1));
    RealScalar t;
    if(tau>RealScalar(0))
    {
      t = RealScalar(1) / (tau + w);
    }
    else
    {
      t = RealScalar(1) / (tau - w);
    }
    RealScalar sign_t = t > RealScalar(0) ? RealScalar(1) : RealScalar(-1);
    RealScalar n = RealScalar(1) / internal::sqrt(internal::abs2(t)+RealScalar(1));
    m_s = - sign_t * (internal::conj(y) / internal::abs(y)) * internal::abs(t) * n;
    m_c = n;
    return true;
  }
}
# 134 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Jacobi/Jacobi.h"
template<typename Scalar>
template<typename Derived>
inline bool JacobiRotation<Scalar>::makeJacobi(const MatrixBase<Derived>& m, typename Derived::Index p, typename Derived::Index q)
{
  return makeJacobi(internal::real(m.coeff(p,p)), m.coeff(p,q), internal::real(m.coeff(q,q)));
}
# 157 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Jacobi/Jacobi.h"
template<typename Scalar>
void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* z)
{
  makeGivens(p, q, z, typename internal::conditional<NumTraits<Scalar>::IsComplex, internal::true_type, internal::false_type>::type());
}



template<typename Scalar>
void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::true_type)
{
  if(q==Scalar(0))
  {
    m_c = internal::real(p)<0 ? Scalar(-1) : Scalar(1);
    m_s = 0;
    if(r) *r = m_c * p;
  }
  else if(p==Scalar(0))
  {
    m_c = 0;
    m_s = -q/internal::abs(q);
    if(r) *r = internal::abs(q);
  }
  else
  {
    RealScalar p1 = internal::norm1(p);
    RealScalar q1 = internal::norm1(q);
    if(p1>=q1)
    {
      Scalar ps = p / p1;
      RealScalar p2 = internal::abs2(ps);
      Scalar qs = q / p1;
      RealScalar q2 = internal::abs2(qs);

      RealScalar u = internal::sqrt(RealScalar(1) + q2/p2);
      if(internal::real(p)<RealScalar(0))
        u = -u;

      m_c = Scalar(1)/u;
      m_s = -qs*internal::conj(ps)*(m_c/p2);
      if(r) *r = p * u;
    }
    else
    {
      Scalar ps = p / q1;
      RealScalar p2 = internal::abs2(ps);
      Scalar qs = q / q1;
      RealScalar q2 = internal::abs2(qs);

      RealScalar u = q1 * internal::sqrt(p2 + q2);
      if(internal::real(p)<RealScalar(0))
        u = -u;

      p1 = internal::abs(p);
      ps = p/p1;
      m_c = p1/u;
      m_s = -internal::conj(ps) * (q/u);
      if(r) *r = ps * u;
    }
  }
}


template<typename Scalar>
void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::false_type)
{

  if(q==Scalar(0))
  {
    m_c = p<Scalar(0) ? Scalar(-1) : Scalar(1);
    m_s = Scalar(0);
    if(r) *r = internal::abs(p);
  }
  else if(p==Scalar(0))
  {
    m_c = Scalar(0);
    m_s = q<Scalar(0) ? Scalar(1) : Scalar(-1);
    if(r) *r = internal::abs(q);
  }
  else if(internal::abs(p) > internal::abs(q))
  {
    Scalar t = q/p;
    Scalar u = internal::sqrt(Scalar(1) + internal::abs2(t));
    if(p<Scalar(0))
      u = -u;
    m_c = Scalar(1)/u;
    m_s = -t * m_c;
    if(r) *r = p * u;
  }
  else
  {
    Scalar t = p/q;
    Scalar u = internal::sqrt(Scalar(1) + internal::abs2(t));
    if(q<Scalar(0))
      u = -u;
    m_s = -Scalar(1)/u;
    m_c = -t * m_s;
    if(r) *r = q * u;
  }

}
# 269 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Jacobi/Jacobi.h"
namespace internal {
template<typename VectorX, typename VectorY, typename OtherScalar>
void apply_rotation_in_the_plane(VectorX& _x, VectorY& _y, const JacobiRotation<OtherScalar>& j);
}







template<typename Derived>
template<typename OtherScalar>
inline void MatrixBase<Derived>::applyOnTheLeft(Index p, Index q, const JacobiRotation<OtherScalar>& j)
{
  RowXpr x(this->row(p));
  RowXpr y(this->row(q));
  internal::apply_rotation_in_the_plane(x, y, j);
}







template<typename Derived>
template<typename OtherScalar>
inline void MatrixBase<Derived>::applyOnTheRight(Index p, Index q, const JacobiRotation<OtherScalar>& j)
{
  ColXpr x(this->col(p));
  ColXpr y(this->col(q));
  internal::apply_rotation_in_the_plane(x, y, j.transpose());
}

namespace internal {
template<typename VectorX, typename VectorY, typename OtherScalar>
void apply_rotation_in_the_plane(VectorX& _x, VectorY& _y, const JacobiRotation<OtherScalar>& j)
{
  typedef typename VectorX::Index Index;
  typedef typename VectorX::Scalar Scalar;
  enum { PacketSize = packet_traits<Scalar>::size };
  typedef typename packet_traits<Scalar>::type Packet;
  if( (!Eigen::internal::copy_bool(_x.size() == _y.size())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(_x.size() == _y.size())) Eigen::internal::assert_fail("_x.size() == _y.size()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Jacobi/Jacobi.h", 312); } while(false); else throw Eigen::eigen_assert_exception(); };
  Index size = _x.size();
  Index incrx = _x.innerStride();
  Index incry = _y.innerStride();

  Scalar* __restrict x = &_x.coeffRef(0);
  Scalar* __restrict y = &_y.coeffRef(0);



  if(VectorX::SizeAtCompileTime == Dynamic &&
    (VectorX::Flags & VectorY::Flags & PacketAccessBit) &&
    ((incrx==1 && incry==1) || PacketSize == 1))
  {

    enum { Peeling = 2 };

    Index alignedStart = first_aligned(y, size);
    Index alignedEnd = alignedStart + ((size-alignedStart)/PacketSize)*PacketSize;

    const Packet pc = pset1<Packet>(j.c());
    const Packet ps = pset1<Packet>(j.s());
    conj_helper<Packet,Packet,NumTraits<Scalar>::IsComplex,false> pcj;

    for(Index i=0; i<alignedStart; ++i)
    {
      Scalar xi = x[i];
      Scalar yi = y[i];
      x[i] = j.c() * xi + conj(j.s()) * yi;
      y[i] = -j.s() * xi + conj(j.c()) * yi;
    }

    Scalar* __restrict px = x + alignedStart;
    Scalar* __restrict py = y + alignedStart;

    if(first_aligned(x, size)==alignedStart)
    {
      for(Index i=alignedStart; i<alignedEnd; i+=PacketSize)
      {
        Packet xi = pload<Packet>(px);
        Packet yi = pload<Packet>(py);
        pstore(px, padd(pmul(pc,xi),pcj.pmul(ps,yi)));
        pstore(py, psub(pcj.pmul(pc,yi),pmul(ps,xi)));
        px += PacketSize;
        py += PacketSize;
      }
    }
    else
    {
      Index peelingEnd = alignedStart + ((size-alignedStart)/(Peeling*PacketSize))*(Peeling*PacketSize);
      for(Index i=alignedStart; i<peelingEnd; i+=Peeling*PacketSize)
      {
        Packet xi = ploadu<Packet>(px);
        Packet xi1 = ploadu<Packet>(px+PacketSize);
        Packet yi = pload <Packet>(py);
        Packet yi1 = pload <Packet>(py+PacketSize);
        pstoreu(px, padd(pmul(pc,xi),pcj.pmul(ps,yi)));
        pstoreu(px+PacketSize, padd(pmul(pc,xi1),pcj.pmul(ps,yi1)));
        pstore (py, psub(pcj.pmul(pc,yi),pmul(ps,xi)));
        pstore (py+PacketSize, psub(pcj.pmul(pc,yi1),pmul(ps,xi1)));
        px += Peeling*PacketSize;
        py += Peeling*PacketSize;
      }
      if(alignedEnd!=peelingEnd)
      {
        Packet xi = ploadu<Packet>(x+peelingEnd);
        Packet yi = pload <Packet>(y+peelingEnd);
        pstoreu(x+peelingEnd, padd(pmul(pc,xi),pcj.pmul(ps,yi)));
        pstore (y+peelingEnd, psub(pcj.pmul(pc,yi),pmul(ps,xi)));
      }
    }

    for(Index i=alignedEnd; i<size; ++i)
    {
      Scalar xi = x[i];
      Scalar yi = y[i];
      x[i] = j.c() * xi + conj(j.s()) * yi;
      y[i] = -j.s() * xi + conj(j.c()) * yi;
    }
  }


  else if(VectorX::SizeAtCompileTime != Dynamic &&
          (VectorX::Flags & VectorY::Flags & PacketAccessBit) &&
          (VectorX::Flags & VectorY::Flags & AlignedBit))
  {
    const Packet pc = pset1<Packet>(j.c());
    const Packet ps = pset1<Packet>(j.s());
    conj_helper<Packet,Packet,NumTraits<Scalar>::IsComplex,false> pcj;
    Scalar* __restrict px = x;
    Scalar* __restrict py = y;
    for(Index i=0; i<size; i+=PacketSize)
    {
      Packet xi = pload<Packet>(px);
      Packet yi = pload<Packet>(py);
      pstore(px, padd(pmul(pc,xi),pcj.pmul(ps,yi)));
      pstore(py, psub(pcj.pmul(pc,yi),pmul(ps,xi)));
      px += PacketSize;
      py += PacketSize;
    }
  }


  else
  {
    for(Index i=0; i<size; ++i)
    {
      Scalar xi = *x;
      Scalar yi = *y;
      *x = j.c() * xi + conj(j.s()) * yi;
      *y = -j.s() * xi + conj(j.c()) * yi;
      x += incrx;
      y += incry;
    }
  }
}
}
# 23 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Jacobi" 2

}


# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/ReenableStupidWarnings.h" 1
# 27 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Jacobi" 2
# 10 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/QR" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Householder" 1





# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/DisableStupidWarnings.h" 1
# 39 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/DisableStupidWarnings.h"
#pragma clang diagnostic ignored "-Wconstant-logical-operand"
# 7 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Householder" 2

namespace Eigen {
# 18 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Householder"
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Householder/Householder.h" 1
# 29 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Householder/Householder.h"
namespace internal {
template<int n> struct decrement_size
{
  enum {
    ret = n==Dynamic ? n : n-1
  };
};
}

template<typename Derived>
void MatrixBase<Derived>::makeHouseholderInPlace(Scalar& tau, RealScalar& beta)
{
  VectorBlock<Derived, internal::decrement_size<Base::SizeAtCompileTime>::ret> essentialPart(derived(), 1, size()-1);
  makeHouseholder(essentialPart, tau, beta);
}
# 60 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Householder/Householder.h"
template<typename Derived>
template<typename EssentialPart>
void MatrixBase<Derived>::makeHouseholder(
  EssentialPart& essential,
  Scalar& tau,
  RealScalar& beta) const
{
  if (Eigen::internal::static_assertion<bool(EssentialPart::IsVectorAtCompileTime)>::YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX) {}
  VectorBlock<const Derived, EssentialPart::SizeAtCompileTime> tail(derived(), 1, size()-1);

  RealScalar tailSqNorm = size()==1 ? RealScalar(0) : tail.squaredNorm();
  Scalar c0 = coeff(0);

  if(tailSqNorm == RealScalar(0) && internal::imag(c0)==RealScalar(0))
  {
    tau = RealScalar(0);
    beta = internal::real(c0);
    essential.setZero();
  }
  else
  {
    beta = internal::sqrt(internal::abs2(c0) + tailSqNorm);
    if (internal::real(c0)>=RealScalar(0))
      beta = -beta;
    essential = tail / (c0 - beta);
    tau = internal::conj((beta - c0) / beta);
  }
}

template<typename Derived>
template<typename EssentialPart>
void MatrixBase<Derived>::applyHouseholderOnTheLeft(
  const EssentialPart& essential,
  const Scalar& tau,
  Scalar* workspace)
{
  if(rows() == 1)
  {
    *this *= Scalar(1)-tau;
  }
  else
  {
    Map<typename internal::plain_row_type<PlainObject>::type> tmp(workspace,cols());
    Block<Derived, EssentialPart::SizeAtCompileTime, Derived::ColsAtCompileTime> bottom(derived(), 1, 0, rows()-1, cols());
    tmp.noalias() = essential.adjoint() * bottom;
    tmp += this->row(0);
    this->row(0) -= tau * tmp;
    bottom.noalias() -= tau * essential * tmp;
  }
}

template<typename Derived>
template<typename EssentialPart>
void MatrixBase<Derived>::applyHouseholderOnTheRight(
  const EssentialPart& essential,
  const Scalar& tau,
  Scalar* workspace)
{
  if(cols() == 1)
  {
    *this *= Scalar(1)-tau;
  }
  else
  {
    Map<typename internal::plain_col_type<PlainObject>::type> tmp(workspace,rows());
    Block<Derived, Derived::RowsAtCompileTime, EssentialPart::SizeAtCompileTime> right(derived(), 0, 1, rows(), cols()-1);
    tmp.noalias() = right * essential.conjugate();
    tmp += this->col(0);
    this->col(0) -= tau * tmp;
    right.noalias() -= tau * tmp * essential.transpose();
  }
}
# 19 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Householder" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Householder/HouseholderSequence.h" 1
# 70 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Householder/HouseholderSequence.h"
namespace internal {

template<typename VectorsType, typename CoeffsType, int Side>
struct traits<HouseholderSequence<VectorsType,CoeffsType,Side> >
{
  typedef typename VectorsType::Scalar Scalar;
  typedef typename VectorsType::Index Index;
  typedef typename VectorsType::StorageKind StorageKind;
  enum {
    RowsAtCompileTime = Side==OnTheLeft ? traits<VectorsType>::RowsAtCompileTime
                                        : traits<VectorsType>::ColsAtCompileTime,
    ColsAtCompileTime = RowsAtCompileTime,
    MaxRowsAtCompileTime = Side==OnTheLeft ? traits<VectorsType>::MaxRowsAtCompileTime
                                           : traits<VectorsType>::MaxColsAtCompileTime,
    MaxColsAtCompileTime = MaxRowsAtCompileTime,
    Flags = 0
  };
};

template<typename VectorsType, typename CoeffsType, int Side>
struct hseq_side_dependent_impl
{
  typedef Block<const VectorsType, Dynamic, 1> EssentialVectorType;
  typedef HouseholderSequence<VectorsType, CoeffsType, OnTheLeft> HouseholderSequenceType;
  typedef typename VectorsType::Index Index;
  static inline const EssentialVectorType essentialVector(const HouseholderSequenceType& h, Index k)
  {
    Index start = k+1+h.m_shift;
    return Block<const VectorsType,Dynamic,1>(h.m_vectors, start, k, h.rows()-start, 1);
  }
};

template<typename VectorsType, typename CoeffsType>
struct hseq_side_dependent_impl<VectorsType, CoeffsType, OnTheRight>
{
  typedef Transpose<Block<const VectorsType, 1, Dynamic> > EssentialVectorType;
  typedef HouseholderSequence<VectorsType, CoeffsType, OnTheRight> HouseholderSequenceType;
  typedef typename VectorsType::Index Index;
  static inline const EssentialVectorType essentialVector(const HouseholderSequenceType& h, Index k)
  {
    Index start = k+1+h.m_shift;
    return Block<const VectorsType,1,Dynamic>(h.m_vectors, k, start, 1, h.rows()-start).transpose();
  }
};

template<typename OtherScalarType, typename MatrixType> struct matrix_type_times_scalar_type
{
  typedef typename scalar_product_traits<OtherScalarType, typename MatrixType::Scalar>::ReturnType
    ResultScalar;
  typedef Matrix<ResultScalar, MatrixType::RowsAtCompileTime, MatrixType::ColsAtCompileTime,
                 0, MatrixType::MaxRowsAtCompileTime, MatrixType::MaxColsAtCompileTime> Type;
};

}

template<typename VectorsType, typename CoeffsType, int Side> class HouseholderSequence
  : public EigenBase<HouseholderSequence<VectorsType,CoeffsType,Side> >
{
    enum {
      RowsAtCompileTime = internal::traits<HouseholderSequence>::RowsAtCompileTime,
      ColsAtCompileTime = internal::traits<HouseholderSequence>::ColsAtCompileTime,
      MaxRowsAtCompileTime = internal::traits<HouseholderSequence>::MaxRowsAtCompileTime,
      MaxColsAtCompileTime = internal::traits<HouseholderSequence>::MaxColsAtCompileTime
    };
    typedef typename internal::traits<HouseholderSequence>::Scalar Scalar;
    typedef typename VectorsType::Index Index;

    typedef typename internal::hseq_side_dependent_impl<VectorsType,CoeffsType,Side>::EssentialVectorType
            EssentialVectorType;

  public:

    typedef HouseholderSequence<
      VectorsType,
      typename internal::conditional<NumTraits<Scalar>::IsComplex,
        typename internal::remove_all<typename CoeffsType::ConjugateReturnType>::type,
        CoeffsType>::type,
      Side
    > ConjugateReturnType;
# 167 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Householder/HouseholderSequence.h"
    HouseholderSequence(const VectorsType& v, const CoeffsType& h)
      : m_vectors(v), m_coeffs(h), m_trans(false), m_length(v.diagonalSize()),
        m_shift(0)
    {
    }


    HouseholderSequence(const HouseholderSequence& other)
      : m_vectors(other.m_vectors),
        m_coeffs(other.m_coeffs),
        m_trans(other.m_trans),
        m_length(other.m_length),
        m_shift(other.m_shift)
    {
    }





    Index rows() const { return Side==OnTheLeft ? m_vectors.rows() : m_vectors.cols(); }





    Index cols() const { return rows(); }
# 209 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Householder/HouseholderSequence.h"
    const EssentialVectorType essentialVector(Index k) const
    {
      if( (!Eigen::internal::copy_bool(k >= 0 && k < m_length)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(k >= 0 && k < m_length)) Eigen::internal::assert_fail("k >= 0 && k < m_length", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Householder/HouseholderSequence.h", 211); } while(false); else throw Eigen::eigen_assert_exception(); };
      return internal::hseq_side_dependent_impl<VectorsType,CoeffsType,Side>::essentialVector(*this, k);
    }


    HouseholderSequence transpose() const
    {
      return HouseholderSequence(*this).setTrans(!m_trans);
    }


    ConjugateReturnType conjugate() const
    {
      return ConjugateReturnType(m_vectors, m_coeffs.conjugate())
             .setTrans(m_trans)
             .setLength(m_length)
             .setShift(m_shift);
    }


    ConjugateReturnType adjoint() const
    {
      return conjugate().setTrans(!m_trans);
    }


    ConjugateReturnType inverse() const { return adjoint(); }


    template<typename DestType> void evalTo(DestType& dst) const
    {
      Index vecs = m_length;

      Matrix<Scalar, DestType::RowsAtCompileTime, 1,
             AutoAlign|ColMajor, DestType::MaxRowsAtCompileTime, 1> temp(rows());
      if( internal::is_same<typename internal::remove_all<VectorsType>::type,DestType>::value
          && internal::extract_data(dst) == internal::extract_data(m_vectors))
      {

        dst.diagonal().setOnes();
        dst.template triangularView<StrictlyUpper>().setZero();
        for(Index k = vecs-1; k >= 0; --k)
        {
          Index cornerSize = rows() - k - m_shift;
          if(m_trans)
            dst.bottomRightCorner(cornerSize, cornerSize)
            .applyHouseholderOnTheRight(essentialVector(k), m_coeffs.coeff(k), &temp.coeffRef(0));
          else
            dst.bottomRightCorner(cornerSize, cornerSize)
              .applyHouseholderOnTheLeft(essentialVector(k), m_coeffs.coeff(k), &temp.coeffRef(0));


          dst.col(k).tail(rows()-k-1).setZero();
        }

        for(Index k = 0; k<cols()-vecs ; ++k)
          dst.col(k).tail(rows()-k-1).setZero();
      }
      else
      {
        dst.setIdentity(rows(), rows());
        for(Index k = vecs-1; k >= 0; --k)
        {
          Index cornerSize = rows() - k - m_shift;
          if(m_trans)
            dst.bottomRightCorner(cornerSize, cornerSize)
            .applyHouseholderOnTheRight(essentialVector(k), m_coeffs.coeff(k), &temp.coeffRef(0));
          else
            dst.bottomRightCorner(cornerSize, cornerSize)
              .applyHouseholderOnTheLeft(essentialVector(k), m_coeffs.coeff(k), &temp.coeffRef(0));
        }
      }
    }


    template<typename Dest> inline void applyThisOnTheRight(Dest& dst) const
    {
      Matrix<Scalar,1,Dest::RowsAtCompileTime> temp(dst.rows());
      for(Index k = 0; k < m_length; ++k)
      {
        Index actual_k = m_trans ? m_length-k-1 : k;
        dst.rightCols(rows()-m_shift-actual_k)
           .applyHouseholderOnTheRight(essentialVector(actual_k), m_coeffs.coeff(actual_k), &temp.coeffRef(0));
      }
    }


    template<typename Dest> inline void applyThisOnTheLeft(Dest& dst) const
    {
      Matrix<Scalar,1,Dest::ColsAtCompileTime> temp(dst.cols());
      for(Index k = 0; k < m_length; ++k)
      {
        Index actual_k = m_trans ? k : m_length-k-1;
        dst.bottomRows(rows()-m_shift-actual_k)
           .applyHouseholderOnTheLeft(essentialVector(actual_k), m_coeffs.coeff(actual_k), &temp.coeffRef(0));
      }
    }
# 316 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Householder/HouseholderSequence.h"
    template<typename OtherDerived>
    typename internal::matrix_type_times_scalar_type<Scalar, OtherDerived>::Type operator*(const MatrixBase<OtherDerived>& other) const
    {
      typename internal::matrix_type_times_scalar_type<Scalar, OtherDerived>::Type
        res(other.template cast<typename internal::matrix_type_times_scalar_type<Scalar,OtherDerived>::ResultScalar>());
      applyThisOnTheLeft(res);
      return res;
    }

    template<typename _VectorsType, typename _CoeffsType, int _Side> friend struct internal::hseq_side_dependent_impl;
# 336 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Householder/HouseholderSequence.h"
    HouseholderSequence& setLength(Index length)
    {
      m_length = length;
      return *this;
    }
# 353 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Householder/HouseholderSequence.h"
    HouseholderSequence& setShift(Index shift)
    {
      m_shift = shift;
      return *this;
    }

    Index length() const { return m_length; }
    Index shift() const { return m_shift; }


    template <typename VectorsType2, typename CoeffsType2, int Side2> friend class HouseholderSequence;

  protected:
# 375 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Householder/HouseholderSequence.h"
    HouseholderSequence& setTrans(bool trans)
    {
      m_trans = trans;
      return *this;
    }

    bool trans() const { return m_trans; }

    typename VectorsType::Nested m_vectors;
    typename CoeffsType::Nested m_coeffs;
    bool m_trans;
    Index m_length;
    Index m_shift;
};
# 398 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Householder/HouseholderSequence.h"
template<typename OtherDerived, typename VectorsType, typename CoeffsType, int Side>
typename internal::matrix_type_times_scalar_type<typename VectorsType::Scalar,OtherDerived>::Type operator*(const MatrixBase<OtherDerived>& other, const HouseholderSequence<VectorsType,CoeffsType,Side>& h)
{
  typename internal::matrix_type_times_scalar_type<typename VectorsType::Scalar,OtherDerived>::Type
    res(other.template cast<typename internal::matrix_type_times_scalar_type<typename VectorsType::Scalar,OtherDerived>::ResultScalar>());
  h.applyThisOnTheRight(res);
  return res;
}





template<typename VectorsType, typename CoeffsType>
HouseholderSequence<VectorsType,CoeffsType> householderSequence(const VectorsType& v, const CoeffsType& h)
{
  return HouseholderSequence<VectorsType,CoeffsType,OnTheLeft>(v, h);
}







template<typename VectorsType, typename CoeffsType>
HouseholderSequence<VectorsType,CoeffsType,OnTheRight> rightHouseholderSequence(const VectorsType& v, const CoeffsType& h)
{
  return HouseholderSequence<VectorsType,CoeffsType,OnTheRight>(v, h);
}
# 20 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Householder" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Householder/BlockHouseholder.h" 1
# 31 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Householder/BlockHouseholder.h"
namespace internal {


template<typename TriangularFactorType,typename VectorsType,typename CoeffsType>
void make_block_householder_triangular_factor(TriangularFactorType& triFactor, const VectorsType& vectors, const CoeffsType& hCoeffs)
{
  typedef typename TriangularFactorType::Index Index;
  typedef typename VectorsType::Scalar Scalar;
  const Index nbVecs = vectors.cols();
  if( (!Eigen::internal::copy_bool(triFactor.rows() == nbVecs && triFactor.cols() == nbVecs && vectors.rows()>=nbVecs)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(triFactor.rows() == nbVecs && triFactor.cols() == nbVecs && vectors.rows()>=nbVecs)) Eigen::internal::assert_fail("triFactor.rows() == nbVecs && triFactor.cols() == nbVecs && vectors.rows()>=nbVecs", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Householder/BlockHouseholder.h", 40); } while(false); else throw Eigen::eigen_assert_exception(); };

  for(Index i = 0; i < nbVecs; i++)
  {
    Index rs = vectors.rows() - i;
    Scalar Vii = vectors(i,i);
    vectors.const_cast_derived().coeffRef(i,i) = Scalar(1);
    triFactor.col(i).head(i).noalias() = -hCoeffs(i) * vectors.block(i, 0, rs, i).adjoint()
                                       * vectors.col(i).tail(rs);
    vectors.const_cast_derived().coeffRef(i, i) = Vii;

    triFactor.col(i).head(i) = triFactor.block(0,0,i,i).template triangularView<Upper>()
                             * triFactor.col(i).head(i);
    triFactor(i,i) = hCoeffs(i);
  }
}


template<typename MatrixType,typename VectorsType,typename CoeffsType>
void apply_block_householder_on_the_left(MatrixType& mat, const VectorsType& vectors, const CoeffsType& hCoeffs)
{
  typedef typename MatrixType::Index Index;
  enum { TFactorSize = MatrixType::ColsAtCompileTime };
  Index nbVecs = vectors.cols();
  Matrix<typename MatrixType::Scalar, TFactorSize, TFactorSize> T(nbVecs,nbVecs);
  make_block_householder_triangular_factor(T, vectors, hCoeffs);

  const TriangularView<VectorsType, UnitLower>& V(vectors);


  Matrix<typename MatrixType::Scalar,VectorsType::ColsAtCompileTime,MatrixType::ColsAtCompileTime,0,
         VectorsType::MaxColsAtCompileTime,MatrixType::MaxColsAtCompileTime> tmp = V.adjoint() * mat;

  tmp = T.template triangularView<Upper>().adjoint() * tmp;
  mat.noalias() -= V * tmp;
}

}
# 21 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Householder" 2

}


# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/ReenableStupidWarnings.h" 1
# 25 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Householder" 2
# 11 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/QR" 2

namespace Eigen {
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/QR"
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/HouseholderQR.h" 1
# 55 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/HouseholderQR.h"
template<typename _MatrixType> class HouseholderQR
{
  public:

    typedef _MatrixType MatrixType;
    enum {
      RowsAtCompileTime = MatrixType::RowsAtCompileTime,
      ColsAtCompileTime = MatrixType::ColsAtCompileTime,
      Options = MatrixType::Options,
      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
    };
    typedef typename MatrixType::Scalar Scalar;
    typedef typename MatrixType::RealScalar RealScalar;
    typedef typename MatrixType::Index Index;
    typedef Matrix<Scalar, RowsAtCompileTime, RowsAtCompileTime, (MatrixType::Flags&RowMajorBit) ? RowMajor : ColMajor, MaxRowsAtCompileTime, MaxRowsAtCompileTime> MatrixQType;
    typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;
    typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;
    typedef typename HouseholderSequence<MatrixType,HCoeffsType>::ConjugateReturnType HouseholderSequenceType;







    HouseholderQR() : m_qr(), m_hCoeffs(), m_temp(), m_isInitialized(false) {}







    HouseholderQR(Index rows, Index cols)
      : m_qr(rows, cols),
        m_hCoeffs((std::min)(rows,cols)),
        m_temp(cols),
        m_isInitialized(false) {}

    HouseholderQR(const MatrixType& matrix)
      : m_qr(matrix.rows(), matrix.cols()),
        m_hCoeffs((std::min)(matrix.rows(),matrix.cols())),
        m_temp(matrix.cols()),
        m_isInitialized(false)
    {
      compute(matrix);
    }
# 121 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/HouseholderQR.h"
    template<typename Rhs>
    inline const internal::solve_retval<HouseholderQR, Rhs>
    solve(const MatrixBase<Rhs>& b) const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "HouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "HouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"HouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/HouseholderQR.h", 125); } while(false); else throw Eigen::eigen_assert_exception(); };
      return internal::solve_retval<HouseholderQR, Rhs>(*this, b.derived());
    }

    HouseholderSequenceType householderQ() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "HouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "HouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"HouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/HouseholderQR.h", 131); } while(false); else throw Eigen::eigen_assert_exception(); };
      return HouseholderSequenceType(m_qr, m_hCoeffs.conjugate());
    }




    const MatrixType& matrixQR() const
    {
        if( (!Eigen::internal::copy_bool(m_isInitialized && "HouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "HouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"HouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/HouseholderQR.h", 140); } while(false); else throw Eigen::eigen_assert_exception(); };
        return m_qr;
    }

    HouseholderQR& compute(const MatrixType& matrix);
# 159 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/HouseholderQR.h"
    typename MatrixType::RealScalar absDeterminant() const;
# 173 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/HouseholderQR.h"
    typename MatrixType::RealScalar logAbsDeterminant() const;

    inline Index rows() const { return m_qr.rows(); }
    inline Index cols() const { return m_qr.cols(); }
    const HCoeffsType& hCoeffs() const { return m_hCoeffs; }

  protected:
    MatrixType m_qr;
    HCoeffsType m_hCoeffs;
    RowVectorType m_temp;
    bool m_isInitialized;
};

template<typename MatrixType>
typename MatrixType::RealScalar HouseholderQR<MatrixType>::absDeterminant() const
{
  if( (!Eigen::internal::copy_bool(m_isInitialized && "HouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "HouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"HouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/HouseholderQR.h", 189); } while(false); else throw Eigen::eigen_assert_exception(); };
  if( (!Eigen::internal::copy_bool(m_qr.rows() == m_qr.cols() && "You can't take the determinant of a non-square matrix!")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_qr.rows() == m_qr.cols() && "You can't take the determinant of a non-square matrix!")) Eigen::internal::assert_fail("m_qr.rows() == m_qr.cols() && \"You can't take the determinant of a non-square matrix!\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/HouseholderQR.h", 190); } while(false); else throw Eigen::eigen_assert_exception(); };
  return internal::abs(m_qr.diagonal().prod());
}

template<typename MatrixType>
typename MatrixType::RealScalar HouseholderQR<MatrixType>::logAbsDeterminant() const
{
  if( (!Eigen::internal::copy_bool(m_isInitialized && "HouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "HouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"HouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/HouseholderQR.h", 197); } while(false); else throw Eigen::eigen_assert_exception(); };
  if( (!Eigen::internal::copy_bool(m_qr.rows() == m_qr.cols() && "You can't take the determinant of a non-square matrix!")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_qr.rows() == m_qr.cols() && "You can't take the determinant of a non-square matrix!")) Eigen::internal::assert_fail("m_qr.rows() == m_qr.cols() && \"You can't take the determinant of a non-square matrix!\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/HouseholderQR.h", 198); } while(false); else throw Eigen::eigen_assert_exception(); };
  return m_qr.diagonal().cwiseAbs().array().log().sum();
}

namespace internal {


template<typename MatrixQR, typename HCoeffs>
void householder_qr_inplace_unblocked(MatrixQR& mat, HCoeffs& hCoeffs, typename MatrixQR::Scalar* tempData = 0)
{
  typedef typename MatrixQR::Index Index;
  typedef typename MatrixQR::Scalar Scalar;
  typedef typename MatrixQR::RealScalar RealScalar;
  Index rows = mat.rows();
  Index cols = mat.cols();
  Index size = (std::min)(rows,cols);

  if( (!Eigen::internal::copy_bool(hCoeffs.size() == size)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(hCoeffs.size() == size)) Eigen::internal::assert_fail("hCoeffs.size() == size", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/HouseholderQR.h", 215); } while(false); else throw Eigen::eigen_assert_exception(); };

  typedef Matrix<Scalar,MatrixQR::ColsAtCompileTime,1> TempType;
  TempType tempVector;
  if(tempData==0)
  {
    tempVector.resize(cols);
    tempData = tempVector.data();
  }

  for(Index k = 0; k < size; ++k)
  {
    Index remainingRows = rows - k;
    Index remainingCols = cols - k - 1;

    RealScalar beta;
    mat.col(k).tail(remainingRows).makeHouseholderInPlace(hCoeffs.coeffRef(k), beta);
    mat.coeffRef(k,k) = beta;


    mat.bottomRightCorner(remainingRows, remainingCols)
        .applyHouseholderOnTheLeft(mat.col(k).tail(remainingRows-1), hCoeffs.coeffRef(k), tempData+k+1);
  }
}


template<typename MatrixQR, typename HCoeffs>
void householder_qr_inplace_blocked(MatrixQR& mat, HCoeffs& hCoeffs,
                                       typename MatrixQR::Index maxBlockSize=32,
                                       typename MatrixQR::Scalar* tempData = 0)
{
  typedef typename MatrixQR::Index Index;
  typedef typename MatrixQR::Scalar Scalar;
  typedef typename MatrixQR::RealScalar RealScalar;
  typedef Block<MatrixQR,Dynamic,Dynamic> BlockType;

  Index rows = mat.rows();
  Index cols = mat.cols();
  Index size = (std::min)(rows, cols);

  typedef Matrix<Scalar,Dynamic,1,ColMajor,MatrixQR::MaxColsAtCompileTime,1> TempType;
  TempType tempVector;
  if(tempData==0)
  {
    tempVector.resize(cols);
    tempData = tempVector.data();
  }

  Index blockSize = (std::min)(maxBlockSize,size);

  Index k = 0;
  for (k = 0; k < size; k += blockSize)
  {
    Index bs = (std::min)(size-k,blockSize);
    Index tcols = cols - k - bs;
    Index brows = rows-k;
# 280 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/HouseholderQR.h"
    BlockType A11_21 = mat.block(k,k,brows,bs);
    Block<HCoeffs,Dynamic,1> hCoeffsSegment = hCoeffs.segment(k,bs);

    householder_qr_inplace_unblocked(A11_21, hCoeffsSegment, tempData);

    if(tcols)
    {
      BlockType A21_22 = mat.block(k,k+bs,brows,tcols);
      apply_block_householder_on_the_left(A21_22,A11_21,hCoeffsSegment.adjoint());
    }
  }
}

template<typename _MatrixType, typename Rhs>
struct solve_retval<HouseholderQR<_MatrixType>, Rhs>
  : solve_retval_base<HouseholderQR<_MatrixType>, Rhs>
{
  typedef typename HouseholderQR<_MatrixType>::MatrixType MatrixType; typedef typename MatrixType::Scalar Scalar; typedef typename MatrixType::RealScalar RealScalar; typedef typename MatrixType::Index Index; typedef Eigen::internal::solve_retval_base<HouseholderQR<_MatrixType>,Rhs> Base; using Base::dec; using Base::rhs; using Base::rows; using Base::cols; solve_retval(const HouseholderQR<_MatrixType>& dec, const Rhs& rhs) : Base(dec, rhs) {}

  template<typename Dest> void evalTo(Dest& dst) const
  {
    const Index rows = dec().rows(), cols = dec().cols();
    const Index rank = (std::min)(rows, cols);
    if( (!Eigen::internal::copy_bool(rhs().rows() == rows)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(rhs().rows() == rows)) Eigen::internal::assert_fail("rhs().rows() == rows", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/HouseholderQR.h", 303); } while(false); else throw Eigen::eigen_assert_exception(); };

    typename Rhs::PlainObject c(rhs());


    c.applyOnTheLeft(householderSequence(
      dec().matrixQR().leftCols(rank),
      dec().hCoeffs().head(rank)).transpose()
    );

    dec().matrixQR()
       .topLeftCorner(rank, rank)
       .template triangularView<Upper>()
       .solveInPlace(c.topRows(rank));

    dst.topRows(rank) = c.topRows(rank);
    dst.bottomRows(cols-rank).setZero();
  }
};

}

template<typename MatrixType>
HouseholderQR<MatrixType>& HouseholderQR<MatrixType>::compute(const MatrixType& matrix)
{
  Index rows = matrix.rows();
  Index cols = matrix.cols();
  Index size = (std::min)(rows,cols);

  m_qr = matrix;
  m_hCoeffs.resize(size);

  m_temp.resize(cols);

  internal::householder_qr_inplace_blocked(m_qr, m_hCoeffs, 48, m_temp.data());

  m_isInitialized = true;
  return *this;
}





template<typename Derived>
const HouseholderQR<typename MatrixBase<Derived>::PlainObject>
MatrixBase<Derived>::householderQr() const
{
  return HouseholderQR<PlainObject>(eval());
}
# 29 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/QR" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/FullPivHouseholderQR.h" 1
# 50 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/FullPivHouseholderQR.h"
template<typename _MatrixType> class FullPivHouseholderQR
{
  public:

    typedef _MatrixType MatrixType;
    enum {
      RowsAtCompileTime = MatrixType::RowsAtCompileTime,
      ColsAtCompileTime = MatrixType::ColsAtCompileTime,
      Options = MatrixType::Options,
      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
    };
    typedef typename MatrixType::Scalar Scalar;
    typedef typename MatrixType::RealScalar RealScalar;
    typedef typename MatrixType::Index Index;
    typedef Matrix<Scalar, RowsAtCompileTime, RowsAtCompileTime, Options, MaxRowsAtCompileTime, MaxRowsAtCompileTime> MatrixQType;
    typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;
    typedef Matrix<Index, 1, ColsAtCompileTime, RowMajor, 1, MaxColsAtCompileTime> IntRowVectorType;
    typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationType;
    typedef typename internal::plain_col_type<MatrixType, Index>::type IntColVectorType;
    typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;
    typedef typename internal::plain_col_type<MatrixType>::type ColVectorType;






    FullPivHouseholderQR()
      : m_qr(),
        m_hCoeffs(),
        m_rows_transpositions(),
        m_cols_transpositions(),
        m_cols_permutation(),
        m_temp(),
        m_isInitialized(false),
        m_usePrescribedThreshold(false) {}







    FullPivHouseholderQR(Index rows, Index cols)
      : m_qr(rows, cols),
        m_hCoeffs((std::min)(rows,cols)),
        m_rows_transpositions(rows),
        m_cols_transpositions(cols),
        m_cols_permutation(cols),
        m_temp((std::min)(rows,cols)),
        m_isInitialized(false),
        m_usePrescribedThreshold(false) {}

    FullPivHouseholderQR(const MatrixType& matrix)
      : m_qr(matrix.rows(), matrix.cols()),
        m_hCoeffs((std::min)(matrix.rows(), matrix.cols())),
        m_rows_transpositions(matrix.rows()),
        m_cols_transpositions(matrix.cols()),
        m_cols_permutation(matrix.cols()),
        m_temp((std::min)(matrix.rows(), matrix.cols())),
        m_isInitialized(false),
        m_usePrescribedThreshold(false)
    {
      compute(matrix);
    }
# 134 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/FullPivHouseholderQR.h"
    template<typename Rhs>
    inline const internal::solve_retval<FullPivHouseholderQR, Rhs>
    solve(const MatrixBase<Rhs>& b) const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "FullPivHouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "FullPivHouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"FullPivHouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/FullPivHouseholderQR.h", 138); } while(false); else throw Eigen::eigen_assert_exception(); };
      return internal::solve_retval<FullPivHouseholderQR, Rhs>(*this, b.derived());
    }

    MatrixQType matrixQ(void) const;



    const MatrixType& matrixQR() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "FullPivHouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "FullPivHouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"FullPivHouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/FullPivHouseholderQR.h", 148); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_qr;
    }

    FullPivHouseholderQR& compute(const MatrixType& matrix);

    const PermutationType& colsPermutation() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "FullPivHouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "FullPivHouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"FullPivHouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/FullPivHouseholderQR.h", 156); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_cols_permutation;
    }

    const IntColVectorType& rowsTranspositions() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "FullPivHouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "FullPivHouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"FullPivHouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/FullPivHouseholderQR.h", 162); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_rows_transpositions;
    }
# 179 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/FullPivHouseholderQR.h"
    typename MatrixType::RealScalar absDeterminant() const;
# 193 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/FullPivHouseholderQR.h"
    typename MatrixType::RealScalar logAbsDeterminant() const;







    inline Index rank() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "FullPivHouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "FullPivHouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"FullPivHouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/FullPivHouseholderQR.h", 203); } while(false); else throw Eigen::eigen_assert_exception(); };
      RealScalar premultiplied_threshold = internal::abs(m_maxpivot) * threshold();
      Index result = 0;
      for(Index i = 0; i < m_nonzero_pivots; ++i)
        result += (internal::abs(m_qr.coeff(i,i)) > premultiplied_threshold);
      return result;
    }







    inline Index dimensionOfKernel() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "FullPivHouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "FullPivHouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"FullPivHouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/FullPivHouseholderQR.h", 219); } while(false); else throw Eigen::eigen_assert_exception(); };
      return cols() - rank();
    }
# 230 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/FullPivHouseholderQR.h"
    inline bool isInjective() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "FullPivHouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "FullPivHouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"FullPivHouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/FullPivHouseholderQR.h", 232); } while(false); else throw Eigen::eigen_assert_exception(); };
      return rank() == cols();
    }
# 243 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/FullPivHouseholderQR.h"
    inline bool isSurjective() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "FullPivHouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "FullPivHouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"FullPivHouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/FullPivHouseholderQR.h", 245); } while(false); else throw Eigen::eigen_assert_exception(); };
      return rank() == rows();
    }







    inline bool isInvertible() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "FullPivHouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "FullPivHouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"FullPivHouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/FullPivHouseholderQR.h", 257); } while(false); else throw Eigen::eigen_assert_exception(); };
      return isInjective() && isSurjective();
    }





            inline const
    internal::solve_retval<FullPivHouseholderQR, typename MatrixType::IdentityReturnType>
    inverse() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "FullPivHouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "FullPivHouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"FullPivHouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/FullPivHouseholderQR.h", 269); } while(false); else throw Eigen::eigen_assert_exception(); };
      return internal::solve_retval<FullPivHouseholderQR,typename MatrixType::IdentityReturnType>
               (*this, MatrixType::Identity(m_qr.rows(), m_qr.cols()));
    }

    inline Index rows() const { return m_qr.rows(); }
    inline Index cols() const { return m_qr.cols(); }
    const HCoeffsType& hCoeffs() const { return m_hCoeffs; }
# 295 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/FullPivHouseholderQR.h"
    FullPivHouseholderQR& setThreshold(const RealScalar& threshold)
    {
      m_usePrescribedThreshold = true;
      m_prescribedThreshold = threshold;
      return *this;
    }
# 310 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/FullPivHouseholderQR.h"
    FullPivHouseholderQR& setThreshold(Default_t)
    {
      m_usePrescribedThreshold = false;
      return *this;
    }





    RealScalar threshold() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized || m_usePrescribedThreshold)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized || m_usePrescribedThreshold)) Eigen::internal::assert_fail("m_isInitialized || m_usePrescribedThreshold", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/FullPivHouseholderQR.h", 322); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_usePrescribedThreshold ? m_prescribedThreshold


                                      : NumTraits<Scalar>::epsilon() * m_qr.diagonalSize();
    }
# 336 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/FullPivHouseholderQR.h"
    inline Index nonzeroPivots() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LU is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/FullPivHouseholderQR.h", 338); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_nonzero_pivots;
    }




    RealScalar maxPivot() const { return m_maxpivot; }

  protected:
    MatrixType m_qr;
    HCoeffsType m_hCoeffs;
    IntColVectorType m_rows_transpositions;
    IntRowVectorType m_cols_transpositions;
    PermutationType m_cols_permutation;
    RowVectorType m_temp;
    bool m_isInitialized, m_usePrescribedThreshold;
    RealScalar m_prescribedThreshold, m_maxpivot;
    Index m_nonzero_pivots;
    RealScalar m_precision;
    Index m_det_pq;
};

template<typename MatrixType>
typename MatrixType::RealScalar FullPivHouseholderQR<MatrixType>::absDeterminant() const
{
  if( (!Eigen::internal::copy_bool(m_isInitialized && "FullPivHouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "FullPivHouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"FullPivHouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/FullPivHouseholderQR.h", 364); } while(false); else throw Eigen::eigen_assert_exception(); };
  if( (!Eigen::internal::copy_bool(m_qr.rows() == m_qr.cols() && "You can't take the determinant of a non-square matrix!")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_qr.rows() == m_qr.cols() && "You can't take the determinant of a non-square matrix!")) Eigen::internal::assert_fail("m_qr.rows() == m_qr.cols() && \"You can't take the determinant of a non-square matrix!\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/FullPivHouseholderQR.h", 365); } while(false); else throw Eigen::eigen_assert_exception(); };
  return internal::abs(m_qr.diagonal().prod());
}

template<typename MatrixType>
typename MatrixType::RealScalar FullPivHouseholderQR<MatrixType>::logAbsDeterminant() const
{
  if( (!Eigen::internal::copy_bool(m_isInitialized && "FullPivHouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "FullPivHouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"FullPivHouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/FullPivHouseholderQR.h", 372); } while(false); else throw Eigen::eigen_assert_exception(); };
  if( (!Eigen::internal::copy_bool(m_qr.rows() == m_qr.cols() && "You can't take the determinant of a non-square matrix!")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_qr.rows() == m_qr.cols() && "You can't take the determinant of a non-square matrix!")) Eigen::internal::assert_fail("m_qr.rows() == m_qr.cols() && \"You can't take the determinant of a non-square matrix!\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/FullPivHouseholderQR.h", 373); } while(false); else throw Eigen::eigen_assert_exception(); };
  return m_qr.diagonal().cwiseAbs().array().log().sum();
}

template<typename MatrixType>
FullPivHouseholderQR<MatrixType>& FullPivHouseholderQR<MatrixType>::compute(const MatrixType& matrix)
{
  Index rows = matrix.rows();
  Index cols = matrix.cols();
  Index size = (std::min)(rows,cols);

  m_qr = matrix;
  m_hCoeffs.resize(size);

  m_temp.resize(cols);

  m_precision = NumTraits<Scalar>::epsilon() * size;

  m_rows_transpositions.resize(matrix.rows());
  m_cols_transpositions.resize(matrix.cols());
  Index number_of_transpositions = 0;

  RealScalar biggest(0);

  m_nonzero_pivots = size;
  m_maxpivot = RealScalar(0);

  for (Index k = 0; k < size; ++k)
  {
    Index row_of_biggest_in_corner, col_of_biggest_in_corner;
    RealScalar biggest_in_corner;

    biggest_in_corner = m_qr.bottomRightCorner(rows-k, cols-k)
                            .cwiseAbs()
                            .maxCoeff(&row_of_biggest_in_corner, &col_of_biggest_in_corner);
    row_of_biggest_in_corner += k;
    col_of_biggest_in_corner += k;
    if(k==0) biggest = biggest_in_corner;


    if(internal::isMuchSmallerThan(biggest_in_corner, biggest, m_precision))
    {
      m_nonzero_pivots = k;
      for(Index i = k; i < size; i++)
      {
        m_rows_transpositions.coeffRef(i) = i;
        m_cols_transpositions.coeffRef(i) = i;
        m_hCoeffs.coeffRef(i) = Scalar(0);
      }
      break;
    }

    m_rows_transpositions.coeffRef(k) = row_of_biggest_in_corner;
    m_cols_transpositions.coeffRef(k) = col_of_biggest_in_corner;
    if(k != row_of_biggest_in_corner) {
      m_qr.row(k).tail(cols-k).swap(m_qr.row(row_of_biggest_in_corner).tail(cols-k));
      ++number_of_transpositions;
    }
    if(k != col_of_biggest_in_corner) {
      m_qr.col(k).swap(m_qr.col(col_of_biggest_in_corner));
      ++number_of_transpositions;
    }

    RealScalar beta;
    m_qr.col(k).tail(rows-k).makeHouseholderInPlace(m_hCoeffs.coeffRef(k), beta);
    m_qr.coeffRef(k,k) = beta;


    if(internal::abs(beta) > m_maxpivot) m_maxpivot = internal::abs(beta);

    m_qr.bottomRightCorner(rows-k, cols-k-1)
        .applyHouseholderOnTheLeft(m_qr.col(k).tail(rows-k-1), m_hCoeffs.coeffRef(k), &m_temp.coeffRef(k+1));
  }

  m_cols_permutation.setIdentity(cols);
  for(Index k = 0; k < size; ++k)
    m_cols_permutation.applyTranspositionOnTheRight(k, m_cols_transpositions.coeff(k));

  m_det_pq = (number_of_transpositions%2) ? -1 : 1;
  m_isInitialized = true;

  return *this;
}

namespace internal {

template<typename _MatrixType, typename Rhs>
struct solve_retval<FullPivHouseholderQR<_MatrixType>, Rhs>
  : solve_retval_base<FullPivHouseholderQR<_MatrixType>, Rhs>
{
  typedef typename FullPivHouseholderQR<_MatrixType>::MatrixType MatrixType; typedef typename MatrixType::Scalar Scalar; typedef typename MatrixType::RealScalar RealScalar; typedef typename MatrixType::Index Index; typedef Eigen::internal::solve_retval_base<FullPivHouseholderQR<_MatrixType>,Rhs> Base; using Base::dec; using Base::rhs; using Base::rows; using Base::cols; solve_retval(const FullPivHouseholderQR<_MatrixType>& dec, const Rhs& rhs) : Base(dec, rhs) {}

  template<typename Dest> void evalTo(Dest& dst) const
  {
    const Index rows = dec().rows(), cols = dec().cols();
    if( (!Eigen::internal::copy_bool(rhs().rows() == rows)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(rhs().rows() == rows)) Eigen::internal::assert_fail("rhs().rows() == rows", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/FullPivHouseholderQR.h", 468); } while(false); else throw Eigen::eigen_assert_exception(); };



    if(dec().rank()==0)
    {
      dst.setZero();
      return;
    }

    typename Rhs::PlainObject c(rhs());

    Matrix<Scalar,1,Rhs::ColsAtCompileTime> temp(rhs().cols());
    for (Index k = 0; k < dec().rank(); ++k)
    {
      Index remainingSize = rows-k;
      c.row(k).swap(c.row(dec().rowsTranspositions().coeff(k)));
      c.bottomRightCorner(remainingSize, rhs().cols())
       .applyHouseholderOnTheLeft(dec().matrixQR().col(k).tail(remainingSize-1),
                                  dec().hCoeffs().coeff(k), &temp.coeffRef(0));
    }

    if(!dec().isSurjective())
    {

      RealScalar biggest_in_upper_part_of_c = c.topRows( dec().rank() ).cwiseAbs().maxCoeff();
      RealScalar biggest_in_lower_part_of_c = c.bottomRows(rows-dec().rank()).cwiseAbs().maxCoeff();

      const RealScalar m_precision = NumTraits<Scalar>::epsilon() * (std::min)(rows,cols);

      if(!internal::isMuchSmallerThan(biggest_in_lower_part_of_c, biggest_in_upper_part_of_c, m_precision))
        return;
    }
    dec().matrixQR()
       .topLeftCorner(dec().rank(), dec().rank())
       .template triangularView<Upper>()
       .solveInPlace(c.topRows(dec().rank()));

    for(Index i = 0; i < dec().rank(); ++i) dst.row(dec().colsPermutation().indices().coeff(i)) = c.row(i);
    for(Index i = dec().rank(); i < cols; ++i) dst.row(dec().colsPermutation().indices().coeff(i)).setZero();
  }
};

}


template<typename MatrixType>
typename FullPivHouseholderQR<MatrixType>::MatrixQType FullPivHouseholderQR<MatrixType>::matrixQ() const
{
  if( (!Eigen::internal::copy_bool(m_isInitialized && "FullPivHouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "FullPivHouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"FullPivHouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/FullPivHouseholderQR.h", 517); } while(false); else throw Eigen::eigen_assert_exception(); };



  Index rows = m_qr.rows();
  Index cols = m_qr.cols();
  Index size = (std::min)(rows,cols);
  MatrixQType res = MatrixQType::Identity(rows, rows);
  Matrix<Scalar,1,MatrixType::RowsAtCompileTime> temp(rows);
  for (Index k = size-1; k >= 0; k--)
  {
    res.block(k, k, rows-k, rows-k)
       .applyHouseholderOnTheLeft(m_qr.col(k).tail(rows-k-1), internal::conj(m_hCoeffs.coeff(k)), &temp.coeffRef(k));
    res.row(k).swap(res.row(m_rows_transpositions.coeff(k)));
  }
  return res;
}





template<typename Derived>
const FullPivHouseholderQR<typename MatrixBase<Derived>::PlainObject>
MatrixBase<Derived>::fullPivHouseholderQr() const
{
  return FullPivHouseholderQR<PlainObject>(eval());
}
# 30 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/QR" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/ColPivHouseholderQR.h" 1
# 50 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/ColPivHouseholderQR.h"
template<typename _MatrixType> class ColPivHouseholderQR
{
  public:

    typedef _MatrixType MatrixType;
    enum {
      RowsAtCompileTime = MatrixType::RowsAtCompileTime,
      ColsAtCompileTime = MatrixType::ColsAtCompileTime,
      Options = MatrixType::Options,
      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
    };
    typedef typename MatrixType::Scalar Scalar;
    typedef typename MatrixType::RealScalar RealScalar;
    typedef typename MatrixType::Index Index;
    typedef Matrix<Scalar, RowsAtCompileTime, RowsAtCompileTime, Options, MaxRowsAtCompileTime, MaxRowsAtCompileTime> MatrixQType;
    typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;
    typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationType;
    typedef typename internal::plain_row_type<MatrixType, Index>::type IntRowVectorType;
    typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;
    typedef typename internal::plain_row_type<MatrixType, RealScalar>::type RealRowVectorType;
    typedef typename HouseholderSequence<MatrixType,HCoeffsType>::ConjugateReturnType HouseholderSequenceType;







    ColPivHouseholderQR()
      : m_qr(),
        m_hCoeffs(),
        m_colsPermutation(),
        m_colsTranspositions(),
        m_temp(),
        m_colSqNorms(),
        m_isInitialized(false) {}







    ColPivHouseholderQR(Index rows, Index cols)
      : m_qr(rows, cols),
        m_hCoeffs((std::min)(rows,cols)),
        m_colsPermutation(cols),
        m_colsTranspositions(cols),
        m_temp(cols),
        m_colSqNorms(cols),
        m_isInitialized(false),
        m_usePrescribedThreshold(false) {}

    ColPivHouseholderQR(const MatrixType& matrix)
      : m_qr(matrix.rows(), matrix.cols()),
        m_hCoeffs((std::min)(matrix.rows(),matrix.cols())),
        m_colsPermutation(matrix.cols()),
        m_colsTranspositions(matrix.cols()),
        m_temp(matrix.cols()),
        m_colSqNorms(matrix.cols()),
        m_isInitialized(false),
        m_usePrescribedThreshold(false)
    {
      compute(matrix);
    }
# 134 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/ColPivHouseholderQR.h"
    template<typename Rhs>
    inline const internal::solve_retval<ColPivHouseholderQR, Rhs>
    solve(const MatrixBase<Rhs>& b) const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "ColPivHouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "ColPivHouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"ColPivHouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/ColPivHouseholderQR.h", 138); } while(false); else throw Eigen::eigen_assert_exception(); };
      return internal::solve_retval<ColPivHouseholderQR, Rhs>(*this, b.derived());
    }

    HouseholderSequenceType householderQ(void) const;



    const MatrixType& matrixQR() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "ColPivHouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "ColPivHouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"ColPivHouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/ColPivHouseholderQR.h", 148); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_qr;
    }

    ColPivHouseholderQR& compute(const MatrixType& matrix);

    const PermutationType& colsPermutation() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "ColPivHouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "ColPivHouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"ColPivHouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/ColPivHouseholderQR.h", 156); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_colsPermutation;
    }
# 173 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/ColPivHouseholderQR.h"
    typename MatrixType::RealScalar absDeterminant() const;
# 187 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/ColPivHouseholderQR.h"
    typename MatrixType::RealScalar logAbsDeterminant() const;







    inline Index rank() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "ColPivHouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "ColPivHouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"ColPivHouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/ColPivHouseholderQR.h", 197); } while(false); else throw Eigen::eigen_assert_exception(); };
      RealScalar premultiplied_threshold = internal::abs(m_maxpivot) * threshold();
      Index result = 0;
      for(Index i = 0; i < m_nonzero_pivots; ++i)
        result += (internal::abs(m_qr.coeff(i,i)) > premultiplied_threshold);
      return result;
    }







    inline Index dimensionOfKernel() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "ColPivHouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "ColPivHouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"ColPivHouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/ColPivHouseholderQR.h", 213); } while(false); else throw Eigen::eigen_assert_exception(); };
      return cols() - rank();
    }
# 224 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/ColPivHouseholderQR.h"
    inline bool isInjective() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "ColPivHouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "ColPivHouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"ColPivHouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/ColPivHouseholderQR.h", 226); } while(false); else throw Eigen::eigen_assert_exception(); };
      return rank() == cols();
    }
# 237 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/ColPivHouseholderQR.h"
    inline bool isSurjective() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "ColPivHouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "ColPivHouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"ColPivHouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/ColPivHouseholderQR.h", 239); } while(false); else throw Eigen::eigen_assert_exception(); };
      return rank() == rows();
    }







    inline bool isInvertible() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "ColPivHouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "ColPivHouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"ColPivHouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/ColPivHouseholderQR.h", 251); } while(false); else throw Eigen::eigen_assert_exception(); };
      return isInjective() && isSurjective();
    }






    inline const
    internal::solve_retval<ColPivHouseholderQR, typename MatrixType::IdentityReturnType>
    inverse() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "ColPivHouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "ColPivHouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"ColPivHouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/ColPivHouseholderQR.h", 264); } while(false); else throw Eigen::eigen_assert_exception(); };
      return internal::solve_retval<ColPivHouseholderQR,typename MatrixType::IdentityReturnType>
               (*this, MatrixType::Identity(m_qr.rows(), m_qr.cols()));
    }

    inline Index rows() const { return m_qr.rows(); }
    inline Index cols() const { return m_qr.cols(); }
    const HCoeffsType& hCoeffs() const { return m_hCoeffs; }
# 290 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/ColPivHouseholderQR.h"
    ColPivHouseholderQR& setThreshold(const RealScalar& threshold)
    {
      m_usePrescribedThreshold = true;
      m_prescribedThreshold = threshold;
      return *this;
    }
# 305 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/ColPivHouseholderQR.h"
    ColPivHouseholderQR& setThreshold(Default_t)
    {
      m_usePrescribedThreshold = false;
      return *this;
    }





    RealScalar threshold() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized || m_usePrescribedThreshold)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized || m_usePrescribedThreshold)) Eigen::internal::assert_fail("m_isInitialized || m_usePrescribedThreshold", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/ColPivHouseholderQR.h", 317); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_usePrescribedThreshold ? m_prescribedThreshold


                                      : NumTraits<Scalar>::epsilon() * m_qr.diagonalSize();
    }
# 331 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/ColPivHouseholderQR.h"
    inline Index nonzeroPivots() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "ColPivHouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "ColPivHouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"ColPivHouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/ColPivHouseholderQR.h", 333); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_nonzero_pivots;
    }




    RealScalar maxPivot() const { return m_maxpivot; }

  protected:
    MatrixType m_qr;
    HCoeffsType m_hCoeffs;
    PermutationType m_colsPermutation;
    IntRowVectorType m_colsTranspositions;
    RowVectorType m_temp;
    RealRowVectorType m_colSqNorms;
    bool m_isInitialized, m_usePrescribedThreshold;
    RealScalar m_prescribedThreshold, m_maxpivot;
    Index m_nonzero_pivots;
    Index m_det_pq;
};

template<typename MatrixType>
typename MatrixType::RealScalar ColPivHouseholderQR<MatrixType>::absDeterminant() const
{
  if( (!Eigen::internal::copy_bool(m_isInitialized && "ColPivHouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "ColPivHouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"ColPivHouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/ColPivHouseholderQR.h", 358); } while(false); else throw Eigen::eigen_assert_exception(); };
  if( (!Eigen::internal::copy_bool(m_qr.rows() == m_qr.cols() && "You can't take the determinant of a non-square matrix!")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_qr.rows() == m_qr.cols() && "You can't take the determinant of a non-square matrix!")) Eigen::internal::assert_fail("m_qr.rows() == m_qr.cols() && \"You can't take the determinant of a non-square matrix!\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/ColPivHouseholderQR.h", 359); } while(false); else throw Eigen::eigen_assert_exception(); };
  return internal::abs(m_qr.diagonal().prod());
}

template<typename MatrixType>
typename MatrixType::RealScalar ColPivHouseholderQR<MatrixType>::logAbsDeterminant() const
{
  if( (!Eigen::internal::copy_bool(m_isInitialized && "ColPivHouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "ColPivHouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"ColPivHouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/ColPivHouseholderQR.h", 366); } while(false); else throw Eigen::eigen_assert_exception(); };
  if( (!Eigen::internal::copy_bool(m_qr.rows() == m_qr.cols() && "You can't take the determinant of a non-square matrix!")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_qr.rows() == m_qr.cols() && "You can't take the determinant of a non-square matrix!")) Eigen::internal::assert_fail("m_qr.rows() == m_qr.cols() && \"You can't take the determinant of a non-square matrix!\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/ColPivHouseholderQR.h", 367); } while(false); else throw Eigen::eigen_assert_exception(); };
  return m_qr.diagonal().cwiseAbs().array().log().sum();
}

template<typename MatrixType>
ColPivHouseholderQR<MatrixType>& ColPivHouseholderQR<MatrixType>::compute(const MatrixType& matrix)
{
  Index rows = matrix.rows();
  Index cols = matrix.cols();
  Index size = matrix.diagonalSize();

  m_qr = matrix;
  m_hCoeffs.resize(size);

  m_temp.resize(cols);

  m_colsTranspositions.resize(matrix.cols());
  Index number_of_transpositions = 0;

  m_colSqNorms.resize(cols);
  for(Index k = 0; k < cols; ++k)
    m_colSqNorms.coeffRef(k) = m_qr.col(k).squaredNorm();

  RealScalar threshold_helper = m_colSqNorms.maxCoeff() * internal::abs2(NumTraits<Scalar>::epsilon()) / RealScalar(rows);

  m_nonzero_pivots = size;
  m_maxpivot = RealScalar(0);

  for(Index k = 0; k < size; ++k)
  {

    Index biggest_col_index;
    RealScalar biggest_col_sq_norm = m_colSqNorms.tail(cols-k).maxCoeff(&biggest_col_index);
    biggest_col_index += k;





    biggest_col_sq_norm = m_qr.col(biggest_col_index).tail(rows-k).squaredNorm();


    m_colSqNorms.coeffRef(biggest_col_index) = biggest_col_sq_norm;






    if(biggest_col_sq_norm < threshold_helper * RealScalar(rows-k))
    {
      m_nonzero_pivots = k;
      m_hCoeffs.tail(size-k).setZero();
      m_qr.bottomRightCorner(rows-k,cols-k)
          .template triangularView<StrictlyLower>()
          .setZero();
      break;
    }


    m_colsTranspositions.coeffRef(k) = biggest_col_index;
    if(k != biggest_col_index) {
      m_qr.col(k).swap(m_qr.col(biggest_col_index));
      std::swap(m_colSqNorms.coeffRef(k), m_colSqNorms.coeffRef(biggest_col_index));
      ++number_of_transpositions;
    }


    RealScalar beta;
    m_qr.col(k).tail(rows-k).makeHouseholderInPlace(m_hCoeffs.coeffRef(k), beta);


    m_qr.coeffRef(k,k) = beta;


    if(internal::abs(beta) > m_maxpivot) m_maxpivot = internal::abs(beta);


    m_qr.bottomRightCorner(rows-k, cols-k-1)
        .applyHouseholderOnTheLeft(m_qr.col(k).tail(rows-k-1), m_hCoeffs.coeffRef(k), &m_temp.coeffRef(k+1));


    m_colSqNorms.tail(cols-k-1) -= m_qr.row(k).tail(cols-k-1).cwiseAbs2();
  }

  m_colsPermutation.setIdentity(cols);
  for(Index k = 0; k < m_nonzero_pivots; ++k)
    m_colsPermutation.applyTranspositionOnTheRight(k, m_colsTranspositions.coeff(k));

  m_det_pq = (number_of_transpositions%2) ? -1 : 1;
  m_isInitialized = true;

  return *this;
}

namespace internal {

template<typename _MatrixType, typename Rhs>
struct solve_retval<ColPivHouseholderQR<_MatrixType>, Rhs>
  : solve_retval_base<ColPivHouseholderQR<_MatrixType>, Rhs>
{
  typedef typename ColPivHouseholderQR<_MatrixType>::MatrixType MatrixType; typedef typename MatrixType::Scalar Scalar; typedef typename MatrixType::RealScalar RealScalar; typedef typename MatrixType::Index Index; typedef Eigen::internal::solve_retval_base<ColPivHouseholderQR<_MatrixType>,Rhs> Base; using Base::dec; using Base::rhs; using Base::rows; using Base::cols; solve_retval(const ColPivHouseholderQR<_MatrixType>& dec, const Rhs& rhs) : Base(dec, rhs) {}

  template<typename Dest> void evalTo(Dest& dst) const
  {
    if( (!Eigen::internal::copy_bool(rhs().rows() == dec().rows())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(rhs().rows() == dec().rows())) Eigen::internal::assert_fail("rhs().rows() == dec().rows()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/ColPivHouseholderQR.h", 472); } while(false); else throw Eigen::eigen_assert_exception(); };

    const int cols = dec().cols(),
    nonzero_pivots = dec().nonzeroPivots();

    if(nonzero_pivots == 0)
    {
      dst.setZero();
      return;
    }

    typename Rhs::PlainObject c(rhs());


    c.applyOnTheLeft(householderSequence(dec().matrixQR(), dec().hCoeffs())
                     .setLength(dec().nonzeroPivots())
       .transpose()
      );

    dec().matrixQR()
       .topLeftCorner(nonzero_pivots, nonzero_pivots)
       .template triangularView<Upper>()
       .solveInPlace(c.topRows(nonzero_pivots));


    typename Rhs::PlainObject d(c);
    d.topRows(nonzero_pivots)
      = dec().matrixQR()
       .topLeftCorner(nonzero_pivots, nonzero_pivots)
       .template triangularView<Upper>()
       * c.topRows(nonzero_pivots);

    for(Index i = 0; i < nonzero_pivots; ++i) dst.row(dec().colsPermutation().indices().coeff(i)) = c.row(i);
    for(Index i = nonzero_pivots; i < cols; ++i) dst.row(dec().colsPermutation().indices().coeff(i)).setZero();
  }
};

}


template<typename MatrixType>
typename ColPivHouseholderQR<MatrixType>::HouseholderSequenceType ColPivHouseholderQR<MatrixType>
  ::householderQ() const
{
  if( (!Eigen::internal::copy_bool(m_isInitialized && "ColPivHouseholderQR is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "ColPivHouseholderQR is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"ColPivHouseholderQR is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/QR/ColPivHouseholderQR.h", 516); } while(false); else throw Eigen::eigen_assert_exception(); };
  return HouseholderSequenceType(m_qr, m_hCoeffs.conjugate()).setLength(m_nonzero_pivots);
}





template<typename Derived>
const ColPivHouseholderQR<typename MatrixBase<Derived>::PlainObject>
MatrixBase<Derived>::colPivHouseholderQr() const
{
  return ColPivHouseholderQR<PlainObject>(eval());
}
# 31 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/QR" 2





}


# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/ReenableStupidWarnings.h" 1
# 39 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/QR" 2
# 178 "/home/pipping/Downloads/eigen-eigen-3.0.3/test/main.h" 2

static void verify_impl(bool condition, const char *testname, const char *file, int line, const char *condition_as_string)
{
  if (!condition)
  {
    std::cerr << "Test " << testname << " failed in " << file << " (" << line << ")" << std::endl << "    " << condition_as_string << std::endl << std::endl; abort();


  }
}
# 303 "/home/pipping/Downloads/eigen-eigen-3.0.3/test/main.h"
namespace Eigen {

template<typename T> inline typename NumTraits<T>::Real test_precision() { return NumTraits<T>::dummy_precision(); }
template<> inline float test_precision<float>() { return 1e-3f; }
template<> inline double test_precision<double>() { return 1e-6; }
template<> inline float test_precision<std::complex<float> >() { return test_precision<float>(); }
template<> inline double test_precision<std::complex<double> >() { return test_precision<double>(); }
template<> inline long double test_precision<long double>() { return 1e-6; }

inline bool test_isApprox(const int& a, const int& b)
{ return internal::isApprox(a, b, test_precision<int>()); }
inline bool test_isMuchSmallerThan(const int& a, const int& b)
{ return internal::isMuchSmallerThan(a, b, test_precision<int>()); }
inline bool test_isApproxOrLessThan(const int& a, const int& b)
{ return internal::isApproxOrLessThan(a, b, test_precision<int>()); }

inline bool test_isApprox(const float& a, const float& b)
{ return internal::isApprox(a, b, test_precision<float>()); }
inline bool test_isMuchSmallerThan(const float& a, const float& b)
{ return internal::isMuchSmallerThan(a, b, test_precision<float>()); }
inline bool test_isApproxOrLessThan(const float& a, const float& b)
{ return internal::isApproxOrLessThan(a, b, test_precision<float>()); }
inline bool test_isApprox(const double& a, const double& b)
{ return internal::isApprox(a, b, test_precision<double>()); }

inline bool test_isMuchSmallerThan(const double& a, const double& b)
{ return internal::isMuchSmallerThan(a, b, test_precision<double>()); }
inline bool test_isApproxOrLessThan(const double& a, const double& b)
{ return internal::isApproxOrLessThan(a, b, test_precision<double>()); }

inline bool test_isApprox(const std::complex<float>& a, const std::complex<float>& b)
{ return internal::isApprox(a, b, test_precision<std::complex<float> >()); }
inline bool test_isMuchSmallerThan(const std::complex<float>& a, const std::complex<float>& b)
{ return internal::isMuchSmallerThan(a, b, test_precision<std::complex<float> >()); }

inline bool test_isApprox(const std::complex<double>& a, const std::complex<double>& b)
{ return internal::isApprox(a, b, test_precision<std::complex<double> >()); }
inline bool test_isMuchSmallerThan(const std::complex<double>& a, const std::complex<double>& b)
{ return internal::isMuchSmallerThan(a, b, test_precision<std::complex<double> >()); }

inline bool test_isApprox(const long double& a, const long double& b)
{
    bool ret = internal::isApprox(a, b, test_precision<long double>());
    if (!ret) std::cerr
        << std::endl << "    actual   = " << a
        << std::endl << "    expected = " << b << std::endl << std::endl;
    return ret;
}

inline bool test_isMuchSmallerThan(const long double& a, const long double& b)
{ return internal::isMuchSmallerThan(a, b, test_precision<long double>()); }
inline bool test_isApproxOrLessThan(const long double& a, const long double& b)
{ return internal::isApproxOrLessThan(a, b, test_precision<long double>()); }

template<typename Type1, typename Type2>
inline bool test_isApprox(const Type1& a, const Type2& b)
{
  return a.isApprox(b, test_precision<typename Type1::Scalar>());
}







template<typename Scalar,typename ScalarRef>
inline bool test_isApproxWithRef(const Scalar& a, const Scalar& b, const ScalarRef& ref)
{
  return test_isApprox(a+ref, b+ref);
}

template<typename Derived1, typename Derived2>
inline bool test_isMuchSmallerThan(const MatrixBase<Derived1>& m1,
                                   const MatrixBase<Derived2>& m2)
{
  return m1.isMuchSmallerThan(m2, test_precision<typename internal::traits<Derived1>::Scalar>());
}

template<typename Derived>
inline bool test_isMuchSmallerThan(const MatrixBase<Derived>& m,
                                   const typename NumTraits<typename internal::traits<Derived>::Scalar>::Real& s)
{
  return m.isMuchSmallerThan(s, test_precision<typename internal::traits<Derived>::Scalar>());
}

template<typename Derived>
inline bool test_isUnitary(const MatrixBase<Derived>& m)
{
  return m.isUnitary(test_precision<typename internal::traits<Derived>::Scalar>());
}

template<typename T, typename U>
bool test_is_equal(const T& actual, const U& expected)
{
    if (actual==expected)
        return true;

    std::cerr
        << std::endl << "    actual   = " << actual
        << std::endl << "    expected = " << expected << std::endl << std::endl;
    return false;
}






template<typename MatrixType>
void createRandomPIMatrixOfRank(typename MatrixType::Index desired_rank, typename MatrixType::Index rows, typename MatrixType::Index cols, MatrixType& m)
{
  typedef typename internal::traits<MatrixType>::Index Index;
  typedef typename internal::traits<MatrixType>::Scalar Scalar;
  enum { Rows = MatrixType::RowsAtCompileTime, Cols = MatrixType::ColsAtCompileTime };

  typedef Matrix<Scalar, Dynamic, 1> VectorType;
  typedef Matrix<Scalar, Rows, Rows> MatrixAType;
  typedef Matrix<Scalar, Cols, Cols> MatrixBType;

  if(desired_rank == 0)
  {
    m.setZero(rows,cols);
    return;
  }

  if(desired_rank == 1)
  {

    m = VectorType::Random(rows).normalized() * VectorType::Random(cols).normalized().transpose();
    return;
  }

  MatrixAType a = MatrixAType::Random(rows,rows);
  MatrixType d = MatrixType::Identity(rows,cols);
  MatrixBType b = MatrixBType::Random(cols,cols);


  const Index diag_size = (std::min)(d.rows(),d.cols());
  if(diag_size != desired_rank)
    d.diagonal().segment(desired_rank, diag_size-desired_rank) = VectorType::Zero(diag_size-desired_rank);

  HouseholderQR<MatrixAType> qra(a);
  HouseholderQR<MatrixBType> qrb(b);
  m = qra.householderQ() * d * qrb.householderQ();
}

}

template<typename T> struct GetDifferentType;

template<> struct GetDifferentType<float> { typedef double type; };
template<> struct GetDifferentType<double> { typedef float type; };
template<typename T> struct GetDifferentType<std::complex<T> >
{ typedef std::complex<typename GetDifferentType<T>::type> type; };

template<typename T> std::string type_name() { return "other"; }
template<> std::string type_name<float>() { return "float"; }
template<> std::string type_name<double>() { return "double"; }
template<> std::string type_name<int>() { return "int"; }
template<> std::string type_name<std::complex<float> >() { return "complex<float>"; }
template<> std::string type_name<std::complex<double> >() { return "complex<double>"; }
template<> std::string type_name<std::complex<int> >() { return "complex<int>"; }


void test_nomalloc();

using namespace Eigen;

void set_repeat_from_string(const char *str)
{
  (*__errno_location ()) = 0;
  g_repeat = int(strtoul(str, 0, 10));
  if((*__errno_location ()) || g_repeat <= 0)
  {
    std::cout << "Invalid repeat value " << str << std::endl;
    exit(1);
  }
  g_has_set_repeat = true;
}

void set_seed_from_string(const char *str)
{
  (*__errno_location ()) = 0;
  g_seed = strtoul(str, 0, 10);
  if((*__errno_location ()) || g_seed == 0)
  {
    std::cout << "Invalid seed value " << str << std::endl;
    exit(1);
  }
  g_has_set_seed = true;
}

int main(int argc, char *argv[])
{
    g_has_set_repeat = false;
    g_has_set_seed = false;
    bool need_help = false;

    for(int i = 1; i < argc; i++)
    {
      if(argv[i][0] == 'r')
      {
        if(g_has_set_repeat)
        {
          std::cout << "Argument " << argv[i] << " conflicting with a former argument" << std::endl;
          return 1;
        }
        set_repeat_from_string(argv[i]+1);
      }
      else if(argv[i][0] == 's')
      {
        if(g_has_set_seed)
        {
          std::cout << "Argument " << argv[i] << " conflicting with a former argument" << std::endl;
          return 1;
        }
         set_seed_from_string(argv[i]+1);
      }
      else
      {
        need_help = true;
      }
    }

    if(need_help)
    {
      std::cout << "This test application takes the following optional arguments:" << std::endl;
      std::cout << "  rN     Repeat each test N times (default: " << 10 << ")" << std::endl;
      std::cout << "  sN     Use N as seed for random numbers (default: based on current time)" << std::endl;
      std::cout << std::endl;
      std::cout << "If defined, the environment variables EIGEN_REPEAT and EIGEN_SEED" << std::endl;
      std::cout << "will be used as default values for these parameters." << std::endl;
      return 1;
    }

    char *env_EIGEN_REPEAT = getenv("EIGEN_REPEAT");
    if(!g_has_set_repeat && env_EIGEN_REPEAT)
      set_repeat_from_string(env_EIGEN_REPEAT);
    char *env_EIGEN_SEED = getenv("EIGEN_SEED");
    if(!g_has_set_seed && env_EIGEN_SEED)
      set_seed_from_string(env_EIGEN_SEED);

    if(!g_has_set_seed) g_seed = (unsigned int) time(__null);
    if(!g_has_set_repeat) g_repeat = 10;

    std::cout << "Initializing random number generator with seed " << g_seed << std::endl;
    srand(g_seed);
    std::cout << "Repeating each test " << g_repeat << " times" << std::endl;

    Eigen::g_test_stack.push_back("nomalloc");

    test_nomalloc();
    return 0;
}
# 36 "/home/pipping/Downloads/eigen-eigen-3.0.3/test/nomalloc.cpp" 2

# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Eigenvalues" 1





# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/DisableStupidWarnings.h" 1
# 39 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/DisableStupidWarnings.h"
#pragma clang diagnostic ignored "-Wconstant-logical-operand"
# 7 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Eigenvalues" 2




# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/LU" 1







namespace Eigen {
# 22 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/LU"
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/misc/Kernel.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/misc/Kernel.h"
namespace internal {




template<typename DecompositionType>
struct traits<kernel_retval_base<DecompositionType> >
{
  typedef typename DecompositionType::MatrixType MatrixType;
  typedef Matrix<
    typename MatrixType::Scalar,
    MatrixType::ColsAtCompileTime,


    Dynamic,
    MatrixType::Options,
    MatrixType::MaxColsAtCompileTime,
    MatrixType::MaxColsAtCompileTime

  > ReturnType;
};

template<typename _DecompositionType> struct kernel_retval_base
 : public ReturnByValue<kernel_retval_base<_DecompositionType> >
{
  typedef _DecompositionType DecompositionType;
  typedef ReturnByValue<kernel_retval_base> Base;
  typedef typename Base::Index Index;

  kernel_retval_base(const DecompositionType& dec)
    : m_dec(dec),
      m_rank(dec.rank()),
      m_cols(m_rank==dec.cols() ? 1 : dec.cols() - m_rank)
  {}

  inline Index rows() const { return m_dec.cols(); }
  inline Index cols() const { return m_cols; }
  inline Index rank() const { return m_rank; }
  inline const DecompositionType& dec() const { return m_dec; }

  template<typename Dest> inline void evalTo(Dest& dst) const
  {
    static_cast<const kernel_retval<DecompositionType>*>(this)->evalTo(dst);
  }

  protected:
    const DecompositionType& m_dec;
    Index m_rank, m_cols;
};

}
# 23 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/LU" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/misc/Image.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/misc/Image.h"
namespace internal {




template<typename DecompositionType>
struct traits<image_retval_base<DecompositionType> >
{
  typedef typename DecompositionType::MatrixType MatrixType;
  typedef Matrix<
    typename MatrixType::Scalar,
    MatrixType::RowsAtCompileTime,

    Dynamic,
    MatrixType::Options,
    MatrixType::MaxRowsAtCompileTime,
    MatrixType::MaxColsAtCompileTime
  > ReturnType;
};

template<typename _DecompositionType> struct image_retval_base
 : public ReturnByValue<image_retval_base<_DecompositionType> >
{
  typedef _DecompositionType DecompositionType;
  typedef typename DecompositionType::MatrixType MatrixType;
  typedef ReturnByValue<image_retval_base> Base;
  typedef typename Base::Index Index;

  image_retval_base(const DecompositionType& dec, const MatrixType& originalMatrix)
    : m_dec(dec), m_rank(dec.rank()),
      m_cols(m_rank == 0 ? 1 : m_rank),
      m_originalMatrix(originalMatrix)
  {}

  inline Index rows() const { return m_dec.rows(); }
  inline Index cols() const { return m_cols; }
  inline Index rank() const { return m_rank; }
  inline const DecompositionType& dec() const { return m_dec; }
  inline const MatrixType& originalMatrix() const { return m_originalMatrix; }

  template<typename Dest> inline void evalTo(Dest& dst) const
  {
    static_cast<const image_retval<DecompositionType>*>(this)->evalTo(dst);
  }

  protected:
    const DecompositionType& m_dec;
    Index m_rank, m_cols;
    const MatrixType& m_originalMatrix;
};

}
# 24 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/LU" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h" 1
# 58 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h"
template<typename _MatrixType> class FullPivLU
{
  public:
    typedef _MatrixType MatrixType;
    enum {
      RowsAtCompileTime = MatrixType::RowsAtCompileTime,
      ColsAtCompileTime = MatrixType::ColsAtCompileTime,
      Options = MatrixType::Options,
      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
    };
    typedef typename MatrixType::Scalar Scalar;
    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;
    typedef typename internal::traits<MatrixType>::StorageKind StorageKind;
    typedef typename MatrixType::Index Index;
    typedef typename internal::plain_row_type<MatrixType, Index>::type IntRowVectorType;
    typedef typename internal::plain_col_type<MatrixType, Index>::type IntColVectorType;
    typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationQType;
    typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationPType;







    FullPivLU();







    FullPivLU(Index rows, Index cols);






    FullPivLU(const MatrixType& matrix);
# 108 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h"
    FullPivLU& compute(const MatrixType& matrix);







    inline const MatrixType& matrixLU() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LU is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h", 118); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_lu;
    }
# 129 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h"
    inline Index nonzeroPivots() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LU is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h", 131); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_nonzero_pivots;
    }




    RealScalar maxPivot() const { return m_maxpivot; }





    inline const PermutationPType& permutationP() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LU is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h", 146); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_p;
    }





    inline const PermutationQType& permutationQ() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LU is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h", 156); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_q;
    }
# 174 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h"
    inline const internal::kernel_retval<FullPivLU> kernel() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LU is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h", 176); } while(false); else throw Eigen::eigen_assert_exception(); };
      return internal::kernel_retval<FullPivLU>(*this);
    }
# 199 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h"
    inline const internal::image_retval<FullPivLU>
      image(const MatrixType& originalMatrix) const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LU is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h", 202); } while(false); else throw Eigen::eigen_assert_exception(); };
      return internal::image_retval<FullPivLU>(*this, originalMatrix);
    }
# 225 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h"
    template<typename Rhs>
    inline const internal::solve_retval<FullPivLU, Rhs>
    solve(const MatrixBase<Rhs>& b) const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LU is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h", 229); } while(false); else throw Eigen::eigen_assert_exception(); };
      return internal::solve_retval<FullPivLU, Rhs>(*this, b.derived());
    }
# 248 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h"
    typename internal::traits<MatrixType>::Scalar determinant() const;
# 267 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h"
    FullPivLU& setThreshold(const RealScalar& threshold)
    {
      m_usePrescribedThreshold = true;
      m_prescribedThreshold = threshold;
      return *this;
    }
# 282 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h"
    FullPivLU& setThreshold(Default_t)
    {
      m_usePrescribedThreshold = false;
    }





    RealScalar threshold() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized || m_usePrescribedThreshold)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized || m_usePrescribedThreshold)) Eigen::internal::assert_fail("m_isInitialized || m_usePrescribedThreshold", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h", 293); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_usePrescribedThreshold ? m_prescribedThreshold


                                      : NumTraits<Scalar>::epsilon() * m_lu.diagonalSize();
    }







    inline Index rank() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LU is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h", 308); } while(false); else throw Eigen::eigen_assert_exception(); };
      RealScalar premultiplied_threshold = internal::abs(m_maxpivot) * threshold();
      Index result = 0;
      for(Index i = 0; i < m_nonzero_pivots; ++i)
        result += (internal::abs(m_lu.coeff(i,i)) > premultiplied_threshold);
      return result;
    }







    inline Index dimensionOfKernel() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LU is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h", 324); } while(false); else throw Eigen::eigen_assert_exception(); };
      return cols() - rank();
    }
# 335 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h"
    inline bool isInjective() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LU is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h", 337); } while(false); else throw Eigen::eigen_assert_exception(); };
      return rank() == cols();
    }
# 348 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h"
    inline bool isSurjective() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LU is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h", 350); } while(false); else throw Eigen::eigen_assert_exception(); };
      return rank() == rows();
    }







    inline bool isInvertible() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LU is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h", 362); } while(false); else throw Eigen::eigen_assert_exception(); };
      return isInjective() && (m_lu.rows() == m_lu.cols());
    }
# 373 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h"
    inline const internal::solve_retval<FullPivLU,typename MatrixType::IdentityReturnType> inverse() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LU is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h", 375); } while(false); else throw Eigen::eigen_assert_exception(); };
      if( (!Eigen::internal::copy_bool(m_lu.rows() == m_lu.cols() && "You can't take the inverse of a non-square matrix!")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_lu.rows() == m_lu.cols() && "You can't take the inverse of a non-square matrix!")) Eigen::internal::assert_fail("m_lu.rows() == m_lu.cols() && \"You can't take the inverse of a non-square matrix!\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h", 376); } while(false); else throw Eigen::eigen_assert_exception(); };
      return internal::solve_retval<FullPivLU,typename MatrixType::IdentityReturnType>
               (*this, MatrixType::Identity(m_lu.rows(), m_lu.cols()));
    }

    MatrixType reconstructedMatrix() const;

    inline Index rows() const { return m_lu.rows(); }
    inline Index cols() const { return m_lu.cols(); }

  protected:
    MatrixType m_lu;
    PermutationPType m_p;
    PermutationQType m_q;
    IntColVectorType m_rowsTranspositions;
    IntRowVectorType m_colsTranspositions;
    Index m_det_pq, m_nonzero_pivots;
    RealScalar m_maxpivot, m_prescribedThreshold;
    bool m_isInitialized, m_usePrescribedThreshold;
};

template<typename MatrixType>
FullPivLU<MatrixType>::FullPivLU()
  : m_isInitialized(false), m_usePrescribedThreshold(false)
{
}

template<typename MatrixType>
FullPivLU<MatrixType>::FullPivLU(Index rows, Index cols)
  : m_lu(rows, cols),
    m_p(rows),
    m_q(cols),
    m_rowsTranspositions(rows),
    m_colsTranspositions(cols),
    m_isInitialized(false),
    m_usePrescribedThreshold(false)
{
}

template<typename MatrixType>
FullPivLU<MatrixType>::FullPivLU(const MatrixType& matrix)
  : m_lu(matrix.rows(), matrix.cols()),
    m_p(matrix.rows()),
    m_q(matrix.cols()),
    m_rowsTranspositions(matrix.rows()),
    m_colsTranspositions(matrix.cols()),
    m_isInitialized(false),
    m_usePrescribedThreshold(false)
{
  compute(matrix);
}

template<typename MatrixType>
FullPivLU<MatrixType>& FullPivLU<MatrixType>::compute(const MatrixType& matrix)
{
  m_isInitialized = true;
  m_lu = matrix;

  const Index size = matrix.diagonalSize();
  const Index rows = matrix.rows();
  const Index cols = matrix.cols();



  m_rowsTranspositions.resize(matrix.rows());
  m_colsTranspositions.resize(matrix.cols());
  Index number_of_transpositions = 0;

  m_nonzero_pivots = size;
  m_maxpivot = RealScalar(0);
  RealScalar cutoff(0);

  for(Index k = 0; k < size; ++k)
  {



    Index row_of_biggest_in_corner, col_of_biggest_in_corner;
    RealScalar biggest_in_corner;
    biggest_in_corner = m_lu.bottomRightCorner(rows-k, cols-k)
                        .cwiseAbs()
                        .maxCoeff(&row_of_biggest_in_corner, &col_of_biggest_in_corner);
    row_of_biggest_in_corner += k;
    col_of_biggest_in_corner += k;


    if(k == 0) cutoff = biggest_in_corner * NumTraits<Scalar>::epsilon();





    if(biggest_in_corner < cutoff)
    {


      m_nonzero_pivots = k;
      for(Index i = k; i < size; ++i)
      {
        m_rowsTranspositions.coeffRef(i) = i;
        m_colsTranspositions.coeffRef(i) = i;
      }
      break;
    }

    if(biggest_in_corner > m_maxpivot) m_maxpivot = biggest_in_corner;




    m_rowsTranspositions.coeffRef(k) = row_of_biggest_in_corner;
    m_colsTranspositions.coeffRef(k) = col_of_biggest_in_corner;
    if(k != row_of_biggest_in_corner) {
      m_lu.row(k).swap(m_lu.row(row_of_biggest_in_corner));
      ++number_of_transpositions;
    }
    if(k != col_of_biggest_in_corner) {
      m_lu.col(k).swap(m_lu.col(col_of_biggest_in_corner));
      ++number_of_transpositions;
    }




    if(k<rows-1)
      m_lu.col(k).tail(rows-k-1) /= m_lu.coeff(k,k);
    if(k<size-1)
      m_lu.block(k+1,k+1,rows-k-1,cols-k-1).noalias() -= m_lu.col(k).tail(rows-k-1) * m_lu.row(k).tail(cols-k-1);
  }




  m_p.setIdentity(rows);
  for(Index k = size-1; k >= 0; --k)
    m_p.applyTranspositionOnTheRight(k, m_rowsTranspositions.coeff(k));

  m_q.setIdentity(cols);
  for(Index k = 0; k < size; ++k)
    m_q.applyTranspositionOnTheRight(k, m_colsTranspositions.coeff(k));

  m_det_pq = (number_of_transpositions%2) ? -1 : 1;
  return *this;
}

template<typename MatrixType>
typename internal::traits<MatrixType>::Scalar FullPivLU<MatrixType>::determinant() const
{
  if( (!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LU is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h", 524); } while(false); else throw Eigen::eigen_assert_exception(); };
  if( (!Eigen::internal::copy_bool(m_lu.rows() == m_lu.cols() && "You can't take the determinant of a non-square matrix!")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_lu.rows() == m_lu.cols() && "You can't take the determinant of a non-square matrix!")) Eigen::internal::assert_fail("m_lu.rows() == m_lu.cols() && \"You can't take the determinant of a non-square matrix!\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h", 525); } while(false); else throw Eigen::eigen_assert_exception(); };
  return Scalar(m_det_pq) * Scalar(m_lu.diagonal().prod());
}




template<typename MatrixType>
MatrixType FullPivLU<MatrixType>::reconstructedMatrix() const
{
  if( (!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LU is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h", 535); } while(false); else throw Eigen::eigen_assert_exception(); };
  const Index smalldim = (std::min)(m_lu.rows(), m_lu.cols());

  MatrixType res(m_lu.rows(),m_lu.cols());

  res = m_lu.leftCols(smalldim)
            .template triangularView<UnitLower>().toDenseMatrix()
      * m_lu.topRows(smalldim)
            .template triangularView<Upper>().toDenseMatrix();


  res = m_p.inverse() * res;


  res = res * m_q.inverse();

  return res;
}



namespace internal {
template<typename _MatrixType>
struct kernel_retval<FullPivLU<_MatrixType> >
  : kernel_retval_base<FullPivLU<_MatrixType> >
{
  typedef typename FullPivLU<_MatrixType>::MatrixType MatrixType; typedef typename MatrixType::Scalar Scalar; typedef typename MatrixType::RealScalar RealScalar; typedef typename MatrixType::Index Index; typedef Eigen::internal::kernel_retval_base<FullPivLU<_MatrixType> > Base; using Base::dec; using Base::rank; using Base::rows; using Base::cols; kernel_retval(const FullPivLU<_MatrixType>& dec) : Base(dec) {}

  enum { MaxSmallDimAtCompileTime = (((int)MatrixType::MaxColsAtCompileTime == 0 || (int)MatrixType::MaxRowsAtCompileTime == 0) ? 0 : ((int)MatrixType::MaxColsAtCompileTime == 1 || (int)MatrixType::MaxRowsAtCompileTime == 1) ? 1 : ((int)MatrixType::MaxColsAtCompileTime == Dynamic && (int)MatrixType::MaxRowsAtCompileTime == Dynamic) ? Dynamic : ((int)MatrixType::MaxColsAtCompileTime == Dynamic) ? (int)MatrixType::MaxRowsAtCompileTime : ((int)MatrixType::MaxRowsAtCompileTime == Dynamic) ? (int)MatrixType::MaxColsAtCompileTime : ((int)MatrixType::MaxColsAtCompileTime <= (int)MatrixType::MaxRowsAtCompileTime) ? (int)MatrixType::MaxColsAtCompileTime : (int)MatrixType::MaxRowsAtCompileTime)


  };

  template<typename Dest> void evalTo(Dest& dst) const
  {
    const Index cols = dec().matrixLU().cols(), dimker = cols - rank();
    if(dimker == 0)
    {



      dst.setZero();
      return;
    }
# 596 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h"
    Matrix<Index, Dynamic, 1, 0, MaxSmallDimAtCompileTime, 1> pivots(rank());
    RealScalar premultiplied_threshold = dec().maxPivot() * dec().threshold();
    Index p = 0;
    for(Index i = 0; i < dec().nonzeroPivots(); ++i)
      if(abs(dec().matrixLU().coeff(i,i)) > premultiplied_threshold)
        pivots.coeffRef(p++) = i;
    if( (!Eigen::internal::copy_bool(p == rank())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(p == rank())) Eigen::internal::assert_fail("p == rank()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h", 602); } while(false); else throw Eigen::eigen_assert_exception(); };





    Matrix<typename MatrixType::Scalar, Dynamic, Dynamic, MatrixType::Options,
           MaxSmallDimAtCompileTime, MatrixType::MaxColsAtCompileTime>
      m(dec().matrixLU().block(0, 0, rank(), cols));
    for(Index i = 0; i < rank(); ++i)
    {
      if(i) m.row(i).head(i).setZero();
      m.row(i).tail(cols-i) = dec().matrixLU().row(pivots.coeff(i)).tail(cols-i);
    }
    m.block(0, 0, rank(), rank());
    m.block(0, 0, rank(), rank()).template triangularView<StrictlyLower>().setZero();
    for(Index i = 0; i < rank(); ++i)
      m.col(i).swap(m.col(pivots.coeff(i)));




    m.topLeftCorner(rank(), rank())
     .template triangularView<Upper>().solveInPlace(
        m.topRightCorner(rank(), dimker)
      );


    for(Index i = rank()-1; i >= 0; --i)
      m.col(i).swap(m.col(pivots.coeff(i)));


    for(Index i = 0; i < rank(); ++i) dst.row(dec().permutationQ().indices().coeff(i)) = -m.row(i).tail(dimker);
    for(Index i = rank(); i < cols; ++i) dst.row(dec().permutationQ().indices().coeff(i)).setZero();
    for(Index k = 0; k < dimker; ++k) dst.coeffRef(dec().permutationQ().indices().coeff(rank()+k), k) = Scalar(1);
  }
};



template<typename _MatrixType>
struct image_retval<FullPivLU<_MatrixType> >
  : image_retval_base<FullPivLU<_MatrixType> >
{
  typedef typename FullPivLU<_MatrixType>::MatrixType MatrixType; typedef typename MatrixType::Scalar Scalar; typedef typename MatrixType::RealScalar RealScalar; typedef typename MatrixType::Index Index; typedef Eigen::internal::image_retval_base<FullPivLU<_MatrixType> > Base; using Base::dec; using Base::originalMatrix; using Base::rank; using Base::rows; using Base::cols; image_retval(const FullPivLU<_MatrixType>& dec, const MatrixType& originalMatrix) : Base(dec, originalMatrix) {}

  enum { MaxSmallDimAtCompileTime = (((int)MatrixType::MaxColsAtCompileTime == 0 || (int)MatrixType::MaxRowsAtCompileTime == 0) ? 0 : ((int)MatrixType::MaxColsAtCompileTime == 1 || (int)MatrixType::MaxRowsAtCompileTime == 1) ? 1 : ((int)MatrixType::MaxColsAtCompileTime == Dynamic && (int)MatrixType::MaxRowsAtCompileTime == Dynamic) ? Dynamic : ((int)MatrixType::MaxColsAtCompileTime == Dynamic) ? (int)MatrixType::MaxRowsAtCompileTime : ((int)MatrixType::MaxRowsAtCompileTime == Dynamic) ? (int)MatrixType::MaxColsAtCompileTime : ((int)MatrixType::MaxColsAtCompileTime <= (int)MatrixType::MaxRowsAtCompileTime) ? (int)MatrixType::MaxColsAtCompileTime : (int)MatrixType::MaxRowsAtCompileTime)


  };

  template<typename Dest> void evalTo(Dest& dst) const
  {
    if(rank() == 0)
    {



      dst.setZero();
      return;
    }

    Matrix<Index, Dynamic, 1, 0, MaxSmallDimAtCompileTime, 1> pivots(rank());
    RealScalar premultiplied_threshold = dec().maxPivot() * dec().threshold();
    Index p = 0;
    for(Index i = 0; i < dec().nonzeroPivots(); ++i)
      if(abs(dec().matrixLU().coeff(i,i)) > premultiplied_threshold)
        pivots.coeffRef(p++) = i;
    if( (!Eigen::internal::copy_bool(p == rank())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(p == rank())) Eigen::internal::assert_fail("p == rank()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h", 670); } while(false); else throw Eigen::eigen_assert_exception(); };

    for(Index i = 0; i < rank(); ++i)
      dst.col(i) = originalMatrix().col(dec().permutationQ().indices().coeff(pivots.coeff(i)));
  }
};



template<typename _MatrixType, typename Rhs>
struct solve_retval<FullPivLU<_MatrixType>, Rhs>
  : solve_retval_base<FullPivLU<_MatrixType>, Rhs>
{
  typedef typename FullPivLU<_MatrixType>::MatrixType MatrixType; typedef typename MatrixType::Scalar Scalar; typedef typename MatrixType::RealScalar RealScalar; typedef typename MatrixType::Index Index; typedef Eigen::internal::solve_retval_base<FullPivLU<_MatrixType>,Rhs> Base; using Base::dec; using Base::rhs; using Base::rows; using Base::cols; solve_retval(const FullPivLU<_MatrixType>& dec, const Rhs& rhs) : Base(dec, rhs) {}

  template<typename Dest> void evalTo(Dest& dst) const
  {
# 695 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h"
    const Index rows = dec().rows(), cols = dec().cols(),
              nonzero_pivots = dec().nonzeroPivots();
    if( (!Eigen::internal::copy_bool(rhs().rows() == rows)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(rhs().rows() == rows)) Eigen::internal::assert_fail("rhs().rows() == rows", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h", 697); } while(false); else throw Eigen::eigen_assert_exception(); };
    const Index smalldim = (std::min)(rows, cols);

    if(nonzero_pivots == 0)
    {
      dst.setZero();
      return;
    }

    typename Rhs::PlainObject c(rhs().rows(), rhs().cols());


    c = dec().permutationP() * rhs();


    dec().matrixLU()
        .topLeftCorner(smalldim,smalldim)
        .template triangularView<UnitLower>()
        .solveInPlace(c.topRows(smalldim));
    if(rows>cols)
    {
      c.bottomRows(rows-cols)
        -= dec().matrixLU().bottomRows(rows-cols)
         * c.topRows(cols);
    }


    dec().matrixLU()
        .topLeftCorner(nonzero_pivots, nonzero_pivots)
        .template triangularView<Upper>()
        .solveInPlace(c.topRows(nonzero_pivots));


    for(Index i = 0; i < nonzero_pivots; ++i)
      dst.row(dec().permutationQ().indices().coeff(i)) = c.row(i);
    for(Index i = nonzero_pivots; i < dec().matrixLU().cols(); ++i)
      dst.row(dec().permutationQ().indices().coeff(i)).setZero();
  }
};

}
# 747 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/FullPivLU.h"
template<typename Derived>
inline const FullPivLU<typename MatrixBase<Derived>::PlainObject>
MatrixBase<Derived>::fullPivLu() const
{
  return FullPivLU<PlainObject>(eval());
}
# 25 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/LU" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/PartialPivLU.h" 1
# 60 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/PartialPivLU.h"
template<typename _MatrixType> class PartialPivLU
{
  public:

    typedef _MatrixType MatrixType;
    enum {
      RowsAtCompileTime = MatrixType::RowsAtCompileTime,
      ColsAtCompileTime = MatrixType::ColsAtCompileTime,
      Options = MatrixType::Options,
      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
    };
    typedef typename MatrixType::Scalar Scalar;
    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;
    typedef typename internal::traits<MatrixType>::StorageKind StorageKind;
    typedef typename MatrixType::Index Index;
    typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationType;
    typedef Transpositions<RowsAtCompileTime, MaxRowsAtCompileTime> TranspositionType;
# 86 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/PartialPivLU.h"
    PartialPivLU();







    PartialPivLU(Index size);
# 103 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/PartialPivLU.h"
    PartialPivLU(const MatrixType& matrix);

    PartialPivLU& compute(const MatrixType& matrix);







    inline const MatrixType& matrixLU() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "PartialPivLU is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "PartialPivLU is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"PartialPivLU is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/PartialPivLU.h", 115); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_lu;
    }



    inline const PermutationType& permutationP() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "PartialPivLU is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "PartialPivLU is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"PartialPivLU is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/PartialPivLU.h", 123); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_p;
    }
# 144 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/PartialPivLU.h"
    template<typename Rhs>
    inline const internal::solve_retval<PartialPivLU, Rhs>
    solve(const MatrixBase<Rhs>& b) const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "PartialPivLU is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "PartialPivLU is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"PartialPivLU is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/PartialPivLU.h", 148); } while(false); else throw Eigen::eigen_assert_exception(); };
      return internal::solve_retval<PartialPivLU, Rhs>(*this, b.derived());
    }
# 159 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/PartialPivLU.h"
    inline const internal::solve_retval<PartialPivLU,typename MatrixType::IdentityReturnType> inverse() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "PartialPivLU is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "PartialPivLU is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"PartialPivLU is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/PartialPivLU.h", 161); } while(false); else throw Eigen::eigen_assert_exception(); };
      return internal::solve_retval<PartialPivLU,typename MatrixType::IdentityReturnType>
               (*this, MatrixType::Identity(m_lu.rows(), m_lu.cols()));
    }
# 179 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/PartialPivLU.h"
    typename internal::traits<MatrixType>::Scalar determinant() const;

    MatrixType reconstructedMatrix() const;

    inline Index rows() const { return m_lu.rows(); }
    inline Index cols() const { return m_lu.cols(); }

  protected:
    MatrixType m_lu;
    PermutationType m_p;
    TranspositionType m_rowsTranspositions;
    Index m_det_p;
    bool m_isInitialized;
};

template<typename MatrixType>
PartialPivLU<MatrixType>::PartialPivLU()
  : m_lu(),
    m_p(),
    m_rowsTranspositions(),
    m_det_p(0),
    m_isInitialized(false)
{
}

template<typename MatrixType>
PartialPivLU<MatrixType>::PartialPivLU(Index size)
  : m_lu(size, size),
    m_p(size),
    m_rowsTranspositions(size),
    m_det_p(0),
    m_isInitialized(false)
{
}

template<typename MatrixType>
PartialPivLU<MatrixType>::PartialPivLU(const MatrixType& matrix)
  : m_lu(matrix.rows(), matrix.rows()),
    m_p(matrix.rows()),
    m_rowsTranspositions(matrix.rows()),
    m_det_p(0),
    m_isInitialized(false)
{
  compute(matrix);
}

namespace internal {


template<typename Scalar, int StorageOrder, typename PivIndex>
struct partial_lu_impl
{





  typedef Map<Matrix<Scalar, Dynamic, Dynamic, StorageOrder> > MapLU;
  typedef Block<MapLU, Dynamic, Dynamic> MatrixType;
  typedef Block<MatrixType,Dynamic,Dynamic> BlockType;
  typedef typename MatrixType::RealScalar RealScalar;
  typedef typename MatrixType::Index Index;
# 252 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/PartialPivLU.h"
  static Index unblocked_lu(MatrixType& lu, PivIndex* row_transpositions, PivIndex& nb_transpositions)
  {
    const Index rows = lu.rows();
    const Index cols = lu.cols();
    const Index size = (std::min)(rows,cols);
    nb_transpositions = 0;
    int first_zero_pivot = -1;
    for(Index k = 0; k < size; ++k)
    {
      Index rrows = rows-k-1;
      Index rcols = cols-k-1;

      Index row_of_biggest_in_col;
      RealScalar biggest_in_corner
        = lu.col(k).tail(rows-k).cwiseAbs().maxCoeff(&row_of_biggest_in_col);
      row_of_biggest_in_col += k;

      row_transpositions[k] = row_of_biggest_in_col;

      if(biggest_in_corner != RealScalar(0))
      {
        if(k != row_of_biggest_in_col)
        {
          lu.row(k).swap(lu.row(row_of_biggest_in_col));
          ++nb_transpositions;
        }



        lu.col(k).tail(rrows) /= lu.coeff(k,k);
      }
      else if(first_zero_pivot==-1)
      {


        first_zero_pivot = k;
      }

      if(k<rows-1)
        lu.bottomRightCorner(rrows,rcols).noalias() -= lu.col(k).tail(rrows) * lu.row(k).tail(rcols);
    }
    return first_zero_pivot;
  }
# 311 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/PartialPivLU.h"
  static Index blocked_lu(Index rows, Index cols, Scalar* lu_data, Index luStride, PivIndex* row_transpositions, PivIndex& nb_transpositions, Index maxBlockSize=256)
  {
    MapLU lu1(lu_data,StorageOrder==RowMajor?rows:luStride,StorageOrder==RowMajor?luStride:cols);
    MatrixType lu(lu1,0,0,rows,cols);

    const Index size = (std::min)(rows,cols);


    if(size<=16)
    {
      return unblocked_lu(lu, row_transpositions, nb_transpositions);
    }



    Index blockSize;
    {
      blockSize = size/8;
      blockSize = (blockSize/16)*16;
      blockSize = (std::min)((std::max)(blockSize,Index(8)), maxBlockSize);
    }

    nb_transpositions = 0;
    int first_zero_pivot = -1;
    for(Index k = 0; k < size; k+=blockSize)
    {
      Index bs = (std::min)(size-k,blockSize);
      Index trows = rows - k - bs;
      Index tsize = size - k - bs;





      BlockType A_0(lu,0,0,rows,k);
      BlockType A_2(lu,0,k+bs,rows,tsize);
      BlockType A11(lu,k,k,bs,bs);
      BlockType A12(lu,k,k+bs,bs,tsize);
      BlockType A21(lu,k+bs,k,trows,bs);
      BlockType A22(lu,k+bs,k+bs,trows,tsize);

      PivIndex nb_transpositions_in_panel;


      Index ret = blocked_lu(trows+bs, bs, &lu.coeffRef(k,k), luStride,
                   row_transpositions+k, nb_transpositions_in_panel, 16);
      if(ret>=0 && first_zero_pivot==-1)
        first_zero_pivot = k+ret;

      nb_transpositions += nb_transpositions_in_panel;

      for(Index i=k; i<k+bs; ++i)
      {
        Index piv = (row_transpositions[i] += k);
        A_0.row(i).swap(A_0.row(piv));
      }

      if(trows)
      {

        for(Index i=k;i<k+bs; ++i)
          A_2.row(i).swap(A_2.row(row_transpositions[i]));


        A11.template triangularView<UnitLower>().solveInPlace(A12);

        A22.noalias() -= A21 * A12;
      }
    }
    return first_zero_pivot;
  }
};



template<typename MatrixType, typename TranspositionType>
void partial_lu_inplace(MatrixType& lu, TranspositionType& row_transpositions, typename TranspositionType::Index& nb_transpositions)
{
  if( (!Eigen::internal::copy_bool(lu.cols() == row_transpositions.size())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(lu.cols() == row_transpositions.size())) Eigen::internal::assert_fail("lu.cols() == row_transpositions.size()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/PartialPivLU.h", 389); } while(false); else throw Eigen::eigen_assert_exception(); };
  if( (!Eigen::internal::copy_bool((&row_transpositions.coeffRef(1)-&row_transpositions.coeffRef(0)) == 1)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool((&row_transpositions.coeffRef(1)-&row_transpositions.coeffRef(0)) == 1)) Eigen::internal::assert_fail("(&row_transpositions.coeffRef(1)-&row_transpositions.coeffRef(0)) == 1", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/PartialPivLU.h", 390); } while(false); else throw Eigen::eigen_assert_exception(); };

  partial_lu_impl
    <typename MatrixType::Scalar, MatrixType::Flags&RowMajorBit?RowMajor:ColMajor, typename TranspositionType::Index>
    ::blocked_lu(lu.rows(), lu.cols(), &lu.coeffRef(0,0), lu.outerStride(), &row_transpositions.coeffRef(0), nb_transpositions);
}

}

template<typename MatrixType>
PartialPivLU<MatrixType>& PartialPivLU<MatrixType>::compute(const MatrixType& matrix)
{
  m_lu = matrix;

  if( (!Eigen::internal::copy_bool(matrix.rows() == matrix.cols() && "PartialPivLU is only for square (and moreover invertible) matrices")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(matrix.rows() == matrix.cols() && "PartialPivLU is only for square (and moreover invertible) matrices")) Eigen::internal::assert_fail("matrix.rows() == matrix.cols() && \"PartialPivLU is only for square (and moreover invertible) matrices\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/PartialPivLU.h", 404); } while(false); else throw Eigen::eigen_assert_exception(); };
  const Index size = matrix.rows();

  m_rowsTranspositions.resize(size);

  typename TranspositionType::Index nb_transpositions;
  internal::partial_lu_inplace(m_lu, m_rowsTranspositions, nb_transpositions);
  m_det_p = (nb_transpositions%2) ? -1 : 1;

  m_p = m_rowsTranspositions;

  m_isInitialized = true;
  return *this;
}

template<typename MatrixType>
typename internal::traits<MatrixType>::Scalar PartialPivLU<MatrixType>::determinant() const
{
  if( (!Eigen::internal::copy_bool(m_isInitialized && "PartialPivLU is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "PartialPivLU is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"PartialPivLU is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/PartialPivLU.h", 422); } while(false); else throw Eigen::eigen_assert_exception(); };
  return Scalar(m_det_p) * m_lu.diagonal().prod();
}




template<typename MatrixType>
MatrixType PartialPivLU<MatrixType>::reconstructedMatrix() const
{
  if( (!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "LU is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"LU is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/PartialPivLU.h", 432); } while(false); else throw Eigen::eigen_assert_exception(); };

  MatrixType res = m_lu.template triangularView<UnitLower>().toDenseMatrix()
                 * m_lu.template triangularView<Upper>();


  res = m_p.inverse() * res;

  return res;
}



namespace internal {

template<typename _MatrixType, typename Rhs>
struct solve_retval<PartialPivLU<_MatrixType>, Rhs>
  : solve_retval_base<PartialPivLU<_MatrixType>, Rhs>
{
  typedef typename PartialPivLU<_MatrixType>::MatrixType MatrixType; typedef typename MatrixType::Scalar Scalar; typedef typename MatrixType::RealScalar RealScalar; typedef typename MatrixType::Index Index; typedef Eigen::internal::solve_retval_base<PartialPivLU<_MatrixType>,Rhs> Base; using Base::dec; using Base::rhs; using Base::rows; using Base::cols; solve_retval(const PartialPivLU<_MatrixType>& dec, const Rhs& rhs) : Base(dec, rhs) {}

  template<typename Dest> void evalTo(Dest& dst) const
  {







    if( (!Eigen::internal::copy_bool(rhs().rows() == dec().matrixLU().rows())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(rhs().rows() == dec().matrixLU().rows())) Eigen::internal::assert_fail("rhs().rows() == dec().matrixLU().rows()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/PartialPivLU.h", 462); } while(false); else throw Eigen::eigen_assert_exception(); };


    dst = dec().permutationP() * rhs();


    dec().matrixLU().template triangularView<UnitLower>().solveInPlace(dst);


    dec().matrixLU().template triangularView<Upper>().solveInPlace(dst);
  }
};

}
# 485 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/PartialPivLU.h"
template<typename Derived>
inline const PartialPivLU<typename MatrixBase<Derived>::PlainObject>
MatrixBase<Derived>::partialPivLu() const
{
  return PartialPivLU<PlainObject>(eval());
}
# 501 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/PartialPivLU.h"
template<typename Derived>
inline const PartialPivLU<typename MatrixBase<Derived>::PlainObject>
MatrixBase<Derived>::lu() const
{
  return PartialPivLU<PlainObject>(eval());
}
# 26 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/LU" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/Determinant.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/Determinant.h"
namespace internal {

template<typename Derived>
inline const typename Derived::Scalar bruteforce_det3_helper
(const MatrixBase<Derived>& matrix, int a, int b, int c)
{
  return matrix.coeff(0,a)
         * (matrix.coeff(1,b) * matrix.coeff(2,c) - matrix.coeff(1,c) * matrix.coeff(2,b));
}

template<typename Derived>
const typename Derived::Scalar bruteforce_det4_helper
(const MatrixBase<Derived>& matrix, int j, int k, int m, int n)
{
  return (matrix.coeff(j,0) * matrix.coeff(k,1) - matrix.coeff(k,0) * matrix.coeff(j,1))
       * (matrix.coeff(m,2) * matrix.coeff(n,3) - matrix.coeff(n,2) * matrix.coeff(m,3));
}

template<typename Derived,
         int DeterminantType = Derived::RowsAtCompileTime
> struct determinant_impl
{
  static inline typename traits<Derived>::Scalar run(const Derived& m)
  {
    if(Derived::ColsAtCompileTime==Dynamic && m.rows()==0)
      return typename traits<Derived>::Scalar(1);
    return m.partialPivLu().determinant();
  }
};

template<typename Derived> struct determinant_impl<Derived, 1>
{
  static inline typename traits<Derived>::Scalar run(const Derived& m)
  {
    return m.coeff(0,0);
  }
};

template<typename Derived> struct determinant_impl<Derived, 2>
{
  static inline typename traits<Derived>::Scalar run(const Derived& m)
  {
    return m.coeff(0,0) * m.coeff(1,1) - m.coeff(1,0) * m.coeff(0,1);
  }
};

template<typename Derived> struct determinant_impl<Derived, 3>
{
  static inline typename traits<Derived>::Scalar run(const Derived& m)
  {
    return bruteforce_det3_helper(m,0,1,2)
          - bruteforce_det3_helper(m,1,0,2)
          + bruteforce_det3_helper(m,2,0,1);
  }
};

template<typename Derived> struct determinant_impl<Derived, 4>
{
  static typename traits<Derived>::Scalar run(const Derived& m)
  {

    return bruteforce_det4_helper(m,0,1,2,3)
          - bruteforce_det4_helper(m,0,2,1,3)
          + bruteforce_det4_helper(m,0,3,1,2)
          + bruteforce_det4_helper(m,1,2,0,3)
          - bruteforce_det4_helper(m,1,3,0,2)
          + bruteforce_det4_helper(m,2,3,0,1);
  }
};

}





template<typename Derived>
inline typename internal::traits<Derived>::Scalar MatrixBase<Derived>::determinant() const
{
  ((rows() == cols()) ? static_cast<void> (0) : __assert_fail ("rows() == cols()", "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/Determinant.h", 107, __PRETTY_FUNCTION__));
  typedef typename internal::nested<Derived,Base::RowsAtCompileTime>::type Nested;
  return internal::determinant_impl<typename internal::remove_all<Nested>::type>::run(derived());
}
# 27 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/LU" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/Inverse.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/Inverse.h"
namespace internal {





template<typename MatrixType, typename ResultType, int Size = MatrixType::RowsAtCompileTime>
struct compute_inverse
{
  static inline void run(const MatrixType& matrix, ResultType& result)
  {
    result = matrix.partialPivLu().inverse();
  }
};

template<typename MatrixType, typename ResultType, int Size = MatrixType::RowsAtCompileTime>
struct compute_inverse_and_det_with_check { };





template<typename MatrixType, typename ResultType>
struct compute_inverse<MatrixType, ResultType, 1>
{
  static inline void run(const MatrixType& matrix, ResultType& result)
  {
    typedef typename MatrixType::Scalar Scalar;
    result.coeffRef(0,0) = Scalar(1) / matrix.coeff(0,0);
  }
};

template<typename MatrixType, typename ResultType>
struct compute_inverse_and_det_with_check<MatrixType, ResultType, 1>
{
  static inline void run(
    const MatrixType& matrix,
    const typename MatrixType::RealScalar& absDeterminantThreshold,
    ResultType& result,
    typename ResultType::Scalar& determinant,
    bool& invertible
  )
  {
    determinant = matrix.coeff(0,0);
    invertible = abs(determinant) > absDeterminantThreshold;
    if(invertible) result.coeffRef(0,0) = typename ResultType::Scalar(1) / determinant;
  }
};





template<typename MatrixType, typename ResultType>
inline void compute_inverse_size2_helper(
    const MatrixType& matrix, const typename ResultType::Scalar& invdet,
    ResultType& result)
{
  result.coeffRef(0,0) = matrix.coeff(1,1) * invdet;
  result.coeffRef(1,0) = -matrix.coeff(1,0) * invdet;
  result.coeffRef(0,1) = -matrix.coeff(0,1) * invdet;
  result.coeffRef(1,1) = matrix.coeff(0,0) * invdet;
}

template<typename MatrixType, typename ResultType>
struct compute_inverse<MatrixType, ResultType, 2>
{
  static inline void run(const MatrixType& matrix, ResultType& result)
  {
    typedef typename ResultType::Scalar Scalar;
    const Scalar invdet = typename MatrixType::Scalar(1) / matrix.determinant();
    compute_inverse_size2_helper(matrix, invdet, result);
  }
};

template<typename MatrixType, typename ResultType>
struct compute_inverse_and_det_with_check<MatrixType, ResultType, 2>
{
  static inline void run(
    const MatrixType& matrix,
    const typename MatrixType::RealScalar& absDeterminantThreshold,
    ResultType& inverse,
    typename ResultType::Scalar& determinant,
    bool& invertible
  )
  {
    typedef typename ResultType::Scalar Scalar;
    determinant = matrix.determinant();
    invertible = abs(determinant) > absDeterminantThreshold;
    if(!invertible) return;
    const Scalar invdet = Scalar(1) / determinant;
    compute_inverse_size2_helper(matrix, invdet, inverse);
  }
};





template<typename MatrixType, int i, int j>
inline typename MatrixType::Scalar cofactor_3x3(const MatrixType& m)
{
  enum {
    i1 = (i+1) % 3,
    i2 = (i+2) % 3,
    j1 = (j+1) % 3,
    j2 = (j+2) % 3
  };
  return m.coeff(i1, j1) * m.coeff(i2, j2)
       - m.coeff(i1, j2) * m.coeff(i2, j1);
}

template<typename MatrixType, typename ResultType>
inline void compute_inverse_size3_helper(
    const MatrixType& matrix,
    const typename ResultType::Scalar& invdet,
    const Matrix<typename ResultType::Scalar,3,1>& cofactors_col0,
    ResultType& result)
{
  result.row(0) = cofactors_col0 * invdet;
  result.coeffRef(1,0) = cofactor_3x3<MatrixType,0,1>(matrix) * invdet;
  result.coeffRef(1,1) = cofactor_3x3<MatrixType,1,1>(matrix) * invdet;
  result.coeffRef(1,2) = cofactor_3x3<MatrixType,2,1>(matrix) * invdet;
  result.coeffRef(2,0) = cofactor_3x3<MatrixType,0,2>(matrix) * invdet;
  result.coeffRef(2,1) = cofactor_3x3<MatrixType,1,2>(matrix) * invdet;
  result.coeffRef(2,2) = cofactor_3x3<MatrixType,2,2>(matrix) * invdet;
}

template<typename MatrixType, typename ResultType>
struct compute_inverse<MatrixType, ResultType, 3>
{
  static inline void run(const MatrixType& matrix, ResultType& result)
  {
    typedef typename ResultType::Scalar Scalar;
    Matrix<typename MatrixType::Scalar,3,1> cofactors_col0;
    cofactors_col0.coeffRef(0) = cofactor_3x3<MatrixType,0,0>(matrix);
    cofactors_col0.coeffRef(1) = cofactor_3x3<MatrixType,1,0>(matrix);
    cofactors_col0.coeffRef(2) = cofactor_3x3<MatrixType,2,0>(matrix);
    const Scalar det = (cofactors_col0.cwiseProduct(matrix.col(0))).sum();
    const Scalar invdet = Scalar(1) / det;
    compute_inverse_size3_helper(matrix, invdet, cofactors_col0, result);
  }
};

template<typename MatrixType, typename ResultType>
struct compute_inverse_and_det_with_check<MatrixType, ResultType, 3>
{
  static inline void run(
    const MatrixType& matrix,
    const typename MatrixType::RealScalar& absDeterminantThreshold,
    ResultType& inverse,
    typename ResultType::Scalar& determinant,
    bool& invertible
  )
  {
    typedef typename ResultType::Scalar Scalar;
    Matrix<Scalar,3,1> cofactors_col0;
    cofactors_col0.coeffRef(0) = cofactor_3x3<MatrixType,0,0>(matrix);
    cofactors_col0.coeffRef(1) = cofactor_3x3<MatrixType,1,0>(matrix);
    cofactors_col0.coeffRef(2) = cofactor_3x3<MatrixType,2,0>(matrix);
    determinant = (cofactors_col0.cwiseProduct(matrix.col(0))).sum();
    invertible = abs(determinant) > absDeterminantThreshold;
    if(!invertible) return;
    const Scalar invdet = Scalar(1) / determinant;
    compute_inverse_size3_helper(matrix, invdet, cofactors_col0, inverse);
  }
};





template<typename Derived>
inline const typename Derived::Scalar general_det3_helper
(const MatrixBase<Derived>& matrix, int i1, int i2, int i3, int j1, int j2, int j3)
{
  return matrix.coeff(i1,j1)
         * (matrix.coeff(i2,j2) * matrix.coeff(i3,j3) - matrix.coeff(i2,j3) * matrix.coeff(i3,j2));
}

template<typename MatrixType, int i, int j>
inline typename MatrixType::Scalar cofactor_4x4(const MatrixType& matrix)
{
  enum {
    i1 = (i+1) % 4,
    i2 = (i+2) % 4,
    i3 = (i+3) % 4,
    j1 = (j+1) % 4,
    j2 = (j+2) % 4,
    j3 = (j+3) % 4
  };
  return general_det3_helper(matrix, i1, i2, i3, j1, j2, j3)
       + general_det3_helper(matrix, i2, i3, i1, j1, j2, j3)
       + general_det3_helper(matrix, i3, i1, i2, j1, j2, j3);
}

template<int Arch, typename Scalar, typename MatrixType, typename ResultType>
struct compute_inverse_size4
{
  static void run(const MatrixType& matrix, ResultType& result)
  {
    result.coeffRef(0,0) = cofactor_4x4<MatrixType,0,0>(matrix);
    result.coeffRef(1,0) = -cofactor_4x4<MatrixType,0,1>(matrix);
    result.coeffRef(2,0) = cofactor_4x4<MatrixType,0,2>(matrix);
    result.coeffRef(3,0) = -cofactor_4x4<MatrixType,0,3>(matrix);
    result.coeffRef(0,2) = cofactor_4x4<MatrixType,2,0>(matrix);
    result.coeffRef(1,2) = -cofactor_4x4<MatrixType,2,1>(matrix);
    result.coeffRef(2,2) = cofactor_4x4<MatrixType,2,2>(matrix);
    result.coeffRef(3,2) = -cofactor_4x4<MatrixType,2,3>(matrix);
    result.coeffRef(0,1) = -cofactor_4x4<MatrixType,1,0>(matrix);
    result.coeffRef(1,1) = cofactor_4x4<MatrixType,1,1>(matrix);
    result.coeffRef(2,1) = -cofactor_4x4<MatrixType,1,2>(matrix);
    result.coeffRef(3,1) = cofactor_4x4<MatrixType,1,3>(matrix);
    result.coeffRef(0,3) = -cofactor_4x4<MatrixType,3,0>(matrix);
    result.coeffRef(1,3) = cofactor_4x4<MatrixType,3,1>(matrix);
    result.coeffRef(2,3) = -cofactor_4x4<MatrixType,3,2>(matrix);
    result.coeffRef(3,3) = cofactor_4x4<MatrixType,3,3>(matrix);
    result /= (matrix.col(0).cwiseProduct(result.row(0).transpose())).sum();
  }
};

template<typename MatrixType, typename ResultType>
struct compute_inverse<MatrixType, ResultType, 4>
 : compute_inverse_size4<Architecture::Target, typename MatrixType::Scalar,
                            MatrixType, ResultType>
{
};

template<typename MatrixType, typename ResultType>
struct compute_inverse_and_det_with_check<MatrixType, ResultType, 4>
{
  static inline void run(
    const MatrixType& matrix,
    const typename MatrixType::RealScalar& absDeterminantThreshold,
    ResultType& inverse,
    typename ResultType::Scalar& determinant,
    bool& invertible
  )
  {
    determinant = matrix.determinant();
    invertible = abs(determinant) > absDeterminantThreshold;
    if(invertible) compute_inverse<MatrixType, ResultType>::run(matrix, inverse);
  }
};





template<typename MatrixType>
struct traits<inverse_impl<MatrixType> >
{
  typedef typename MatrixType::PlainObject ReturnType;
};

template<typename MatrixType>
struct inverse_impl : public ReturnByValue<inverse_impl<MatrixType> >
{
  typedef typename MatrixType::Index Index;
  typedef typename internal::eval<MatrixType>::type MatrixTypeNested;
  typedef typename remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;
  const MatrixTypeNested m_matrix;

  inverse_impl(const MatrixType& matrix)
    : m_matrix(matrix)
  {}

  inline Index rows() const { return m_matrix.rows(); }
  inline Index cols() const { return m_matrix.cols(); }

  template<typename Dest> inline void evalTo(Dest& dst) const
  {
    const int Size = (((int)MatrixType::ColsAtCompileTime <= (int)Dest::ColsAtCompileTime) ? (int)MatrixType::ColsAtCompileTime : (int)Dest::ColsAtCompileTime);
                                   ;
    if( (!Eigen::internal::copy_bool(( (Size<=1) || (Size>4) || (extract_data(m_matrix)!=extract_data(dst))) && "Aliasing problem detected in inverse(), you need to do inverse().eval() here.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(( (Size<=1) || (Size>4) || (extract_data(m_matrix)!=extract_data(dst))) && "Aliasing problem detected in inverse(), you need to do inverse().eval() here.")) Eigen::internal::assert_fail("( (Size<=1) || (Size>4) || (extract_data(m_matrix)!=extract_data(dst))) && \"Aliasing problem detected in inverse(), you need to do inverse().eval() here.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/Inverse.h", 303); } while(false); else throw Eigen::eigen_assert_exception(); };


    compute_inverse<MatrixTypeNestedCleaned, Dest>::run(m_matrix, dst);
  }
};

}
# 328 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/Inverse.h"
template<typename Derived>
inline const internal::inverse_impl<Derived> MatrixBase<Derived>::inverse() const
{
  if (Eigen::internal::static_assertion<bool(!NumTraits<Scalar>::IsInteger)>::THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES) {}
  if( (!Eigen::internal::copy_bool(rows() == cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(rows() == cols())) Eigen::internal::assert_fail("rows() == cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/Inverse.h", 332); } while(false); else throw Eigen::eigen_assert_exception(); };
  return internal::inverse_impl<Derived>(derived());
}
# 354 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/Inverse.h"
template<typename Derived>
template<typename ResultType>
inline void MatrixBase<Derived>::computeInverseAndDetWithCheck(
    ResultType& inverse,
    typename ResultType::Scalar& determinant,
    bool& invertible,
    const RealScalar& absDeterminantThreshold
  ) const
{

  if( (!Eigen::internal::copy_bool(rows() == cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(rows() == cols())) Eigen::internal::assert_fail("rows() == cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/Inverse.h", 364); } while(false); else throw Eigen::eigen_assert_exception(); };


  typedef typename internal::conditional<
    RowsAtCompileTime == 2,
    typename internal::remove_all<typename internal::nested<Derived, 2>::type>::type,
    PlainObject
  >::type MatrixType;
  internal::compute_inverse_and_det_with_check<MatrixType, ResultType>::run
    (derived(), absDeterminantThreshold, inverse, determinant, invertible);
}
# 393 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/Inverse.h"
template<typename Derived>
template<typename ResultType>
inline void MatrixBase<Derived>::computeInverseWithCheck(
    ResultType& inverse,
    bool& invertible,
    const RealScalar& absDeterminantThreshold
  ) const
{
  RealScalar determinant;

  if( (!Eigen::internal::copy_bool(rows() == cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(rows() == cols())) Eigen::internal::assert_fail("rows() == cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/Inverse.h", 403); } while(false); else throw Eigen::eigen_assert_exception(); };
  computeInverseAndDetWithCheck(inverse,determinant,invertible,absDeterminantThreshold);
}
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/LU" 2


# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/arch/Inverse_SSE.h" 1
# 45 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/arch/Inverse_SSE.h"
namespace internal {

template<typename MatrixType, typename ResultType>
struct compute_inverse_size4<Architecture::SSE, float, MatrixType, ResultType>
{
  enum {
    MatrixAlignment = bool(MatrixType::Flags&AlignedBit),
    ResultAlignment = bool(ResultType::Flags&AlignedBit),
    StorageOrdersMatch = (MatrixType::Flags&RowMajorBit) == (ResultType::Flags&RowMajorBit)
  };

  static void run(const MatrixType& matrix, ResultType& result)
  {
    __attribute__((aligned(16))) const int _Sign_PNNP[4] = { 0x00000000, 0x80000000, 0x80000000, 0x00000000 };


    __m128 _L1 = matrix.template packet<MatrixAlignment>( 0);
    __m128 _L2 = matrix.template packet<MatrixAlignment>( 4);
    __m128 _L3 = matrix.template packet<MatrixAlignment>( 8);
    __m128 _L4 = matrix.template packet<MatrixAlignment>(12);







    __m128 A, B, C, D;
    if(!StorageOrdersMatch)
    {
      A = _mm_unpacklo_ps(_L1, _L2);
      B = _mm_unpacklo_ps(_L3, _L4);
      C = _mm_unpackhi_ps(_L1, _L2);
      D = _mm_unpackhi_ps(_L3, _L4);
    }
    else
    {
      A = _mm_movelh_ps(_L1, _L2);
      B = _mm_movehl_ps(_L2, _L1);
      C = _mm_movelh_ps(_L3, _L4);
      D = _mm_movehl_ps(_L4, _L3);
    }

    __m128 iA, iB, iC, iD,
            DC, AB;
    __m128 dA, dB, dC, dD;
    __m128 det, d, d1, d2;
    __m128 rd;


    AB = _mm_mul_ps((__builtin_shufflevector((__v4sf)(A), (__v4sf)(A), (0x0F) & 0x3, ((0x0F) & 0xc) >> 2, (((0x0F) & 0x30) >> 4) + 4, (((0x0F) & 0xc0) >> 6) + 4)), B);
    AB = _mm_sub_ps(AB,_mm_mul_ps((__builtin_shufflevector((__v4sf)(A), (__v4sf)(A), (0xA5) & 0x3, ((0xA5) & 0xc) >> 2, (((0xA5) & 0x30) >> 4) + 4, (((0xA5) & 0xc0) >> 6) + 4)), (__builtin_shufflevector((__v4sf)(B), (__v4sf)(B), (0x4E) & 0x3, ((0x4E) & 0xc) >> 2, (((0x4E) & 0x30) >> 4) + 4, (((0x4E) & 0xc0) >> 6) + 4))));

    DC = _mm_mul_ps((__builtin_shufflevector((__v4sf)(D), (__v4sf)(D), (0x0F) & 0x3, ((0x0F) & 0xc) >> 2, (((0x0F) & 0x30) >> 4) + 4, (((0x0F) & 0xc0) >> 6) + 4)), C);
    DC = _mm_sub_ps(DC,_mm_mul_ps((__builtin_shufflevector((__v4sf)(D), (__v4sf)(D), (0xA5) & 0x3, ((0xA5) & 0xc) >> 2, (((0xA5) & 0x30) >> 4) + 4, (((0xA5) & 0xc0) >> 6) + 4)), (__builtin_shufflevector((__v4sf)(C), (__v4sf)(C), (0x4E) & 0x3, ((0x4E) & 0xc) >> 2, (((0x4E) & 0x30) >> 4) + 4, (((0x4E) & 0xc0) >> 6) + 4))));


    dA = _mm_mul_ps((__builtin_shufflevector((__v4sf)(A), (__v4sf)(A), (0x5F) & 0x3, ((0x5F) & 0xc) >> 2, (((0x5F) & 0x30) >> 4) + 4, (((0x5F) & 0xc0) >> 6) + 4)),A);
    dA = _mm_sub_ss(dA, _mm_movehl_ps(dA,dA));

    dB = _mm_mul_ps((__builtin_shufflevector((__v4sf)(B), (__v4sf)(B), (0x5F) & 0x3, ((0x5F) & 0xc) >> 2, (((0x5F) & 0x30) >> 4) + 4, (((0x5F) & 0xc0) >> 6) + 4)),B);
    dB = _mm_sub_ss(dB, _mm_movehl_ps(dB,dB));


    dC = _mm_mul_ps((__builtin_shufflevector((__v4sf)(C), (__v4sf)(C), (0x5F) & 0x3, ((0x5F) & 0xc) >> 2, (((0x5F) & 0x30) >> 4) + 4, (((0x5F) & 0xc0) >> 6) + 4)),C);
    dC = _mm_sub_ss(dC, _mm_movehl_ps(dC,dC));

    dD = _mm_mul_ps((__builtin_shufflevector((__v4sf)(D), (__v4sf)(D), (0x5F) & 0x3, ((0x5F) & 0xc) >> 2, (((0x5F) & 0x30) >> 4) + 4, (((0x5F) & 0xc0) >> 6) + 4)),D);
    dD = _mm_sub_ss(dD, _mm_movehl_ps(dD,dD));


    d = _mm_mul_ps((__builtin_shufflevector((__v4sf)(DC), (__v4sf)(DC), (0xD8) & 0x3, ((0xD8) & 0xc) >> 2, (((0xD8) & 0x30) >> 4) + 4, (((0xD8) & 0xc0) >> 6) + 4)),AB);


    iD = _mm_mul_ps((__builtin_shufflevector((__v4sf)(C), (__v4sf)(C), (0xA0) & 0x3, ((0xA0) & 0xc) >> 2, (((0xA0) & 0x30) >> 4) + 4, (((0xA0) & 0xc0) >> 6) + 4)), _mm_movelh_ps(AB,AB));
    iD = _mm_add_ps(iD,_mm_mul_ps((__builtin_shufflevector((__v4sf)(C), (__v4sf)(C), (0xF5) & 0x3, ((0xF5) & 0xc) >> 2, (((0xF5) & 0x30) >> 4) + 4, (((0xF5) & 0xc0) >> 6) + 4)), _mm_movehl_ps(AB,AB)));

    iA = _mm_mul_ps((__builtin_shufflevector((__v4sf)(B), (__v4sf)(B), (0xA0) & 0x3, ((0xA0) & 0xc) >> 2, (((0xA0) & 0x30) >> 4) + 4, (((0xA0) & 0xc0) >> 6) + 4)), _mm_movelh_ps(DC,DC));
    iA = _mm_add_ps(iA,_mm_mul_ps((__builtin_shufflevector((__v4sf)(B), (__v4sf)(B), (0xF5) & 0x3, ((0xF5) & 0xc) >> 2, (((0xF5) & 0x30) >> 4) + 4, (((0xF5) & 0xc0) >> 6) + 4)), _mm_movehl_ps(DC,DC)));


    d = _mm_add_ps(d, _mm_movehl_ps(d, d));
    d = _mm_add_ss(d, (__builtin_shufflevector((__v4sf)(d), (__v4sf)(d), (1) & 0x3, ((1) & 0xc) >> 2, (((1) & 0x30) >> 4) + 4, (((1) & 0xc0) >> 6) + 4)));
    d1 = _mm_mul_ss(dA,dD);
    d2 = _mm_mul_ss(dB,dC);


    iD = _mm_sub_ps(_mm_mul_ps(D,(__builtin_shufflevector((__v4sf)(dA), (__v4sf)(dA), (0) & 0x3, ((0) & 0xc) >> 2, (((0) & 0x30) >> 4) + 4, (((0) & 0xc0) >> 6) + 4))), iD);


    iA = _mm_sub_ps(_mm_mul_ps(A,(__builtin_shufflevector((__v4sf)(dD), (__v4sf)(dD), (0) & 0x3, ((0) & 0xc) >> 2, (((0) & 0x30) >> 4) + 4, (((0) & 0xc0) >> 6) + 4))), iA);


    det = _mm_sub_ss(_mm_add_ss(d1,d2),d);
    rd = _mm_div_ss(_mm_set_ss(1.0f), det);






    iB = _mm_mul_ps(D, (__builtin_shufflevector((__v4sf)(AB), (__v4sf)(AB), (0x33) & 0x3, ((0x33) & 0xc) >> 2, (((0x33) & 0x30) >> 4) + 4, (((0x33) & 0xc0) >> 6) + 4)));
    iB = _mm_sub_ps(iB, _mm_mul_ps((__builtin_shufflevector((__v4sf)(D), (__v4sf)(D), (0xB1) & 0x3, ((0xB1) & 0xc) >> 2, (((0xB1) & 0x30) >> 4) + 4, (((0xB1) & 0xc0) >> 6) + 4)), (__builtin_shufflevector((__v4sf)(AB), (__v4sf)(AB), (0x66) & 0x3, ((0x66) & 0xc) >> 2, (((0x66) & 0x30) >> 4) + 4, (((0x66) & 0xc0) >> 6) + 4))));

    iC = _mm_mul_ps(A, (__builtin_shufflevector((__v4sf)(DC), (__v4sf)(DC), (0x33) & 0x3, ((0x33) & 0xc) >> 2, (((0x33) & 0x30) >> 4) + 4, (((0x33) & 0xc0) >> 6) + 4)));
    iC = _mm_sub_ps(iC, _mm_mul_ps((__builtin_shufflevector((__v4sf)(A), (__v4sf)(A), (0xB1) & 0x3, ((0xB1) & 0xc) >> 2, (((0xB1) & 0x30) >> 4) + 4, (((0xB1) & 0xc0) >> 6) + 4)), (__builtin_shufflevector((__v4sf)(DC), (__v4sf)(DC), (0x66) & 0x3, ((0x66) & 0xc) >> 2, (((0x66) & 0x30) >> 4) + 4, (((0x66) & 0xc0) >> 6) + 4))));

    rd = (__builtin_shufflevector((__v4sf)(rd), (__v4sf)(rd), (0) & 0x3, ((0) & 0xc) >> 2, (((0) & 0x30) >> 4) + 4, (((0) & 0xc0) >> 6) + 4));
    rd = _mm_xor_ps(rd, _mm_load_ps((float*)_Sign_PNNP));


    iB = _mm_sub_ps(_mm_mul_ps(C,(__builtin_shufflevector((__v4sf)(dB), (__v4sf)(dB), (0) & 0x3, ((0) & 0xc) >> 2, (((0) & 0x30) >> 4) + 4, (((0) & 0xc0) >> 6) + 4))), iB);


    iC = _mm_sub_ps(_mm_mul_ps(B,(__builtin_shufflevector((__v4sf)(dC), (__v4sf)(dC), (0) & 0x3, ((0) & 0xc) >> 2, (((0) & 0x30) >> 4) + 4, (((0) & 0xc0) >> 6) + 4))), iC);


    iA = _mm_mul_ps(rd,iA);
    iB = _mm_mul_ps(rd,iB);
    iC = _mm_mul_ps(rd,iC);
    iD = _mm_mul_ps(rd,iD);

    result.template writePacket<ResultAlignment>( 0, (__builtin_shufflevector((__v4sf)(iA), (__v4sf)(iB), (0x77) & 0x3, ((0x77) & 0xc) >> 2, (((0x77) & 0x30) >> 4) + 4, (((0x77) & 0xc0) >> 6) + 4)));
    result.template writePacket<ResultAlignment>( 4, (__builtin_shufflevector((__v4sf)(iA), (__v4sf)(iB), (0x22) & 0x3, ((0x22) & 0xc) >> 2, (((0x22) & 0x30) >> 4) + 4, (((0x22) & 0xc0) >> 6) + 4)));
    result.template writePacket<ResultAlignment>( 8, (__builtin_shufflevector((__v4sf)(iC), (__v4sf)(iD), (0x77) & 0x3, ((0x77) & 0xc) >> 2, (((0x77) & 0x30) >> 4) + 4, (((0x77) & 0xc0) >> 6) + 4)));
    result.template writePacket<ResultAlignment>(12, (__builtin_shufflevector((__v4sf)(iC), (__v4sf)(iD), (0x22) & 0x3, ((0x22) & 0xc) >> 2, (((0x22) & 0x30) >> 4) + 4, (((0x22) & 0xc0) >> 6) + 4)));
  }

};

template<typename MatrixType, typename ResultType>
struct compute_inverse_size4<Architecture::SSE, double, MatrixType, ResultType>
{
  enum {
    MatrixAlignment = bool(MatrixType::Flags&AlignedBit),
    ResultAlignment = bool(ResultType::Flags&AlignedBit),
    StorageOrdersMatch = (MatrixType::Flags&RowMajorBit) == (ResultType::Flags&RowMajorBit)
  };
  static void run(const MatrixType& matrix, ResultType& result)
  {
    const __m128d _Sign_NP = _mm_castsi128_pd(_mm_set_epi32(0x0,0x0,0x80000000,0x0));
    const __m128d _Sign_PN = _mm_castsi128_pd(_mm_set_epi32(0x80000000,0x0,0x0,0x0));
# 195 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/LU/arch/Inverse_SSE.h"
    __m128d A1, A2, B1, B2, C1, C2, D1, D2;

    if(StorageOrdersMatch)
    {
      A1 = matrix.template packet<MatrixAlignment>( 0); B1 = matrix.template packet<MatrixAlignment>( 2);
      A2 = matrix.template packet<MatrixAlignment>( 4); B2 = matrix.template packet<MatrixAlignment>( 6);
      C1 = matrix.template packet<MatrixAlignment>( 8); D1 = matrix.template packet<MatrixAlignment>(10);
      C2 = matrix.template packet<MatrixAlignment>(12); D2 = matrix.template packet<MatrixAlignment>(14);
    }
    else
    {
      __m128d tmp;
      A1 = matrix.template packet<MatrixAlignment>( 0); C1 = matrix.template packet<MatrixAlignment>( 2);
      A2 = matrix.template packet<MatrixAlignment>( 4); C2 = matrix.template packet<MatrixAlignment>( 6);
      tmp = A1;
      A1 = _mm_unpacklo_pd(A1,A2);
      A2 = _mm_unpackhi_pd(tmp,A2);
      tmp = C1;
      C1 = _mm_unpacklo_pd(C1,C2);
      C2 = _mm_unpackhi_pd(tmp,C2);

      B1 = matrix.template packet<MatrixAlignment>( 8); D1 = matrix.template packet<MatrixAlignment>(10);
      B2 = matrix.template packet<MatrixAlignment>(12); D2 = matrix.template packet<MatrixAlignment>(14);
      tmp = B1;
      B1 = _mm_unpacklo_pd(B1,B2);
      B2 = _mm_unpackhi_pd(tmp,B2);
      tmp = D1;
      D1 = _mm_unpacklo_pd(D1,D2);
      D2 = _mm_unpackhi_pd(tmp,D2);
    }

    __m128d iA1, iA2, iB1, iB2, iC1, iC2, iD1, iD2,
            DC1, DC2, AB1, AB2;
    __m128d dA, dB, dC, dD;
    __m128d det, d1, d2, rd;


    dA = (__builtin_shufflevector((__m128d)(A2), (__m128d)(A2), (1) & 1, (((1) & 2) >> 1) + 2));
    dA = _mm_mul_pd(A1, dA);
    dA = _mm_sub_sd(dA, (__builtin_shufflevector((__m128d)(dA), (__m128d)(dA), (3) & 1, (((3) & 2) >> 1) + 2)));

    dB = (__builtin_shufflevector((__m128d)(B2), (__m128d)(B2), (1) & 1, (((1) & 2) >> 1) + 2));
    dB = _mm_mul_pd(B1, dB);
    dB = _mm_sub_sd(dB, (__builtin_shufflevector((__m128d)(dB), (__m128d)(dB), (3) & 1, (((3) & 2) >> 1) + 2)));


    AB1 = _mm_mul_pd(B1, (__builtin_shufflevector((__m128d)(A2), (__m128d)(A2), (3) & 1, (((3) & 2) >> 1) + 2)));
    AB2 = _mm_mul_pd(B2, (__builtin_shufflevector((__m128d)(A1), (__m128d)(A1), (0) & 1, (((0) & 2) >> 1) + 2)));
    AB1 = _mm_sub_pd(AB1, _mm_mul_pd(B2, (__builtin_shufflevector((__m128d)(A1), (__m128d)(A1), (3) & 1, (((3) & 2) >> 1) + 2))));
    AB2 = _mm_sub_pd(AB2, _mm_mul_pd(B1, (__builtin_shufflevector((__m128d)(A2), (__m128d)(A2), (0) & 1, (((0) & 2) >> 1) + 2))));


    dC = (__builtin_shufflevector((__m128d)(C2), (__m128d)(C2), (1) & 1, (((1) & 2) >> 1) + 2));
    dC = _mm_mul_pd(C1, dC);
    dC = _mm_sub_sd(dC, (__builtin_shufflevector((__m128d)(dC), (__m128d)(dC), (3) & 1, (((3) & 2) >> 1) + 2)));

    dD = (__builtin_shufflevector((__m128d)(D2), (__m128d)(D2), (1) & 1, (((1) & 2) >> 1) + 2));
    dD = _mm_mul_pd(D1, dD);
    dD = _mm_sub_sd(dD, (__builtin_shufflevector((__m128d)(dD), (__m128d)(dD), (3) & 1, (((3) & 2) >> 1) + 2)));


    DC1 = _mm_mul_pd(C1, (__builtin_shufflevector((__m128d)(D2), (__m128d)(D2), (3) & 1, (((3) & 2) >> 1) + 2)));
    DC2 = _mm_mul_pd(C2, (__builtin_shufflevector((__m128d)(D1), (__m128d)(D1), (0) & 1, (((0) & 2) >> 1) + 2)));
    DC1 = _mm_sub_pd(DC1, _mm_mul_pd(C2, (__builtin_shufflevector((__m128d)(D1), (__m128d)(D1), (3) & 1, (((3) & 2) >> 1) + 2))));
    DC2 = _mm_sub_pd(DC2, _mm_mul_pd(C1, (__builtin_shufflevector((__m128d)(D2), (__m128d)(D2), (0) & 1, (((0) & 2) >> 1) + 2))));


    d1 = _mm_mul_pd(AB1, (__builtin_shufflevector((__m128d)(DC1), (__m128d)(DC2), (0) & 1, (((0) & 2) >> 1) + 2)));
    d2 = _mm_mul_pd(AB2, (__builtin_shufflevector((__m128d)(DC1), (__m128d)(DC2), (3) & 1, (((3) & 2) >> 1) + 2)));
    rd = _mm_add_pd(d1, d2);
    rd = _mm_add_sd(rd, (__builtin_shufflevector((__m128d)(rd), (__m128d)(rd), (3) & 1, (((3) & 2) >> 1) + 2)));


    iD1 = _mm_mul_pd(AB1, (__builtin_shufflevector((__m128d)(C1), (__m128d)(C1), (0) & 1, (((0) & 2) >> 1) + 2)));
    iD2 = _mm_mul_pd(AB1, (__builtin_shufflevector((__m128d)(C2), (__m128d)(C2), (0) & 1, (((0) & 2) >> 1) + 2)));
    iD1 = _mm_add_pd(iD1, _mm_mul_pd(AB2, (__builtin_shufflevector((__m128d)(C1), (__m128d)(C1), (3) & 1, (((3) & 2) >> 1) + 2))));
    iD2 = _mm_add_pd(iD2, _mm_mul_pd(AB2, (__builtin_shufflevector((__m128d)(C2), (__m128d)(C2), (3) & 1, (((3) & 2) >> 1) + 2))));


    iA1 = _mm_mul_pd(DC1, (__builtin_shufflevector((__m128d)(B1), (__m128d)(B1), (0) & 1, (((0) & 2) >> 1) + 2)));
    iA2 = _mm_mul_pd(DC1, (__builtin_shufflevector((__m128d)(B2), (__m128d)(B2), (0) & 1, (((0) & 2) >> 1) + 2)));
    iA1 = _mm_add_pd(iA1, _mm_mul_pd(DC2, (__builtin_shufflevector((__m128d)(B1), (__m128d)(B1), (3) & 1, (((3) & 2) >> 1) + 2))));
    iA2 = _mm_add_pd(iA2, _mm_mul_pd(DC2, (__builtin_shufflevector((__m128d)(B2), (__m128d)(B2), (3) & 1, (((3) & 2) >> 1) + 2))));


    dA = (__builtin_shufflevector((__m128d)(dA), (__m128d)(dA), (0) & 1, (((0) & 2) >> 1) + 2));
    iD1 = _mm_sub_pd(_mm_mul_pd(D1, dA), iD1);
    iD2 = _mm_sub_pd(_mm_mul_pd(D2, dA), iD2);


    dD = (__builtin_shufflevector((__m128d)(dD), (__m128d)(dD), (0) & 1, (((0) & 2) >> 1) + 2));
    iA1 = _mm_sub_pd(_mm_mul_pd(A1, dD), iA1);
    iA2 = _mm_sub_pd(_mm_mul_pd(A2, dD), iA2);

    d1 = _mm_mul_sd(dA, dD);
    d2 = _mm_mul_sd(dB, dC);


    iB1 = _mm_mul_pd(D1, (__builtin_shufflevector((__m128d)(AB2), (__m128d)(AB1), (1) & 1, (((1) & 2) >> 1) + 2)));
    iB2 = _mm_mul_pd(D2, (__builtin_shufflevector((__m128d)(AB2), (__m128d)(AB1), (1) & 1, (((1) & 2) >> 1) + 2)));
    iB1 = _mm_sub_pd(iB1, _mm_mul_pd((__builtin_shufflevector((__m128d)(D1), (__m128d)(D1), (1) & 1, (((1) & 2) >> 1) + 2)), (__builtin_shufflevector((__m128d)(AB2), (__m128d)(AB1), (2) & 1, (((2) & 2) >> 1) + 2))));
    iB2 = _mm_sub_pd(iB2, _mm_mul_pd((__builtin_shufflevector((__m128d)(D2), (__m128d)(D2), (1) & 1, (((1) & 2) >> 1) + 2)), (__builtin_shufflevector((__m128d)(AB2), (__m128d)(AB1), (2) & 1, (((2) & 2) >> 1) + 2))));


    det = _mm_add_sd(d1, d2);
    det = _mm_sub_sd(det, rd);


    iC1 = _mm_mul_pd(A1, (__builtin_shufflevector((__m128d)(DC2), (__m128d)(DC1), (1) & 1, (((1) & 2) >> 1) + 2)));
    iC2 = _mm_mul_pd(A2, (__builtin_shufflevector((__m128d)(DC2), (__m128d)(DC1), (1) & 1, (((1) & 2) >> 1) + 2)));
    iC1 = _mm_sub_pd(iC1, _mm_mul_pd((__builtin_shufflevector((__m128d)(A1), (__m128d)(A1), (1) & 1, (((1) & 2) >> 1) + 2)), (__builtin_shufflevector((__m128d)(DC2), (__m128d)(DC1), (2) & 1, (((2) & 2) >> 1) + 2))));
    iC2 = _mm_sub_pd(iC2, _mm_mul_pd((__builtin_shufflevector((__m128d)(A2), (__m128d)(A2), (1) & 1, (((1) & 2) >> 1) + 2)), (__builtin_shufflevector((__m128d)(DC2), (__m128d)(DC1), (2) & 1, (((2) & 2) >> 1) + 2))));

    rd = _mm_div_sd(_mm_set_sd(1.0), det);



    rd = (__builtin_shufflevector((__m128d)(rd), (__m128d)(rd), (0) & 1, (((0) & 2) >> 1) + 2));


    dB = (__builtin_shufflevector((__m128d)(dB), (__m128d)(dB), (0) & 1, (((0) & 2) >> 1) + 2));
    iB1 = _mm_sub_pd(_mm_mul_pd(C1, dB), iB1);
    iB2 = _mm_sub_pd(_mm_mul_pd(C2, dB), iB2);

    d1 = _mm_xor_pd(rd, _Sign_PN);
    d2 = _mm_xor_pd(rd, _Sign_NP);


    dC = (__builtin_shufflevector((__m128d)(dC), (__m128d)(dC), (0) & 1, (((0) & 2) >> 1) + 2));
    iC1 = _mm_sub_pd(_mm_mul_pd(B1, dC), iC1);
    iC2 = _mm_sub_pd(_mm_mul_pd(B2, dC), iC2);

    result.template writePacket<ResultAlignment>( 0, _mm_mul_pd((__builtin_shufflevector((__m128d)(iA2), (__m128d)(iA1), (3) & 1, (((3) & 2) >> 1) + 2)), d1));
    result.template writePacket<ResultAlignment>( 4, _mm_mul_pd((__builtin_shufflevector((__m128d)(iA2), (__m128d)(iA1), (0) & 1, (((0) & 2) >> 1) + 2)), d2));
    result.template writePacket<ResultAlignment>( 2, _mm_mul_pd((__builtin_shufflevector((__m128d)(iB2), (__m128d)(iB1), (3) & 1, (((3) & 2) >> 1) + 2)), d1));
    result.template writePacket<ResultAlignment>( 6, _mm_mul_pd((__builtin_shufflevector((__m128d)(iB2), (__m128d)(iB1), (0) & 1, (((0) & 2) >> 1) + 2)), d2));
    result.template writePacket<ResultAlignment>( 8, _mm_mul_pd((__builtin_shufflevector((__m128d)(iC2), (__m128d)(iC1), (3) & 1, (((3) & 2) >> 1) + 2)), d1));
    result.template writePacket<ResultAlignment>(12, _mm_mul_pd((__builtin_shufflevector((__m128d)(iC2), (__m128d)(iC1), (0) & 1, (((0) & 2) >> 1) + 2)), d2));
    result.template writePacket<ResultAlignment>(10, _mm_mul_pd((__builtin_shufflevector((__m128d)(iD2), (__m128d)(iD1), (3) & 1, (((3) & 2) >> 1) + 2)), d1));
    result.template writePacket<ResultAlignment>(14, _mm_mul_pd((__builtin_shufflevector((__m128d)(iD2), (__m128d)(iD1), (0) & 1, (((0) & 2) >> 1) + 2)), d2));
  }
};

}
# 31 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/LU" 2






}


# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/ReenableStupidWarnings.h" 1
# 40 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/LU" 2
# 12 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Eigenvalues" 2

namespace Eigen {
# 29 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Eigenvalues"
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/Tridiagonalization.h" 1
# 29 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/Tridiagonalization.h"
namespace internal {

template<typename MatrixType> struct TridiagonalizationMatrixTReturnType;
template<typename MatrixType>
struct traits<TridiagonalizationMatrixTReturnType<MatrixType> >
{
  typedef typename MatrixType::PlainObject ReturnType;
};

template<typename MatrixType, typename CoeffVectorType>
void tridiagonalization_inplace(MatrixType& matA, CoeffVectorType& hCoeffs);
}
# 74 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/Tridiagonalization.h"
template<typename _MatrixType> class Tridiagonalization
{
  public:


    typedef _MatrixType MatrixType;

    typedef typename MatrixType::Scalar Scalar;
    typedef typename NumTraits<Scalar>::Real RealScalar;
    typedef typename MatrixType::Index Index;

    enum {
      Size = MatrixType::RowsAtCompileTime,
      SizeMinusOne = Size == Dynamic ? Dynamic : (Size > 1 ? Size - 1 : 1),
      Options = MatrixType::Options,
      MaxSize = MatrixType::MaxRowsAtCompileTime,
      MaxSizeMinusOne = MaxSize == Dynamic ? Dynamic : (MaxSize > 1 ? MaxSize - 1 : 1)
    };

    typedef Matrix<Scalar, SizeMinusOne, 1, Options & ~RowMajor, MaxSizeMinusOne, 1> CoeffVectorType;
    typedef typename internal::plain_col_type<MatrixType, RealScalar>::type DiagonalType;
    typedef Matrix<RealScalar, SizeMinusOne, 1, Options & ~RowMajor, MaxSizeMinusOne, 1> SubDiagonalType;
    typedef typename internal::remove_all<typename MatrixType::RealReturnType>::type MatrixTypeRealView;
    typedef internal::TridiagonalizationMatrixTReturnType<MatrixTypeRealView> MatrixTReturnType;

    typedef typename internal::conditional<NumTraits<Scalar>::IsComplex,
              const typename Diagonal<const MatrixType>::RealReturnType,
              const Diagonal<const MatrixType>
            >::type DiagonalReturnType;

    typedef typename internal::conditional<NumTraits<Scalar>::IsComplex,
              const typename Diagonal<
                Block<const MatrixType,SizeMinusOne,SizeMinusOne> >::RealReturnType,
              const Diagonal<
                Block<const MatrixType,SizeMinusOne,SizeMinusOne> >
            >::type SubDiagonalReturnType;


    typedef typename HouseholderSequence<MatrixType,CoeffVectorType>::ConjugateReturnType HouseholderSequenceType;
# 126 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/Tridiagonalization.h"
    Tridiagonalization(Index size = Size==Dynamic ? 2 : Size)
      : m_matrix(size,size),
        m_hCoeffs(size > 1 ? size-1 : 1),
        m_isInitialized(false)
    {}
# 142 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/Tridiagonalization.h"
    Tridiagonalization(const MatrixType& matrix)
      : m_matrix(matrix),
        m_hCoeffs(matrix.cols() > 1 ? matrix.cols()-1 : 1),
        m_isInitialized(false)
    {
      internal::tridiagonalization_inplace(m_matrix, m_hCoeffs);
      m_isInitialized = true;
    }
# 168 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/Tridiagonalization.h"
    Tridiagonalization& compute(const MatrixType& matrix)
    {
      m_matrix = matrix;
      m_hCoeffs.resize(matrix.rows()-1, 1);
      internal::tridiagonalization_inplace(m_matrix, m_hCoeffs);
      m_isInitialized = true;
      return *this;
    }
# 193 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/Tridiagonalization.h"
    inline CoeffVectorType householderCoefficients() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "Tridiagonalization is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "Tridiagonalization is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"Tridiagonalization is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/Tridiagonalization.h", 195); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_hCoeffs;
    }
# 230 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/Tridiagonalization.h"
    inline const MatrixType& packedMatrix() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "Tridiagonalization is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "Tridiagonalization is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"Tridiagonalization is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/Tridiagonalization.h", 232); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_matrix;
    }
# 251 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/Tridiagonalization.h"
    HouseholderSequenceType matrixQ() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "Tridiagonalization is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "Tridiagonalization is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"Tridiagonalization is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/Tridiagonalization.h", 253); } while(false); else throw Eigen::eigen_assert_exception(); };
      return HouseholderSequenceType(m_matrix, m_hCoeffs.conjugate())
             .setLength(m_matrix.rows() - 1)
             .setShift(1);
    }
# 276 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/Tridiagonalization.h"
    MatrixTReturnType matrixT() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "Tridiagonalization is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "Tridiagonalization is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"Tridiagonalization is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/Tridiagonalization.h", 278); } while(false); else throw Eigen::eigen_assert_exception(); };
      return MatrixTReturnType(m_matrix.real());
    }
# 295 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/Tridiagonalization.h"
    DiagonalReturnType diagonal() const;
# 307 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/Tridiagonalization.h"
    SubDiagonalReturnType subDiagonal() const;

  protected:

    MatrixType m_matrix;
    CoeffVectorType m_hCoeffs;
    bool m_isInitialized;
};

template<typename MatrixType>
typename Tridiagonalization<MatrixType>::DiagonalReturnType
Tridiagonalization<MatrixType>::diagonal() const
{
  if( (!Eigen::internal::copy_bool(m_isInitialized && "Tridiagonalization is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "Tridiagonalization is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"Tridiagonalization is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/Tridiagonalization.h", 320); } while(false); else throw Eigen::eigen_assert_exception(); };
  return m_matrix.diagonal();
}

template<typename MatrixType>
typename Tridiagonalization<MatrixType>::SubDiagonalReturnType
Tridiagonalization<MatrixType>::subDiagonal() const
{
  if( (!Eigen::internal::copy_bool(m_isInitialized && "Tridiagonalization is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "Tridiagonalization is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"Tridiagonalization is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/Tridiagonalization.h", 328); } while(false); else throw Eigen::eigen_assert_exception(); };
  Index n = m_matrix.rows();
  return Block<const MatrixType,SizeMinusOne,SizeMinusOne>(m_matrix, 1, 0, n-1,n-1).diagonal();
}

namespace internal {
# 358 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/Tridiagonalization.h"
template<typename MatrixType, typename CoeffVectorType>
void tridiagonalization_inplace(MatrixType& matA, CoeffVectorType& hCoeffs)
{
  typedef typename MatrixType::Index Index;
  typedef typename MatrixType::Scalar Scalar;
  typedef typename MatrixType::RealScalar RealScalar;
  Index n = matA.rows();
  if( (!Eigen::internal::copy_bool(n==matA.cols())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(n==matA.cols())) Eigen::internal::assert_fail("n==matA.cols()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/Tridiagonalization.h", 365); } while(false); else throw Eigen::eigen_assert_exception(); };
  if( (!Eigen::internal::copy_bool(n==hCoeffs.size()+1 || n==1)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(n==hCoeffs.size()+1 || n==1)) Eigen::internal::assert_fail("n==hCoeffs.size()+1 || n==1", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/Tridiagonalization.h", 366); } while(false); else throw Eigen::eigen_assert_exception(); };

  for (Index i = 0; i<n-1; ++i)
  {
    Index remainingSize = n-i-1;
    RealScalar beta;
    Scalar h;
    matA.col(i).tail(remainingSize).makeHouseholderInPlace(h, beta);



    matA.col(i).coeffRef(i+1) = 1;

    hCoeffs.tail(n-i-1).noalias() = (matA.bottomRightCorner(remainingSize,remainingSize).template selfadjointView<Lower>()
                                  * (conj(h) * matA.col(i).tail(remainingSize)));

    hCoeffs.tail(n-i-1) += (conj(h)*Scalar(-0.5)*(hCoeffs.tail(remainingSize).dot(matA.col(i).tail(remainingSize)))) * matA.col(i).tail(n-i-1);

    matA.bottomRightCorner(remainingSize, remainingSize).template selfadjointView<Lower>()
      .rankUpdate(matA.col(i).tail(remainingSize), hCoeffs.tail(remainingSize), -1);

    matA.col(i).coeffRef(i+1) = beta;
    hCoeffs.coeffRef(i) = h;
  }
}


template<typename MatrixType,
         int Size=MatrixType::ColsAtCompileTime,
         bool IsComplex=NumTraits<typename MatrixType::Scalar>::IsComplex>
struct tridiagonalization_inplace_selector;
# 438 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/Tridiagonalization.h"
template<typename MatrixType, typename DiagonalType, typename SubDiagonalType>
void tridiagonalization_inplace(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)
{
  typedef typename MatrixType::Index Index;

  if( (!Eigen::internal::copy_bool(mat.cols()==mat.rows() && diag.size()==mat.rows() && subdiag.size()==mat.rows()-1)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(mat.cols()==mat.rows() && diag.size()==mat.rows() && subdiag.size()==mat.rows()-1)) Eigen::internal::assert_fail("mat.cols()==mat.rows() && diag.size()==mat.rows() && subdiag.size()==mat.rows()-1", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/Tridiagonalization.h", 443); } while(false); else throw Eigen::eigen_assert_exception(); };
  tridiagonalization_inplace_selector<MatrixType>::run(mat, diag, subdiag, extractQ);
}




template<typename MatrixType, int Size, bool IsComplex>
struct tridiagonalization_inplace_selector
{
  typedef typename Tridiagonalization<MatrixType>::CoeffVectorType CoeffVectorType;
  typedef typename Tridiagonalization<MatrixType>::HouseholderSequenceType HouseholderSequenceType;
  typedef typename MatrixType::Index Index;
  template<typename DiagonalType, typename SubDiagonalType>
  static void run(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)
  {
    CoeffVectorType hCoeffs(mat.cols()-1);
    tridiagonalization_inplace(mat,hCoeffs);
    diag = mat.diagonal().real();
    subdiag = mat.template diagonal<-1>().real();
    if(extractQ)
      mat = HouseholderSequenceType(mat, hCoeffs.conjugate())
            .setLength(mat.rows() - 1)
            .setShift(1);
  }
};





template<typename MatrixType>
struct tridiagonalization_inplace_selector<MatrixType,3,false>
{
  typedef typename MatrixType::Scalar Scalar;
  typedef typename MatrixType::RealScalar RealScalar;

  template<typename DiagonalType, typename SubDiagonalType>
  static void run(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)
  {
    diag[0] = mat(0,0);
    RealScalar v1norm2 = abs2(mat(2,0));
    if(v1norm2 == RealScalar(0))
    {
      diag[1] = mat(1,1);
      diag[2] = mat(2,2);
      subdiag[0] = mat(1,0);
      subdiag[1] = mat(2,1);
      if (extractQ)
        mat.setIdentity();
    }
    else
    {
      RealScalar beta = sqrt(abs2(mat(1,0)) + v1norm2);
      RealScalar invBeta = RealScalar(1)/beta;
      Scalar m01 = mat(1,0) * invBeta;
      Scalar m02 = mat(2,0) * invBeta;
      Scalar q = RealScalar(2)*m01*mat(2,1) + m02*(mat(2,2) - mat(1,1));
      diag[1] = mat(1,1) + m02*q;
      diag[2] = mat(2,2) - m02*q;
      subdiag[0] = beta;
      subdiag[1] = mat(2,1) - m01 * q;
      if (extractQ)
      {
        mat << 1, 0, 0,
               0, m01, m02,
               0, m02, -m01;
      }
    }
  }
};




template<typename MatrixType, bool IsComplex>
struct tridiagonalization_inplace_selector<MatrixType,1,IsComplex>
{
  typedef typename MatrixType::Scalar Scalar;

  template<typename DiagonalType, typename SubDiagonalType>
  static void run(MatrixType& mat, DiagonalType& diag, SubDiagonalType&, bool extractQ)
  {
    diag(0,0) = real(mat(0,0));
    if(extractQ)
      mat(0,0) = Scalar(1);
  }
};
# 539 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/Tridiagonalization.h"
template<typename MatrixType> struct TridiagonalizationMatrixTReturnType
: public ReturnByValue<TridiagonalizationMatrixTReturnType<MatrixType> >
{
    typedef typename MatrixType::Index Index;
  public:




    TridiagonalizationMatrixTReturnType(const MatrixType& mat) : m_matrix(mat) { }

    template <typename ResultType>
    inline void evalTo(ResultType& result) const
    {
      result.setZero();
      result.template diagonal<1>() = m_matrix.template diagonal<-1>().conjugate();
      result.diagonal() = m_matrix.diagonal();
      result.template diagonal<-1>() = m_matrix.template diagonal<-1>();
    }

    Index rows() const { return m_matrix.rows(); }
    Index cols() const { return m_matrix.cols(); }

  protected:
    const typename MatrixType::Nested m_matrix;
};

}
# 30 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Eigenvalues" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/RealSchur.h" 1
# 29 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/RealSchur.h"
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/./EigenvaluesCommon.h" 1
# 30 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/RealSchur.h" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/./HessenbergDecomposition.h" 1
# 29 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/./HessenbergDecomposition.h"
namespace internal {

template<typename MatrixType> struct HessenbergDecompositionMatrixHReturnType;
template<typename MatrixType>
struct traits<HessenbergDecompositionMatrixHReturnType<MatrixType> >
{
  typedef MatrixType ReturnType;
};

}
# 70 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/./HessenbergDecomposition.h"
template<typename _MatrixType> class HessenbergDecomposition
{
  public:


    typedef _MatrixType MatrixType;

    enum {
      Size = MatrixType::RowsAtCompileTime,
      SizeMinusOne = Size == Dynamic ? Dynamic : Size - 1,
      Options = MatrixType::Options,
      MaxSize = MatrixType::MaxRowsAtCompileTime,
      MaxSizeMinusOne = MaxSize == Dynamic ? Dynamic : MaxSize - 1
    };


    typedef typename MatrixType::Scalar Scalar;
    typedef typename MatrixType::Index Index;







    typedef Matrix<Scalar, SizeMinusOne, 1, Options & ~RowMajor, MaxSizeMinusOne, 1> CoeffVectorType;


    typedef typename HouseholderSequence<MatrixType,CoeffVectorType>::ConjugateReturnType HouseholderSequenceType;

    typedef internal::HessenbergDecompositionMatrixHReturnType<MatrixType> MatrixHReturnType;
# 113 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/./HessenbergDecomposition.h"
    HessenbergDecomposition(Index size = Size==Dynamic ? 2 : Size)
      : m_matrix(size,size),
        m_temp(size),
        m_isInitialized(false)
    {
      if(size>1)
        m_hCoeffs.resize(size-1);
    }
# 131 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/./HessenbergDecomposition.h"
    HessenbergDecomposition(const MatrixType& matrix)
      : m_matrix(matrix),
        m_temp(matrix.rows()),
        m_isInitialized(false)
    {
      if(matrix.rows()<2)
      {
        m_isInitialized = true;
        return;
      }
      m_hCoeffs.resize(matrix.rows()-1,1);
      _compute(m_matrix, m_hCoeffs, m_temp);
      m_isInitialized = true;
    }
# 163 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/./HessenbergDecomposition.h"
    HessenbergDecomposition& compute(const MatrixType& matrix)
    {
      m_matrix = matrix;
      if(matrix.rows()<2)
      {
        m_isInitialized = true;
        return *this;
      }
      m_hCoeffs.resize(matrix.rows()-1,1);
      _compute(m_matrix, m_hCoeffs, m_temp);
      m_isInitialized = true;
      return *this;
    }
# 190 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/./HessenbergDecomposition.h"
    const CoeffVectorType& householderCoefficients() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "HessenbergDecomposition is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "HessenbergDecomposition is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"HessenbergDecomposition is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/./HessenbergDecomposition.h", 192); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_hCoeffs;
    }
# 225 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/./HessenbergDecomposition.h"
    const MatrixType& packedMatrix() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "HessenbergDecomposition is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "HessenbergDecomposition is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"HessenbergDecomposition is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/./HessenbergDecomposition.h", 227); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_matrix;
    }
# 245 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/./HessenbergDecomposition.h"
    HouseholderSequenceType matrixQ() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "HessenbergDecomposition is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "HessenbergDecomposition is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"HessenbergDecomposition is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/./HessenbergDecomposition.h", 247); } while(false); else throw Eigen::eigen_assert_exception(); };
      return HouseholderSequenceType(m_matrix, m_hCoeffs.conjugate())
             .setLength(m_matrix.rows() - 1)
             .setShift(1);
    }
# 273 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/./HessenbergDecomposition.h"
    MatrixHReturnType matrixH() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "HessenbergDecomposition is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "HessenbergDecomposition is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"HessenbergDecomposition is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/./HessenbergDecomposition.h", 275); } while(false); else throw Eigen::eigen_assert_exception(); };
      return MatrixHReturnType(*this);
    }

  private:

    typedef Matrix<Scalar, 1, Size, Options | RowMajor, 1, MaxSize> VectorType;
    typedef typename NumTraits<Scalar>::Real RealScalar;
    static void _compute(MatrixType& matA, CoeffVectorType& hCoeffs, VectorType& temp);

  protected:
    MatrixType m_matrix;
    CoeffVectorType m_hCoeffs;
    VectorType m_temp;
    bool m_isInitialized;
};
# 304 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/./HessenbergDecomposition.h"
template<typename MatrixType>
void HessenbergDecomposition<MatrixType>::_compute(MatrixType& matA, CoeffVectorType& hCoeffs, VectorType& temp)
{
  ((matA.rows()==matA.cols()) ? static_cast<void> (0) : __assert_fail ("matA.rows()==matA.cols()", "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/./HessenbergDecomposition.h", 307, __PRETTY_FUNCTION__));
  Index n = matA.rows();
  temp.resize(n);
  for (Index i = 0; i<n-1; ++i)
  {

    Index remainingSize = n-i-1;
    RealScalar beta;
    Scalar h;
    matA.col(i).tail(remainingSize).makeHouseholderInPlace(h, beta);
    matA.col(i).coeffRef(i+1) = beta;
    hCoeffs.coeffRef(i) = h;





    matA.bottomRightCorner(remainingSize, remainingSize)
        .applyHouseholderOnTheLeft(matA.col(i).tail(remainingSize-1), h, &temp.coeffRef(0));


    matA.rightCols(remainingSize)
        .applyHouseholderOnTheRight(matA.col(i).tail(remainingSize-1).conjugate(), internal::conj(h), &temp.coeffRef(0));
  }
}

namespace internal {
# 350 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/./HessenbergDecomposition.h"
template<typename MatrixType> struct HessenbergDecompositionMatrixHReturnType
: public ReturnByValue<HessenbergDecompositionMatrixHReturnType<MatrixType> >
{
    typedef typename MatrixType::Index Index;
  public:




    HessenbergDecompositionMatrixHReturnType(const HessenbergDecomposition<MatrixType>& hess) : m_hess(hess) { }






    template <typename ResultType>
    inline void evalTo(ResultType& result) const
    {
      result = m_hess.packedMatrix();
      Index n = result.rows();
      if (n>2)
        result.bottomLeftCorner(n-2, n-2).template triangularView<Lower>().setZero();
    }

    Index rows() const { return m_hess.packedMatrix().rows(); }
    Index cols() const { return m_hess.packedMatrix().cols(); }

  protected:
    const HessenbergDecomposition<MatrixType>& m_hess;
};

}
# 31 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/RealSchur.h" 2
# 68 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/RealSchur.h"
template<typename _MatrixType> class RealSchur
{
  public:
    typedef _MatrixType MatrixType;
    enum {
      RowsAtCompileTime = MatrixType::RowsAtCompileTime,
      ColsAtCompileTime = MatrixType::ColsAtCompileTime,
      Options = MatrixType::Options,
      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
    };
    typedef typename MatrixType::Scalar Scalar;
    typedef std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;
    typedef typename MatrixType::Index Index;

    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> EigenvalueType;
    typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ColumnVectorType;
# 97 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/RealSchur.h"
    RealSchur(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)
            : m_matT(size, size),
              m_matU(size, size),
              m_workspaceVector(size),
              m_hess(size),
              m_isInitialized(false),
              m_matUisUptodate(false)
    { }
# 116 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/RealSchur.h"
    RealSchur(const MatrixType& matrix, bool computeU = true)
            : m_matT(matrix.rows(),matrix.cols()),
              m_matU(matrix.rows(),matrix.cols()),
              m_workspaceVector(matrix.rows()),
              m_hess(matrix.rows()),
              m_isInitialized(false),
              m_matUisUptodate(false)
    {
      compute(matrix, computeU);
    }
# 138 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/RealSchur.h"
    const MatrixType& matrixU() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "RealSchur is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "RealSchur is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"RealSchur is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/RealSchur.h", 140); } while(false); else throw Eigen::eigen_assert_exception(); };
      if( (!Eigen::internal::copy_bool(m_matUisUptodate && "The matrix U has not been computed during the RealSchur decomposition.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_matUisUptodate && "The matrix U has not been computed during the RealSchur decomposition.")) Eigen::internal::assert_fail("m_matUisUptodate && \"The matrix U has not been computed during the RealSchur decomposition.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/RealSchur.h", 141); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_matU;
    }
# 155 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/RealSchur.h"
    const MatrixType& matrixT() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "RealSchur is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "RealSchur is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"RealSchur is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/RealSchur.h", 157); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_matT;
    }
# 178 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/RealSchur.h"
    RealSchur& compute(const MatrixType& matrix, bool computeU = true);





    ComputationInfo info() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "RealSchur is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "RealSchur is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"RealSchur is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/RealSchur.h", 186); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_info;
    }





    static const int m_maxIterations = 40;

  private:

    MatrixType m_matT;
    MatrixType m_matU;
    ColumnVectorType m_workspaceVector;
    HessenbergDecomposition<MatrixType> m_hess;
    ComputationInfo m_info;
    bool m_isInitialized;
    bool m_matUisUptodate;

    typedef Matrix<Scalar,3,1> Vector3s;

    Scalar computeNormOfT();
    Index findSmallSubdiagEntry(Index iu, Scalar norm);
    void splitOffTwoRows(Index iu, bool computeU, Scalar exshift);
    void computeShift(Index iu, Index iter, Scalar& exshift, Vector3s& shiftInfo);
    void initFrancisQRStep(Index il, Index iu, const Vector3s& shiftInfo, Index& im, Vector3s& firstHouseholderVector);
    void performFrancisQRStep(Index il, Index im, Index iu, bool computeU, const Vector3s& firstHouseholderVector, Scalar* workspace);
};


template<typename MatrixType>
RealSchur<MatrixType>& RealSchur<MatrixType>::compute(const MatrixType& matrix, bool computeU)
{
  ((matrix.cols() == matrix.rows()) ? static_cast<void> (0) : __assert_fail ("matrix.cols() == matrix.rows()", "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/RealSchur.h", 220, __PRETTY_FUNCTION__));


  m_hess.compute(matrix);
  m_matT = m_hess.matrixH();
  if (computeU)
    m_matU = m_hess.matrixQ();


  m_workspaceVector.resize(m_matT.cols());
  Scalar* workspace = &m_workspaceVector.coeffRef(0);





  Index iu = m_matT.cols() - 1;
  Index iter = 0;
  Scalar exshift = 0.0;
  Scalar norm = computeNormOfT();

  while (iu >= 0)
  {
    Index il = findSmallSubdiagEntry(iu, norm);


    if (il == iu)
    {
      m_matT.coeffRef(iu,iu) = m_matT.coeff(iu,iu) + exshift;
      if (iu > 0)
        m_matT.coeffRef(iu, iu-1) = Scalar(0);
      iu--;
      iter = 0;
    }
    else if (il == iu-1)
    {
      splitOffTwoRows(iu, computeU, exshift);
      iu -= 2;
      iter = 0;
    }
    else
    {

      Vector3s firstHouseholderVector(0,0,0), shiftInfo;
      computeShift(iu, iter, exshift, shiftInfo);
      iter = iter + 1;
      if (iter > m_maxIterations) break;
      Index im;
      initFrancisQRStep(il, iu, shiftInfo, im, firstHouseholderVector);
      performFrancisQRStep(il, im, iu, computeU, firstHouseholderVector, workspace);
    }
  }

  if(iter <= m_maxIterations)
    m_info = Success;
  else
    m_info = NoConvergence;

  m_isInitialized = true;
  m_matUisUptodate = computeU;
  return *this;
}


template<typename MatrixType>
inline typename MatrixType::Scalar RealSchur<MatrixType>::computeNormOfT()
{
  const Index size = m_matT.cols();



  Scalar norm = 0.0;
  for (Index j = 0; j < size; ++j)
    norm += m_matT.row(j).segment((std::max)(j-1,Index(0)), size-(std::max)(j-1,Index(0))).cwiseAbs().sum();
  return norm;
}


template<typename MatrixType>
inline typename MatrixType::Index RealSchur<MatrixType>::findSmallSubdiagEntry(Index iu, Scalar norm)
{
  Index res = iu;
  while (res > 0)
  {
    Scalar s = internal::abs(m_matT.coeff(res-1,res-1)) + internal::abs(m_matT.coeff(res,res));
    if (s == 0.0)
      s = norm;
    if (internal::abs(m_matT.coeff(res,res-1)) < NumTraits<Scalar>::epsilon() * s)
      break;
    res--;
  }
  return res;
}


template<typename MatrixType>
inline void RealSchur<MatrixType>::splitOffTwoRows(Index iu, bool computeU, Scalar exshift)
{
  const Index size = m_matT.cols();



  Scalar p = Scalar(0.5) * (m_matT.coeff(iu-1,iu-1) - m_matT.coeff(iu,iu));
  Scalar q = p * p + m_matT.coeff(iu,iu-1) * m_matT.coeff(iu-1,iu);
  m_matT.coeffRef(iu,iu) += exshift;
  m_matT.coeffRef(iu-1,iu-1) += exshift;

  if (q >= Scalar(0))
  {
    Scalar z = internal::sqrt(internal::abs(q));
    JacobiRotation<Scalar> rot;
    if (p >= Scalar(0))
      rot.makeGivens(p + z, m_matT.coeff(iu, iu-1));
    else
      rot.makeGivens(p - z, m_matT.coeff(iu, iu-1));

    m_matT.rightCols(size-iu+1).applyOnTheLeft(iu-1, iu, rot.adjoint());
    m_matT.topRows(iu+1).applyOnTheRight(iu-1, iu, rot);
    m_matT.coeffRef(iu, iu-1) = Scalar(0);
    if (computeU)
      m_matU.applyOnTheRight(iu-1, iu, rot);
  }

  if (iu > 1)
    m_matT.coeffRef(iu-1, iu-2) = Scalar(0);
}


template<typename MatrixType>
inline void RealSchur<MatrixType>::computeShift(Index iu, Index iter, Scalar& exshift, Vector3s& shiftInfo)
{
  shiftInfo.coeffRef(0) = m_matT.coeff(iu,iu);
  shiftInfo.coeffRef(1) = m_matT.coeff(iu-1,iu-1);
  shiftInfo.coeffRef(2) = m_matT.coeff(iu,iu-1) * m_matT.coeff(iu-1,iu);


  if (iter == 10)
  {
    exshift += shiftInfo.coeff(0);
    for (Index i = 0; i <= iu; ++i)
      m_matT.coeffRef(i,i) -= shiftInfo.coeff(0);
    Scalar s = internal::abs(m_matT.coeff(iu,iu-1)) + internal::abs(m_matT.coeff(iu-1,iu-2));
    shiftInfo.coeffRef(0) = Scalar(0.75) * s;
    shiftInfo.coeffRef(1) = Scalar(0.75) * s;
    shiftInfo.coeffRef(2) = Scalar(-0.4375) * s * s;
  }


  if (iter == 30)
  {
    Scalar s = (shiftInfo.coeff(1) - shiftInfo.coeff(0)) / Scalar(2.0);
    s = s * s + shiftInfo.coeff(2);
    if (s > Scalar(0))
    {
      s = internal::sqrt(s);
      if (shiftInfo.coeff(1) < shiftInfo.coeff(0))
        s = -s;
      s = s + (shiftInfo.coeff(1) - shiftInfo.coeff(0)) / Scalar(2.0);
      s = shiftInfo.coeff(0) - shiftInfo.coeff(2) / s;
      exshift += s;
      for (Index i = 0; i <= iu; ++i)
        m_matT.coeffRef(i,i) -= s;
      shiftInfo.setConstant(Scalar(0.964));
    }
  }
}


template<typename MatrixType>
inline void RealSchur<MatrixType>::initFrancisQRStep(Index il, Index iu, const Vector3s& shiftInfo, Index& im, Vector3s& firstHouseholderVector)
{
  Vector3s& v = firstHouseholderVector;

  for (im = iu-2; im >= il; --im)
  {
    const Scalar Tmm = m_matT.coeff(im,im);
    const Scalar r = shiftInfo.coeff(0) - Tmm;
    const Scalar s = shiftInfo.coeff(1) - Tmm;
    v.coeffRef(0) = (r * s - shiftInfo.coeff(2)) / m_matT.coeff(im+1,im) + m_matT.coeff(im,im+1);
    v.coeffRef(1) = m_matT.coeff(im+1,im+1) - Tmm - r - s;
    v.coeffRef(2) = m_matT.coeff(im+2,im+1);
    if (im == il) {
      break;
    }
    const Scalar lhs = m_matT.coeff(im,im-1) * (internal::abs(v.coeff(1)) + internal::abs(v.coeff(2)));
    const Scalar rhs = v.coeff(0) * (internal::abs(m_matT.coeff(im-1,im-1)) + internal::abs(Tmm) + internal::abs(m_matT.coeff(im+1,im+1)));
    if (internal::abs(lhs) < NumTraits<Scalar>::epsilon() * rhs)
    {
      break;
    }
  }
}


template<typename MatrixType>
inline void RealSchur<MatrixType>::performFrancisQRStep(Index il, Index im, Index iu, bool computeU, const Vector3s& firstHouseholderVector, Scalar* workspace)
{
  ((im >= il) ? static_cast<void> (0) : __assert_fail ("im >= il", "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/RealSchur.h", 417, __PRETTY_FUNCTION__));
  ((im <= iu-2) ? static_cast<void> (0) : __assert_fail ("im <= iu-2", "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/RealSchur.h", 418, __PRETTY_FUNCTION__));

  const Index size = m_matT.cols();

  for (Index k = im; k <= iu-2; ++k)
  {
    bool firstIteration = (k == im);

    Vector3s v;
    if (firstIteration)
      v = firstHouseholderVector;
    else
      v = m_matT.template block<3,1>(k,k-1);

    Scalar tau, beta;
    Matrix<Scalar, 2, 1> ess;
    v.makeHouseholder(ess, tau, beta);

    if (beta != Scalar(0))
    {
      if (firstIteration && k > il)
        m_matT.coeffRef(k,k-1) = -m_matT.coeff(k,k-1);
      else if (!firstIteration)
        m_matT.coeffRef(k,k-1) = beta;


      m_matT.block(k, k, 3, size-k).applyHouseholderOnTheLeft(ess, tau, workspace);
      m_matT.block(0, k, (std::min)(iu,k+3) + 1, 3).applyHouseholderOnTheRight(ess, tau, workspace);
      if (computeU)
        m_matU.block(0, k, size, 3).applyHouseholderOnTheRight(ess, tau, workspace);
    }
  }

  Matrix<Scalar, 2, 1> v = m_matT.template block<2,1>(iu-1, iu-2);
  Scalar tau, beta;
  Matrix<Scalar, 1, 1> ess;
  v.makeHouseholder(ess, tau, beta);

  if (beta != Scalar(0))
  {
    m_matT.coeffRef(iu-1, iu-2) = beta;
    m_matT.block(iu-1, iu-1, 2, size-iu+1).applyHouseholderOnTheLeft(ess, tau, workspace);
    m_matT.block(0, iu-1, iu+1, 2).applyHouseholderOnTheRight(ess, tau, workspace);
    if (computeU)
      m_matU.block(0, iu-1, size, 2).applyHouseholderOnTheRight(ess, tau, workspace);
  }


  for (Index i = im+2; i <= iu; ++i)
  {
    m_matT.coeffRef(i,i-2) = Scalar(0);
    if (i > im+2)
      m_matT.coeffRef(i,i-3) = Scalar(0);
  }
}
# 31 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Eigenvalues" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/EigenSolver.h" 1
# 78 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/EigenSolver.h"
template<typename _MatrixType> class EigenSolver
{
  public:


    typedef _MatrixType MatrixType;

    enum {
      RowsAtCompileTime = MatrixType::RowsAtCompileTime,
      ColsAtCompileTime = MatrixType::ColsAtCompileTime,
      Options = MatrixType::Options,
      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
    };


    typedef typename MatrixType::Scalar Scalar;
    typedef typename NumTraits<Scalar>::Real RealScalar;
    typedef typename MatrixType::Index Index;







    typedef std::complex<RealScalar> ComplexScalar;






    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> EigenvalueType;






    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> EigenvectorsType;
# 127 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/EigenSolver.h"
 EigenSolver() : m_eivec(), m_eivalues(), m_isInitialized(false), m_realSchur(), m_matT(), m_tmp() {}







    EigenSolver(Index size)
      : m_eivec(size, size),
        m_eivalues(size),
        m_isInitialized(false),
        m_eigenvectorsOk(false),
        m_realSchur(size),
        m_matT(size, size),
        m_tmp(size)
    {}
# 160 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/EigenSolver.h"
    EigenSolver(const MatrixType& matrix, bool computeEigenvectors = true)
      : m_eivec(matrix.rows(), matrix.cols()),
        m_eivalues(matrix.cols()),
        m_isInitialized(false),
        m_eigenvectorsOk(false),
        m_realSchur(matrix.cols()),
        m_matT(matrix.rows(), matrix.cols()),
        m_tmp(matrix.cols())
    {
      compute(matrix, computeEigenvectors);
    }
# 192 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/EigenSolver.h"
    EigenvectorsType eigenvectors() const;
# 212 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/EigenSolver.h"
    const MatrixType& pseudoEigenvectors() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "EigenSolver is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "EigenSolver is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"EigenSolver is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/EigenSolver.h", 214); } while(false); else throw Eigen::eigen_assert_exception(); };
      if( (!Eigen::internal::copy_bool(m_eigenvectorsOk && "The eigenvectors have not been computed together with the eigenvalues.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_eigenvectorsOk && "The eigenvectors have not been computed together with the eigenvalues.")) Eigen::internal::assert_fail("m_eigenvectorsOk && \"The eigenvectors have not been computed together with the eigenvalues.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/EigenSolver.h", 215); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_eivec;
    }
# 237 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/EigenSolver.h"
    MatrixType pseudoEigenvalueMatrix() const;
# 257 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/EigenSolver.h"
    const EigenvalueType& eigenvalues() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "EigenSolver is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "EigenSolver is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"EigenSolver is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/EigenSolver.h", 259); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_eivalues;
    }
# 290 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/EigenSolver.h"
    EigenSolver& compute(const MatrixType& matrix, bool computeEigenvectors = true);

    ComputationInfo info() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "ComplexEigenSolver is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "ComplexEigenSolver is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"ComplexEigenSolver is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/EigenSolver.h", 294); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_realSchur.info();
    }

  private:
    void doComputeEigenvectors();

  protected:
    MatrixType m_eivec;
    EigenvalueType m_eivalues;
    bool m_isInitialized;
    bool m_eigenvectorsOk;
    RealSchur<MatrixType> m_realSchur;
    MatrixType m_matT;

    typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ColumnVectorType;
    ColumnVectorType m_tmp;
};

template<typename MatrixType>
MatrixType EigenSolver<MatrixType>::pseudoEigenvalueMatrix() const
{
  if( (!Eigen::internal::copy_bool(m_isInitialized && "EigenSolver is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "EigenSolver is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"EigenSolver is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/EigenSolver.h", 316); } while(false); else throw Eigen::eigen_assert_exception(); };
  Index n = m_eivalues.rows();
  MatrixType matD = MatrixType::Zero(n,n);
  for (Index i=0; i<n; ++i)
  {
    if (internal::isMuchSmallerThan(internal::imag(m_eivalues.coeff(i)), internal::real(m_eivalues.coeff(i))))
      matD.coeffRef(i,i) = internal::real(m_eivalues.coeff(i));
    else
    {
      matD.template block<2,2>(i,i) << internal::real(m_eivalues.coeff(i)), internal::imag(m_eivalues.coeff(i)),
                                       -internal::imag(m_eivalues.coeff(i)), internal::real(m_eivalues.coeff(i));
      ++i;
    }
  }
  return matD;
}

template<typename MatrixType>
typename EigenSolver<MatrixType>::EigenvectorsType EigenSolver<MatrixType>::eigenvectors() const
{
  if( (!Eigen::internal::copy_bool(m_isInitialized && "EigenSolver is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "EigenSolver is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"EigenSolver is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/EigenSolver.h", 336); } while(false); else throw Eigen::eigen_assert_exception(); };
  if( (!Eigen::internal::copy_bool(m_eigenvectorsOk && "The eigenvectors have not been computed together with the eigenvalues.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_eigenvectorsOk && "The eigenvectors have not been computed together with the eigenvalues.")) Eigen::internal::assert_fail("m_eigenvectorsOk && \"The eigenvectors have not been computed together with the eigenvalues.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/EigenSolver.h", 337); } while(false); else throw Eigen::eigen_assert_exception(); };
  Index n = m_eivec.cols();
  EigenvectorsType matV(n,n);
  for (Index j=0; j<n; ++j)
  {
    if (internal::isMuchSmallerThan(internal::imag(m_eivalues.coeff(j)), internal::real(m_eivalues.coeff(j))))
    {

      matV.col(j) = m_eivec.col(j).template cast<ComplexScalar>();
      matV.col(j).normalize();
    }
    else
    {

      for (Index i=0; i<n; ++i)
      {
        matV.coeffRef(i,j) = ComplexScalar(m_eivec.coeff(i,j), m_eivec.coeff(i,j+1));
        matV.coeffRef(i,j+1) = ComplexScalar(m_eivec.coeff(i,j), -m_eivec.coeff(i,j+1));
      }
      matV.col(j).normalize();
      matV.col(j+1).normalize();
      ++j;
    }
  }
  return matV;
}

template<typename MatrixType>
EigenSolver<MatrixType>& EigenSolver<MatrixType>::compute(const MatrixType& matrix, bool computeEigenvectors)
{
  ((matrix.cols() == matrix.rows()) ? static_cast<void> (0) : __assert_fail ("matrix.cols() == matrix.rows()", "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/EigenSolver.h", 367, __PRETTY_FUNCTION__));


  m_realSchur.compute(matrix, computeEigenvectors);
  if (m_realSchur.info() == Success)
  {
    m_matT = m_realSchur.matrixT();
    if (computeEigenvectors)
      m_eivec = m_realSchur.matrixU();


    m_eivalues.resize(matrix.cols());
    Index i = 0;
    while (i < matrix.cols())
    {
      if (i == matrix.cols() - 1 || m_matT.coeff(i+1, i) == Scalar(0))
      {
        m_eivalues.coeffRef(i) = m_matT.coeff(i, i);
        ++i;
      }
      else
      {
        Scalar p = Scalar(0.5) * (m_matT.coeff(i, i) - m_matT.coeff(i+1, i+1));
        Scalar z = internal::sqrt(internal::abs(p * p + m_matT.coeff(i+1, i) * m_matT.coeff(i, i+1)));
        m_eivalues.coeffRef(i) = ComplexScalar(m_matT.coeff(i+1, i+1) + p, z);
        m_eivalues.coeffRef(i+1) = ComplexScalar(m_matT.coeff(i+1, i+1) + p, -z);
        i += 2;
      }
    }


    if (computeEigenvectors)
      doComputeEigenvectors();
  }

  m_isInitialized = true;
  m_eigenvectorsOk = computeEigenvectors;

  return *this;
}


template<typename Scalar>
std::complex<Scalar> cdiv(Scalar xr, Scalar xi, Scalar yr, Scalar yi)
{
  Scalar r,d;
  if (internal::abs(yr) > internal::abs(yi))
  {
      r = yi/yr;
      d = yr + r*yi;
      return std::complex<Scalar>((xr + r*xi)/d, (xi - r*xr)/d);
  }
  else
  {
      r = yr/yi;
      d = yi + r*yr;
      return std::complex<Scalar>((r*xr + xi)/d, (r*xi - xr)/d);
  }
}


template<typename MatrixType>
void EigenSolver<MatrixType>::doComputeEigenvectors()
{
  const Index size = m_eivec.cols();
  const Scalar eps = NumTraits<Scalar>::epsilon();


  Scalar norm = 0.0;
  for (Index j = 0; j < size; ++j)
  {
    norm += m_matT.row(j).segment((std::max)(j-1,Index(0)), size-(std::max)(j-1,Index(0))).cwiseAbs().sum();
  }


  if (norm == 0.0)
  {
    return;
  }

  for (Index n = size-1; n >= 0; n--)
  {
    Scalar p = m_eivalues.coeff(n).real();
    Scalar q = m_eivalues.coeff(n).imag();


    if (q == Scalar(0))
    {
      Scalar lastr=0, lastw=0;
      Index l = n;

      m_matT.coeffRef(n,n) = 1.0;
      for (Index i = n-1; i >= 0; i--)
      {
        Scalar w = m_matT.coeff(i,i) - p;
        Scalar r = m_matT.row(i).segment(l,n-l+1).dot(m_matT.col(n).segment(l, n-l+1));

        if (m_eivalues.coeff(i).imag() < 0.0)
        {
          lastw = w;
          lastr = r;
        }
        else
        {
          l = i;
          if (m_eivalues.coeff(i).imag() == 0.0)
          {
            if (w != 0.0)
              m_matT.coeffRef(i,n) = -r / w;
            else
              m_matT.coeffRef(i,n) = -r / (eps * norm);
          }
          else
          {
            Scalar x = m_matT.coeff(i,i+1);
            Scalar y = m_matT.coeff(i+1,i);
            Scalar denom = (m_eivalues.coeff(i).real() - p) * (m_eivalues.coeff(i).real() - p) + m_eivalues.coeff(i).imag() * m_eivalues.coeff(i).imag();
            Scalar t = (x * lastr - lastw * r) / denom;
            m_matT.coeffRef(i,n) = t;
            if (internal::abs(x) > internal::abs(lastw))
              m_matT.coeffRef(i+1,n) = (-r - w * t) / x;
            else
              m_matT.coeffRef(i+1,n) = (-lastr - y * t) / lastw;
          }


          Scalar t = internal::abs(m_matT.coeff(i,n));
          if ((eps * t) * t > Scalar(1))
            m_matT.col(n).tail(size-i) /= t;
        }
      }
    }
    else if (q < Scalar(0) && n > 0)
    {
      Scalar lastra=0, lastsa=0, lastw=0;
      Index l = n-1;


      if (internal::abs(m_matT.coeff(n,n-1)) > internal::abs(m_matT.coeff(n-1,n)))
      {
        m_matT.coeffRef(n-1,n-1) = q / m_matT.coeff(n,n-1);
        m_matT.coeffRef(n-1,n) = -(m_matT.coeff(n,n) - p) / m_matT.coeff(n,n-1);
      }
      else
      {
        std::complex<Scalar> cc = cdiv<Scalar>(0.0,-m_matT.coeff(n-1,n),m_matT.coeff(n-1,n-1)-p,q);
        m_matT.coeffRef(n-1,n-1) = internal::real(cc);
        m_matT.coeffRef(n-1,n) = internal::imag(cc);
      }
      m_matT.coeffRef(n,n-1) = 0.0;
      m_matT.coeffRef(n,n) = 1.0;
      for (Index i = n-2; i >= 0; i--)
      {
        Scalar ra = m_matT.row(i).segment(l, n-l+1).dot(m_matT.col(n-1).segment(l, n-l+1));
        Scalar sa = m_matT.row(i).segment(l, n-l+1).dot(m_matT.col(n).segment(l, n-l+1));
        Scalar w = m_matT.coeff(i,i) - p;

        if (m_eivalues.coeff(i).imag() < 0.0)
        {
          lastw = w;
          lastra = ra;
          lastsa = sa;
        }
        else
        {
          l = i;
          if (m_eivalues.coeff(i).imag() == RealScalar(0))
          {
            std::complex<Scalar> cc = cdiv(-ra,-sa,w,q);
            m_matT.coeffRef(i,n-1) = internal::real(cc);
            m_matT.coeffRef(i,n) = internal::imag(cc);
          }
          else
          {

            Scalar x = m_matT.coeff(i,i+1);
            Scalar y = m_matT.coeff(i+1,i);
            Scalar vr = (m_eivalues.coeff(i).real() - p) * (m_eivalues.coeff(i).real() - p) + m_eivalues.coeff(i).imag() * m_eivalues.coeff(i).imag() - q * q;
            Scalar vi = (m_eivalues.coeff(i).real() - p) * Scalar(2) * q;
            if ((vr == 0.0) && (vi == 0.0))
              vr = eps * norm * (internal::abs(w) + internal::abs(q) + internal::abs(x) + internal::abs(y) + internal::abs(lastw));

     std::complex<Scalar> cc = cdiv(x*lastra-lastw*ra+q*sa,x*lastsa-lastw*sa-q*ra,vr,vi);
            m_matT.coeffRef(i,n-1) = internal::real(cc);
            m_matT.coeffRef(i,n) = internal::imag(cc);
            if (internal::abs(x) > (internal::abs(lastw) + internal::abs(q)))
            {
              m_matT.coeffRef(i+1,n-1) = (-ra - w * m_matT.coeff(i,n-1) + q * m_matT.coeff(i,n)) / x;
              m_matT.coeffRef(i+1,n) = (-sa - w * m_matT.coeff(i,n) - q * m_matT.coeff(i,n-1)) / x;
            }
            else
            {
              cc = cdiv(-lastra-y*m_matT.coeff(i,n-1),-lastsa-y*m_matT.coeff(i,n),lastw,q);
              m_matT.coeffRef(i+1,n-1) = internal::real(cc);
              m_matT.coeffRef(i+1,n) = internal::imag(cc);
            }
          }


          using std::max;
          Scalar t = (max)(internal::abs(m_matT.coeff(i,n-1)),internal::abs(m_matT.coeff(i,n)));
          if ((eps * t) * t > Scalar(1))
            m_matT.block(i, n-1, size-i, 2) /= t;

        }
      }
    }
    else
    {
      if( (!Eigen::internal::copy_bool("Internal bug in EigenSolver")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool("Internal bug in EigenSolver")) Eigen::internal::assert_fail("\"Internal bug in EigenSolver\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/EigenSolver.h", 576); } while(false); else throw Eigen::eigen_assert_exception(); };
    }
  }


  for (Index j = size-1; j >= 0; j--)
  {
    m_tmp.noalias() = m_eivec.leftCols(j+1) * m_matT.col(j).segment(0, j+1);
    m_eivec.col(j) = m_tmp;
  }
}
# 32 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Eigenvalues" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h" 1
# 32 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h"
template<typename _MatrixType>
class GeneralizedSelfAdjointEigenSolver;
# 78 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h"
template<typename _MatrixType> class SelfAdjointEigenSolver
{
  public:

    typedef _MatrixType MatrixType;
    enum {
      Size = MatrixType::RowsAtCompileTime,
      ColsAtCompileTime = MatrixType::ColsAtCompileTime,
      Options = MatrixType::Options,
      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
    };


    typedef typename MatrixType::Scalar Scalar;
    typedef typename MatrixType::Index Index;







    typedef typename NumTraits<Scalar>::Real RealScalar;






    typedef typename internal::plain_col_type<MatrixType, RealScalar>::type RealVectorType;
    typedef Tridiagonalization<MatrixType> TridiagonalizationType;
# 120 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h"
    SelfAdjointEigenSolver()
        : m_eivec(),
          m_eivalues(),
          m_subdiag(),
          m_isInitialized(false)
    { }
# 139 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h"
    SelfAdjointEigenSolver(Index size)
        : m_eivec(size, size),
          m_eivalues(size),
          m_subdiag(size > 1 ? size - 1 : 1),
          m_isInitialized(false)
    {}
# 161 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h"
    SelfAdjointEigenSolver(const MatrixType& matrix, int options = ComputeEigenvectors)
      : m_eivec(matrix.rows(), matrix.cols()),
        m_eivalues(matrix.cols()),
        m_subdiag(matrix.rows() > 1 ? matrix.rows() - 1 : 1),
        m_isInitialized(false)
    {
      compute(matrix, options);
    }
# 200 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h"
    SelfAdjointEigenSolver& compute(const MatrixType& matrix, int options = ComputeEigenvectors);
# 220 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h"
    const MatrixType& eigenvectors() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "SelfAdjointEigenSolver is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "SelfAdjointEigenSolver is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"SelfAdjointEigenSolver is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h", 222); } while(false); else throw Eigen::eigen_assert_exception(); };
      if( (!Eigen::internal::copy_bool(m_eigenvectorsOk && "The eigenvectors have not been computed together with the eigenvalues.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_eigenvectorsOk && "The eigenvectors have not been computed together with the eigenvalues.")) Eigen::internal::assert_fail("m_eigenvectorsOk && \"The eigenvectors have not been computed together with the eigenvalues.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h", 223); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_eivec;
    }
# 242 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h"
    const RealVectorType& eigenvalues() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "SelfAdjointEigenSolver is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "SelfAdjointEigenSolver is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"SelfAdjointEigenSolver is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h", 244); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_eivalues;
    }
# 266 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h"
    MatrixType operatorSqrt() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "SelfAdjointEigenSolver is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "SelfAdjointEigenSolver is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"SelfAdjointEigenSolver is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h", 268); } while(false); else throw Eigen::eigen_assert_exception(); };
      if( (!Eigen::internal::copy_bool(m_eigenvectorsOk && "The eigenvectors have not been computed together with the eigenvalues.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_eigenvectorsOk && "The eigenvectors have not been computed together with the eigenvalues.")) Eigen::internal::assert_fail("m_eigenvectorsOk && \"The eigenvectors have not been computed together with the eigenvalues.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h", 269); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_eivec * m_eivalues.cwiseSqrt().asDiagonal() * m_eivec.adjoint();
    }
# 291 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h"
    MatrixType operatorInverseSqrt() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "SelfAdjointEigenSolver is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "SelfAdjointEigenSolver is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"SelfAdjointEigenSolver is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h", 293); } while(false); else throw Eigen::eigen_assert_exception(); };
      if( (!Eigen::internal::copy_bool(m_eigenvectorsOk && "The eigenvectors have not been computed together with the eigenvalues.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_eigenvectorsOk && "The eigenvectors have not been computed together with the eigenvalues.")) Eigen::internal::assert_fail("m_eigenvectorsOk && \"The eigenvectors have not been computed together with the eigenvalues.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h", 294); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_eivec * m_eivalues.cwiseInverse().cwiseSqrt().asDiagonal() * m_eivec.adjoint();
    }





    ComputationInfo info() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "SelfAdjointEigenSolver is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "SelfAdjointEigenSolver is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"SelfAdjointEigenSolver is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h", 304); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_info;
    }





    static const int m_maxIterations = 30;
# 344 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h"
  protected:
    MatrixType m_eivec;
    RealVectorType m_eivalues;
    typename TridiagonalizationType::SubDiagonalType m_subdiag;
    ComputationInfo m_info;
    bool m_isInitialized;
    bool m_eigenvectorsOk;
};
# 369 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h"
namespace internal {
template<int StorageOrder,typename RealScalar, typename Scalar, typename Index>
static void tridiagonal_qr_step(RealScalar* diag, RealScalar* subdiag, Index start, Index end, Scalar* matrixQ, Index n);
}

template<typename MatrixType>
SelfAdjointEigenSolver<MatrixType>& SelfAdjointEigenSolver<MatrixType>
::compute(const MatrixType& matrix, int options)
{
  if( (!Eigen::internal::copy_bool(matrix.cols() == matrix.rows())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(matrix.cols() == matrix.rows())) Eigen::internal::assert_fail("matrix.cols() == matrix.rows()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h", 378); } while(false); else throw Eigen::eigen_assert_exception(); };
  if( (!Eigen::internal::copy_bool((options&~(EigVecMask|GenEigMask))==0 && (options&EigVecMask)!=EigVecMask && "invalid option parameter")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool((options&~(EigVecMask|GenEigMask))==0 && (options&EigVecMask)!=EigVecMask && "invalid option parameter")) Eigen::internal::assert_fail("(options&~(EigVecMask|GenEigMask))==0 && (options&EigVecMask)!=EigVecMask && \"invalid option parameter\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h", 381); } while(false); else throw Eigen::eigen_assert_exception(); };


  bool computeEigenvectors = (options&ComputeEigenvectors)==ComputeEigenvectors;
  Index n = matrix.cols();
  m_eivalues.resize(n,1);

  if(n==1)
  {
    m_eivalues.coeffRef(0,0) = internal::real(matrix.coeff(0,0));
    if(computeEigenvectors)
      m_eivec.setOnes(n,n);
    m_info = Success;
    m_isInitialized = true;
    m_eigenvectorsOk = computeEigenvectors;
    return *this;
  }


  RealVectorType& diag = m_eivalues;
  MatrixType& mat = m_eivec;


  RealScalar scale = matrix.cwiseAbs().maxCoeff();
  if(scale==Scalar(0)) scale = 1;
  mat = matrix / scale;
  m_subdiag.resize(n-1);
  internal::tridiagonalization_inplace(mat, diag, m_subdiag, computeEigenvectors);

  Index end = n-1;
  Index start = 0;
  Index iter = 0;

  while (end>0)
  {
    for (Index i = start; i<end; ++i)
      if (internal::isMuchSmallerThan(internal::abs(m_subdiag[i]),(internal::abs(diag[i])+internal::abs(diag[i+1]))))
        m_subdiag[i] = 0;


    while (end>0 && m_subdiag[end-1]==0)
    {
      iter = 0;
      end--;
    }
    if (end<=0)
      break;


    iter++;
    if(iter > m_maxIterations) break;

    start = end - 1;
    while (start>0 && m_subdiag[start-1]!=0)
      start--;

    internal::tridiagonal_qr_step<MatrixType::Flags&RowMajorBit ? RowMajor : ColMajor>(diag.data(), m_subdiag.data(), start, end, computeEigenvectors ? m_eivec.data() : (Scalar*)0, n);
  }

  if (iter <= m_maxIterations)
    m_info = Success;
  else
    m_info = NoConvergence;




  if (m_info == Success)
  {
    for (Index i = 0; i < n-1; ++i)
    {
      Index k;
      m_eivalues.segment(i,n-i).minCoeff(&k);
      if (k > 0)
      {
        std::swap(m_eivalues[i], m_eivalues[k+i]);
        if(computeEigenvectors)
          m_eivec.col(i).swap(m_eivec.col(k+i));
      }
    }
  }


  m_eivalues *= scale;

  m_isInitialized = true;
  m_eigenvectorsOk = computeEigenvectors;
  return *this;
}

namespace internal {
template<int StorageOrder,typename RealScalar, typename Scalar, typename Index>
static void tridiagonal_qr_step(RealScalar* diag, RealScalar* subdiag, Index start, Index end, Scalar* matrixQ, Index n)
{






  RealScalar td = (diag[end-1] - diag[end])*RealScalar(0.5);
  RealScalar e2 = abs2(subdiag[end-1]);
  RealScalar mu = diag[end] - e2 / (td + (td>0 ? 1 : -1) * sqrt(td*td + e2));
  RealScalar x = diag[start] - mu;
  RealScalar z = subdiag[start];
  for (Index k = start; k < end; ++k)
  {
    JacobiRotation<RealScalar> rot;
    rot.makeGivens(x, z);


    RealScalar sdk = rot.s() * diag[k] + rot.c() * subdiag[k];
    RealScalar dkp1 = rot.s() * subdiag[k] + rot.c() * diag[k+1];

    diag[k] = rot.c() * (rot.c() * diag[k] - rot.s() * subdiag[k]) - rot.s() * (rot.c() * subdiag[k] - rot.s() * diag[k+1]);
    diag[k+1] = rot.s() * sdk + rot.c() * dkp1;
    subdiag[k] = rot.c() * sdk - rot.s() * dkp1;


    if (k > start)
      subdiag[k - 1] = rot.c() * subdiag[k-1] - rot.s() * z;

    x = subdiag[k];

    if (k < end - 1)
    {
      z = -rot.s() * subdiag[k+1];
      subdiag[k + 1] = rot.c() * subdiag[k+1];
    }


    if (matrixQ)
    {

      Map<Matrix<Scalar,Dynamic,Dynamic,StorageOrder> > q(matrixQ,n,n);
      q.applyOnTheRight(k,k+1,rot);
    }
  }
}
}
# 33 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Eigenvalues" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h" 1
# 61 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h"
template<typename _MatrixType>
class GeneralizedSelfAdjointEigenSolver : public SelfAdjointEigenSolver<_MatrixType>
{
    typedef SelfAdjointEigenSolver<_MatrixType> Base;
  public:

    typedef typename Base::Index Index;
    typedef _MatrixType MatrixType;
# 77 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h"
    GeneralizedSelfAdjointEigenSolver() : Base() {}
# 91 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h"
    GeneralizedSelfAdjointEigenSolver(Index size)
        : Base(size)
    {}
# 121 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h"
    GeneralizedSelfAdjointEigenSolver(const MatrixType& matA, const MatrixType& matB,
                                      int options = ComputeEigenvectors|Ax_lBx)
      : Base(matA.cols())
    {
      compute(matA, matB, options);
    }
# 168 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h"
    GeneralizedSelfAdjointEigenSolver& compute(const MatrixType& matA, const MatrixType& matB,
                                               int options = ComputeEigenvectors|Ax_lBx);

  protected:

};


template<typename MatrixType>
GeneralizedSelfAdjointEigenSolver<MatrixType>& GeneralizedSelfAdjointEigenSolver<MatrixType>::
compute(const MatrixType& matA, const MatrixType& matB, int options)
{
  if( (!Eigen::internal::copy_bool(matA.cols()==matA.rows() && matB.rows()==matA.rows() && matB.cols()==matB.rows())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(matA.cols()==matA.rows() && matB.rows()==matA.rows() && matB.cols()==matB.rows())) Eigen::internal::assert_fail("matA.cols()==matA.rows() && matB.rows()==matA.rows() && matB.cols()==matB.rows()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h", 180); } while(false); else throw Eigen::eigen_assert_exception(); };
  if( (!Eigen::internal::copy_bool((options&~(EigVecMask|GenEigMask))==0 && (options&EigVecMask)!=EigVecMask && ((options&GenEigMask)==0 || (options&GenEigMask)==Ax_lBx || (options&GenEigMask)==ABx_lx || (options&GenEigMask)==BAx_lx) && "invalid option parameter")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool((options&~(EigVecMask|GenEigMask))==0 && (options&EigVecMask)!=EigVecMask && ((options&GenEigMask)==0 || (options&GenEigMask)==Ax_lBx || (options&GenEigMask)==ABx_lx || (options&GenEigMask)==BAx_lx) && "invalid option parameter")) Eigen::internal::assert_fail("(options&~(EigVecMask|GenEigMask))==0 && (options&EigVecMask)!=EigVecMask && ((options&GenEigMask)==0 || (options&GenEigMask)==Ax_lBx || (options&GenEigMask)==ABx_lx || (options&GenEigMask)==BAx_lx) && \"invalid option parameter\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h", 185); } while(false); else throw Eigen::eigen_assert_exception(); };





  bool computeEigVecs = ((options&EigVecMask)==0) || ((options&EigVecMask)==ComputeEigenvectors);


  LLT<MatrixType> cholB(matB);

  int type = (options&GenEigMask);
  if(type==0)
    type = Ax_lBx;

  if(type==Ax_lBx)
  {

    MatrixType matC = matA.template selfadjointView<Lower>();
    cholB.matrixL().template solveInPlace<OnTheLeft>(matC);
    cholB.matrixU().template solveInPlace<OnTheRight>(matC);

    Base::compute(matC, computeEigVecs ? ComputeEigenvectors : EigenvaluesOnly );


    if(computeEigVecs)
      cholB.matrixU().solveInPlace(Base::m_eivec);
  }
  else if(type==ABx_lx)
  {

    MatrixType matC = matA.template selfadjointView<Lower>();
    matC = matC * cholB.matrixL();
    matC = cholB.matrixU() * matC;

    Base::compute(matC, computeEigVecs ? ComputeEigenvectors : EigenvaluesOnly);


    if(computeEigVecs)
      cholB.matrixU().solveInPlace(Base::m_eivec);
  }
  else if(type==BAx_lx)
  {

    MatrixType matC = matA.template selfadjointView<Lower>();
    matC = matC * cholB.matrixL();
    matC = cholB.matrixU() * matC;

    Base::compute(matC, computeEigVecs ? ComputeEigenvectors : EigenvaluesOnly);


    if(computeEigVecs)
      Base::m_eivec = cholB.matrixL() * Base::m_eivec;
  }

  return *this;
}
# 34 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Eigenvalues" 2

# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/ComplexSchur.h" 1
# 33 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/ComplexSchur.h"
namespace internal {
template<typename MatrixType, bool IsComplex> struct complex_schur_reduce_to_hessenberg;
}
# 65 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/ComplexSchur.h"
template<typename _MatrixType> class ComplexSchur
{
  public:
    typedef _MatrixType MatrixType;
    enum {
      RowsAtCompileTime = MatrixType::RowsAtCompileTime,
      ColsAtCompileTime = MatrixType::ColsAtCompileTime,
      Options = MatrixType::Options,
      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
    };


    typedef typename MatrixType::Scalar Scalar;
    typedef typename NumTraits<Scalar>::Real RealScalar;
    typedef typename MatrixType::Index Index;







    typedef std::complex<RealScalar> ComplexScalar;






    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> ComplexMatrixType;
# 108 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/ComplexSchur.h"
    ComplexSchur(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)
      : m_matT(size,size),
        m_matU(size,size),
        m_hess(size),
        m_isInitialized(false),
        m_matUisUptodate(false)
    {}
# 125 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/ComplexSchur.h"
    ComplexSchur(const MatrixType& matrix, bool computeU = true)
            : m_matT(matrix.rows(),matrix.cols()),
              m_matU(matrix.rows(),matrix.cols()),
              m_hess(matrix.rows()),
              m_isInitialized(false),
              m_matUisUptodate(false)
    {
      compute(matrix, computeU);
    }
# 149 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/ComplexSchur.h"
    const ComplexMatrixType& matrixU() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "ComplexSchur is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "ComplexSchur is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"ComplexSchur is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/ComplexSchur.h", 151); } while(false); else throw Eigen::eigen_assert_exception(); };
      if( (!Eigen::internal::copy_bool(m_matUisUptodate && "The matrix U has not been computed during the ComplexSchur decomposition.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_matUisUptodate && "The matrix U has not been computed during the ComplexSchur decomposition.")) Eigen::internal::assert_fail("m_matUisUptodate && \"The matrix U has not been computed during the ComplexSchur decomposition.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/ComplexSchur.h", 152); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_matU;
    }
# 173 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/ComplexSchur.h"
    const ComplexMatrixType& matrixT() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "ComplexSchur is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "ComplexSchur is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"ComplexSchur is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/ComplexSchur.h", 175); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_matT;
    }
# 198 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/ComplexSchur.h"
    ComplexSchur& compute(const MatrixType& matrix, bool computeU = true);





    ComputationInfo info() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "RealSchur is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "RealSchur is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"RealSchur is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/ComplexSchur.h", 206); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_info;
    }





    static const int m_maxIterations = 30;

  protected:
    ComplexMatrixType m_matT, m_matU;
    HessenbergDecomposition<MatrixType> m_hess;
    ComputationInfo m_info;
    bool m_isInitialized;
    bool m_matUisUptodate;

  private:
    bool subdiagonalEntryIsNeglegible(Index i);
    ComplexScalar computeShift(Index iu, Index iter);
    void reduceToTriangularForm(bool computeU);
    friend struct internal::complex_schur_reduce_to_hessenberg<MatrixType, NumTraits<Scalar>::IsComplex>;
};

namespace internal {


template<typename RealScalar>
std::complex<RealScalar> sqrt(const std::complex<RealScalar> &z)
{
  RealScalar t, tre, tim;

  t = abs(z);

  if (abs(real(z)) <= abs(imag(z)))
  {

    tre = sqrt(RealScalar(0.5)*(t + real(z)));
    tim = sqrt(RealScalar(0.5)*(t - real(z)));
  }
  else
  {

    if (z.real() > RealScalar(0))
    {
      tre = t + z.real();
      tim = abs(imag(z))*sqrt(RealScalar(0.5)/tre);
      tre = sqrt(RealScalar(0.5)*tre);
    }
    else
    {
      tim = t - z.real();
      tre = abs(imag(z))*sqrt(RealScalar(0.5)/tim);
      tim = sqrt(RealScalar(0.5)*tim);
    }
  }
  if(z.imag() < RealScalar(0))
    tim = -tim;

  return (std::complex<RealScalar>(tre,tim));
}
}





template<typename MatrixType>
inline bool ComplexSchur<MatrixType>::subdiagonalEntryIsNeglegible(Index i)
{
  RealScalar d = internal::norm1(m_matT.coeff(i,i)) + internal::norm1(m_matT.coeff(i+1,i+1));
  RealScalar sd = internal::norm1(m_matT.coeff(i+1,i));
  if (internal::isMuchSmallerThan(sd, d, NumTraits<RealScalar>::epsilon()))
  {
    m_matT.coeffRef(i+1,i) = ComplexScalar(0);
    return true;
  }
  return false;
}



template<typename MatrixType>
typename ComplexSchur<MatrixType>::ComplexScalar ComplexSchur<MatrixType>::computeShift(Index iu, Index iter)
{
  if (iter == 10 || iter == 20)
  {

    return internal::abs(internal::real(m_matT.coeff(iu,iu-1))) + internal::abs(internal::real(m_matT.coeff(iu-1,iu-2)));
  }



  Matrix<ComplexScalar,2,2> t = m_matT.template block<2,2>(iu-1,iu-1);
  RealScalar normt = t.cwiseAbs().sum();
  t /= normt;

  ComplexScalar b = t.coeff(0,1) * t.coeff(1,0);
  ComplexScalar c = t.coeff(0,0) - t.coeff(1,1);
  ComplexScalar disc = internal::sqrt(c*c + RealScalar(4)*b);
  ComplexScalar det = t.coeff(0,0) * t.coeff(1,1) - b;
  ComplexScalar trace = t.coeff(0,0) + t.coeff(1,1);
  ComplexScalar eival1 = (trace + disc) / RealScalar(2);
  ComplexScalar eival2 = (trace - disc) / RealScalar(2);

  if(internal::norm1(eival1) > internal::norm1(eival2))
    eival2 = det / eival1;
  else
    eival1 = det / eival2;


  if(internal::norm1(eival1-t.coeff(1,1)) < internal::norm1(eival2-t.coeff(1,1)))
    return normt * eival1;
  else
    return normt * eival2;
}


template<typename MatrixType>
ComplexSchur<MatrixType>& ComplexSchur<MatrixType>::compute(const MatrixType& matrix, bool computeU)
{
  m_matUisUptodate = false;
  if( (!Eigen::internal::copy_bool(matrix.cols() == matrix.rows())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(matrix.cols() == matrix.rows())) Eigen::internal::assert_fail("matrix.cols() == matrix.rows()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/ComplexSchur.h", 328); } while(false); else throw Eigen::eigen_assert_exception(); };

  if(matrix.cols() == 1)
  {
    m_matT = matrix.template cast<ComplexScalar>();
    if(computeU) m_matU = ComplexMatrixType::Identity(1,1);
    m_info = Success;
    m_isInitialized = true;
    m_matUisUptodate = computeU;
    return *this;
  }

  internal::complex_schur_reduce_to_hessenberg<MatrixType, NumTraits<Scalar>::IsComplex>::run(*this, matrix, computeU);
  reduceToTriangularForm(computeU);
  return *this;
}

namespace internal {


template<typename MatrixType, bool IsComplex>
struct complex_schur_reduce_to_hessenberg
{

  static void run(ComplexSchur<MatrixType>& _this, const MatrixType& matrix, bool computeU)
  {
    _this.m_hess.compute(matrix);
    _this.m_matT = _this.m_hess.matrixH();
    if(computeU) _this.m_matU = _this.m_hess.matrixQ();
  }
};

template<typename MatrixType>
struct complex_schur_reduce_to_hessenberg<MatrixType, false>
{
  static void run(ComplexSchur<MatrixType>& _this, const MatrixType& matrix, bool computeU)
  {
    typedef typename ComplexSchur<MatrixType>::ComplexScalar ComplexScalar;
    typedef typename ComplexSchur<MatrixType>::ComplexMatrixType ComplexMatrixType;


    _this.m_hess.compute(matrix);
    _this.m_matT = _this.m_hess.matrixH().template cast<ComplexScalar>();
    if(computeU)
    {

      MatrixType Q = _this.m_hess.matrixQ();
      _this.m_matU = Q.template cast<ComplexScalar>();
    }
  }
};

}


template<typename MatrixType>
void ComplexSchur<MatrixType>::reduceToTriangularForm(bool computeU)
{




  Index iu = m_matT.cols() - 1;
  Index il;
  Index iter = 0;

  while(true)
  {

    while(iu > 0)
    {
      if(!subdiagonalEntryIsNeglegible(iu-1)) break;
      iter = 0;
      --iu;
    }


    if(iu==0) break;


    iter++;
    if(iter > m_maxIterations) break;


    il = iu-1;
    while(il > 0 && !subdiagonalEntryIsNeglegible(il-1))
    {
      --il;
    }





    ComplexScalar shift = computeShift(iu, iter);
    JacobiRotation<ComplexScalar> rot;
    rot.makeGivens(m_matT.coeff(il,il) - shift, m_matT.coeff(il+1,il));
    m_matT.rightCols(m_matT.cols()-il).applyOnTheLeft(il, il+1, rot.adjoint());
    m_matT.topRows((std::min)(il+2,iu)+1).applyOnTheRight(il, il+1, rot);
    if(computeU) m_matU.applyOnTheRight(il, il+1, rot);

    for(Index i=il+1 ; i<iu ; i++)
    {
      rot.makeGivens(m_matT.coeffRef(i,i-1), m_matT.coeffRef(i+1,i-1), &m_matT.coeffRef(i,i-1));
      m_matT.coeffRef(i+1,i-1) = ComplexScalar(0);
      m_matT.rightCols(m_matT.cols()-i).applyOnTheLeft(i, i+1, rot.adjoint());
      m_matT.topRows((std::min)(i+2,iu)+1).applyOnTheRight(i, i+1, rot);
      if(computeU) m_matU.applyOnTheRight(i, i+1, rot);
    }
  }

  if(iter <= m_maxIterations)
    m_info = Success;
  else
    m_info = NoConvergence;

  m_isInitialized = true;
  m_matUisUptodate = computeU;
}
# 36 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Eigenvalues" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/ComplexEigenSolver.h" 1
# 59 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/ComplexEigenSolver.h"
template<typename _MatrixType> class ComplexEigenSolver
{
  public:


    typedef _MatrixType MatrixType;

    enum {
      RowsAtCompileTime = MatrixType::RowsAtCompileTime,
      ColsAtCompileTime = MatrixType::ColsAtCompileTime,
      Options = MatrixType::Options,
      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
    };


    typedef typename MatrixType::Scalar Scalar;
    typedef typename NumTraits<Scalar>::Real RealScalar;
    typedef typename MatrixType::Index Index;







    typedef std::complex<RealScalar> ComplexScalar;






    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options&(~RowMajor), MaxColsAtCompileTime, 1> EigenvalueType;






    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> EigenvectorType;






    ComplexEigenSolver()
            : m_eivec(),
              m_eivalues(),
              m_schur(),
              m_isInitialized(false),
              m_eigenvectorsOk(false),
              m_matX()
    {}







    ComplexEigenSolver(Index size)
            : m_eivec(size, size),
              m_eivalues(size),
              m_schur(size),
              m_isInitialized(false),
              m_eigenvectorsOk(false),
              m_matX(size, size)
    {}
# 139 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/ComplexEigenSolver.h"
      ComplexEigenSolver(const MatrixType& matrix, bool computeEigenvectors = true)
            : m_eivec(matrix.rows(),matrix.cols()),
              m_eivalues(matrix.cols()),
              m_schur(matrix.rows()),
              m_isInitialized(false),
              m_eigenvectorsOk(false),
              m_matX(matrix.rows(),matrix.cols())
    {
      compute(matrix, computeEigenvectors);
    }
# 170 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/ComplexEigenSolver.h"
    const EigenvectorType& eigenvectors() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "ComplexEigenSolver is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "ComplexEigenSolver is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"ComplexEigenSolver is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/ComplexEigenSolver.h", 172); } while(false); else throw Eigen::eigen_assert_exception(); };
      if( (!Eigen::internal::copy_bool(m_eigenvectorsOk && "The eigenvectors have not been computed together with the eigenvalues.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_eigenvectorsOk && "The eigenvectors have not been computed together with the eigenvalues.")) Eigen::internal::assert_fail("m_eigenvectorsOk && \"The eigenvectors have not been computed together with the eigenvalues.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/ComplexEigenSolver.h", 173); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_eivec;
    }
# 195 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/ComplexEigenSolver.h"
    const EigenvalueType& eigenvalues() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "ComplexEigenSolver is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "ComplexEigenSolver is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"ComplexEigenSolver is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/ComplexEigenSolver.h", 197); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_eivalues;
    }
# 225 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/ComplexEigenSolver.h"
    ComplexEigenSolver& compute(const MatrixType& matrix, bool computeEigenvectors = true);





    ComputationInfo info() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "ComplexEigenSolver is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "ComplexEigenSolver is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"ComplexEigenSolver is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/ComplexEigenSolver.h", 233); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_schur.info();
    }

  protected:
    EigenvectorType m_eivec;
    EigenvalueType m_eivalues;
    ComplexSchur<MatrixType> m_schur;
    bool m_isInitialized;
    bool m_eigenvectorsOk;
    EigenvectorType m_matX;

  private:
    void doComputeEigenvectors(RealScalar matrixnorm);
    void sortEigenvalues(bool computeEigenvectors);
};


template<typename MatrixType>
ComplexEigenSolver<MatrixType>& ComplexEigenSolver<MatrixType>::compute(const MatrixType& matrix, bool computeEigenvectors)
{

  ((matrix.cols() == matrix.rows()) ? static_cast<void> (0) : __assert_fail ("matrix.cols() == matrix.rows()", "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/ComplexEigenSolver.h", 255, __PRETTY_FUNCTION__));



  m_schur.compute(matrix, computeEigenvectors);

  if(m_schur.info() == Success)
  {
    m_eivalues = m_schur.matrixT().diagonal();
    if(computeEigenvectors)
      doComputeEigenvectors(matrix.norm());
    sortEigenvalues(computeEigenvectors);
  }

  m_isInitialized = true;
  m_eigenvectorsOk = computeEigenvectors;
  return *this;
}


template<typename MatrixType>
void ComplexEigenSolver<MatrixType>::doComputeEigenvectors(RealScalar matrixnorm)
{
  const Index n = m_eivalues.size();



  m_matX = EigenvectorType::Zero(n, n);
  for(Index k=n-1 ; k>=0 ; k--)
  {
    m_matX.coeffRef(k,k) = ComplexScalar(1.0,0.0);

    for(Index i=k-1 ; i>=0 ; i--)
    {
      m_matX.coeffRef(i,k) = -m_schur.matrixT().coeff(i,k);
      if(k-i-1>0)
        m_matX.coeffRef(i,k) -= (m_schur.matrixT().row(i).segment(i+1,k-i-1) * m_matX.col(k).segment(i+1,k-i-1)).value();
      ComplexScalar z = m_schur.matrixT().coeff(i,i) - m_schur.matrixT().coeff(k,k);
      if(z==ComplexScalar(0))
      {


        internal::real_ref(z) = NumTraits<RealScalar>::epsilon() * matrixnorm;
      }
      m_matX.coeffRef(i,k) = m_matX.coeff(i,k) / z;
    }
  }


  m_eivec.noalias() = m_schur.matrixU() * m_matX;

  for(Index k=0 ; k<n ; k++)
  {
    m_eivec.col(k).normalize();
  }
}


template<typename MatrixType>
void ComplexEigenSolver<MatrixType>::sortEigenvalues(bool computeEigenvectors)
{
  const Index n = m_eivalues.size();
  for (Index i=0; i<n; i++)
  {
    Index k;
    m_eivalues.cwiseAbs().tail(n-i).minCoeff(&k);
    if (k != 0)
    {
      k += i;
      std::swap(m_eivalues[k],m_eivalues[i]);
      if(computeEigenvectors)
 m_eivec.col(i).swap(m_eivec.col(k));
    }
  }
}
# 37 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Eigenvalues" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h" 1
# 29 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h"
namespace internal {

template<typename Derived, bool IsComplex>
struct eigenvalues_selector
{

  static inline typename MatrixBase<Derived>::EigenvaluesReturnType const
  run(const MatrixBase<Derived>& m)
  {
    typedef typename Derived::PlainObject PlainObject;
    PlainObject m_eval(m);
    return ComplexEigenSolver<PlainObject>(m_eval, false).eigenvalues();
  }
};

template<typename Derived>
struct eigenvalues_selector<Derived, false>
{
  static inline typename MatrixBase<Derived>::EigenvaluesReturnType const
  run(const MatrixBase<Derived>& m)
  {
    typedef typename Derived::PlainObject PlainObject;
    PlainObject m_eval(m);
    return EigenSolver<PlainObject>(m_eval, false).eigenvalues();
  }
};

}
# 78 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h"
template<typename Derived>
inline typename MatrixBase<Derived>::EigenvaluesReturnType
MatrixBase<Derived>::eigenvalues() const
{
  typedef typename internal::traits<Derived>::Scalar Scalar;
  return internal::eigenvalues_selector<Derived, NumTraits<Scalar>::IsComplex>::run(derived());
}
# 100 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h"
template<typename MatrixType, unsigned int UpLo>
inline typename SelfAdjointView<MatrixType, UpLo>::EigenvaluesReturnType
SelfAdjointView<MatrixType, UpLo>::eigenvalues() const
{
  typedef typename SelfAdjointView<MatrixType, UpLo>::PlainObject PlainObject;
  PlainObject thisAsMatrix(*this);
  return SelfAdjointEigenSolver<PlainObject>(thisAsMatrix, false).eigenvalues();
}
# 133 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h"
template<typename Derived>
inline typename MatrixBase<Derived>::RealScalar
MatrixBase<Derived>::operatorNorm() const
{
  typename Derived::PlainObject m_eval(derived());


  return internal::sqrt((m_eval*m_eval.adjoint())
                 .eval()
   .template selfadjointView<Lower>()
   .eigenvalues()
   .maxCoeff()
   );
}
# 163 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h"
template<typename MatrixType, unsigned int UpLo>
inline typename SelfAdjointView<MatrixType, UpLo>::RealScalar
SelfAdjointView<MatrixType, UpLo>::operatorNorm() const
{
  return eigenvalues().cwiseAbs().maxCoeff();
}
# 38 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Eigenvalues" 2

}


# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/ReenableStupidWarnings.h" 1
# 42 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/Eigenvalues" 2
# 38 "/home/pipping/Downloads/eigen-eigen-3.0.3/test/nomalloc.cpp" 2


# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/SVD" 1







# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/DisableStupidWarnings.h" 1
# 39 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/DisableStupidWarnings.h"
#pragma clang diagnostic ignored "-Wconstant-logical-operand"
# 9 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/SVD" 2

namespace Eigen {
# 26 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/SVD"
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/JacobiSVD.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/JacobiSVD.h"
namespace internal {


template<typename MatrixType, int QRPreconditioner,
         bool IsComplex = NumTraits<typename MatrixType::Scalar>::IsComplex>
struct svd_precondition_2x2_block_to_be_real {};
# 42 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/JacobiSVD.h"
enum { PreconditionIfMoreColsThanRows, PreconditionIfMoreRowsThanCols };

template<typename MatrixType, int QRPreconditioner, int Case>
struct qr_preconditioner_should_do_anything
{
  enum { a = MatrixType::RowsAtCompileTime != Dynamic &&
             MatrixType::ColsAtCompileTime != Dynamic &&
             MatrixType::ColsAtCompileTime <= MatrixType::RowsAtCompileTime,
         b = MatrixType::RowsAtCompileTime != Dynamic &&
             MatrixType::ColsAtCompileTime != Dynamic &&
             MatrixType::RowsAtCompileTime <= MatrixType::ColsAtCompileTime,
         ret = !( (QRPreconditioner == NoQRPreconditioner) ||
                  (Case == PreconditionIfMoreColsThanRows && bool(a)) ||
                  (Case == PreconditionIfMoreRowsThanCols && bool(b)) )
  };
};

template<typename MatrixType, int QRPreconditioner, int Case,
         bool DoAnything = qr_preconditioner_should_do_anything<MatrixType, QRPreconditioner, Case>::ret
> struct qr_preconditioner_impl {};

template<typename MatrixType, int QRPreconditioner, int Case>
struct qr_preconditioner_impl<MatrixType, QRPreconditioner, Case, false>
{
  static bool run(JacobiSVD<MatrixType, QRPreconditioner>&, const MatrixType&)
  {
    return false;
  }
};



template<typename MatrixType>
struct qr_preconditioner_impl<MatrixType, FullPivHouseholderQRPreconditioner, PreconditionIfMoreRowsThanCols, true>
{
  static bool run(JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd, const MatrixType& matrix)
  {
    if(matrix.rows() > matrix.cols())
    {
      FullPivHouseholderQR<MatrixType> qr(matrix);
      svd.m_workMatrix = qr.matrixQR().block(0,0,matrix.cols(),matrix.cols()).template triangularView<Upper>();
      if(svd.m_computeFullU) svd.m_matrixU = qr.matrixQ();
      if(svd.computeV()) svd.m_matrixV = qr.colsPermutation();
      return true;
    }
    return false;
  }
};

template<typename MatrixType>
struct qr_preconditioner_impl<MatrixType, FullPivHouseholderQRPreconditioner, PreconditionIfMoreColsThanRows, true>
{
  static bool run(JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd, const MatrixType& matrix)
  {
    if(matrix.cols() > matrix.rows())
    {
      typedef Matrix<typename MatrixType::Scalar, MatrixType::ColsAtCompileTime, MatrixType::RowsAtCompileTime,
                     MatrixType::Options, MatrixType::MaxColsAtCompileTime, MatrixType::MaxRowsAtCompileTime>
              TransposeTypeWithSameStorageOrder;
      FullPivHouseholderQR<TransposeTypeWithSameStorageOrder> qr(matrix.adjoint());
      svd.m_workMatrix = qr.matrixQR().block(0,0,matrix.rows(),matrix.rows()).template triangularView<Upper>().adjoint();
      if(svd.m_computeFullV) svd.m_matrixV = qr.matrixQ();
      if(svd.computeU()) svd.m_matrixU = qr.colsPermutation();
      return true;
    }
    else return false;
  }
};



template<typename MatrixType>
struct qr_preconditioner_impl<MatrixType, ColPivHouseholderQRPreconditioner, PreconditionIfMoreRowsThanCols, true>
{
  static bool run(JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd, const MatrixType& matrix)
  {
    if(matrix.rows() > matrix.cols())
    {
      ColPivHouseholderQR<MatrixType> qr(matrix);
      svd.m_workMatrix = qr.matrixQR().block(0,0,matrix.cols(),matrix.cols()).template triangularView<Upper>();
      if(svd.m_computeFullU) svd.m_matrixU = qr.householderQ();
      else if(svd.m_computeThinU) {
        svd.m_matrixU.setIdentity(matrix.rows(), matrix.cols());
        qr.householderQ().applyThisOnTheLeft(svd.m_matrixU);
      }
      if(svd.computeV()) svd.m_matrixV = qr.colsPermutation();
      return true;
    }
    return false;
  }
};

template<typename MatrixType>
struct qr_preconditioner_impl<MatrixType, ColPivHouseholderQRPreconditioner, PreconditionIfMoreColsThanRows, true>
{
  static bool run(JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd, const MatrixType& matrix)
  {
    if(matrix.cols() > matrix.rows())
    {
      typedef Matrix<typename MatrixType::Scalar, MatrixType::ColsAtCompileTime, MatrixType::RowsAtCompileTime,
                     MatrixType::Options, MatrixType::MaxColsAtCompileTime, MatrixType::MaxRowsAtCompileTime>
              TransposeTypeWithSameStorageOrder;
      ColPivHouseholderQR<TransposeTypeWithSameStorageOrder> qr(matrix.adjoint());
      svd.m_workMatrix = qr.matrixQR().block(0,0,matrix.rows(),matrix.rows()).template triangularView<Upper>().adjoint();
      if(svd.m_computeFullV) svd.m_matrixV = qr.householderQ();
      else if(svd.m_computeThinV) {
        svd.m_matrixV.setIdentity(matrix.cols(), matrix.rows());
        qr.householderQ().applyThisOnTheLeft(svd.m_matrixV);
      }
      if(svd.computeU()) svd.m_matrixU = qr.colsPermutation();
      return true;
    }
    else return false;
  }
};



template<typename MatrixType>
struct qr_preconditioner_impl<MatrixType, HouseholderQRPreconditioner, PreconditionIfMoreRowsThanCols, true>
{
  static bool run(JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd, const MatrixType& matrix)
  {
    if(matrix.rows() > matrix.cols())
    {
      HouseholderQR<MatrixType> qr(matrix);
      svd.m_workMatrix = qr.matrixQR().block(0,0,matrix.cols(),matrix.cols()).template triangularView<Upper>();
      if(svd.m_computeFullU) svd.m_matrixU = qr.householderQ();
      else if(svd.m_computeThinU) {
        svd.m_matrixU.setIdentity(matrix.rows(), matrix.cols());
        qr.householderQ().applyThisOnTheLeft(svd.m_matrixU);
      }
      if(svd.computeV()) svd.m_matrixV.setIdentity(matrix.cols(), matrix.cols());
      return true;
    }
    return false;
  }
};

template<typename MatrixType>
struct qr_preconditioner_impl<MatrixType, HouseholderQRPreconditioner, PreconditionIfMoreColsThanRows, true>
{
  static bool run(JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd, const MatrixType& matrix)
  {
    if(matrix.cols() > matrix.rows())
    {
      typedef Matrix<typename MatrixType::Scalar, MatrixType::ColsAtCompileTime, MatrixType::RowsAtCompileTime,
                     MatrixType::Options, MatrixType::MaxColsAtCompileTime, MatrixType::MaxRowsAtCompileTime>
              TransposeTypeWithSameStorageOrder;
      HouseholderQR<TransposeTypeWithSameStorageOrder> qr(matrix.adjoint());
      svd.m_workMatrix = qr.matrixQR().block(0,0,matrix.rows(),matrix.rows()).template triangularView<Upper>().adjoint();
      if(svd.m_computeFullV) svd.m_matrixV = qr.householderQ();
      else if(svd.m_computeThinV) {
        svd.m_matrixV.setIdentity(matrix.cols(), matrix.rows());
        qr.householderQ().applyThisOnTheLeft(svd.m_matrixV);
      }
      if(svd.computeU()) svd.m_matrixU.setIdentity(matrix.rows(), matrix.rows());
      return true;
    }
    else return false;
  }
};






template<typename MatrixType, int QRPreconditioner>
struct svd_precondition_2x2_block_to_be_real<MatrixType, QRPreconditioner, false>
{
  typedef JacobiSVD<MatrixType, QRPreconditioner> SVD;
  typedef typename SVD::Index Index;
  static void run(typename SVD::WorkMatrixType&, SVD&, Index, Index) {}
};

template<typename MatrixType, int QRPreconditioner>
struct svd_precondition_2x2_block_to_be_real<MatrixType, QRPreconditioner, true>
{
  typedef JacobiSVD<MatrixType, QRPreconditioner> SVD;
  typedef typename MatrixType::Scalar Scalar;
  typedef typename MatrixType::RealScalar RealScalar;
  typedef typename SVD::Index Index;
  static void run(typename SVD::WorkMatrixType& work_matrix, SVD& svd, Index p, Index q)
  {
    Scalar z;
    JacobiRotation<Scalar> rot;
    RealScalar n = sqrt(abs2(work_matrix.coeff(p,p)) + abs2(work_matrix.coeff(q,p)));
    if(n==0)
    {
      z = abs(work_matrix.coeff(p,q)) / work_matrix.coeff(p,q);
      work_matrix.row(p) *= z;
      if(svd.computeU()) svd.m_matrixU.col(p) *= conj(z);
      z = abs(work_matrix.coeff(q,q)) / work_matrix.coeff(q,q);
      work_matrix.row(q) *= z;
      if(svd.computeU()) svd.m_matrixU.col(q) *= conj(z);
    }
    else
    {
      rot.c() = conj(work_matrix.coeff(p,p)) / n;
      rot.s() = work_matrix.coeff(q,p) / n;
      work_matrix.applyOnTheLeft(p,q,rot);
      if(svd.computeU()) svd.m_matrixU.applyOnTheRight(p,q,rot.adjoint());
      if(work_matrix.coeff(p,q) != Scalar(0))
      {
        Scalar z = abs(work_matrix.coeff(p,q)) / work_matrix.coeff(p,q);
        work_matrix.col(q) *= z;
        if(svd.computeV()) svd.m_matrixV.col(q) *= z;
      }
      if(work_matrix.coeff(q,q) != Scalar(0))
      {
        z = abs(work_matrix.coeff(q,q)) / work_matrix.coeff(q,q);
        work_matrix.row(q) *= z;
        if(svd.computeU()) svd.m_matrixU.col(q) *= conj(z);
      }
    }
  }
};

template<typename MatrixType, typename RealScalar, typename Index>
void real_2x2_jacobi_svd(const MatrixType& matrix, Index p, Index q,
                            JacobiRotation<RealScalar> *j_left,
                            JacobiRotation<RealScalar> *j_right)
{
  Matrix<RealScalar,2,2> m;
  m << real(matrix.coeff(p,p)), real(matrix.coeff(p,q)),
       real(matrix.coeff(q,p)), real(matrix.coeff(q,q));
  JacobiRotation<RealScalar> rot1;
  RealScalar t = m.coeff(0,0) + m.coeff(1,1);
  RealScalar d = m.coeff(1,0) - m.coeff(0,1);
  if(t == RealScalar(0))
  {
    rot1.c() = RealScalar(0);
    rot1.s() = d > RealScalar(0) ? RealScalar(1) : RealScalar(-1);
  }
  else
  {
    RealScalar u = d / t;
    rot1.c() = RealScalar(1) / sqrt(RealScalar(1) + abs2(u));
    rot1.s() = rot1.c() * u;
  }
  m.applyOnTheLeft(0,1,rot1);
  j_right->makeJacobi(m,0,1);
  *j_left = rot1 * j_right->transpose();
}

}
# 343 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/JacobiSVD.h"
template<typename _MatrixType, int QRPreconditioner> class JacobiSVD
{
  public:

    typedef _MatrixType MatrixType;
    typedef typename MatrixType::Scalar Scalar;
    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;
    typedef typename MatrixType::Index Index;
    enum {
      RowsAtCompileTime = MatrixType::RowsAtCompileTime,
      ColsAtCompileTime = MatrixType::ColsAtCompileTime,
      DiagSizeAtCompileTime = (((int)RowsAtCompileTime == 0 || (int)ColsAtCompileTime == 0) ? 0 : ((int)RowsAtCompileTime == 1 || (int)ColsAtCompileTime == 1) ? 1 : ((int)RowsAtCompileTime == Dynamic || (int)ColsAtCompileTime == Dynamic) ? Dynamic : ((int)RowsAtCompileTime <= (int)ColsAtCompileTime) ? (int)RowsAtCompileTime : (int)ColsAtCompileTime),
      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,
      MaxDiagSizeAtCompileTime = (((int)MaxRowsAtCompileTime == 0 || (int)MaxColsAtCompileTime == 0) ? 0 : ((int)MaxRowsAtCompileTime == 1 || (int)MaxColsAtCompileTime == 1) ? 1 : ((int)MaxRowsAtCompileTime == Dynamic && (int)MaxColsAtCompileTime == Dynamic) ? Dynamic : ((int)MaxRowsAtCompileTime == Dynamic) ? (int)MaxColsAtCompileTime : ((int)MaxColsAtCompileTime == Dynamic) ? (int)MaxRowsAtCompileTime : ((int)MaxRowsAtCompileTime <= (int)MaxColsAtCompileTime) ? (int)MaxRowsAtCompileTime : (int)MaxColsAtCompileTime),
      MatrixOptions = MatrixType::Options
    };

    typedef Matrix<Scalar, RowsAtCompileTime, RowsAtCompileTime,
                   MatrixOptions, MaxRowsAtCompileTime, MaxRowsAtCompileTime>
            MatrixUType;
    typedef Matrix<Scalar, ColsAtCompileTime, ColsAtCompileTime,
                   MatrixOptions, MaxColsAtCompileTime, MaxColsAtCompileTime>
            MatrixVType;
    typedef typename internal::plain_diag_type<MatrixType, RealScalar>::type SingularValuesType;
    typedef typename internal::plain_row_type<MatrixType>::type RowType;
    typedef typename internal::plain_col_type<MatrixType>::type ColType;
    typedef Matrix<Scalar, DiagSizeAtCompileTime, DiagSizeAtCompileTime,
                   MatrixOptions, MaxDiagSizeAtCompileTime, MaxDiagSizeAtCompileTime>
            WorkMatrixType;






    JacobiSVD()
      : m_isInitialized(false),
        m_isAllocated(false),
        m_computationOptions(0),
        m_rows(-1), m_cols(-1)
    {}
# 393 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/JacobiSVD.h"
    JacobiSVD(Index rows, Index cols, unsigned int computationOptions = 0)
      : m_isInitialized(false),
        m_isAllocated(false),
        m_computationOptions(0),
        m_rows(-1), m_cols(-1)
    {
      allocate(rows, cols, computationOptions);
    }
# 412 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/JacobiSVD.h"
    JacobiSVD(const MatrixType& matrix, unsigned int computationOptions = 0)
      : m_isInitialized(false),
        m_isAllocated(false),
        m_computationOptions(0),
        m_rows(-1), m_cols(-1)
    {
      compute(matrix, computationOptions);
    }
# 431 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/JacobiSVD.h"
    JacobiSVD& compute(const MatrixType& matrix, unsigned int computationOptions);







    JacobiSVD& compute(const MatrixType& matrix)
    {
      return compute(matrix, m_computationOptions);
    }
# 453 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/JacobiSVD.h"
    const MatrixUType& matrixU() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "JacobiSVD is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "JacobiSVD is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"JacobiSVD is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/JacobiSVD.h", 455); } while(false); else throw Eigen::eigen_assert_exception(); };
      if( (!Eigen::internal::copy_bool(computeU() && "This JacobiSVD decomposition didn't compute U. Did you ask for it?")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(computeU() && "This JacobiSVD decomposition didn't compute U. Did you ask for it?")) Eigen::internal::assert_fail("computeU() && \"This JacobiSVD decomposition didn't compute U. Did you ask for it?\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/JacobiSVD.h", 456); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_matrixU;
    }
# 469 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/JacobiSVD.h"
    const MatrixVType& matrixV() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "JacobiSVD is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "JacobiSVD is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"JacobiSVD is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/JacobiSVD.h", 471); } while(false); else throw Eigen::eigen_assert_exception(); };
      if( (!Eigen::internal::copy_bool(computeV() && "This JacobiSVD decomposition didn't compute V. Did you ask for it?")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(computeV() && "This JacobiSVD decomposition didn't compute V. Did you ask for it?")) Eigen::internal::assert_fail("computeV() && \"This JacobiSVD decomposition didn't compute V. Did you ask for it?\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/JacobiSVD.h", 472); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_matrixV;
    }






    const SingularValuesType& singularValues() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "JacobiSVD is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "JacobiSVD is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"JacobiSVD is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/JacobiSVD.h", 483); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_singularValues;
    }


    inline bool computeU() const { return m_computeFullU || m_computeThinU; }

    inline bool computeV() const { return m_computeFullV || m_computeThinV; }
# 501 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/JacobiSVD.h"
    template<typename Rhs>
    inline const internal::solve_retval<JacobiSVD, Rhs>
    solve(const MatrixBase<Rhs>& b) const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "JacobiSVD is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "JacobiSVD is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"JacobiSVD is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/JacobiSVD.h", 505); } while(false); else throw Eigen::eigen_assert_exception(); };
      if( (!Eigen::internal::copy_bool(computeU() && computeV() && "JacobiSVD::solve() requires both unitaries U and V to be computed (thin unitaries suffice).")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(computeU() && computeV() && "JacobiSVD::solve() requires both unitaries U and V to be computed (thin unitaries suffice).")) Eigen::internal::assert_fail("computeU() && computeV() && \"JacobiSVD::solve() requires both unitaries U and V to be computed (thin unitaries suffice).\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/JacobiSVD.h", 506); } while(false); else throw Eigen::eigen_assert_exception(); };
      return internal::solve_retval<JacobiSVD, Rhs>(*this, b.derived());
    }


    Index nonzeroSingularValues() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "JacobiSVD is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "JacobiSVD is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"JacobiSVD is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/JacobiSVD.h", 513); } while(false); else throw Eigen::eigen_assert_exception(); };
      return m_nonzeroSingularValues;
    }

    inline Index rows() const { return m_rows; }
    inline Index cols() const { return m_cols; }

  private:
    void allocate(Index rows, Index cols, unsigned int computationOptions);

  protected:
    MatrixUType m_matrixU;
    MatrixVType m_matrixV;
    SingularValuesType m_singularValues;
    WorkMatrixType m_workMatrix;
    bool m_isInitialized, m_isAllocated;
    bool m_computeFullU, m_computeThinU;
    bool m_computeFullV, m_computeThinV;
    unsigned int m_computationOptions;
    Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;

    template<typename __MatrixType, int _QRPreconditioner, bool _IsComplex>
    friend struct internal::svd_precondition_2x2_block_to_be_real;
    template<typename __MatrixType, int _QRPreconditioner, int _Case, bool _DoAnything>
    friend struct internal::qr_preconditioner_impl;
};

template<typename MatrixType, int QRPreconditioner>
void JacobiSVD<MatrixType, QRPreconditioner>::allocate(Index rows, Index cols, unsigned int computationOptions)
{
  if( (!Eigen::internal::copy_bool(rows >= 0 && cols >= 0)) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(rows >= 0 && cols >= 0)) Eigen::internal::assert_fail("rows >= 0 && cols >= 0", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/JacobiSVD.h", 543); } while(false); else throw Eigen::eigen_assert_exception(); };

  if (m_isAllocated &&
      rows == m_rows &&
      cols == m_cols &&
      computationOptions == m_computationOptions)
  {
    return;
  }

  m_rows = rows;
  m_cols = cols;
  m_isInitialized = false;
  m_isAllocated = true;
  m_computationOptions = computationOptions;
  m_computeFullU = (computationOptions & ComputeFullU) != 0;
  m_computeThinU = (computationOptions & ComputeThinU) != 0;
  m_computeFullV = (computationOptions & ComputeFullV) != 0;
  m_computeThinV = (computationOptions & ComputeThinV) != 0;
  if( (!Eigen::internal::copy_bool(!(m_computeFullU && m_computeThinU) && "JacobiSVD: you can't ask for both full and thin U")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(!(m_computeFullU && m_computeThinU) && "JacobiSVD: you can't ask for both full and thin U")) Eigen::internal::assert_fail("!(m_computeFullU && m_computeThinU) && \"JacobiSVD: you can't ask for both full and thin U\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/JacobiSVD.h", 562); } while(false); else throw Eigen::eigen_assert_exception(); };
  if( (!Eigen::internal::copy_bool(!(m_computeFullV && m_computeThinV) && "JacobiSVD: you can't ask for both full and thin V")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(!(m_computeFullV && m_computeThinV) && "JacobiSVD: you can't ask for both full and thin V")) Eigen::internal::assert_fail("!(m_computeFullV && m_computeThinV) && \"JacobiSVD: you can't ask for both full and thin V\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/JacobiSVD.h", 563); } while(false); else throw Eigen::eigen_assert_exception(); };
  if( (!Eigen::internal::copy_bool((!(m_computeThinU || m_computeThinV) || (MatrixType::ColsAtCompileTime==Dynamic)) && "JacobiSVD: thin U and V are only available when your matrix has a dynamic number of columns.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool((!(m_computeThinU || m_computeThinV) || (MatrixType::ColsAtCompileTime==Dynamic)) && "JacobiSVD: thin U and V are only available when your matrix has a dynamic number of columns.")) Eigen::internal::assert_fail("(!(m_computeThinU || m_computeThinV) || (MatrixType::ColsAtCompileTime==Dynamic)) && \"JacobiSVD: thin U and V are only available when your matrix has a dynamic number of columns.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/JacobiSVD.h", 565); } while(false); else throw Eigen::eigen_assert_exception(); };

  if (QRPreconditioner == FullPivHouseholderQRPreconditioner)
  {
      if( (!Eigen::internal::copy_bool(!(m_computeThinU || m_computeThinV) && "JacobiSVD: can't compute thin U or thin V with the FullPivHouseholderQR preconditioner. " "Use the ColPivHouseholderQR preconditioner instead.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(!(m_computeThinU || m_computeThinV) && "JacobiSVD: can't compute thin U or thin V with the FullPivHouseholderQR preconditioner. " "Use the ColPivHouseholderQR preconditioner instead.")) Eigen::internal::assert_fail("!(m_computeThinU || m_computeThinV) && \"JacobiSVD: can't compute thin U or thin V with the FullPivHouseholderQR preconditioner. \" \"Use the ColPivHouseholderQR preconditioner instead.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/JacobiSVD.h", 570); } while(false); else throw Eigen::eigen_assert_exception(); };


  }
  m_diagSize = (std::min)(m_rows, m_cols);
  m_singularValues.resize(m_diagSize);
  m_matrixU.resize(m_rows, m_computeFullU ? m_rows
                          : m_computeThinU ? m_diagSize
                          : 0);
  m_matrixV.resize(m_cols, m_computeFullV ? m_cols
                          : m_computeThinV ? m_diagSize
                          : 0);
  m_workMatrix.resize(m_diagSize, m_diagSize);
}

template<typename MatrixType, int QRPreconditioner>
JacobiSVD<MatrixType, QRPreconditioner>&
JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType& matrix, unsigned int computationOptions)
{
  allocate(matrix.rows(), matrix.cols(), computationOptions);



  const RealScalar precision = RealScalar(2) * NumTraits<Scalar>::epsilon();


  const RealScalar considerAsZero = RealScalar(2) * std::numeric_limits<RealScalar>::denorm_min();



  if(!internal::qr_preconditioner_impl<MatrixType, QRPreconditioner, internal::PreconditionIfMoreColsThanRows>::run(*this, matrix)
  && !internal::qr_preconditioner_impl<MatrixType, QRPreconditioner, internal::PreconditionIfMoreRowsThanCols>::run(*this, matrix))
  {
    m_workMatrix = matrix.block(0,0,m_diagSize,m_diagSize);
    if(m_computeFullU) m_matrixU.setIdentity(m_rows,m_rows);
    if(m_computeThinU) m_matrixU.setIdentity(m_rows,m_diagSize);
    if(m_computeFullV) m_matrixV.setIdentity(m_cols,m_cols);
    if(m_computeThinV) m_matrixV.setIdentity(m_cols, m_diagSize);
  }



  bool finished = false;
  while(!finished)
  {
    finished = true;



    for(Index p = 1; p < m_diagSize; ++p)
    {
      for(Index q = 0; q < p; ++q)
      {



        using std::max;
        RealScalar threshold = (max)(considerAsZero, precision * (max)(internal::abs(m_workMatrix.coeff(p,p)),
                                                                       internal::abs(m_workMatrix.coeff(q,q))));
        if((max)(internal::abs(m_workMatrix.coeff(p,q)),internal::abs(m_workMatrix.coeff(q,p))) > threshold)
        {
          finished = false;


          internal::svd_precondition_2x2_block_to_be_real<MatrixType, QRPreconditioner>::run(m_workMatrix, *this, p, q);
          JacobiRotation<RealScalar> j_left, j_right;
          internal::real_2x2_jacobi_svd(m_workMatrix, p, q, &j_left, &j_right);


          m_workMatrix.applyOnTheLeft(p,q,j_left);
          if(computeU()) m_matrixU.applyOnTheRight(p,q,j_left.transpose());

          m_workMatrix.applyOnTheRight(p,q,j_right);
          if(computeV()) m_matrixV.applyOnTheRight(p,q,j_right);
        }
      }
    }
  }



  for(Index i = 0; i < m_diagSize; ++i)
  {
    RealScalar a = internal::abs(m_workMatrix.coeff(i,i));
    m_singularValues.coeffRef(i) = a;
    if(computeU() && (a!=RealScalar(0))) m_matrixU.col(i) *= m_workMatrix.coeff(i,i)/a;
  }



  m_nonzeroSingularValues = m_diagSize;
  for(Index i = 0; i < m_diagSize; i++)
  {
    Index pos;
    RealScalar maxRemainingSingularValue = m_singularValues.tail(m_diagSize-i).maxCoeff(&pos);
    if(maxRemainingSingularValue == RealScalar(0))
    {
      m_nonzeroSingularValues = i;
      break;
    }
    if(pos)
    {
      pos += i;
      std::swap(m_singularValues.coeffRef(i), m_singularValues.coeffRef(pos));
      if(computeU()) m_matrixU.col(pos).swap(m_matrixU.col(i));
      if(computeV()) m_matrixV.col(pos).swap(m_matrixV.col(i));
    }
  }

  m_isInitialized = true;
  return *this;
}

namespace internal {
template<typename _MatrixType, int QRPreconditioner, typename Rhs>
struct solve_retval<JacobiSVD<_MatrixType, QRPreconditioner>, Rhs>
  : solve_retval_base<JacobiSVD<_MatrixType, QRPreconditioner>, Rhs>
{
  typedef JacobiSVD<_MatrixType, QRPreconditioner> JacobiSVDType;
  typedef typename JacobiSVDType::MatrixType MatrixType; typedef typename MatrixType::Scalar Scalar; typedef typename MatrixType::RealScalar RealScalar; typedef typename MatrixType::Index Index; typedef Eigen::internal::solve_retval_base<JacobiSVDType,Rhs> Base; using Base::dec; using Base::rhs; using Base::rows; using Base::cols; solve_retval(const JacobiSVDType& dec, const Rhs& rhs) : Base(dec, rhs) {}

  template<typename Dest> void evalTo(Dest& dst) const
  {
    if( (!Eigen::internal::copy_bool(rhs().rows() == dec().rows())) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(rhs().rows() == dec().rows())) Eigen::internal::assert_fail("rhs().rows() == dec().rows()", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/JacobiSVD.h", 691); } while(false); else throw Eigen::eigen_assert_exception(); };




    Index diagSize = (std::min)(dec().rows(), dec().cols());
    typename JacobiSVDType::SingularValuesType invertedSingVals(diagSize);

    Index nonzeroSingVals = dec().nonzeroSingularValues();
    invertedSingVals.head(nonzeroSingVals) = dec().singularValues().head(nonzeroSingVals).array().inverse();
    invertedSingVals.tail(diagSize - nonzeroSingVals).setZero();

    dst = dec().matrixV().leftCols(diagSize)
        * invertedSingVals.asDiagonal()
        * dec().matrixU().leftCols(diagSize).adjoint()
        * rhs();
  }
};
}

template<typename Derived>
JacobiSVD<typename MatrixBase<Derived>::PlainObject>
MatrixBase<Derived>::jacobiSvd(unsigned int computationOptions) const
{
  return JacobiSVD<PlainObject>(*this, computationOptions);
}
# 27 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/SVD" 2
# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/UpperBidiagonalization.h" 1
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/UpperBidiagonalization.h"
namespace internal {



template<typename _MatrixType> class UpperBidiagonalization
{
  public:

    typedef _MatrixType MatrixType;
    enum {
      RowsAtCompileTime = MatrixType::RowsAtCompileTime,
      ColsAtCompileTime = MatrixType::ColsAtCompileTime,
      ColsAtCompileTimeMinusOne = internal::decrement_size<ColsAtCompileTime>::ret
    };
    typedef typename MatrixType::Scalar Scalar;
    typedef typename MatrixType::RealScalar RealScalar;
    typedef typename MatrixType::Index Index;
    typedef Matrix<Scalar, 1, ColsAtCompileTime> RowVectorType;
    typedef Matrix<Scalar, RowsAtCompileTime, 1> ColVectorType;
    typedef BandMatrix<RealScalar, ColsAtCompileTime, ColsAtCompileTime, 1, 0> BidiagonalType;
    typedef Matrix<Scalar, ColsAtCompileTime, 1> DiagVectorType;
    typedef Matrix<Scalar, ColsAtCompileTimeMinusOne, 1> SuperDiagVectorType;
    typedef HouseholderSequence<
              const MatrixType,
              CwiseUnaryOp<internal::scalar_conjugate_op<Scalar>, const Diagonal<const MatrixType,0> >
            > HouseholderUSequenceType;
    typedef HouseholderSequence<
              const MatrixType,
              Diagonal<const MatrixType,1>,
              OnTheRight
            > HouseholderVSequenceType;







    UpperBidiagonalization() : m_householder(), m_bidiagonal(), m_isInitialized(false) {}

    UpperBidiagonalization(const MatrixType& matrix)
      : m_householder(matrix.rows(), matrix.cols()),
        m_bidiagonal(matrix.cols(), matrix.cols()),
        m_isInitialized(false)
    {
      compute(matrix);
    }

    UpperBidiagonalization& compute(const MatrixType& matrix);

    const MatrixType& householder() const { return m_householder; }
    const BidiagonalType& bidiagonal() const { return m_bidiagonal; }

    const HouseholderUSequenceType householderU() const
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "UpperBidiagonalization is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "UpperBidiagonalization is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"UpperBidiagonalization is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/UpperBidiagonalization.h", 83); } while(false); else throw Eigen::eigen_assert_exception(); };
      return HouseholderUSequenceType(m_householder, m_householder.diagonal().conjugate());
    }

    const HouseholderVSequenceType householderV()
    {
      if( (!Eigen::internal::copy_bool(m_isInitialized && "UpperBidiagonalization is not initialized.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(m_isInitialized && "UpperBidiagonalization is not initialized.")) Eigen::internal::assert_fail("m_isInitialized && \"UpperBidiagonalization is not initialized.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/UpperBidiagonalization.h", 89); } while(false); else throw Eigen::eigen_assert_exception(); };
      return HouseholderVSequenceType(m_householder, m_householder.const_derived().template diagonal<1>())
             .setLength(m_householder.cols()-1)
             .setShift(1);
    }

  protected:
    MatrixType m_householder;
    BidiagonalType m_bidiagonal;
    bool m_isInitialized;
};

template<typename _MatrixType>
UpperBidiagonalization<_MatrixType>& UpperBidiagonalization<_MatrixType>::compute(const _MatrixType& matrix)
{
  Index rows = matrix.rows();
  Index cols = matrix.cols();

  if( (!Eigen::internal::copy_bool(rows >= cols && "UpperBidiagonalization is only for matrices satisfying rows>=cols.")) && (!no_more_assert) ) { Eigen::no_more_assert = true; if(report_on_cerr_on_assert_failure) do { if(!Eigen::internal::copy_bool(rows >= cols && "UpperBidiagonalization is only for matrices satisfying rows>=cols.")) Eigen::internal::assert_fail("rows >= cols && \"UpperBidiagonalization is only for matrices satisfying rows>=cols.\"", __PRETTY_FUNCTION__, "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/UpperBidiagonalization.h", 107); } while(false); else throw Eigen::eigen_assert_exception(); };

  m_householder = matrix;

  ColVectorType temp(rows);

  for (Index k = 0; ; ++k)
  {
    Index remainingRows = rows - k;
    Index remainingCols = cols - k - 1;


    m_householder.col(k).tail(remainingRows)
                 .makeHouseholderInPlace(m_householder.coeffRef(k,k),
                                         m_bidiagonal.template diagonal<0>().coeffRef(k));

    m_householder.bottomRightCorner(remainingRows, remainingCols)
                 .applyHouseholderOnTheLeft(m_householder.col(k).tail(remainingRows-1),
                                            m_householder.coeff(k,k),
                                            temp.data());

    if(k == cols-1) break;


    m_householder.row(k).tail(remainingCols)
                 .makeHouseholderInPlace(m_householder.coeffRef(k,k+1),
                                         m_bidiagonal.template diagonal<1>().coeffRef(k));

    m_householder.bottomRightCorner(remainingRows-1, remainingCols)
                 .applyHouseholderOnTheRight(m_householder.row(k).tail(remainingCols-1).transpose(),
                                             m_householder.coeff(k,k+1),
                                             temp.data());
  }
  m_isInitialized = true;
  return *this;
}
# 157 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/SVD/UpperBidiagonalization.h"
}
# 28 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/SVD" 2





}


# 1 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/src/Core/util/ReenableStupidWarnings.h" 1
# 36 "/home/pipping/Downloads/eigen-eigen-3.0.3/Eigen/SVD" 2
# 41 "/home/pipping/Downloads/eigen-eigen-3.0.3/test/nomalloc.cpp" 2

template<typename MatrixType> void nomalloc(const MatrixType& m)
{


  typedef typename MatrixType::Index Index;
  typedef typename MatrixType::Scalar Scalar;
  typedef Matrix<Scalar, MatrixType::RowsAtCompileTime, 1> VectorType;

  Index rows = m.rows();
  Index cols = m.cols();

  MatrixType m1 = MatrixType::Random(rows, cols),
             m2 = MatrixType::Random(rows, cols),
             m3(rows, cols),
             mzero = MatrixType::Zero(rows, cols),
             identity = Matrix<Scalar, MatrixType::RowsAtCompileTime, MatrixType::RowsAtCompileTime>
                              ::Identity(rows, rows),
             square = Matrix<Scalar, MatrixType::RowsAtCompileTime, MatrixType::RowsAtCompileTime>
                              ::Random(rows, rows);
  VectorType v1 = VectorType::Random(rows),
             v2 = VectorType::Random(rows),
             vzero = VectorType::Zero(rows);

  Scalar s1 = internal::random<Scalar>();

  Index r = internal::random<Index>(0, rows-1),
        c = internal::random<Index>(0, cols-1);

  verify_impl(test_isApprox((m1+m2)*s1, s1*m1+s1*m2), g_test_stack.back().c_str(), "/home/pipping/Downloads/eigen-eigen-3.0.3/test/nomalloc.cpp", 70, "test_isApprox((m1+m2)*s1, s1*m1+s1*m2)");
  verify_impl(test_isApprox((m1+m2)(r,c), (m1(r,c))+(m2(r,c))), g_test_stack.back().c_str(), "/home/pipping/Downloads/eigen-eigen-3.0.3/test/nomalloc.cpp", 71, "test_isApprox((m1+m2)(r,c), (m1(r,c))+(m2(r,c)))");
  verify_impl(test_isApprox(m1.cwiseProduct(m1.block(0,0,rows,cols)), (m1.array()*m1.array()).matrix()), g_test_stack.back().c_str(), "/home/pipping/Downloads/eigen-eigen-3.0.3/test/nomalloc.cpp", 72, "test_isApprox(m1.cwiseProduct(m1.block(0,0,rows,cols)), (m1.array()*m1.array()).matrix())");
  verify_impl(test_isApprox((m1*m1.transpose())*m2, m1*(m1.transpose()*m2)), g_test_stack.back().c_str(), "/home/pipping/Downloads/eigen-eigen-3.0.3/test/nomalloc.cpp", 73, "test_isApprox((m1*m1.transpose())*m2, m1*(m1.transpose()*m2))");

  m2.col(0).noalias() = m1 * m1.col(0);
  m2.col(0).noalias() -= m1.adjoint() * m1.col(0);
  m2.col(0).noalias() -= m1 * m1.row(0).adjoint();
  m2.col(0).noalias() -= m1.adjoint() * m1.row(0).adjoint();

  m2.row(0).noalias() = m1.row(0) * m1;
  m2.row(0).noalias() -= m1.row(0) * m1.adjoint();
  m2.row(0).noalias() -= m1.col(0).adjoint() * m1;
  m2.row(0).noalias() -= m1.col(0).adjoint() * m1.adjoint();
  verify_impl(test_isApprox(m2, m2), g_test_stack.back().c_str(), "/home/pipping/Downloads/eigen-eigen-3.0.3/test/nomalloc.cpp", 84, "test_isApprox(m2, m2)");

  m2.col(0).noalias() = m1.template triangularView<Upper>() * m1.col(0);
  m2.col(0).noalias() -= m1.adjoint().template triangularView<Upper>() * m1.col(0);
  m2.col(0).noalias() -= m1.template triangularView<Upper>() * m1.row(0).adjoint();
  m2.col(0).noalias() -= m1.adjoint().template triangularView<Upper>() * m1.row(0).adjoint();

  m2.row(0).noalias() = m1.row(0) * m1.template triangularView<Upper>();
  m2.row(0).noalias() -= m1.row(0) * m1.adjoint().template triangularView<Upper>();
  m2.row(0).noalias() -= m1.col(0).adjoint() * m1.template triangularView<Upper>();
  m2.row(0).noalias() -= m1.col(0).adjoint() * m1.adjoint().template triangularView<Upper>();
  verify_impl(test_isApprox(m2, m2), g_test_stack.back().c_str(), "/home/pipping/Downloads/eigen-eigen-3.0.3/test/nomalloc.cpp", 95, "test_isApprox(m2, m2)");

  m2.col(0).noalias() = m1.template selfadjointView<Upper>() * m1.col(0);
  m2.col(0).noalias() -= m1.adjoint().template selfadjointView<Upper>() * m1.col(0);
  m2.col(0).noalias() -= m1.template selfadjointView<Upper>() * m1.row(0).adjoint();
  m2.col(0).noalias() -= m1.adjoint().template selfadjointView<Upper>() * m1.row(0).adjoint();

  m2.row(0).noalias() = m1.row(0) * m1.template selfadjointView<Upper>();
  m2.row(0).noalias() -= m1.row(0) * m1.adjoint().template selfadjointView<Upper>();
  m2.row(0).noalias() -= m1.col(0).adjoint() * m1.template selfadjointView<Upper>();
  m2.row(0).noalias() -= m1.col(0).adjoint() * m1.adjoint().template selfadjointView<Upper>();
  verify_impl(test_isApprox(m2, m2), g_test_stack.back().c_str(), "/home/pipping/Downloads/eigen-eigen-3.0.3/test/nomalloc.cpp", 106, "test_isApprox(m2, m2)");

  m2.template selfadjointView<Lower>().rankUpdate(m1.col(0),-1);
  m2.template selfadjointView<Lower>().rankUpdate(m1.row(0),-1);







}

template<typename Scalar>
void ctms_decompositions()
{
  const int maxSize = 16;
  const int size = 12;

  typedef Eigen::Matrix<Scalar,
                        Eigen::Dynamic, Eigen::Dynamic,
                        0,
                        maxSize, maxSize> Matrix;

  typedef Eigen::Matrix<Scalar,
                        Eigen::Dynamic, 1,
                        0,
                        maxSize, 1> Vector;

  typedef Eigen::Matrix<std::complex<Scalar>,
                        Eigen::Dynamic, Eigen::Dynamic,
                        0,
                        maxSize, maxSize> ComplexMatrix;

  const Matrix A(Matrix::Random(size, size));
  const ComplexMatrix complexA(ComplexMatrix::Random(size, size));
  const Matrix saA = A.adjoint() * A;


  Eigen::LLT<Matrix> LLT; LLT.compute(A);
  Eigen::LDLT<Matrix> LDLT; LDLT.compute(A);


  Eigen::HessenbergDecomposition<ComplexMatrix> hessDecomp; hessDecomp.compute(complexA);
  Eigen::ComplexSchur<ComplexMatrix> cSchur(size); cSchur.compute(complexA);
  Eigen::ComplexEigenSolver<ComplexMatrix> cEigSolver; cEigSolver.compute(complexA);
  Eigen::EigenSolver<Matrix> eigSolver; eigSolver.compute(A);
  Eigen::SelfAdjointEigenSolver<Matrix> saEigSolver(size); saEigSolver.compute(saA);
  Eigen::Tridiagonalization<Matrix> tridiag; tridiag.compute(saA);


  Eigen::PartialPivLU<Matrix> ppLU; ppLU.compute(A);
  Eigen::FullPivLU<Matrix> fpLU; fpLU.compute(A);


  Eigen::HouseholderQR<Matrix> hQR; hQR.compute(A);
  Eigen::ColPivHouseholderQR<Matrix> cpQR; cpQR.compute(A);
  Eigen::FullPivHouseholderQR<Matrix> fpQR; fpQR.compute(A);


  Eigen::JacobiSVD<Matrix> jSVD; jSVD.compute(A, ComputeFullU | ComputeFullV);
}

void test_nomalloc()
{

  { Eigen::no_more_assert = false; Eigen::report_on_cerr_on_assert_failure = false; try { MatrixXd dummy(MatrixXd::Random(3,3)); verify_impl(Eigen::should_raise_an_assert && "MatrixXd dummy(MatrixXd::Random(3,3))", g_test_stack.back().c_str(), "/home/pipping/Downloads/eigen-eigen-3.0.3/test/nomalloc.cpp", 172, "Eigen::should_raise_an_assert && \"MatrixXd dummy(MatrixXd::Random(3,3))\""); } catch (Eigen::eigen_assert_exception&) { verify_impl(true, g_test_stack.back().c_str(), "/home/pipping/Downloads/eigen-eigen-3.0.3/test/nomalloc.cpp", 172, "true"); } Eigen::report_on_cerr_on_assert_failure = true; };
                                                  ;
                                       ;
                                                  ;


  do { g_test_stack.push_back("ctms_decompositions<float>()"); ctms_decompositions<float>(); g_test_stack.pop_back(); } while (0);

}
