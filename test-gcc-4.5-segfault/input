# 1 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/test/test-edges0.5.cc"
# 1 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/test/test-edges0.5.cc" 1
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 143 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/test/test-edges0.5.cc" 2




# 1 "../../../config.h" 1
# 6 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/test/test-edges0.5.cc" 2


# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3

# 1 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/c++config.h" 1 3
# 243 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/c++config.h" 3
# 1 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/os_defines.h" 1 3
# 39 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/os_defines.h" 3
# 1 "/usr/include/features.h" 1 3 4
# 313 "/usr/include/features.h" 3 4
# 1 "/usr/include/bits/predefs.h" 1 3 4
# 314 "/usr/include/features.h" 2 3 4
# 346 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 353 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 354 "/usr/include/sys/cdefs.h" 2 3 4
# 347 "/usr/include/features.h" 2 3 4
# 378 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4



# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 5 "/usr/include/gnu/stubs.h" 2 3 4




# 1 "/usr/include/gnu/stubs-64.h" 1 3 4
# 10 "/usr/include/gnu/stubs.h" 2 3 4
# 379 "/usr/include/features.h" 2 3 4
# 40 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/os_defines.h" 2 3
# 244 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/c++config.h" 2 3


# 1 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/cpu_defines.h" 1 3
# 247 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/c++config.h" 2 3
# 43 "/usr/include/c++/4.4/cstddef" 2 3
# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 31 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 3 4
typedef __typeof__(((int*)0)-((int*)0)) ptrdiff_t;



typedef __typeof__(sizeof(int)) size_t;
# 44 "/usr/include/c++/4.4/cstddef" 2 3




namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::ptrdiff_t;
  using ::size_t;

}
# 9 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/test/test-edges0.5.cc" 2
# 1 "/usr/include/c++/4.4/iostream" 1 3
# 37 "/usr/include/c++/4.4/iostream" 3
# 37 "/usr/include/c++/4.4/iostream" 3


# 1 "/usr/include/c++/4.4/ostream" 1 3
# 38 "/usr/include/c++/4.4/ostream" 3
# 38 "/usr/include/c++/4.4/ostream" 3

# 1 "/usr/include/c++/4.4/ios" 1 3
# 37 "/usr/include/c++/4.4/ios" 3
# 37 "/usr/include/c++/4.4/ios" 3

# 1 "/usr/include/c++/4.4/iosfwd" 1 3
# 38 "/usr/include/c++/4.4/iosfwd" 3
# 38 "/usr/include/c++/4.4/iosfwd" 3


# 1 "/usr/include/c++/4.4/bits/stringfwd.h" 1 3
# 38 "/usr/include/c++/4.4/bits/stringfwd.h" 3
# 38 "/usr/include/c++/4.4/bits/stringfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Alloc>
    class allocator;

  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;

  typedef basic_string<char> string;


  template<> struct char_traits<wchar_t>;

  typedef basic_string<wchar_t> wstring;
# 74 "/usr/include/c++/4.4/bits/stringfwd.h" 3
}
# 41 "/usr/include/c++/4.4/iosfwd" 2 3
# 1 "/usr/include/c++/4.4/bits/postypes.h" 1 3
# 40 "/usr/include/c++/4.4/bits/postypes.h" 3
# 40 "/usr/include/c++/4.4/bits/postypes.h" 3

# 1 "/usr/include/c++/4.4/cwchar" 1 3
# 41 "/usr/include/c++/4.4/cwchar" 3
# 41 "/usr/include/c++/4.4/cwchar" 3


# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 44 "/usr/include/c++/4.4/cwchar" 2 3


# 1 "/usr/include/wchar.h" 1 3 4
# 37 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/stdio.h" 1 3 4
# 45 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;
# 65 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 38 "/usr/include/wchar.h" 2 3 4


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stdarg.h" 1 3 4
# 30 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stdarg.h" 3 4
typedef __builtin_va_list va_list;
# 48 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 41 "/usr/include/wchar.h" 2 3 4

# 1 "/usr/include/bits/wchar.h" 1 3 4
# 43 "/usr/include/wchar.h" 2 3 4
# 52 "/usr/include/wchar.h" 3 4
# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 61 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 53 "/usr/include/wchar.h" 2 3 4
# 83 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 106 "/usr/include/wchar.h" 3 4
typedef __mbstate_t mbstate_t;
# 129 "/usr/include/wchar.h" 3 4
extern "C" {




struct tm;
# 144 "/usr/include/wchar.h" 3 4
extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     throw ();


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     throw ();


extern int wcscmp (__const wchar_t *__s1, __const wchar_t *__s2)
     throw () __attribute__ ((__pure__));

extern int wcsncmp (__const wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));




extern int wcscasecmp (__const wchar_t *__s1, __const wchar_t *__s2) throw ();


extern int wcsncasecmp (__const wchar_t *__s1, __const wchar_t *__s2,
   size_t __n) throw ();




# 1 "/usr/include/xlocale.h" 1 3 4
# 28 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 178 "/usr/include/wchar.h" 2 3 4

extern int wcscasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
    __locale_t __loc) throw ();

extern int wcsncasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
     size_t __n, __locale_t __loc) throw ();





extern int wcscoll (__const wchar_t *__s1, __const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         __const wchar_t *__restrict __s2, size_t __n) throw ();
# 203 "/usr/include/wchar.h" 3 4
extern int wcscoll_l (__const wchar_t *__s1, __const wchar_t *__s2,
        __locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, __const wchar_t *__s2,
    size_t __n, __locale_t __loc) throw ();


extern wchar_t *wcsdup (__const wchar_t *__s) throw () __attribute__ ((__malloc__));
# 224 "/usr/include/wchar.h" 3 4
extern wchar_t *wcschr (__const wchar_t *__wcs, wchar_t __wc)
     throw () __attribute__ ((__pure__));
# 234 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsrchr (__const wchar_t *__wcs, wchar_t __wc)
     throw () __attribute__ ((__pure__));






extern wchar_t *wcschrnul (__const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));





extern size_t wcscspn (__const wchar_t *__wcs, __const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (__const wchar_t *__wcs, __const wchar_t *__accept)
     throw () __attribute__ ((__pure__));
# 263 "/usr/include/wchar.h" 3 4
extern wchar_t *wcspbrk (__const wchar_t *__wcs, __const wchar_t *__accept)
     throw () __attribute__ ((__pure__));
# 274 "/usr/include/wchar.h" 3 4
extern wchar_t *wcsstr (__const wchar_t *__haystack, __const wchar_t *__needle)
     throw () __attribute__ ((__pure__));



extern wchar_t *wcstok (wchar_t *__restrict __s,
   __const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (__const wchar_t *__s) throw () __attribute__ ((__pure__));
# 296 "/usr/include/wchar.h" 3 4
extern wchar_t *wcswcs (__const wchar_t *__haystack, __const wchar_t *__needle)
     throw () __attribute__ ((__pure__));





extern size_t wcsnlen (__const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));
# 317 "/usr/include/wchar.h" 3 4
extern wchar_t *wmemchr (__const wchar_t *__s, wchar_t __c, size_t __n)
     throw () __attribute__ ((__pure__));



extern int wmemcmp (__const wchar_t *__restrict __s1,
      __const wchar_t *__restrict __s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    __const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();





extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     __const wchar_t *__restrict __s2, size_t __n)
     throw ();






extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (__const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         __const char *__restrict __s, size_t __n,
         mbstate_t *__p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (__const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (__const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();
# 406 "/usr/include/wchar.h" 3 4
extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    __const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
    __const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();






extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     __const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
     __const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (__const wchar_t *__s, size_t __n) throw ();






extern double wcstod (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();





extern float wcstof (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();







extern long int wcstol (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (__const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();






__extension__
extern long long int wcstoll (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();






__extension__
extern long long int wcstoq (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (__const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();
# 528 "/usr/include/wchar.h" 3 4
extern long int wcstol_l (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     __locale_t __loc) throw ();

extern unsigned long int wcstoul_l (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, __locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (__const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, __locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, __locale_t __loc)
     throw ();

extern double wcstod_l (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern float wcstof_l (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern long double wcstold_l (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         __locale_t __loc) throw ();






extern wchar_t *wcpcpy (wchar_t *__dest, __const wchar_t *__src) throw ();



extern wchar_t *wcpncpy (wchar_t *__dest, __const wchar_t *__src, size_t __n)
     throw ();
# 578 "/usr/include/wchar.h" 3 4
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();






extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
       __const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (__const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       __const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
        __const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (__const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        __const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
      __const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (__const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (__const wchar_t *__restrict __s,
      __const wchar_t *__restrict __format, ...)
     throw () ;
# 687 "/usr/include/wchar.h" 3 4
extern int vfwscanf (__FILE *__restrict __s,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (__const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (__const wchar_t *__restrict __s,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;
# 743 "/usr/include/wchar.h" 3 4
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (__const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
# 799 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 825 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 835 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (__const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);







extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   __const wchar_t *__restrict __format,
   __const struct tm *__restrict __tp) throw ();







extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     __const wchar_t *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) throw ();
# 889 "/usr/include/wchar.h" 3 4
}
# 47 "/usr/include/c++/4.4/cwchar" 2 3
# 64 "/usr/include/c++/4.4/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::mbstate_t;

}
# 138 "/usr/include/c++/4.4/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;
  using ::swprintf;
  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;

  using ::vswprintf;

  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;


  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }


}







namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {






  using ::wcstold;
# 253 "/usr/include/c++/4.4/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;


}

namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;

}
# 42 "/usr/include/c++/4.4/bits/postypes.h" 2 3
# 69 "/usr/include/c++/4.4/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 87 "/usr/include/c++/4.4/bits/postypes.h" 3
  typedef long streamoff;
# 97 "/usr/include/c++/4.4/bits/postypes.h" 3
  typedef ptrdiff_t streamsize;
# 110 "/usr/include/c++/4.4/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 132 "/usr/include/c++/4.4/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;
# 238 "/usr/include/c++/4.4/bits/postypes.h" 3
}
# 42 "/usr/include/c++/4.4/iosfwd" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  class ios_base;
# 126 "/usr/include/c++/4.4/iosfwd" 3
  typedef basic_ios<char> ios;
  typedef basic_streambuf<char> streambuf;
  typedef basic_istream<char> istream;
  typedef basic_ostream<char> ostream;
  typedef basic_iostream<char> iostream;
  typedef basic_stringbuf<char> stringbuf;
  typedef basic_istringstream<char> istringstream;
  typedef basic_ostringstream<char> ostringstream;
  typedef basic_stringstream<char> stringstream;
  typedef basic_filebuf<char> filebuf;
  typedef basic_ifstream<char> ifstream;
  typedef basic_ofstream<char> ofstream;
  typedef basic_fstream<char> fstream;


  typedef basic_ios<wchar_t> wios;
  typedef basic_streambuf<wchar_t> wstreambuf;
  typedef basic_istream<wchar_t> wistream;
  typedef basic_ostream<wchar_t> wostream;
  typedef basic_iostream<wchar_t> wiostream;
  typedef basic_stringbuf<wchar_t> wstringbuf;
  typedef basic_istringstream<wchar_t> wistringstream;
  typedef basic_ostringstream<wchar_t> wostringstream;
  typedef basic_stringstream<wchar_t> wstringstream;
  typedef basic_filebuf<wchar_t> wfilebuf;
  typedef basic_ifstream<wchar_t> wifstream;
  typedef basic_ofstream<wchar_t> wofstream;
  typedef basic_fstream<wchar_t> wfstream;



}
# 39 "/usr/include/c++/4.4/ios" 2 3
# 1 "/usr/include/c++/4.4/exception" 1 3
# 35 "/usr/include/c++/4.4/exception" 3
#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 59 "/usr/include/c++/4.4/exception" 3
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();



    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }



    virtual ~bad_exception() throw();


    virtual const char* what() const throw();
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();



  void terminate() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();



  void unexpected() __attribute__ ((__noreturn__));
# 115 "/usr/include/c++/4.4/exception" 3
  bool uncaught_exception() throw();


}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 138 "/usr/include/c++/4.4/exception" 3
  void __verbose_terminate_handler();

}

}

#pragma GCC visibility pop
# 40 "/usr/include/c++/4.4/ios" 2 3
# 1 "/usr/include/c++/4.4/bits/char_traits.h" 1 3
# 39 "/usr/include/c++/4.4/bits/char_traits.h" 3
# 39 "/usr/include/c++/4.4/bits/char_traits.h" 3

# 1 "/usr/include/c++/4.4/bits/stl_algobase.h" 1 3
# 61 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 62 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.4/bits/functexcept.h" 1 3
# 37 "/usr/include/c++/4.4/bits/functexcept.h" 3
# 1 "/usr/include/c++/4.4/exception_defines.h" 1 3
# 38 "/usr/include/c++/4.4/bits/functexcept.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {


  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

}
# 63 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.4/bits/cpp_type_traits.h" 1 3
# 36 "/usr/include/c++/4.4/bits/cpp_type_traits.h" 3
# 36 "/usr/include/c++/4.4/bits/cpp_type_traits.h" 3
# 68 "/usr/include/c++/4.4/bits/cpp_type_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {

  template<typename _Iterator, typename _Container>
    class __normal_iterator;

}

namespace std __attribute__ ((__visibility__ ("default"))) {

  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };




  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 193 "/usr/include/c++/4.4/bits/cpp_type_traits.h" 3
  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
# 416 "/usr/include/c++/4.4/bits/cpp_type_traits.h" 3
}
# 64 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.4/ext/type_traits.h" 1 3
# 32 "/usr/include/c++/4.4/ext/type_traits.h" 3
# 32 "/usr/include/c++/4.4/ext/type_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {


  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };

  template<typename _Tp>
    struct __promote<_Tp, false>
    { typedef _Tp __type; };

  template<typename _Tp, typename _Up>
    struct __promote_2
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;

    public:
      typedef __typeof__(__type1() + __type2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp>
    struct __promote_3
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;
      typedef typename __promote<_Vp>::__type __type3;

    public:
      typedef __typeof__(__type1() + __type2() + __type3()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp>
    struct __promote_4
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;
      typedef typename __promote<_Vp>::__type __type3;
      typedef typename __promote<_Wp>::__type __type4;

    public:
      typedef __typeof__(__type1() + __type2() + __type3() + __type4()) __type;
    };

}
# 65 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.4/ext/numeric_traits.h" 1 3
# 32 "/usr/include/c++/4.4/ext/numeric_traits.h" 3
# 32 "/usr/include/c++/4.4/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 51 "/usr/include/c++/4.4/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 96 "/usr/include/c++/4.4/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 3010 / 10000);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };

}
# 66 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.4/bits/stl_pair.h" 1 3
# 60 "/usr/include/c++/4.4/bits/stl_pair.h" 3
# 1 "/usr/include/c++/4.4/bits/move.h" 1 3
# 34 "/usr/include/c++/4.4/bits/move.h" 3
# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 35 "/usr/include/c++/4.4/bits/move.h" 2 3
# 1 "/usr/include/c++/4.4/bits/concept_check.h" 1 3
# 33 "/usr/include/c++/4.4/bits/concept_check.h" 3
# 33 "/usr/include/c++/4.4/bits/concept_check.h" 3
# 36 "/usr/include/c++/4.4/bits/move.h" 2 3
# 66 "/usr/include/c++/4.4/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {







  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
    {



      _Tp __tmp = (__a);
      __a = (__b);
      __b = (__tmp);
    }



  template<typename _Tp, size_t _Nm>
    inline void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }

}
# 61 "/usr/include/c++/4.4/bits/stl_pair.h" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {


  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





      pair()
      : first(), second() { }


      pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
# 98 "/usr/include/c++/4.4/bits/stl_pair.h" 3
      template<class _U1, class _U2>
        pair(const pair<_U1, _U2>& __p)
 : first(__p.first),
   second(__p.second) { }
# 141 "/usr/include/c++/4.4/bits/stl_pair.h" 3
    };


  template<class _T1, class _T2>
    inline bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
# 213 "/usr/include/c++/4.4/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
    { return pair<_T1, _T2>(__x, __y); }
# 259 "/usr/include/c++/4.4/bits/stl_pair.h" 3
}
# 67 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.4/bits/stl_iterator_base_types.h" 1 3
# 63 "/usr/include/c++/4.4/bits/stl_iterator_base_types.h" 3
# 63 "/usr/include/c++/4.4/bits/stl_iterator_base_types.h" 3


# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 66 "/usr/include/c++/4.4/bits/stl_iterator_base_types.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 78 "/usr/include/c++/4.4/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };

  struct output_iterator_tag { };

  struct forward_iterator_tag : public input_iterator_tag { };


  struct bidirectional_iterator_tag : public forward_iterator_tag { };


  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 101 "/usr/include/c++/4.4/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };







  template<typename _Iterator>
    struct iterator_traits
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };

  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }



}
# 68 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.4/bits/stl_iterator_base_funcs.h" 1 3
# 63 "/usr/include/c++/4.4/bits/stl_iterator_base_funcs.h" 3
# 63 "/usr/include/c++/4.4/bits/stl_iterator_base_funcs.h" 3


namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {



      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {



      return __last - __first;
    }
# 107 "/usr/include/c++/4.4/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {


      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {



      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {



      __i += __n;
    }
# 165 "/usr/include/c++/4.4/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }
# 194 "/usr/include/c++/4.4/bits/stl_iterator_base_funcs.h" 3
}
# 69 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.4/bits/stl_iterator.h" 1 3
# 68 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 89 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

    public:
      typedef _Iterator iterator_type;
      typedef typename iterator_traits<_Iterator>::difference_type
              difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

    public:






      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }






      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }






      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }






      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 276 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>







    inline typename reverse_iterator<_IteratorL>::difference_type
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)

    { return __y.base() - __x.base(); }
# 388 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
# 414 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_back(__value);
 return *this;
      }
# 431 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 457 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 472 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
# 497 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_front(__value);
 return *this;
      }
# 514 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 540 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 559 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
# 601 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }
# 620 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 646 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }

}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 665 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

    public:
      typedef _Iterator iterator_type;
      typedef typename iterator_traits<_Iterator>::iterator_category
                                                             iterator_category;
      typedef typename iterator_traits<_Iterator>::value_type value_type;
      typedef typename iterator_traits<_Iterator>::difference_type
                                                             difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i)
        : _M_current(__i.base()) { }


      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
      { return _M_current; }
    };
# 763 "/usr/include/c++/4.4/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>







    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)

    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }

}
# 70 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/4.4/debug/debug.h" 1 3
# 47 "/usr/include/c++/4.4/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
# 72 "/usr/include/c++/4.4/bits/stl_algobase.h" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {




  template<bool _BoolType>
    struct __iter_swap
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          typedef typename iterator_traits<_ForwardIterator1>::value_type
            _ValueType1;
          _ValueType1 __tmp = (*__a);
          *__a = (*__b);
          *__b = (__tmp);
 }
    };

  template<>
    struct __iter_swap<true>
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          swap(*__a, *__b);
        }
    };
# 115 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;
# 134 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
      typedef typename iterator_traits<_ForwardIterator1>::reference
 _ReferenceType1;
      typedef typename iterator_traits<_ForwardIterator2>::reference
 _ReferenceType2;
      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
 && __are_same<_ValueType1&, _ReferenceType1>::__value
 && __are_same<_ValueType2&, _ReferenceType2>::__value>::
 iter_swap(__a, __b);
    }
# 156 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {





                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 184 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {



      if (__b < __a)
 return __b;
      return __a;
    }
# 207 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {



      if (__a < __b)
 return __b;
      return __a;
    }
# 230 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 251 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }




  template<typename _Iterator,
    bool _IsNormal = __is_normal_iterator<_Iterator>::__value>
    struct __niter_base
    {
      static _Iterator
      __b(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct __niter_base<_Iterator, true>
    {
      static typename _Iterator::iterator_type
      __b(_Iterator __it)
      { return __it.base(); }
    };


  template<typename _Iterator,
    bool _IsMove = __is_move_iterator<_Iterator>::__value>
    struct __miter_base
    {
      static _Iterator
      __b(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct __miter_base<_Iterator, true>
    {
      static typename _Iterator::iterator_type
      __b(_Iterator __it)
      { return __it.base(); }
    };







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };
# 333 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };
# 371 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   __builtin_memmove(__result, __first,
       sizeof(_Tp) * (__last - __first));
   return __result + (__last - __first);
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_pod(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>
   (std::__niter_base<_II>::__b(__first),
    std::__niter_base<_II>::__b(__last),
    std::__niter_base<_OI>::__b(__result)));
    }
# 456 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {




                                                     ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base<_II>::__b(__first),
        std::__miter_base<_II>::__b(__last), __result));
    }
# 509 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };
# 537 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };
# 567 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_pod(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base<_BI1>::__b(__first),
     std::__niter_base<_BI1>::__b(__last),
     std::__niter_base<_BI2>::__b(__result)));
    }
# 626 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {






                                                     ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base<_BI1>::__b(__first),
        std::__miter_base<_BI1>::__b(__last), __result));
    }
# 684 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      __builtin_memset(__first, static_cast<unsigned char>(__tmp),
         __last - __first);
    }
# 728 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {



                                                     ;

      std::__fill_a(std::__niter_base<_ForwardIterator>::__b(__first),
      std::__niter_base<_ForwardIterator>::__b(__last), __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (; __n > 0; --__n, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __n > 0; --__n, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
# 783 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {



      return _OI(std::__fill_n_a(std::__niter_base<_OI>::__b(__first),
     __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)
       * (__last1 - __first1));
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = (__is_integer<_ValueType1>::__value
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }


  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 typedef typename iterator_traits<_II1>::iterator_category _Category1;
 typedef typename iterator_traits<_II2>::iterator_category _Category2;
 typedef std::__lc_rai<_Category1, _Category2> __rai_type;

 __last1 = __rai_type::__newlast1(__first1, __last1,
      __first2, __last2);
 for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
      ++__first1, ++__first2)
   {
     if (*__first1 < *__first2)
       return true;
     if (*__first2 < *__first1)
       return false;
   }
 return __first1 == __last1 && __first2 != __last2;
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   const int __result = __builtin_memcmp(__first1, __first2,
      std::min(__len1, __len2));
   return __result != 0 ? __result < 0 : __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

}

namespace std __attribute__ ((__visibility__ ("default"))) {
# 950 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {






                                                       ;

      return std::__equal_aux(std::__niter_base<_II1>::__b(__first1),
         std::__niter_base<_II1>::__b(__last1),
         std::__niter_base<_II2>::__b(__first2));
    }
# 982 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {



                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
# 1013 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {

      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;




                                                       ;
                                                       ;

      return std::__lexicographical_compare_aux
 (std::__niter_base<_II1>::__b(__first1),
  std::__niter_base<_II1>::__b(__last1),
  std::__niter_base<_II2>::__b(__first2),
  std::__niter_base<_II2>::__b(__last2));
    }
# 1048 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;




                                                       ;
                                                       ;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
# 1088 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {






                                                       ;

      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1125 "/usr/include/c++/4.4/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {



                                                       ;

      while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }

}
# 41 "/usr/include/c++/4.4/bits/char_traits.h" 2 3

# 1 "/usr/include/c++/4.4/cwchar" 1 3
# 41 "/usr/include/c++/4.4/cwchar" 3
# 41 "/usr/include/c++/4.4/cwchar" 3


# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 44 "/usr/include/c++/4.4/cwchar" 2 3


# 1 "/usr/include/wchar.h" 1 3 4
# 47 "/usr/include/c++/4.4/cwchar" 2 3
# 43 "/usr/include/c++/4.4/bits/char_traits.h" 2 3








namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 63 "/usr/include/c++/4.4/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 88 "/usr/include/c++/4.4/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }

}

namespace std __attribute__ ((__visibility__ ("default"))) {
# 229 "/usr/include/c++/4.4/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return __builtin_memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }



      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static char_type
      to_char_type(const int_type& __c)
      { return char_type(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return int_type(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((0xffffffffu)); }

      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };


}
# 41 "/usr/include/c++/4.4/ios" 2 3
# 1 "/usr/include/c++/4.4/bits/localefwd.h" 1 3
# 39 "/usr/include/c++/4.4/bits/localefwd.h" 3
# 39 "/usr/include/c++/4.4/bits/localefwd.h" 3


# 1 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/c++locale.h" 1 3
# 40 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/c++locale.h" 3
# 40 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/c++locale.h" 3

# 1 "/usr/include/c++/4.4/clocale" 1 3
# 41 "/usr/include/c++/4.4/clocale" 3
# 41 "/usr/include/c++/4.4/clocale" 3


# 1 "/usr/include/locale.h" 1 3 4
# 29 "/usr/include/locale.h" 3 4
# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/bits/locale.h" 1 3 4
# 27 "/usr/include/bits/locale.h" 3 4
enum
{
  __LC_CTYPE = 0,
  __LC_NUMERIC = 1,
  __LC_TIME = 2,
  __LC_COLLATE = 3,
  __LC_MONETARY = 4,
  __LC_MESSAGES = 5,
  __LC_ALL = 6,
  __LC_PAPER = 7,
  __LC_NAME = 8,
  __LC_ADDRESS = 9,
  __LC_TELEPHONE = 10,
  __LC_MEASUREMENT = 11,
  __LC_IDENTIFICATION = 12
};
# 31 "/usr/include/locale.h" 2 3 4

extern "C" {
# 54 "/usr/include/locale.h" 3 4
struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 121 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, __const char *__locale) throw ();


extern struct lconv *localeconv (void) throw ();
# 152 "/usr/include/locale.h" 3 4
extern __locale_t newlocale (int __category_mask, __const char *__locale,
        __locale_t __base) throw ();
# 187 "/usr/include/locale.h" 3 4
extern __locale_t duplocale (__locale_t __dataset) throw ();



extern void freelocale (__locale_t __dataset) throw ();






extern __locale_t uselocale (__locale_t __dataset) throw ();







}
# 44 "/usr/include/c++/4.4/clocale" 2 3








namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::lconv;
  using ::setlocale;
  using ::localeconv;

}
# 42 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/c++locale.h" 2 3
# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 43 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/c++locale.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {

  extern "C" __typeof(uselocale) __uselocale;

}


namespace std __attribute__ ((__visibility__ ("default"))) {

  typedef __locale_t __c_locale;





  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 84 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/c++locale.h" 3
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }

}
# 42 "/usr/include/c++/4.4/bits/localefwd.h" 2 3

# 1 "/usr/include/c++/4.4/cctype" 1 3
# 41 "/usr/include/c++/4.4/cctype" 3
# 41 "/usr/include/c++/4.4/cctype" 3


# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/bits/types.h" 1 3 4
# 28 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 131 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 132 "/usr/include/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef long int __swblk_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;

typedef long int __ssize_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
# 29 "/usr/include/ctype.h" 2 3 4

extern "C" {
# 41 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
# 38 "/usr/include/endian.h" 2 3 4
# 61 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 28 "/usr/include/bits/byteswap.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/byteswap.h" 2 3 4
# 62 "/usr/include/endian.h" 2 3 4
# 42 "/usr/include/ctype.h" 2 3 4






enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 81 "/usr/include/ctype.h" 3 4
extern __const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const));
extern __const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const));
extern __const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const));
# 102 "/usr/include/ctype.h" 3 4
extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();
# 128 "/usr/include/ctype.h" 3 4
extern int isblank (int) throw ();






extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
# 247 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) throw ();
extern int isalpha_l (int, __locale_t) throw ();
extern int iscntrl_l (int, __locale_t) throw ();
extern int isdigit_l (int, __locale_t) throw ();
extern int islower_l (int, __locale_t) throw ();
extern int isgraph_l (int, __locale_t) throw ();
extern int isprint_l (int, __locale_t) throw ();
extern int ispunct_l (int, __locale_t) throw ();
extern int isspace_l (int, __locale_t) throw ();
extern int isupper_l (int, __locale_t) throw ();
extern int isxdigit_l (int, __locale_t) throw ();

extern int isblank_l (int, __locale_t) throw ();



extern int __tolower_l (int __c, __locale_t __l) throw ();
extern int tolower_l (int __c, __locale_t __l) throw ();


extern int __toupper_l (int __c, __locale_t __l) throw ();
extern int toupper_l (int __c, __locale_t __l) throw ();
# 323 "/usr/include/ctype.h" 3 4
}
# 44 "/usr/include/c++/4.4/cctype" 2 3
# 63 "/usr/include/c++/4.4/cctype" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;

}
# 44 "/usr/include/c++/4.4/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {


  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;


  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;


  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;

  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;

  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;


  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;

}
# 42 "/usr/include/c++/4.4/ios" 2 3
# 1 "/usr/include/c++/4.4/bits/ios_base.h" 1 3
# 39 "/usr/include/c++/4.4/bits/ios_base.h" 3
# 39 "/usr/include/c++/4.4/bits/ios_base.h" 3

# 1 "/usr/include/c++/4.4/ext/atomicity.h" 1 3
# 34 "/usr/include/c++/4.4/ext/atomicity.h" 3
# 1 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/gthr.h" 1 3
# 30 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 162 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/gthr.h" 3
# 1 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/gthr-default.h" 1 3
# 41 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/gthr-default.h" 3
# 1 "/usr/include/pthread.h" 1 3 4
# 25 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 29 "/usr/include/sched.h" 3 4
# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 30 "/usr/include/sched.h" 2 3 4


# 1 "/usr/include/time.h" 1 3 4
# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    long int tv_nsec;
  };
# 33 "/usr/include/sched.h" 2 3 4


# 1 "/usr/include/bits/sched.h" 1 3 4
# 71 "/usr/include/bits/sched.h" 3 4
struct sched_param
  {
    int __sched_priority;
  };

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


}







struct __sched_param
  {
    int __sched_priority;
  };
# 113 "/usr/include/bits/sched.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 196 "/usr/include/bits/sched.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}
# 36 "/usr/include/sched.h" 2 3 4




extern "C" {


extern int sched_setparam (__pid_t __pid, __const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          __const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
# 110 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         __const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
# 26 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
# 30 "/usr/include/time.h" 3 4
extern "C" {








# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 39 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/time.h" 1 3 4
# 43 "/usr/include/time.h" 2 3 4
# 60 "/usr/include/time.h" 3 4
typedef __clock_t clock_t;
# 76 "/usr/include/time.h" 3 4
typedef __time_t time_t;
# 92 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 104 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 133 "/usr/include/time.h" 3 4
struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  __const char *tm_zone;




};
# 161 "/usr/include/time.h" 3 4
struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;





typedef __pid_t pid_t;
# 183 "/usr/include/time.h" 3 4
extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   __const char *__restrict __format,
   __const struct tm *__restrict __tp) throw ();





extern char *strptime (__const char *__restrict __s,
         __const char *__restrict __fmt, struct tm *__tp)
     throw ();







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     __const char *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) throw ();



extern char *strptime_l (__const char *__restrict __s,
    __const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) throw ();






extern struct tm *gmtime (__const time_t *__timer) throw ();



extern struct tm *localtime (__const time_t *__timer) throw ();





extern struct tm *gmtime_r (__const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (__const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();





extern char *asctime (__const struct tm *__tp) throw ();


extern char *ctime (__const time_t *__timer) throw ();







extern char *asctime_r (__const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (__const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (__const time_t *__when) throw ();
# 313 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 328 "/usr/include/time.h" 3 4
extern int nanosleep (__const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       __const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     __const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();
# 390 "/usr/include/time.h" 3 4
extern int getdate_err;
# 399 "/usr/include/time.h" 3 4
extern struct tm *getdate (__const char *__string);
# 413 "/usr/include/time.h" 3 4
extern int getdate_r (__const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 27 "/usr/include/pthread.h" 2 3 4


# 1 "/usr/include/signal.h" 1 3 4
# 31 "/usr/include/signal.h" 3 4
extern "C" {


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 24 "/usr/include/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 34 "/usr/include/signal.h" 2 3 4
# 50 "/usr/include/signal.h" 3 4
typedef __sigset_t sigset_t;
# 408 "/usr/include/signal.h" 3 4
}
# 30 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 24 "/usr/include/bits/pthreadtypes.h" 2 3 4
# 50 "/usr/include/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


typedef union
{
  char __size[56];
  long int __align;
} pthread_attr_t;



typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 76 "/usr/include/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    int __spins;
    __pthread_list_t __list;
# 101 "/usr/include/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    unsigned long int __pad1;
    unsigned long int __pad2;


    unsigned int __flags;
  } __data;
# 187 "/usr/include/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 31 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/setjmp.h" 1 3 4
# 27 "/usr/include/bits/setjmp.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 32 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 33 "/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 117 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 149 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 184 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 222 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      __const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     __const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2) throw ();







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (__const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (__const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (__const pthread_attr_t *__restrict
           __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           __const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (__const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (__const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (__const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (__const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (__const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (__const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     __const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (__const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));





extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      __const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       __const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
# 468 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 480 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 514 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};




class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
# 716 "/usr/include/pthread.h" 3 4
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          __const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
                                    __const struct timespec *__restrict
                                    __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));




extern int pthread_mutex_getprioceiling (__const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));





extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
# 782 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (__const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (__const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprotocol (__const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (__const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));




extern int pthread_mutexattr_getrobust (__const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (__const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
# 864 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    __const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           __const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           __const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (__const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (__const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         __const pthread_condattr_t *__restrict
         __cond_attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 976 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       __const struct timespec *__restrict
       __abstime) __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (__const pthread_condattr_t *
                                        __restrict __attr,
                                        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
                                        int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (__const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
# 1020 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     __const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (__const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
                                           int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
# 1087 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    __const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
# 1121 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();
# 1135 "/usr/include/pthread.h" 3 4
}
# 42 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/gthr-default.h" 2 3
# 1 "/usr/include/unistd.h" 1 3 4
# 28 "/usr/include/unistd.h" 3 4
extern "C" {
# 203 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/bits/posix_opt.h" 1 3 4
# 204 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/bits/environments.h" 1 3 4
# 23 "/usr/include/bits/environments.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 24 "/usr/include/bits/environments.h" 2 3 4
# 208 "/usr/include/unistd.h" 2 3 4
# 221 "/usr/include/unistd.h" 3 4
typedef __ssize_t ssize_t;






# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 228 "/usr/include/unistd.h" 2 3 4





typedef __gid_t gid_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __useconds_t useconds_t;
# 268 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 288 "/usr/include/unistd.h" 3 4
extern int access (__const char *__name, int __type) throw () __attribute__ ((__nonnull__ (1)));




extern int euidaccess (__const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));


extern int eaccess (__const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, __const char *__file, int __type, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;
# 331 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) throw ();
# 342 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     throw ();






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, __const void *__buf, size_t __n) ;
# 373 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, __const void *__buf, size_t __n,
         __off_t __offset) ;
# 401 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, __const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) throw () ;




extern int pipe2 (int __pipedes[2], int __flags) throw () ;
# 429 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) throw ();
# 441 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);






extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     throw ();






extern int usleep (__useconds_t __useconds);
# 465 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (__const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) throw () ;




extern int lchown (__const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, __const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int chdir (__const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) throw () ;
# 507 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) throw () ;





extern char *get_current_dir_name (void) throw ();






extern char *getwd (char *__buf)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) throw () ;


extern int dup2 (int __fd, int __fd2) throw ();




extern int dup3 (int __fd, int __fd2, int __flags) throw ();



extern char **__environ;

extern char **environ;





extern int execve (__const char *__path, char *__const __argv[],
     char *__const __envp[]) throw () __attribute__ ((__nonnull__ (1)));




extern int fexecve (int __fd, char *__const __argv[], char *__const __envp[])
     throw ();




extern int execv (__const char *__path, char *__const __argv[])
     throw () __attribute__ ((__nonnull__ (1)));



extern int execle (__const char *__path, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1)));



extern int execl (__const char *__path, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1)));



extern int execvp (__const char *__file, char *__const __argv[])
     throw () __attribute__ ((__nonnull__ (1)));




extern int execlp (__const char *__file, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1)));




extern int execvpe (__const char *__file, char *__const __argv[],
      char *__const __envp[])
     throw () __attribute__ ((__nonnull__ (1)));





extern int nice (int __inc) throw () ;




extern void _exit (int __status) __attribute__ ((__noreturn__));






# 1 "/usr/include/bits/confname.h" 1 3 4
# 26 "/usr/include/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS

  };
# 605 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (__const char *__path, int __name)
     throw () __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) throw ();


extern long int sysconf (int __name) throw ();



extern size_t confstr (int __name, char *__buf, size_t __len) throw ();




extern __pid_t getpid (void) throw ();


extern __pid_t getppid (void) throw ();




extern __pid_t getpgrp (void) throw ();
# 641 "/usr/include/unistd.h" 3 4
extern __pid_t __getpgid (__pid_t __pid) throw ();

extern __pid_t getpgid (__pid_t __pid) throw ();






extern int setpgid (__pid_t __pid, __pid_t __pgid) throw ();
# 667 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) throw ();
# 684 "/usr/include/unistd.h" 3 4
extern __pid_t setsid (void) throw ();



extern __pid_t getsid (__pid_t __pid) throw ();



extern __uid_t getuid (void) throw ();


extern __uid_t geteuid (void) throw ();


extern __gid_t getgid (void) throw ();


extern __gid_t getegid (void) throw ();




extern int getgroups (int __size, __gid_t __list[]) throw () ;



extern int group_member (__gid_t __gid) throw ();






extern int setuid (__uid_t __uid) throw ();




extern int setreuid (__uid_t __ruid, __uid_t __euid) throw ();




extern int seteuid (__uid_t __uid) throw ();






extern int setgid (__gid_t __gid) throw ();




extern int setregid (__gid_t __rgid, __gid_t __egid) throw ();




extern int setegid (__gid_t __gid) throw ();





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     throw ();



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     throw ();



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     throw ();



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     throw ();






extern __pid_t fork (void) throw ();






extern __pid_t vfork (void) throw ();





extern char *ttyname (int __fd) throw ();



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) throw ();





extern int ttyslot (void) throw ();




extern int link (__const char *__from, __const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, __const char *__from, int __tofd,
     __const char *__to, int __flags)
     throw () __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (__const char *__from, __const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (__const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (__const char *__from, int __tofd,
        __const char *__to) throw () __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, __const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, __const char *__name, int __flag)
     throw () __attribute__ ((__nonnull__ (2)));



extern int rmdir (__const char *__path) throw () __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) throw ();


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) throw ();






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));
# 887 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/getopt.h" 1 3 4
# 50 "/usr/include/getopt.h" 3 4
extern "C" {
# 59 "/usr/include/getopt.h" 3 4
extern char *optarg;
# 73 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 152 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       throw ();
# 187 "/usr/include/getopt.h" 3 4
}
# 888 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) throw () __attribute__ ((__nonnull__ (1)));






extern int sethostname (__const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) throw () ;





extern int getdomainname (char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (__const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) throw ();


extern int revoke (__const char *__file) throw () __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     throw () __attribute__ ((__nonnull__ (1)));





extern int acct (__const char *__name) throw ();



extern char *getusershell (void) throw ();
extern void endusershell (void) throw ();
extern void setusershell (void) throw ();





extern int daemon (int __nochdir, int __noclose) throw () ;






extern int chroot (__const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (__const char *__prompt) __attribute__ ((__nonnull__ (1)));
# 973 "/usr/include/unistd.h" 3 4
extern int fsync (int __fd);






extern long int gethostid (void);


extern void sync (void) throw ();




extern int getpagesize (void) throw () __attribute__ ((__const__));




extern int getdtablesize (void) throw ();




extern int truncate (__const char *__file, __off_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 1010 "/usr/include/unistd.h" 3 4
extern int truncate64 (__const char *__file, __off64_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 1020 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) throw () ;
# 1030 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) throw () ;
# 1040 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) throw () ;





extern void *sbrk (intptr_t __delta) throw ();
# 1061 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) throw ();
# 1084 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1094 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1115 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes);







extern char *crypt (__const char *__key, __const char *__salt)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__libc_block, int __edflag) throw () __attribute__ ((__nonnull__ (1)));






extern void swab (__const void *__restrict __from, void *__restrict __to,
    ssize_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));







extern char *ctermid (char *__s) throw ();
# 1153 "/usr/include/unistd.h" 3 4
}
# 43 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/gthr-default.h" 2 3

typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 118 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/gthr-default.h" 3
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once")));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific")));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific")));

static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create")));
static __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join")));
static __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal")));
static __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self")));
static __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach")));
static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel")));
static __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield")));

static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock")));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock")));


static __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock")));


static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock")));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init")));
static __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy")));

static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast")));
static __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal")));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait")));
static __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait")));
static __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy")));


static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create")));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete")));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init")));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype")));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy")));
# 237 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &__gthrw_pthread_cancel;
  return __gthread_active_ptr != 0;
}
# 675 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return __gthrw_pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_pthread_setspecific (__key, __ptr);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (__mutex);
  else
    return 0;
}



static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}



static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (__mutex);
  else
    return 0;
}
# 818 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}



static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}



static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait_recursive (__gthread_cond_t *__cond,
        __gthread_recursive_mutex_t *__mutex,
        const __gthread_time_t *__abs_timeout)
{
  return __gthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_pthread_cond_destroy (__cond);
}
# 163 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/gthr.h" 2 3







#pragma GCC visibility pop
# 35 "/usr/include/c++/4.4/ext/atomicity.h" 2 3
# 1 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/atomic_word.h" 1 3
# 32 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 36 "/usr/include/c++/4.4/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {






  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __sync_fetch_and_add(__mem, __val); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __sync_fetch_and_add(__mem, __val); }
# 61 "/usr/include/c++/4.4/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }

}
# 41 "/usr/include/c++/4.4/bits/ios_base.h" 2 3

# 1 "/usr/include/c++/4.4/bits/locale_classes.h" 1 3
# 39 "/usr/include/c++/4.4/bits/locale_classes.h" 3
# 39 "/usr/include/c++/4.4/bits/locale_classes.h" 3


# 1 "/usr/include/c++/4.4/string" 1 3
# 38 "/usr/include/c++/4.4/string" 3
# 38 "/usr/include/c++/4.4/string" 3




# 1 "/usr/include/c++/4.4/bits/allocator.h" 1 3
# 48 "/usr/include/c++/4.4/bits/allocator.h" 3
# 1 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/c++allocator.h" 1 3
# 34 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/c++allocator.h" 3
# 1 "/usr/include/c++/4.4/ext/new_allocator.h" 1 3
# 33 "/usr/include/c++/4.4/ext/new_allocator.h" 3
# 1 "/usr/include/c++/4.4/new" 1 3
# 39 "/usr/include/c++/4.4/new" 3
# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 40 "/usr/include/c++/4.4/new" 2 3


#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };

  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();
}
# 91 "/usr/include/c++/4.4/new" 3
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();


inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }


inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }

}

#pragma GCC visibility pop
# 34 "/usr/include/c++/4.4/ext/new_allocator.h" 2 3



namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {

  using std::size_t;
  using std::ptrdiff_t;
# 50 "/usr/include/c++/4.4/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

      new_allocator() throw() { }

      new_allocator(const new_allocator&) throw() { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }

      ~new_allocator() throw() { }

      pointer
      address(reference __x) const { return &__x; }

      const_pointer
      address(const_reference __x) const { return &__x; }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__builtin_expect(__n > this->max_size(), false))
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const throw()
      { return size_t(-1) / sizeof(_Tp); }



      void
      construct(pointer __p, const _Tp& __val)
      { ::new((void *)__p) _Tp(__val); }
# 114 "/usr/include/c++/4.4/ext/new_allocator.h" 3
      void
      destroy(pointer __p) { __p->~_Tp(); }
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }

}
# 35 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/c++allocator.h" 2 3
# 49 "/usr/include/c++/4.4/bits/allocator.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 59 "/usr/include/c++/4.4/bits/allocator.h" 3
  template<typename _Tp>
    class allocator;


  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
    };
# 85 "/usr/include/c++/4.4/bits/allocator.h" 3
  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };

      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __gnu_cxx::new_allocator<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    { return false; }





  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two)
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };

}
# 43 "/usr/include/c++/4.4/string" 2 3


# 1 "/usr/include/c++/4.4/bits/ostream_insert.h" 1 3
# 33 "/usr/include/c++/4.4/bits/ostream_insert.h" 3
# 33 "/usr/include/c++/4.4/bits/ostream_insert.h" 3


# 1 "/usr/include/c++/4.4/cxxabi-forced.h" 1 3
# 29 "/usr/include/c++/4.4/cxxabi-forced.h" 3
#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();
    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 36 "/usr/include/c++/4.4/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }





  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);



}
# 46 "/usr/include/c++/4.4/string" 2 3



# 1 "/usr/include/c++/4.4/bits/stl_function.h" 1 3
# 60 "/usr/include/c++/4.4/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 99 "/usr/include/c++/4.4/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {
      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {
      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;
      typedef _Result result_type;
    };
# 134 "/usr/include/c++/4.4/bits/stl_function.h" 3
  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
# 198 "/usr/include/c++/4.4/bits/stl_function.h" 3
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
# 262 "/usr/include/c++/4.4/bits/stl_function.h" 3
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };
# 345 "/usr/include/c++/4.4/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 416 "/usr/include/c++/4.4/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st : public unary_function<_Pair,
           typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }
    };

  template<typename _Pair>
    struct _Select2nd : public unary_function<_Pair,
           typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 523 "/usr/include/c++/4.4/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }



}



# 1 "/usr/include/c++/4.4/backward/binders.h" 1 3
# 60 "/usr/include/c++/4.4/backward/binders.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 96 "/usr/include/c++/4.4/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } ;


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } ;


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }


}
# 713 "/usr/include/c++/4.4/bits/stl_function.h" 2 3
# 50 "/usr/include/c++/4.4/string" 2 3


# 1 "/usr/include/c++/4.4/bits/basic_string.h" 1 3
# 39 "/usr/include/c++/4.4/bits/basic_string.h" 3
# 39 "/usr/include/c++/4.4/bits/basic_string.h" 3



# 1 "/usr/include/c++/4.4/initializer_list" 1 3
# 43 "/usr/include/c++/4.4/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 102 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _CharT_alloc_type::size_type size_type;
      typedef typename _CharT_alloc_type::difference_type difference_type;
      typedef typename _CharT_alloc_type::reference reference;
      typedef typename _CharT_alloc_type::const_reference const_reference;
      typedef typename _CharT_alloc_type::pointer pointer;
      typedef typename _CharT_alloc_type::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
# 139 "/usr/include/c++/4.4/bits/basic_string.h" 3
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };

      struct _Rep : _Rep_base
      {

 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
# 164 "/usr/include/c++/4.4/bits/basic_string.h" 3
 static const size_type _S_max_size;
 static const _CharT _S_terminal;



        static size_type _S_empty_rep_storage[];

        static _Rep&
        _S_empty_rep()
        {



   void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
   return *reinterpret_cast<_Rep*>(__p);
 }

        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }

        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }

        void
 _M_set_leaked()
        { this->_M_refcount = -1; }

        void
 _M_set_sharable()
        { this->_M_refcount = 0; }

 void
 _M_set_length_and_sharable(size_type __n)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {
       this->_M_set_sharable();
       this->_M_length = __n;
       traits_type::assign(this->_M_refdata()[__n], _S_terminal);


     }
 }

 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }

 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }


 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);

 void
 _M_dispose(const _Alloc& __a)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
             -1) <= 0)
       _M_destroy(__a);
 }

 void
 _M_destroy(const _Alloc&) throw();

 _CharT*
 _M_refcopy() throw()
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
   return _M_refdata();
 }

 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };


      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }

 _CharT* _M_p;
      };

    public:




      static const size_type npos = static_cast<size_type>(-1);

    private:

      mutable _Alloc_hider _M_dataplus;

      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }



      iterator
      _M_ibegin() const
      { return iterator(_M_data()); }

      iterator
      _M_iend() const
      { return iterator(_M_data() + this->size()); }

      void
      _M_leak()
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }


      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2)
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }

    public:







      inline
      basic_string();




      explicit
      basic_string(const _Alloc& __a);






      basic_string(const basic_string& __str);






      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
# 463 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());





      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());






      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());
# 494 "/usr/include/c++/4.4/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());




      ~basic_string()
      { _M_rep()->_M_dispose(this->get_allocator()); }





      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 527 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 552 "/usr/include/c++/4.4/bits/basic_string.h" 3
      iterator
      begin()
      {
 _M_leak();
 return iterator(_M_data());
      }





      const_iterator
      begin() const
      { return const_iterator(_M_data()); }





      iterator
      end()
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }





      const_iterator
      end() const
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->begin()); }

    public:



      size_type
      size() const
      { return _M_rep()->_M_length; }



      size_type
      length() const
      { return _M_rep()->_M_length; }


      size_type
      max_size() const
      { return _Rep::_S_max_size; }
# 651 "/usr/include/c++/4.4/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 664 "/usr/include/c++/4.4/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }





      size_type
      capacity() const
      { return _M_rep()->_M_capacity; }
# 693 "/usr/include/c++/4.4/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear()
      { _M_mutate(0, this->size(), 0); }




      bool
      empty() const
      { return this->size() == 0; }
# 721 "/usr/include/c++/4.4/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const
      {
                                       ;
 return _M_data()[__pos];
      }
# 738 "/usr/include/c++/4.4/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {

                                       ;

                                         ;
 _M_leak();
 return _M_data()[__pos];
      }
# 759 "/usr/include/c++/4.4/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }
# 778 "/usr/include/c++/4.4/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }







      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }
# 834 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str);
# 849 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);







      basic_string&
      append(const _CharT* __s, size_type __n);






      basic_string&
      append(const _CharT* __s)
      {
                               ;
 return this->append(__s, traits_type::length(__s));
      }
# 881 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c);
# 903 "/usr/include/c++/4.4/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __len = 1 + this->size();
 if (__len > this->capacity() || _M_rep()->_M_is_shared())
   this->reserve(__len);
 traits_type::assign(_M_data()[this->size()], __c);
 _M_rep()->_M_set_length_and_sharable(__len);
      }






      basic_string&
      assign(const basic_string& __str);
# 942 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
# 958 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n);
# 970 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
                               ;
 return this->assign(__s, traits_type::length(__s));
      }
# 986 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 998 "/usr/include/c++/4.4/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
# 1026 "/usr/include/c++/4.4/bits/basic_string.h" 3
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
# 1041 "/usr/include/c++/4.4/bits/basic_string.h" 3
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
# 1069 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
# 1091 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
# 1114 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
# 1132 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
                               ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
# 1155 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1172 "/usr/include/c++/4.4/bits/basic_string.h" 3
      iterator
      insert(iterator __p, _CharT __c)
      {
                                                                 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1196 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_mutate(_M_check(__pos, "basic_string::erase"),
    _M_limit(__pos, __n), size_type(0));
 return *this;
      }
# 1212 "/usr/include/c++/4.4/bits/basic_string.h" 3
      iterator
      erase(iterator __position)
      {

                               ;
 const size_type __pos = __position - _M_ibegin();
 _M_mutate(__pos, size_type(1), size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1232 "/usr/include/c++/4.4/bits/basic_string.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 1251 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1273 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1297 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
# 1316 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
                               ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1339 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1357 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 1375 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {

                          ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
# 1396 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
                               ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 1417 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {

                          ;
 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
# 1439 "/usr/include/c++/4.4/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {

                            ;
                                             ;
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }



      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                          ;
                                           ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 1514 "/usr/include/c++/4.4/bits/basic_string.h" 3
    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2);



      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }



      template<class _Integer>
        static _CharT*
        _S_construct_aux(_Integer __beg, _Integer __end,
    const _Alloc& __a, __true_type)
        { return _S_construct(static_cast<size_type>(__beg), __end, __a); }

      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }


      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);



      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:
# 1590 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 1600 "/usr/include/c++/4.4/bits/basic_string.h" 3
      void
      swap(basic_string& __s);
# 1610 "/usr/include/c++/4.4/bits/basic_string.h" 3
      const _CharT*
      c_str() const
      { return _M_data(); }







      const _CharT*
      data() const
      { return _M_data(); }




      allocator_type
      get_allocator() const
      { return _M_dataplus; }
# 1642 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
# 1655 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      { return this->find(__str.data(), __pos, __str.size()); }
# 1669 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
                               ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 1686 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const;
# 1699 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 1714 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
# 1727 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 1744 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const;
# 1757 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 1772 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1785 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
                               ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 1804 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const
      { return this->find(__c, __pos); }
# 1818 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 1833 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1846 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 1865 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const
      { return this->rfind(__c, __pos); }
# 1879 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 1894 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
# 1908 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
                               ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 1925 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const;
# 1938 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 1954 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
# 1967 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
                               ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 1984 "/usr/include/c++/4.4/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const;
# 1999 "/usr/include/c++/4.4/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2017 "/usr/include/c++/4.4/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 2047 "/usr/include/c++/4.4/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2071 "/usr/include/c++/4.4/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
# 2089 "/usr/include/c++/4.4/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
# 2112 "/usr/include/c++/4.4/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 2137 "/usr/include/c++/4.4/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>::
    basic_string()

    : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }
# 2158 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }
# 2229 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 2275 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 2312 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 2349 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 2386 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 2423 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 2460 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
# 2477 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 2495 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 2518 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 2535 "/usr/include/c++/4.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return getline(__is, __str, __is.widen('\n')); }

  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);


}
# 53 "/usr/include/c++/4.4/string" 2 3


# 1 "/usr/include/c++/4.4/bits/basic_string.tcc" 1 3
# 42 "/usr/include/c++/4.4/bits/basic_string.tcc" 3
# 42 "/usr/include/c++/4.4/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;



  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 _M_copy(__r->_M_refdata(), __buf, __len);
 try
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {

      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__len);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 if (__builtin_expect(__gnu_cxx::__is_null_pointer(__beg)
        && __beg != __end, 0))
   __throw_logic_error(("basic_string::_S_construct NULL not valid"));

 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));

 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 try
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__dnew);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {

      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();


      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 _M_assign(__r->_M_refdata(), __n, __c);

      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }
# 240 "/usr/include/c++/4.4/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {

   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
                                             ;
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
 return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
 {

   const size_type __pos = __s - _M_data();
   if (__pos >= __n)
     _M_copy(_M_data(), __s, __n);
   else if (__pos)
     _M_move(_M_data(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__n);
   return *this;
 }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_assign(_M_data() + this->size(), __n, __c);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
                                             ;
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     {
       if (_M_disjunct(__s))
  this->reserve(__len);
       else
  {
    const size_type __off = __s - _M_data();
    this->reserve(__len);
    __s = _M_data() + __off;
  }
     }
   _M_copy(_M_data() + this->size(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
 {
   const size_type __len = __size + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data(), __size);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
 {
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
                                              ;
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {

           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     typename basic_string<_CharT, _Traits, _Alloc>::iterator
     basic_string<_CharT, _Traits, _Alloc>::
     erase(iterator __first, iterator __last)
     {

                           ;




       const size_type __size = __last - __first;
       if (__size)
  {
    const size_type __pos = __first - _M_ibegin();
    _M_mutate(__pos, __size, size_type(0));
    _M_rep()->_M_set_leaked();
    return iterator(_M_data() + __pos);
  }
       else
  return __first;
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
                                               ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {

    size_type __off = __s - _M_data();
    __left ? __off : (__off += __n2 - __n1);
    _M_mutate(__pos, __n1, __n2);
    _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
    return *this;
  }
       else
  {

    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {

      if (_M_rep() == &_S_empty_rep())
 return;

      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
 {

   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);

   if (__pos)
     _M_copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     _M_copy(__r->_M_refdata() + __pos + __len2,
      _M_data() + __pos + __len1, __how_much);

   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {

   _M_move(_M_data() + __pos + __len2,
    _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {

   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }

      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {


      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
# 577 "/usr/include/c++/4.4/bits/basic_string.tcc" 3
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);







      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 __capacity = 2 * __old_capacity;




      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);

      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);

   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }



      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;







      __p->_M_set_sharable();
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {

      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);

      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
      size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
                                      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
                                             ;
      if (__n)
 _M_copy(__s, _M_data() + __pos, __n);

      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
                                             ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
                                    ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
                                    ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
                                              ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }





  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);



}
# 56 "/usr/include/c++/4.4/string" 2 3
# 42 "/usr/include/c++/4.4/bits/locale_classes.h" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {
# 60 "/usr/include/c++/4.4/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 96 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 115 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    locale() throw();
# 124 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 134 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 149 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 162 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 174 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 188 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 203 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    string
    name() const;
# 222 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw ();







    bool
    operator!=(const locale& __other) const throw ()
    { return !(this->operator==(__other)); }
# 250 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 266 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    static locale
    global(const locale&);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 301 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 6 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };
# 334 "/usr/include/c++/4.4/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 365 "/usr/include/c++/4.4/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc);

    static void
    _S_destroy_c_locale(__c_locale& __cloc);



    static __c_locale
    _S_get_c_locale();

    static const char*
    _S_get_c_name();

  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    facet(const facet&);

    facet&
    operator=(const facet&);
  };
# 425 "/usr/include/c++/4.4/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw ();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const;
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    void
    _M_install_cache(const facet*, size_t);
  };
# 568 "/usr/include/c++/4.4/bits/locale_classes.h" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw();
# 585 "/usr/include/c++/4.4/bits/locale_classes.h" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc);
# 602 "/usr/include/c++/4.4/bits/locale_classes.h" 3
  template<typename _CharT>
    class collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 629 "/usr/include/c++/4.4/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 643 "/usr/include/c++/4.4/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 660 "/usr/include/c++/4.4/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 679 "/usr/include/c++/4.4/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 693 "/usr/include/c++/4.4/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const;

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const;

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 722 "/usr/include/c++/4.4/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 738 "/usr/include/c++/4.4/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 751 "/usr/include/c++/4.4/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const;

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const;


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const;

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const;



  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }

    protected:
      virtual
      ~collate_byname() { }
    };

}



# 1 "/usr/include/c++/4.4/bits/locale_classes.tcc" 1 3
# 37 "/usr/include/c++/4.4/bits/locale_classes.tcc" 3
# 37 "/usr/include/c++/4.4/bits/locale_classes.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }


  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }

  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }





  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);



}
# 809 "/usr/include/c++/4.4/bits/locale_classes.h" 2 3
# 43 "/usr/include/c++/4.4/bits/ios_base.h" 2 3
# 53 "/usr/include/c++/4.4/bits/ios_base.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {





  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16
    };

  inline _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }

  inline _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16
    };

  inline _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }

  inline _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16
    };

  inline _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }

  inline _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };
# 206 "/usr/include/c++/4.4/bits/ios_base.h" 3
  class ios_base
  {
  public:







    class failure : public exception
    {
    public:


      explicit
      failure(const string& __str) throw();



      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();

    private:
      string _M_msg;
    };
# 262 "/usr/include/c++/4.4/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 337 "/usr/include/c++/4.4/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 368 "/usr/include/c++/4.4/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 400 "/usr/include/c++/4.4/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;


    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
# 426 "/usr/include/c++/4.4/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 443 "/usr/include/c++/4.4/bits/ios_base.h" 3
    typedef void (*event_callback) (event, ios_base&, int);
# 455 "/usr/include/c++/4.4/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:




    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;




    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      { return __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1); }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void);


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
# 564 "/usr/include/c++/4.4/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 580 "/usr/include/c++/4.4/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 597 "/usr/include/c++/4.4/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
# 623 "/usr/include/c++/4.4/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 674 "/usr/include/c++/4.4/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 686 "/usr/include/c++/4.4/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc);
# 697 "/usr/include/c++/4.4/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
# 708 "/usr/include/c++/4.4/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
# 727 "/usr/include/c++/4.4/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 743 "/usr/include/c++/4.4/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 764 "/usr/include/c++/4.4/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 781 "/usr/include/c++/4.4/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base();



  private:
    ios_base(const ios_base&);

    ios_base&
    operator=(const ios_base&);
  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }

}
# 43 "/usr/include/c++/4.4/ios" 2 3
# 1 "/usr/include/c++/4.4/streambuf" 1 3
# 37 "/usr/include/c++/4.4/streambuf" 3
# 37 "/usr/include/c++/4.4/streambuf" 3








namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 112 "/usr/include/c++/4.4/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(__streambuf_type*, __streambuf_type*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:
# 178 "/usr/include/c++/4.4/streambuf" 3
      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 202 "/usr/include/c++/4.4/streambuf" 3
      locale
      pubimbue(const locale &__loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 219 "/usr/include/c++/4.4/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 232 "/usr/include/c++/4.4/streambuf" 3
      __streambuf_type*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }

      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }

      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }

      int
      pubsync() { return this->sync(); }
# 259 "/usr/include/c++/4.4/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 273 "/usr/include/c++/4.4/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 291 "/usr/include/c++/4.4/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 313 "/usr/include/c++/4.4/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 332 "/usr/include/c++/4.4/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 346 "/usr/include/c++/4.4/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 371 "/usr/include/c++/4.4/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 398 "/usr/include/c++/4.4/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 424 "/usr/include/c++/4.4/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 438 "/usr/include/c++/4.4/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 456 "/usr/include/c++/4.4/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 472 "/usr/include/c++/4.4/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 483 "/usr/include/c++/4.4/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 503 "/usr/include/c++/4.4/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 519 "/usr/include/c++/4.4/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 529 "/usr/include/c++/4.4/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 550 "/usr/include/c++/4.4/streambuf" 3
      virtual void
      imbue(const locale&)
      { }
# 565 "/usr/include/c++/4.4/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 576 "/usr/include/c++/4.4/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 588 "/usr/include/c++/4.4/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 601 "/usr/include/c++/4.4/streambuf" 3
      virtual int
      sync() { return 0; }
# 623 "/usr/include/c++/4.4/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 639 "/usr/include/c++/4.4/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 661 "/usr/include/c++/4.4/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 674 "/usr/include/c++/4.4/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 698 "/usr/include/c++/4.4/streambuf" 3
      virtual int_type
      pbackfail(int_type = traits_type::eof())
      { return traits_type::eof(); }
# 716 "/usr/include/c++/4.4/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 741 "/usr/include/c++/4.4/streambuf" 3
      virtual int_type
      overflow(int_type = traits_type::eof())
      { return traits_type::eof(); }



    public:
# 756 "/usr/include/c++/4.4/streambuf" 3
      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }


    private:


      basic_streambuf(const __streambuf_type& __sb)
      : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur),
      _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg),
      _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur),
      _M_buf_locale(__sb._M_buf_locale)
      { }

      __streambuf_type&
      operator=(const __streambuf_type&) { return *this; };
    };


  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);


}



# 1 "/usr/include/c++/4.4/bits/streambuf.tcc" 1 3
# 38 "/usr/include/c++/4.4/bits/streambuf.tcc" 3
# 38 "/usr/include/c++/4.4/bits/streambuf.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }





  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);



}
# 796 "/usr/include/c++/4.4/streambuf" 2 3
# 44 "/usr/include/c++/4.4/ios" 2 3
# 1 "/usr/include/c++/4.4/bits/basic_ios.h" 1 3
# 35 "/usr/include/c++/4.4/bits/basic_ios.h" 3
# 35 "/usr/include/c++/4.4/bits/basic_ios.h" 3



# 1 "/usr/include/c++/4.4/bits/locale_facets.h" 1 3
# 39 "/usr/include/c++/4.4/bits/locale_facets.h" 3
# 39 "/usr/include/c++/4.4/bits/locale_facets.h" 3

# 1 "/usr/include/c++/4.4/cwctype" 1 3
# 41 "/usr/include/c++/4.4/cwctype" 3
# 41 "/usr/include/c++/4.4/cwctype" 3




# 1 "/usr/include/wctype.h" 1 3 4
# 34 "/usr/include/wctype.h" 3 4
# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 35 "/usr/include/wctype.h" 2 3 4
# 53 "/usr/include/wctype.h" 3 4
typedef unsigned long int wctype_t;
# 72 "/usr/include/wctype.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};



extern "C" {
# 112 "/usr/include/wctype.h" 3 4
extern int iswalnum (wint_t __wc) throw ();





extern int iswalpha (wint_t __wc) throw ();


extern int iswcntrl (wint_t __wc) throw ();



extern int iswdigit (wint_t __wc) throw ();



extern int iswgraph (wint_t __wc) throw ();




extern int iswlower (wint_t __wc) throw ();


extern int iswprint (wint_t __wc) throw ();




extern int iswpunct (wint_t __wc) throw ();




extern int iswspace (wint_t __wc) throw ();




extern int iswupper (wint_t __wc) throw ();




extern int iswxdigit (wint_t __wc) throw ();





extern int iswblank (wint_t __wc) throw ();
# 172 "/usr/include/wctype.h" 3 4
extern wctype_t wctype (__const char *__property) throw ();



extern int iswctype (wint_t __wc, wctype_t __desc) throw ();
# 187 "/usr/include/wctype.h" 3 4
typedef __const __int32_t *wctrans_t;







extern wint_t towlower (wint_t __wc) throw ();


extern wint_t towupper (wint_t __wc) throw ();


}
# 214 "/usr/include/wctype.h" 3 4
extern "C" {




extern wctrans_t wctrans (__const char *__property) throw ();


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) throw ();
# 231 "/usr/include/wctype.h" 3 4
extern int iswalnum_l (wint_t __wc, __locale_t __locale) throw ();





extern int iswalpha_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswcntrl_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswdigit_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswgraph_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswlower_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswprint_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswpunct_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswspace_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswupper_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswxdigit_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswblank_l (wint_t __wc, __locale_t __locale) throw ();



extern wctype_t wctype_l (__const char *__property, __locale_t __locale)
     throw ();



extern int iswctype_l (wint_t __wc, wctype_t __desc, __locale_t __locale)
     throw ();







extern wint_t towlower_l (wint_t __wc, __locale_t __locale) throw ();


extern wint_t towupper_l (wint_t __wc, __locale_t __locale) throw ();



extern wctrans_t wctrans_l (__const char *__property, __locale_t __locale)
     throw ();


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      __locale_t __locale) throw ();



}
# 46 "/usr/include/c++/4.4/cwctype" 2 3
# 75 "/usr/include/c++/4.4/cwctype" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;

}
# 41 "/usr/include/c++/4.4/bits/locale_facets.h" 2 3
# 1 "/usr/include/c++/4.4/cctype" 1 3
# 41 "/usr/include/c++/4.4/cctype" 3
# 41 "/usr/include/c++/4.4/cctype" 3
# 42 "/usr/include/c++/4.4/bits/locale_facets.h" 2 3
# 1 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/ctype_base.h" 1 3
# 37 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/ctype_base.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {


  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalpha | _ISdigit;
  };

}
# 43 "/usr/include/c++/4.4/bits/locale_facets.h" 2 3






# 1 "/usr/include/c++/4.4/bits/streambuf_iterator.h" 1 3
# 35 "/usr/include/c++/4.4/bits/streambuf_iterator.h" 3
# 35 "/usr/include/c++/4.4/bits/streambuf_iterator.h" 3




namespace std __attribute__ ((__visibility__ ("default"))) {



  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*, _CharT&>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

    private:







      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;

    public:

      istreambuf_iterator() throw()
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(istream_type& __s) throw()
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) throw()
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }


      istreambuf_iterator&
      operator++()
      {


                        ;
 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {


                        ;

 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }

      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) throw ()
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) throw ()
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const throw()
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }

}
# 50 "/usr/include/c++/4.4/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 63 "/usr/include/c++/4.4/bits/locale_facets.h" 3
  template<typename _Tv>
    void
    __convert_to_v(const char* __in, _Tv& __out, ios_base::iostate& __err,
     const __c_locale& __cloc);


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&);

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&);

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&);



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 142 "/usr/include/c++/4.4/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 160 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 177 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 193 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 209 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 223 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 238 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 252 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 267 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 284 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 303 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 322 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 344 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char *__to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 369 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 388 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 407 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 426 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 444 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const = 0;
# 461 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 477 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const = 0;
# 494 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 513 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const = 0;
# 534 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi,
        char_type* __dest) const = 0;
# 556 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const = 0;
# 580 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const = 0;
    };
# 603 "/usr/include/c++/4.4/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 672 "/usr/include/c++/4.4/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 709 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 722 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 735 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 750 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 764 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 778 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 793 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 810 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 826 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 843 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 863 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 890 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 921 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 954 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char *__to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
# 1003 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
# 1020 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1036 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
# 1053 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1073 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1096 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const
      {
 __builtin_memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }
# 1122 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char) const
      { return __c; }
# 1148 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char, char* __dest) const
      {
 __builtin_memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
# 1173 "/usr/include/c++/4.4/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1206 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1217 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const;


      virtual
      ~ctype();
# 1241 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1260 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1278 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1296 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1313 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type) const;
# 1330 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1346 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type) const;
# 1363 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1383 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char) const;
# 1405 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;
# 1428 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type, char __dfault) const;
# 1454 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;


      void
      _M_initialize_ctype();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };


}



# 1 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/ctype_inline.h" 1 3
# 37 "/usr/include/c++/4.4/x86_64-linux-gnu/bits/ctype_inline.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }

}
# 1510 "/usr/include/c++/4.4/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {


  class __num_base
  {
  public:


    enum
      {
        _S_ominus,
        _S_oplus,
        _S_ox,
        _S_oX,
        _S_odigits,
        _S_odigits_end = _S_odigits + 16,
        _S_oudigits = _S_odigits_end,
        _S_oudigits_end = _S_oudigits + 16,
        _S_oe = _S_odigits + 14,
        _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod);
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(__null), _M_grouping_size(0), _M_use_grouping(false),
      _M_truename(__null), _M_truename_size(0), _M_falsename(__null),
      _M_falsename_size(0), _M_decimal_point(_CharT()),
      _M_thousands_sep(_CharT()), _M_allocated(false)
      { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }
# 1634 "/usr/include/c++/4.4/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0) : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(); }
# 1671 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1685 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(__cloc); }
# 1699 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1712 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1743 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1756 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1769 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1786 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1798 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1811 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1824 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1837 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = __null);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~numpunct_byname() { }
    };
# 1906 "/usr/include/c++/4.4/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1927 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1953 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 1989 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2048 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2090 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
        iter_type
        _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
        _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
        _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2161 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      void*&) const;
# 2226 "/usr/include/c++/4.4/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2243 "/usr/include/c++/4.4/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2264 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2282 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2324 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __f, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2387 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, double __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __f, __fill, __v); }
# 2412 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __f, __fill, __v); }

    protected:
      template<typename _ValueT>
        iter_type
        _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
        iter_type
        _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { };
# 2460 "/usr/include/c++/4.4/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, double __v) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long double __v) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, const void* __v) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;
# 2518 "/usr/include/c++/4.4/bits/locale_facets.h" 3
  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }


  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }

}



# 1 "/usr/include/c++/4.4/bits/locale_facets.tcc" 1 3
# 35 "/usr/include/c++/4.4/bits/locale_facets.tcc" 3
# 35 "/usr/include/c++/4.4/bits/locale_facets.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {



  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = __null;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      _M_grouping_size = __np.grouping().size();
      char* __grouping = new char[_M_grouping_size];
      __np.grouping().copy(__grouping, _M_grouping_size);
      _M_grouping = __grouping;
      _M_use_grouping = (_M_grouping_size
    && static_cast<signed char>(_M_grouping[0]) > 0
    && (_M_grouping[0]
        != __gnu_cxx::__numeric_traits<char>::__max));

      _M_truename_size = __np.truename().size();
      _CharT* __truename = new _CharT[_M_truename_size];
      __np.truename().copy(__truename, _M_truename_size);
      _M_truename = __truename;

      _M_falsename_size = __np.falsename().size();
      _CharT* __falsename = new _CharT[_M_falsename_size];
      __np.falsename().copy(__falsename, _M_falsename_size);
      _M_falsename = __falsename;

      _M_decimal_point = __np.decimal_point();
      _M_thousands_sep = __np.thousands_sep();

      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
      __ct.widen(__num_base::_S_atoms_out,
   __num_base::_S_atoms_out + __num_base::_S_oend, _M_atoms_out);
      __ct.widen(__num_base::_S_atoms_in,
   __num_base::_S_atoms_in + __num_base::_S_iend, _M_atoms_in);
    }
# 120 "/usr/include/c++/4.4/bits/locale_facets.tcc" 3
  bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp);



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
   ? -__gnu_cxx::__numeric_traits<_ValueT>::__min
   : __gnu_cxx::__numeric_traits<_ValueT>::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative
  && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
     else
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
# 714 "/usr/include/c++/4.4/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 950 "/usr/include/c++/4.4/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);




 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
          __fbuf, __prec, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
       __fbuf, __prec, __v);
   }
# 1011 "/usr/include/c++/4.4/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1136 "/usr/include/c++/4.4/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }
# 1173 "/usr/include/c++/4.4/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }





  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class numpunct<wchar_t>;
  extern template class numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);



}
# 2599 "/usr/include/c++/4.4/bits/locale_facets.h" 2 3
# 39 "/usr/include/c++/4.4/bits/basic_ios.h" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
# 60 "/usr/include/c++/4.4/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:







      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }

      bool
      operator!() const
      { return this->fail(); }
# 125 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 136 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 189 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 210 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 245 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 283 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 295 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 335 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 349 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 378 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 398 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 418 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
# 437 "/usr/include/c++/4.4/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);

      void
      _M_cache_locale(const locale& __loc);
    };

}



# 1 "/usr/include/c++/4.4/bits/basic_ios.tcc" 1 3
# 34 "/usr/include/c++/4.4/bits/basic_ios.tcc" 3
# 34 "/usr/include/c++/4.4/bits/basic_ios.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 144 "/usr/include/c++/4.4/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }





  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;



}
# 471 "/usr/include/c++/4.4/bits/basic_ios.h" 2 3
# 45 "/usr/include/c++/4.4/ios" 2 3
# 40 "/usr/include/c++/4.4/ostream" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {
# 53 "/usr/include/c++/4.4/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 80 "/usr/include/c++/4.4/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 106 "/usr/include/c++/4.4/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 163 "/usr/include/c++/4.4/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }


      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
# 248 "/usr/include/c++/4.4/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 281 "/usr/include/c++/4.4/ostream" 3
      __ostream_type&
      put(char_type __c);


      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 309 "/usr/include/c++/4.4/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 322 "/usr/include/c++/4.4/ostream" 3
      __ostream_type&
      flush();
# 333 "/usr/include/c++/4.4/ostream" 3
      pos_type
      tellp();
# 344 "/usr/include/c++/4.4/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 356 "/usr/include/c++/4.4/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }

      template<typename _ValueT>
        __ostream_type&
        _M_insert(_ValueT __v);
    };
# 375 "/usr/include/c++/4.4/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 394 "/usr/include/c++/4.4/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
# 404 "/usr/include/c++/4.4/ostream" 3
      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
# 422 "/usr/include/c++/4.4/ostream" 3
      operator bool() const
      { return _M_ok; }
    };
# 443 "/usr/include/c++/4.4/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 485 "/usr/include/c++/4.4/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 535 "/usr/include/c++/4.4/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }







  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }

}



# 1 "/usr/include/c++/4.4/bits/ostream.tcc" 1 3
# 39 "/usr/include/c++/4.4/bits/ostream.tcc" 3
# 39 "/usr/include/c++/4.4/bits/ostream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }





  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);



}
# 565 "/usr/include/c++/4.4/ostream" 2 3
# 40 "/usr/include/c++/4.4/iostream" 2 3
# 1 "/usr/include/c++/4.4/istream" 1 3
# 38 "/usr/include/c++/4.4/istream" 3
# 38 "/usr/include/c++/4.4/istream" 3




namespace std __attribute__ ((__visibility__ ("default"))) {
# 53 "/usr/include/c++/4.4/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:
# 89 "/usr/include/c++/4.4/istream" 3
      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 117 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 164 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 236 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 246 "/usr/include/c++/4.4/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 278 "/usr/include/c++/4.4/istream" 3
      int_type
      get();
# 292 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      get(char_type& __c);
# 319 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 330 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 353 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 363 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 392 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 403 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 427 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      ignore();

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore(streamsize __n, int_type __delim);
# 444 "/usr/include/c++/4.4/istream" 3
      int_type
      peek();
# 462 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 481 "/usr/include/c++/4.4/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 497 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      putback(char_type __c);
# 512 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      unget();
# 530 "/usr/include/c++/4.4/istream" 3
      int
      sync();
# 544 "/usr/include/c++/4.4/istream" 3
      pos_type
      tellg();
# 559 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      seekg(pos_type);
# 575 "/usr/include/c++/4.4/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }

      template<typename _ValueT>
        __istream_type&
        _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 630 "/usr/include/c++/4.4/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {
    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 662 "/usr/include/c++/4.4/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 672 "/usr/include/c++/4.4/istream" 3
      operator bool() const
      { return _M_ok; }

    private:
      bool _M_ok;
    };
# 692 "/usr/include/c++/4.4/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 733 "/usr/include/c++/4.4/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 761 "/usr/include/c++/4.4/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }
    };
# 822 "/usr/include/c++/4.4/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);

}



# 1 "/usr/include/c++/4.4/bits/istream.tcc" 1 3
# 39 "/usr/include/c++/4.4/bits/istream.tcc" 3
# 39 "/usr/include/c++/4.4/bits/istream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && bool(__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();




       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      long __l;
      _M_extract(__l);
      if (!this->fail())
 {
   if (__gnu_cxx::__numeric_traits<short>::__min <= __l
       && __l <= __gnu_cxx::__numeric_traits<short>::__max)
     __n = short(__l);
   else
     this->setstate(ios_base::failbit);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      long __l;
      _M_extract(__l);
      if (!this->fail())
 {
   if (__gnu_cxx::__numeric_traits<int>::__min <= __l
       && __l <= __gnu_cxx::__numeric_traits<int>::__max)
     __n = int(__l);
   else
     this->setstate(ios_base::failbit);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 462 "/usr/include/c++/4.4/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
           ios_base::in);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {


      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {

       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::in);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {


      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      try
 {
   if (!this->fail())
     {

       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::in);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }





  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;



}
# 830 "/usr/include/c++/4.4/istream" 2 3
# 41 "/usr/include/c++/4.4/iostream" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 57 "/usr/include/c++/4.4/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;

}
# 10 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/test/test-edges0.5.cc" 2


# 1 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/exceptions.hh" 1








# 1 "/usr/include/c++/4.4/sstream" 1 3
# 37 "/usr/include/c++/4.4/sstream" 3
# 37 "/usr/include/c++/4.4/sstream" 3




namespace std __attribute__ ((__visibility__ ("default"))) {
# 56 "/usr/include/c++/4.4/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

    protected:

      ios_base::openmode _M_mode;


      __string_type _M_string;

    public:
# 90 "/usr/include/c++/4.4/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
# 103 "/usr/include/c++/4.4/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
      { _M_stringbuf_init(__mode); }
# 118 "/usr/include/c++/4.4/sstream" 3
      __string_type
      str() const
      {
 __string_type __ret;
 if (this->pptr())
   {

     if (this->pptr() > this->egptr())
       __ret = __string_type(this->pbase(), this->pptr());
     else
        __ret = __string_type(this->pbase(), this->egptr());
   }
 else
   __ret = _M_string;
 return __ret;
      }
# 142 "/usr/include/c++/4.4/sstream" 3
      void
      str(const __string_type& __s)
      {

 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(_M_mode);
      }

    protected:

      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 _M_mode = __mode;
 __size_type __len = 0;
 if (_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }

      virtual streamsize
      showmanyc()
      {
 streamsize __ret = -1;
 if (_M_mode & ios_base::in)
   {
     _M_update_egptr();
     __ret = this->egptr() - this->gptr();
   }
 return __ret;
      }

      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = traits_type::eof());

      virtual int_type
      overflow(int_type __c = traits_type::eof());
# 194 "/usr/include/c++/4.4/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {






     _M_string.clear();


     _M_sync(__s, __n, 0);
   }
 return this;
      }

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);




      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o);



      void
      _M_update_egptr()
      {
 const bool __testin = _M_mode & ios_base::in;
 if (this->pptr() && this->pptr() > this->egptr())
   {
     if (__testin)
       this->setg(this->eback(), this->gptr(), this->pptr());
     else
       this->setg(this->pptr(), this->pptr(), this->pptr());
   }
      }
    };
# 254 "/usr/include/c++/4.4/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 290 "/usr/include/c++/4.4/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
# 308 "/usr/include/c++/4.4/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }







      ~basic_istringstream()
      { }
# 330 "/usr/include/c++/4.4/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 364 "/usr/include/c++/4.4/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 400 "/usr/include/c++/4.4/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
# 418 "/usr/include/c++/4.4/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }







      ~basic_ostringstream()
      { }
# 440 "/usr/include/c++/4.4/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 474 "/usr/include/c++/4.4/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 508 "/usr/include/c++/4.4/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
# 524 "/usr/include/c++/4.4/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }







      ~basic_stringstream()
      { }
# 546 "/usr/include/c++/4.4/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };

}



# 1 "/usr/include/c++/4.4/bits/sstream.tcc" 1 3
# 39 "/usr/include/c++/4.4/bits/sstream.tcc" 3
# 39 "/usr/include/c++/4.4/bits/sstream.tcc" 3

namespace std __attribute__ ((__visibility__ ("default"))) {

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {


   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();

      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);

      const __size_type __capacity = _M_string.capacity();
      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();



      const char_type __conv = traits_type::to_char_type(__c);
      if (!__testput)
 {
# 109 "/usr/include/c++/4.4/bits/sstream.tcc" 3
   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp;
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   __tmp.push_back(__conv);
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      else
 *this->pptr() = __conv;
      this->pbump(1);
      return __c;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {

   _M_update_egptr();

   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);



      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();

   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;

   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->gbump((__beg + __newoffi) - this->gptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       this->pbump((__beg + __newoffo) - this->pptr());
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;

      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !off_type(__sp)) && (__testin || __testout))
 {
   _M_update_egptr();

   const off_type __pos(__sp);
   const bool __testpos = (0 <= __pos
      && __pos <= this->egptr() - __beg);
   if (__testpos)
     {
       if (__testin)
  this->gbump((__beg + __pos) - this->gptr());
       if (__testout)
                this->pbump((__beg + __pos) - this->pptr());
       __ret = __sp;
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_sync(char_type* __base, __size_type __i, __size_type __o)
    {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout = _M_mode & ios_base::out;
      char_type* __endg = __base + _M_string.size();
      char_type* __endp = __base + _M_string.capacity();

      if (__base != _M_string.data())
 {

   __endg += __i;
   __i = 0;
   __endp = __endg;
 }

      if (__testin)
 this->setg(__base, __base + __i, __endg);
      if (__testout)
 {
   this->setp(__base, __endp);
   this->pbump(__o);



   if (!__testin)
     this->setg(__endg, __endg, __endg);
 }
    }





  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;


  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;



}
# 573 "/usr/include/c++/4.4/sstream" 2 3
# 10 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/exceptions.hh" 2

namespace Dune {
# 72 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/exceptions.hh"
class Exception;
struct ExceptionHook;
# 92 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/exceptions.hh"
class Exception {
public:
  Exception ();
  void message(const std::string &message);
  const std::string& what() const;
  static void registerHook (ExceptionHook * hook);
  static void clearHook ();
private:
  std::string _message;
  static ExceptionHook * _hook;
};
# 169 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/exceptions.hh"
struct ExceptionHook
{
  virtual ~ExceptionHook() {}
  virtual void operator () () = 0;
};





inline Exception::Exception ()
{

  if (_hook != 0) _hook->operator()();
}

inline void Exception::registerHook (ExceptionHook * hook)
{
  _hook = hook;
}

inline void Exception::clearHook ()
{
  _hook = 0;
}

inline void Exception::message(const std::string &message)
{
  _message = message;
}

inline const std::string& Exception::what() const
{
  return _message;
}

inline std::ostream& operator<<(std::ostream &stream, const Exception &e)
{
  return stream << e.what();
}
# 257 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/exceptions.hh"
class IOError : public Exception {};
# 267 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/exceptions.hh"
class MathError : public Exception {};
# 280 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/exceptions.hh"
class RangeError : public Exception {};
# 289 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/exceptions.hh"
class NotImplemented : public Exception {};







class SystemError : public Exception {};




class OutOfMemoryError : public SystemError {};




class InvalidStateException : public Exception {};





class ParallelError : public Exception {};

}
# 13 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/test/test-edges0.5.cc" 2
# 1 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fvector.hh" 1






# 1 "/usr/include/c++/4.4/cmath" 1 3
# 41 "/usr/include/c++/4.4/cmath" 3
# 41 "/usr/include/c++/4.4/cmath" 3




# 1 "/usr/include/math.h" 1 3 4
# 30 "/usr/include/math.h" 3 4
extern "C" {




# 1 "/usr/include/bits/huge_val.h" 1 3 4
# 35 "/usr/include/math.h" 2 3 4

# 1 "/usr/include/bits/huge_valf.h" 1 3 4
# 37 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/huge_vall.h" 1 3 4
# 38 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/inf.h" 1 3 4
# 41 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/nan.h" 1 3 4
# 44 "/usr/include/math.h" 2 3 4



# 1 "/usr/include/bits/mathdef.h" 1 3 4
# 26 "/usr/include/bits/mathdef.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 27 "/usr/include/bits/mathdef.h" 2 3 4




typedef float float_t;
typedef double double_t;
# 48 "/usr/include/math.h" 2 3 4
# 71 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 55 "/usr/include/bits/mathcalls.h" 3 4
extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();




extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ();






extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();







extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw ();




extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();

extern double pow10 (double __x) throw (); extern double __pow10 (double __x) throw ();





extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();






extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();
# 154 "/usr/include/bits/mathcalls.h" 3 4
extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();





extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();






extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();
# 179 "/usr/include/bits/mathcalls.h" 3 4
extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();




extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));





extern int isinf (double __value) throw () __attribute__ ((__const__));


extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();





extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));






extern double nan (__const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnan (double __value) throw () __attribute__ ((__const__));



extern int isnan (double __value) throw () __attribute__ ((__const__));


extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();






extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();






extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();






extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();







extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw () __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) throw () __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) throw () __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) throw () __attribute__ ((__const__));



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw (); extern double __fmax (double __x, double __y) throw ();


extern double fmin (double __x, double __y) throw (); extern double __fmin (double __x, double __y) throw ();



extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();
# 364 "/usr/include/bits/mathcalls.h" 3 4
extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
# 72 "/usr/include/math.h" 2 3 4
# 94 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 55 "/usr/include/bits/mathcalls.h" 3 4
extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();




extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ();






extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();







extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw ();




extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();

extern float pow10f (float __x) throw (); extern float __pow10f (float __x) throw ();





extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();






extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();
# 154 "/usr/include/bits/mathcalls.h" 3 4
extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();





extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();






extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();
# 179 "/usr/include/bits/mathcalls.h" 3 4
extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();




extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));





extern int isinff (float __value) throw () __attribute__ ((__const__));


extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();





extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));






extern float nanf (__const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanf (float __value) throw () __attribute__ ((__const__));



extern int isnanf (float __value) throw () __attribute__ ((__const__));


extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();






extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();






extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();






extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();







extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) throw () __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__));



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw (); extern float __fmaxf (float __x, float __y) throw ();


extern float fminf (float __x, float __y) throw (); extern float __fminf (float __x, float __y) throw ();



extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();
# 364 "/usr/include/bits/mathcalls.h" 3 4
extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
# 95 "/usr/include/math.h" 2 3 4
# 145 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 55 "/usr/include/bits/mathcalls.h" 3 4
extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();




extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ();






extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();







extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw ();




extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();

extern long double pow10l (long double __x) throw (); extern long double __pow10l (long double __x) throw ();





extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();






extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();
# 154 "/usr/include/bits/mathcalls.h" 3 4
extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();





extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();






extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();
# 179 "/usr/include/bits/mathcalls.h" 3 4
extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();




extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));





extern int isinfl (long double __value) throw () __attribute__ ((__const__));


extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();





extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));






extern long double nanl (__const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (__const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanl (long double __value) throw () __attribute__ ((__const__));



extern int isnanl (long double __value) throw () __attribute__ ((__const__));


extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();






extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();






extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();






extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();







extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw (); extern long double __fmaxl (long double __x, long double __y) throw ();


extern long double fminl (long double __x, long double __y) throw (); extern long double __fminl (long double __x, long double __y) throw ();



extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();
# 364 "/usr/include/bits/mathcalls.h" 3 4
extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
# 146 "/usr/include/math.h" 2 3 4
# 161 "/usr/include/math.h" 3 4
extern int signgam;
# 202 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN,

    FP_INFINITE,

    FP_ZERO,

    FP_SUBNORMAL,

    FP_NORMAL

  };
# 295 "/usr/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
# 318 "/usr/include/math.h" 3 4
struct __exception



  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };


extern int matherr (struct __exception *__exc) throw ();
# 476 "/usr/include/math.h" 3 4
}
# 46 "/usr/include/c++/4.4/cmath" 2 3
# 76 "/usr/include/c++/4.4/cmath" 3
namespace std __attribute__ ((__visibility__ ("default"))) {



  template<typename _Tp>
    _Tp __cmath_power(_Tp, unsigned int);

  template<typename _Tp>
    inline _Tp
    __pow_helper(_Tp __x, int __n)
    {
      return __n < 0
        ? _Tp(1)/__cmath_power(__x, -__n)
        : __cmath_power(__x, __n);
    }

  inline double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }

  using ::acos;

  inline float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline long double
  acos(long double __x)
  { return __builtin_acosl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;

  inline float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline long double
  asin(long double __x)
  { return __builtin_asinl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;

  inline float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline long double
  atan(long double __x)
  { return __builtin_atanl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;

  inline float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }

  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<
    typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value
        && __is_arithmetic<_Up>::__value,
        _Tp>::__type, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;

  inline float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;

  inline float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline long double
  cos(long double __x)
  { return __builtin_cosl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;

  inline float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;

  inline float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline long double
  exp(long double __x)
  { return __builtin_expl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;

  inline float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;

  inline float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline long double
  floor(long double __x)
  { return __builtin_floorl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;

  inline float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }

  using ::frexp;

  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;

  inline float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
  ldexp(_Tp __x, int __exp)
  { return __builtin_ldexp(__x, __exp); }

  using ::log;

  inline float
  log(float __x)
  { return __builtin_logf(__x); }

  inline long double
  log(long double __x)
  { return __builtin_logl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;

  inline float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline long double
  log10(long double __x)
  { return __builtin_log10l(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;

  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }

  using ::pow;

  inline float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }




  inline double
  pow(double __x, int __i)
  { return __builtin_powi(__x, __i); }

  inline float
  pow(float __x, int __n)
  { return __builtin_powif(__x, __n); }

  inline long double
  pow(long double __x, int __n)
  { return __builtin_powil(__x, __n); }


  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<
    typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value
        && __is_arithmetic<_Up>::__value,
        _Tp>::__type, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;

  inline float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline long double
  sin(long double __x)
  { return __builtin_sinl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;

  inline float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;

  inline float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;

  inline float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline long double
  tan(long double __x)
  { return __builtin_tanl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;

  inline float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }

}
# 491 "/usr/include/c++/4.4/cmath" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    fpclassify(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL,
      FP_SUBNORMAL, FP_ZERO, __type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isfinite(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isfinite(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isinf(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isinf(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isnan(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isnan(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isnormal(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isnormal(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    signbit(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_signbit(__type(__f));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isgreater(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isgreater(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isgreaterequal(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isgreaterequal(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isless(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isless(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    islessequal(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_islessequal(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    islessgreater(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_islessgreater(__type(__f1), __type(__f2));
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isunordered(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isunordered(__type(__f1), __type(__f2));
    }

}






# 1 "/usr/include/c++/4.4/bits/cmath.tcc" 1 3
# 35 "/usr/include/c++/4.4/bits/cmath.tcc" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Tp>
    inline _Tp
    __cmath_power(_Tp __x, unsigned int __n)
    {
      _Tp __y = __n % 2 ? __x : _Tp(1);

      while (__n >>= 1)
        {
          __x = __x * __x;
          if (__n % 2)
            __y = __y * __x;
        }

      return __y;
    }

}
# 609 "/usr/include/c++/4.4/cmath" 2 3
# 8 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fvector.hh" 2
# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 9 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fvector.hh" 2
# 1 "/usr/include/c++/4.4/cstdlib" 1 3
# 41 "/usr/include/c++/4.4/cstdlib" 3
# 41 "/usr/include/c++/4.4/cstdlib" 3


# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 44 "/usr/include/c++/4.4/cstdlib" 2 3
# 67 "/usr/include/c++/4.4/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 33 "/usr/include/stdlib.h" 3 4
# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 34 "/usr/include/stdlib.h" 2 3 4

extern "C" {







# 1 "/usr/include/bits/waitflags.h" 1 3 4
# 43 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
# 67 "/usr/include/bits/waitstatus.h" 3 4
union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 44 "/usr/include/stdlib.h" 2 3 4
# 98 "/usr/include/stdlib.h" 3 4
typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 140 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;




extern double atof (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (__const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern float strtof (__const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1))) ;

extern long double strtold (__const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern long int strtol (__const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

extern unsigned long int strtoul (__const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;




__extension__
extern long long int strtoq (__const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtouq (__const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;





__extension__
extern long long int strtoll (__const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtoull (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 240 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4))) ;

extern unsigned long int strtoul_l (__const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;

__extension__
extern long long int strtoll_l (__const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;

__extension__
extern unsigned long long int strtoull_l (__const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;

extern double strtod_l (__const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;

extern float strtof_l (__const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;

extern long double strtold_l (__const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;
# 311 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (__const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





# 1 "/usr/include/sys/types.h" 1 3 4
# 29 "/usr/include/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;
# 72 "/usr/include/sys/types.h" 3 4
typedef __mode_t mode_t;




typedef __nlink_t nlink_t;
# 105 "/usr/include/sys/types.h" 3 4
typedef __id_t id_t;
# 116 "/usr/include/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 141 "/usr/include/sys/types.h" 3 4
typedef __suseconds_t suseconds_t;






# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 148 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 195 "/usr/include/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 220 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/select.h" 1 3 4
# 31 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
# 23 "/usr/include/bits/select.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 24 "/usr/include/bits/select.h" 2 3 4
# 32 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 35 "/usr/include/sys/select.h" 2 3 4
# 46 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/time.h" 1 3 4
# 69 "/usr/include/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 47 "/usr/include/sys/select.h" 2 3 4








typedef long int __fd_mask;
# 67 "/usr/include/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 99 "/usr/include/sys/select.h" 3 4
extern "C" {
# 109 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 121 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);


}
# 221 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/sysmacros.h" 1 3 4
# 30 "/usr/include/sys/sysmacros.h" 3 4
__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     throw ();
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     throw ();
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     throw ();
# 224 "/usr/include/sys/types.h" 2 3 4




typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 262 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;
# 273 "/usr/include/sys/types.h" 3 4
}
# 321 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();




extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));
# 471 "/usr/include/stdlib.h" 3 4
extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;
# 485 "/usr/include/stdlib.h" 3 4
extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) throw ();




extern void cfree (void *__ptr) throw ();




# 1 "/usr/include/alloca.h" 1 3 4
# 25 "/usr/include/alloca.h" 3 4
# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 26 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 498 "/usr/include/stdlib.h" 2 3 4




extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));






extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));
# 535 "/usr/include/stdlib.h" 3 4
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) throw () __attribute__ ((__noreturn__));







extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));







extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));






extern char *getenv (__const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;




extern char *__secure_getenv (__const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (__const char *__name, __const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (__const char *__name) throw ();






extern int clearenv (void) throw ();
# 604 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 615 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 625 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 637 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 647 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 658 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 669 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 679 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 689 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 701 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 712 "/usr/include/stdlib.h" 3 4
extern int system (__const char *__command) ;






extern char *canonicalize_file_name (__const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 729 "/usr/include/stdlib.h" 3 4
extern char *realpath (__const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (__const void *, __const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (__const void *, __const void *, void *);





extern void *bsearch (__const void *__key, __const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;



extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;
# 802 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));







extern int mblen (__const char *__s, size_t __n) throw () ;


extern int mbtowc (wchar_t *__restrict __pwc,
     __const char *__restrict __s, size_t __n) throw () ;


extern int wctomb (char *__s, wchar_t __wchar) throw () ;



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   __const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   __const wchar_t *__restrict __pwcs, size_t __n)
     throw ();
# 879 "/usr/include/stdlib.h" 3 4
extern int rpmatch (__const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
# 890 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *__const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (__const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));
# 958 "/usr/include/stdlib.h" 3 4
}
# 68 "/usr/include/c++/4.4/cstdlib" 2 3
# 99 "/usr/include/c++/4.4/cstdlib" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;


  inline long
  abs(long __i) { return labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }

}
# 156 "/usr/include/c++/4.4/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {


  using ::lldiv_t;





  using ::_Exit;


  inline long long
  abs(long long __x) { return __x >= 0 ? __x : -__x; }


  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 189 "/usr/include/c++/4.4/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;

}

namespace std __attribute__ ((__visibility__ ("default"))) {


  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;
  using ::__gnu_cxx::abs;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;

}
# 10 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fvector.hh" 2
# 1 "/usr/include/c++/4.4/complex" 1 3
# 41 "/usr/include/c++/4.4/complex" 3
# 41 "/usr/include/c++/4.4/complex" 3




# 1 "/usr/include/c++/4.4/cmath" 1 3
# 41 "/usr/include/c++/4.4/cmath" 3
# 41 "/usr/include/c++/4.4/cmath" 3
# 46 "/usr/include/c++/4.4/complex" 2 3


namespace std __attribute__ ((__visibility__ ("default"))) {
# 59 "/usr/include/c++/4.4/complex" 3
  template<typename _Tp> class complex;
  template<> class complex<float>;
  template<> class complex<double>;
  template<> class complex<long double>;


  template<typename _Tp> _Tp abs(const complex<_Tp>&);

  template<typename _Tp> _Tp arg(const complex<_Tp>&);

  template<typename _Tp> _Tp norm(const complex<_Tp>&);


  template<typename _Tp> complex<_Tp> conj(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> polar(const _Tp&, const _Tp& = 0);



  template<typename _Tp> complex<_Tp> cos(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> cosh(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> exp(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> log(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> log10(const complex<_Tp>&);



  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, int);


  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, const _Tp&);

  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&,
                                          const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> pow(const _Tp&, const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sin(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sinh(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sqrt(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> tan(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> tanh(const complex<_Tp>&);
# 120 "/usr/include/c++/4.4/complex" 3
  template<typename _Tp>
    struct complex
    {

      typedef _Tp value_type;



      complex(const _Tp& __r = _Tp(), const _Tp& __i = _Tp())
      : _M_real(__r), _M_imag(__i) { }




      template<typename _Up>
        complex(const complex<_Up>& __z)
 : _M_real(__z.real()), _M_imag(__z.imag()) { }
# 148 "/usr/include/c++/4.4/complex" 3
      _Tp& real()
      { return _M_real; }


      const _Tp& real() const
      { return _M_real; }


      _Tp& imag()
      { return _M_imag; }


      const _Tp& imag() const
      { return _M_imag; }




      void real(_Tp __val)
      { _M_real = __val; }

      void imag(_Tp __val)
      { _M_imag = __val; }


      complex<_Tp>& operator=(const _Tp&);



      complex<_Tp>&
      operator+=(const _Tp& __t)
      {
 _M_real += __t;
 return *this;
      }



      complex<_Tp>&
      operator-=(const _Tp& __t)
      {
 _M_real -= __t;
 return *this;
      }


      complex<_Tp>& operator*=(const _Tp&);

      complex<_Tp>& operator/=(const _Tp&);





      template<typename _Up>
        complex<_Tp>& operator=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator+=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator-=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator*=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator/=(const complex<_Up>&);

      const complex& __rep() const
      { return *this; }

    private:
      _Tp _M_real;
      _Tp _M_imag;
    };

  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator=(const _Tp& __t)
    {
     _M_real = __t;
     _M_imag = _Tp();
     return *this;
    }


  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator*=(const _Tp& __t)
    {
      _M_real *= __t;
      _M_imag *= __t;
      return *this;
    }


  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator/=(const _Tp& __t)
    {
      _M_real /= __t;
      _M_imag /= __t;
      return *this;
    }

  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator=(const complex<_Up>& __z)
    {
      _M_real = __z.real();
      _M_imag = __z.imag();
      return *this;
    }


  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator+=(const complex<_Up>& __z)
    {
      _M_real += __z.real();
      _M_imag += __z.imag();
      return *this;
    }


  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator-=(const complex<_Up>& __z)
    {
      _M_real -= __z.real();
      _M_imag -= __z.imag();
      return *this;
    }



  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator*=(const complex<_Up>& __z)
    {
      const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
      _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
      _M_real = __r;
      return *this;
    }



  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator/=(const complex<_Up>& __z)
    {
      const _Tp __r = _M_real * __z.real() + _M_imag * __z.imag();
      const _Tp __n = std::norm(__z);
      _M_imag = (_M_imag * __z.real() - _M_real * __z.imag()) / __n;
      _M_real = __r / __n;
      return *this;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r += __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r += __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator+(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __y;
      __r += __x;
      return __r;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r -= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r -= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator-(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r(__x, -__y.imag());
      __r -= __y.real();
      return __r;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator*(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r *= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator*(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r *= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator*(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __y;
      __r *= __x;
      return __r;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator/(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator/(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator/(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }



  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x)
    { return __x; }


  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x)
    { return complex<_Tp>(-__x.real(), -__x.imag()); }



  template<typename _Tp>
    inline bool
    operator==(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x.real() == __y.real() && __x.imag() == __y.imag(); }

  template<typename _Tp>
    inline bool
    operator==(const complex<_Tp>& __x, const _Tp& __y)
    { return __x.real() == __y && __x.imag() == _Tp(); }

  template<typename _Tp>
    inline bool
    operator==(const _Tp& __x, const complex<_Tp>& __y)
    { return __x == __y.real() && _Tp() == __y.imag(); }




  template<typename _Tp>
    inline bool
    operator!=(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x.real() != __y.real() || __x.imag() != __y.imag(); }

  template<typename _Tp>
    inline bool
    operator!=(const complex<_Tp>& __x, const _Tp& __y)
    { return __x.real() != __y || __x.imag() != _Tp(); }

  template<typename _Tp>
    inline bool
    operator!=(const _Tp& __x, const complex<_Tp>& __y)
    { return __x != __y.real() || _Tp() != __y.imag(); }



  template<typename _Tp, typename _CharT, class _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, complex<_Tp>& __x)
    {
      _Tp __re_x, __im_x;
      _CharT __ch;
      __is >> __ch;
      if (__ch == '(')
 {
   __is >> __re_x >> __ch;
   if (__ch == ',')
     {
       __is >> __im_x >> __ch;
       if (__ch == ')')
  __x = complex<_Tp>(__re_x, __im_x);
       else
  __is.setstate(ios_base::failbit);
     }
   else if (__ch == ')')
     __x = __re_x;
   else
     __is.setstate(ios_base::failbit);
 }
      else
 {
   __is.putback(__ch);
   __is >> __re_x;
   __x = __re_x;
 }
      return __is;
    }


  template<typename _Tp, typename _CharT, class _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const complex<_Tp>& __x)
    {
      basic_ostringstream<_CharT, _Traits> __s;
      __s.flags(__os.flags());
      __s.imbue(__os.getloc());
      __s.precision(__os.precision());
      __s << '(' << __x.real() << ',' << __x.imag() << ')';
      return __os << __s.str();
    }
# 540 "/usr/include/c++/4.4/complex" 3
  template<typename _Tp>
    inline _Tp&
    real(complex<_Tp>& __z)
    { return __z.real(); }

  template<typename _Tp>
    inline const _Tp&
    real(const complex<_Tp>& __z)
    { return __z.real(); }

  template<typename _Tp>
    inline _Tp&
    imag(complex<_Tp>& __z)
    { return __z.imag(); }

  template<typename _Tp>
    inline const _Tp&
    imag(const complex<_Tp>& __z)
    { return __z.imag(); }



  template<typename _Tp>
    inline _Tp
    __complex_abs(const complex<_Tp>& __z)
    {
      _Tp __x = __z.real();
      _Tp __y = __z.imag();
      const _Tp __s = std::max(abs(__x), abs(__y));
      if (__s == _Tp())
        return __s;
      __x /= __s;
      __y /= __s;
      return __s * sqrt(__x * __x + __y * __y);
    }


  inline float
  __complex_abs(__complex__ float __z) { return __builtin_cabsf(__z); }

  inline double
  __complex_abs(__complex__ double __z) { return __builtin_cabs(__z); }

  inline long double
  __complex_abs(const __complex__ long double& __z)
  { return __builtin_cabsl(__z); }

  template<typename _Tp>
    inline _Tp
    abs(const complex<_Tp>& __z) { return __complex_abs(__z.__rep()); }
# 598 "/usr/include/c++/4.4/complex" 3
  template<typename _Tp>
    inline _Tp
    __complex_arg(const complex<_Tp>& __z)
    { return atan2(__z.imag(), __z.real()); }


  inline float
  __complex_arg(__complex__ float __z) { return __builtin_cargf(__z); }

  inline double
  __complex_arg(__complex__ double __z) { return __builtin_carg(__z); }

  inline long double
  __complex_arg(const __complex__ long double& __z)
  { return __builtin_cargl(__z); }

  template<typename _Tp>
    inline _Tp
    arg(const complex<_Tp>& __z) { return __complex_arg(__z.__rep()); }
# 628 "/usr/include/c++/4.4/complex" 3
  template<bool>
    struct _Norm_helper
    {
      template<typename _Tp>
        static inline _Tp _S_do_it(const complex<_Tp>& __z)
        {
          const _Tp __x = __z.real();
          const _Tp __y = __z.imag();
          return __x * __x + __y * __y;
        }
    };

  template<>
    struct _Norm_helper<true>
    {
      template<typename _Tp>
        static inline _Tp _S_do_it(const complex<_Tp>& __z)
        {
          _Tp __res = std::abs(__z);
          return __res * __res;
        }
    };

  template<typename _Tp>
    inline _Tp
    norm(const complex<_Tp>& __z)
    {
      return _Norm_helper<__is_floating<_Tp>::__value
 && !0>::_S_do_it(__z);
    }

  template<typename _Tp>
    inline complex<_Tp>
    polar(const _Tp& __rho, const _Tp& __theta)
    { return complex<_Tp>(__rho * cos(__theta), __rho * sin(__theta)); }

  template<typename _Tp>
    inline complex<_Tp>
    conj(const complex<_Tp>& __z)
    { return complex<_Tp>(__z.real(), -__z.imag()); }




  template<typename _Tp>
    inline complex<_Tp>
    __complex_cos(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(cos(__x) * cosh(__y), -sin(__x) * sinh(__y));
    }


  inline __complex__ float
  __complex_cos(__complex__ float __z) { return __builtin_ccosf(__z); }

  inline __complex__ double
  __complex_cos(__complex__ double __z) { return __builtin_ccos(__z); }

  inline __complex__ long double
  __complex_cos(const __complex__ long double& __z)
  { return __builtin_ccosl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    cos(const complex<_Tp>& __z) { return __complex_cos(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_cosh(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(cosh(__x) * cos(__y), sinh(__x) * sin(__y));
    }


  inline __complex__ float
  __complex_cosh(__complex__ float __z) { return __builtin_ccoshf(__z); }

  inline __complex__ double
  __complex_cosh(__complex__ double __z) { return __builtin_ccosh(__z); }

  inline __complex__ long double
  __complex_cosh(const __complex__ long double& __z)
  { return __builtin_ccoshl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    cosh(const complex<_Tp>& __z) { return __complex_cosh(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_exp(const complex<_Tp>& __z)
    { return std::polar(exp(__z.real()), __z.imag()); }


  inline __complex__ float
  __complex_exp(__complex__ float __z) { return __builtin_cexpf(__z); }

  inline __complex__ double
  __complex_exp(__complex__ double __z) { return __builtin_cexp(__z); }

  inline __complex__ long double
  __complex_exp(const __complex__ long double& __z)
  { return __builtin_cexpl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    exp(const complex<_Tp>& __z) { return __complex_exp(__z.__rep()); }
# 759 "/usr/include/c++/4.4/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_log(const complex<_Tp>& __z)
    { return complex<_Tp>(log(std::abs(__z)), std::arg(__z)); }


  inline __complex__ float
  __complex_log(__complex__ float __z) { return __builtin_clogf(__z); }

  inline __complex__ double
  __complex_log(__complex__ double __z) { return __builtin_clog(__z); }

  inline __complex__ long double
  __complex_log(const __complex__ long double& __z)
  { return __builtin_clogl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    log(const complex<_Tp>& __z) { return __complex_log(__z.__rep()); }






  template<typename _Tp>
    inline complex<_Tp>
    log10(const complex<_Tp>& __z)
    { return std::log(__z) / log(_Tp(10.0)); }


  template<typename _Tp>
    inline complex<_Tp>
    __complex_sin(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(sin(__x) * cosh(__y), cos(__x) * sinh(__y));
    }


  inline __complex__ float
  __complex_sin(__complex__ float __z) { return __builtin_csinf(__z); }

  inline __complex__ double
  __complex_sin(__complex__ double __z) { return __builtin_csin(__z); }

  inline __complex__ long double
  __complex_sin(const __complex__ long double& __z)
  { return __builtin_csinl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sin(const complex<_Tp>& __z) { return __complex_sin(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_sinh(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(sinh(__x) * cos(__y), cosh(__x) * sin(__y));
    }


  inline __complex__ float
  __complex_sinh(__complex__ float __z) { return __builtin_csinhf(__z); }

  inline __complex__ double
  __complex_sinh(__complex__ double __z) { return __builtin_csinh(__z); }

  inline __complex__ long double
  __complex_sinh(const __complex__ long double& __z)
  { return __builtin_csinhl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sinh(const complex<_Tp>& __z) { return __complex_sinh(__z.__rep()); }
# 851 "/usr/include/c++/4.4/complex" 3
  template<typename _Tp>
    complex<_Tp>
    __complex_sqrt(const complex<_Tp>& __z)
    {
      _Tp __x = __z.real();
      _Tp __y = __z.imag();

      if (__x == _Tp())
        {
          _Tp __t = sqrt(abs(__y) / 2);
          return complex<_Tp>(__t, __y < _Tp() ? -__t : __t);
        }
      else
        {
          _Tp __t = sqrt(2 * (std::abs(__z) + abs(__x)));
          _Tp __u = __t / 2;
          return __x > _Tp()
            ? complex<_Tp>(__u, __y / __t)
            : complex<_Tp>(abs(__y) / __t, __y < _Tp() ? -__u : __u);
        }
    }


  inline __complex__ float
  __complex_sqrt(__complex__ float __z) { return __builtin_csqrtf(__z); }

  inline __complex__ double
  __complex_sqrt(__complex__ double __z) { return __builtin_csqrt(__z); }

  inline __complex__ long double
  __complex_sqrt(const __complex__ long double& __z)
  { return __builtin_csqrtl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sqrt(const complex<_Tp>& __z) { return __complex_sqrt(__z.__rep()); }
# 895 "/usr/include/c++/4.4/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_tan(const complex<_Tp>& __z)
    { return std::sin(__z) / std::cos(__z); }


  inline __complex__ float
  __complex_tan(__complex__ float __z) { return __builtin_ctanf(__z); }

  inline __complex__ double
  __complex_tan(__complex__ double __z) { return __builtin_ctan(__z); }

  inline __complex__ long double
  __complex_tan(const __complex__ long double& __z)
  { return __builtin_ctanl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    tan(const complex<_Tp>& __z) { return __complex_tan(__z.__rep()); }
# 923 "/usr/include/c++/4.4/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_tanh(const complex<_Tp>& __z)
    { return std::sinh(__z) / std::cosh(__z); }


  inline __complex__ float
  __complex_tanh(__complex__ float __z) { return __builtin_ctanhf(__z); }

  inline __complex__ double
  __complex_tanh(__complex__ double __z) { return __builtin_ctanh(__z); }

  inline __complex__ long double
  __complex_tanh(const __complex__ long double& __z)
  { return __builtin_ctanhl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    tanh(const complex<_Tp>& __z) { return __complex_tanh(__z.__rep()); }
# 955 "/usr/include/c++/4.4/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    pow(const complex<_Tp>& __z, int __n)
    { return std::__pow_helper(__z, __n); }


  template<typename _Tp>
    complex<_Tp>
    pow(const complex<_Tp>& __x, const _Tp& __y)
    {




      if (__x.imag() == _Tp() && __x.real() > _Tp())
        return pow(__x.real(), __y);

      complex<_Tp> __t = std::log(__x);
      return std::polar(exp(__y * __t.real()), __y * __t.imag());
    }

  template<typename _Tp>
    inline complex<_Tp>
    __complex_pow(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x == _Tp() ? _Tp() : std::exp(__y * std::log(__x)); }


  inline __complex__ float
  __complex_pow(__complex__ float __x, __complex__ float __y)
  { return __builtin_cpowf(__x, __y); }

  inline __complex__ double
  __complex_pow(__complex__ double __x, __complex__ double __y)
  { return __builtin_cpow(__x, __y); }

  inline __complex__ long double
  __complex_pow(const __complex__ long double& __x,
  const __complex__ long double& __y)
  { return __builtin_cpowl(__x, __y); }

  template<typename _Tp>
    inline complex<_Tp>
    pow(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __complex_pow(__x.__rep(), __y.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    pow(const _Tp& __x, const complex<_Tp>& __y)
    {
      return __x > _Tp() ? std::polar(pow(__x, __y.real()),
          __y.imag() * log(__x))
                  : std::pow(complex<_Tp>(__x), __y);
    }



  template<>
    struct complex<float>
    {
      typedef float value_type;
      typedef __complex__ float _ComplexT;

      complex(_ComplexT __z) : _M_value(__z) { }

      complex(float __r = 0.0f, float __i = 0.0f)
      {
 __real__ _M_value = __r;
 __imag__ _M_value = __i;
      }

      explicit complex(const complex<double>&);
      explicit complex(const complex<long double>&);
# 1043 "/usr/include/c++/4.4/complex" 3
      float& real()
      { return __real__ _M_value; }

      const float& real() const
      { return __real__ _M_value; }

      float& imag()
      { return __imag__ _M_value; }

      const float& imag() const
      { return __imag__ _M_value; }




      void real(float __val)
      { __real__ _M_value = __val; }

      void imag(float __val)
      { __imag__ _M_value = __val; }

      complex<float>&
      operator=(float __f)
      {
 __real__ _M_value = __f;
 __imag__ _M_value = 0.0f;
 return *this;
      }

      complex<float>&
      operator+=(float __f)
      {
 __real__ _M_value += __f;
 return *this;
      }

      complex<float>&
      operator-=(float __f)
      {
 __real__ _M_value -= __f;
 return *this;
      }

      complex<float>&
      operator*=(float __f)
      {
 _M_value *= __f;
 return *this;
      }

      complex<float>&
      operator/=(float __f)
      {
 _M_value /= __f;
 return *this;
      }





      template<typename _Tp>
        complex<float>&
        operator=(const complex<_Tp>& __z)
 {
   __real__ _M_value = __z.real();
   __imag__ _M_value = __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex<float>&
        operator+=(const complex<_Tp>& __z)
 {
   __real__ _M_value += __z.real();
   __imag__ _M_value += __z.imag();
   return *this;
 }

      template<class _Tp>
        complex<float>&
        operator-=(const complex<_Tp>& __z)
 {
   __real__ _M_value -= __z.real();
   __imag__ _M_value -= __z.imag();
   return *this;
 }

      template<class _Tp>
        complex<float>&
        operator*=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value *= __t;
   return *this;
 }

      template<class _Tp>
        complex<float>&
        operator/=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value /= __t;
   return *this;
 }

      const _ComplexT& __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  template<>
    struct complex<double>
    {
      typedef double value_type;
      typedef __complex__ double _ComplexT;

      complex(_ComplexT __z) : _M_value(__z) { }

      complex(double __r = 0.0, double __i = 0.0)
      {
 __real__ _M_value = __r;
 __imag__ _M_value = __i;
      }

      complex(const complex<float>& __z)
      : _M_value(__z.__rep()) { }

      explicit complex(const complex<long double>&);
# 1189 "/usr/include/c++/4.4/complex" 3
      double& real()
      { return __real__ _M_value; }

      const double& real() const
      { return __real__ _M_value; }

      double& imag()
      { return __imag__ _M_value; }

      const double& imag() const
      { return __imag__ _M_value; }




      void real(double __val)
      { __real__ _M_value = __val; }

      void imag(double __val)
      { __imag__ _M_value = __val; }

      complex<double>&
      operator=(double __d)
      {
 __real__ _M_value = __d;
 __imag__ _M_value = 0.0;
 return *this;
      }

      complex<double>&
      operator+=(double __d)
      {
 __real__ _M_value += __d;
 return *this;
      }

      complex<double>&
      operator-=(double __d)
      {
 __real__ _M_value -= __d;
 return *this;
      }

      complex<double>&
      operator*=(double __d)
      {
 _M_value *= __d;
 return *this;
      }

      complex<double>&
      operator/=(double __d)
      {
 _M_value /= __d;
 return *this;
      }




      template<typename _Tp>
        complex<double>&
        operator=(const complex<_Tp>& __z)
 {
   __real__ _M_value = __z.real();
   __imag__ _M_value = __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex<double>&
        operator+=(const complex<_Tp>& __z)
 {
   __real__ _M_value += __z.real();
   __imag__ _M_value += __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex<double>&
        operator-=(const complex<_Tp>& __z)
 {
   __real__ _M_value -= __z.real();
   __imag__ _M_value -= __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex<double>&
        operator*=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value *= __t;
   return *this;
 }

      template<typename _Tp>
        complex<double>&
        operator/=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value /= __t;
   return *this;
 }

      const _ComplexT& __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  template<>
    struct complex<long double>
    {
      typedef long double value_type;
      typedef __complex__ long double _ComplexT;

      complex(_ComplexT __z) : _M_value(__z) { }

      complex(long double __r = 0.0L, long double __i = 0.0L)
      {
 __real__ _M_value = __r;
 __imag__ _M_value = __i;
      }

      complex(const complex<float>& __z)
      : _M_value(__z.__rep()) { }

      complex(const complex<double>& __z)
      : _M_value(__z.__rep()) { }
# 1335 "/usr/include/c++/4.4/complex" 3
      long double& real()
      { return __real__ _M_value; }

      const long double& real() const
      { return __real__ _M_value; }

      long double& imag()
      { return __imag__ _M_value; }

      const long double& imag() const
      { return __imag__ _M_value; }




      void real(long double __val)
      { __real__ _M_value = __val; }

      void imag(long double __val)
      { __imag__ _M_value = __val; }

      complex<long double>&
      operator=(long double __r)
      {
 __real__ _M_value = __r;
 __imag__ _M_value = 0.0L;
 return *this;
      }

      complex<long double>&
      operator+=(long double __r)
      {
 __real__ _M_value += __r;
 return *this;
      }

      complex<long double>&
      operator-=(long double __r)
      {
 __real__ _M_value -= __r;
 return *this;
      }

      complex<long double>&
      operator*=(long double __r)
      {
 _M_value *= __r;
 return *this;
      }

      complex<long double>&
      operator/=(long double __r)
      {
 _M_value /= __r;
 return *this;
      }




      template<typename _Tp>
        complex<long double>&
        operator=(const complex<_Tp>& __z)
 {
   __real__ _M_value = __z.real();
   __imag__ _M_value = __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex<long double>&
 operator+=(const complex<_Tp>& __z)
 {
   __real__ _M_value += __z.real();
   __imag__ _M_value += __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex<long double>&
 operator-=(const complex<_Tp>& __z)
 {
   __real__ _M_value -= __z.real();
   __imag__ _M_value -= __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex<long double>&
 operator*=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value *= __t;
   return *this;
 }

      template<typename _Tp>
        complex<long double>&
 operator/=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value /= __t;
   return *this;
 }

      const _ComplexT& __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  inline
  complex<float>::complex(const complex<double>& __z)
  : _M_value(__z.__rep()) { }

  inline
  complex<float>::complex(const complex<long double>& __z)
  : _M_value(__z.__rep()) { }

  inline
  complex<double>::complex(const complex<long double>& __z)
  : _M_value(__z.__rep()) { }





  extern template istream& operator>>(istream&, complex<float>&);
  extern template ostream& operator<<(ostream&, const complex<float>&);
  extern template istream& operator>>(istream&, complex<double>&);
  extern template ostream& operator<<(ostream&, const complex<double>&);
  extern template istream& operator>>(istream&, complex<long double>&);
  extern template ostream& operator<<(ostream&, const complex<long double>&);


  extern template wistream& operator>>(wistream&, complex<float>&);
  extern template wostream& operator<<(wostream&, const complex<float>&);
  extern template wistream& operator>>(wistream&, complex<double>&);
  extern template wostream& operator<<(wostream&, const complex<double>&);
  extern template wistream& operator>>(wistream&, complex<long double>&);
  extern template wostream& operator<<(wostream&, const complex<long double>&);





}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {


  template<typename _Tp, typename _Up>
    struct __promote_2<std::complex<_Tp>, _Up>
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };

  template<typename _Tp, typename _Up>
    struct __promote_2<_Tp, std::complex<_Up> >
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };

  template<typename _Tp, typename _Up>
    struct __promote_2<std::complex<_Tp>, std::complex<_Up> >
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };

}
# 11 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fvector.hh" 2
# 1 "/usr/include/c++/4.4/cstring" 1 3
# 41 "/usr/include/c++/4.4/cstring" 3
# 41 "/usr/include/c++/4.4/cstring" 3


# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 44 "/usr/include/c++/4.4/cstring" 2 3
# 1 "/usr/include/string.h" 1 3 4
# 28 "/usr/include/string.h" 3 4
extern "C" {





# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest,
       __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, __const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 94 "/usr/include/string.h" 3 4
extern void *memchr (__const void *__s, int __c, size_t __n)
      throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 108 "/usr/include/string.h" 3 4
extern void *rawmemchr (__const void *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 119 "/usr/include/string.h" 3 4
extern void *memrchr (__const void *__s, int __c, size_t __n)
      throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));
# 164 "/usr/include/string.h" 3 4
extern int strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
    __locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));




extern char *strdup (__const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (__const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 233 "/usr/include/string.h" 3 4
extern char *strchr (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 260 "/usr/include/string.h" 3 4
extern char *strrchr (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 274 "/usr/include/string.h" 3 4
extern char *strchrnul (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern size_t strcspn (__const char *__s, __const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (__const char *__s, __const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 312 "/usr/include/string.h" 3 4
extern char *strpbrk (__const char *__s, __const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 340 "/usr/include/string.h" 3 4
extern char *strstr (__const char *__haystack, __const char *__needle)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    __const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));
# 371 "/usr/include/string.h" 3 4
extern char *strcasestr (__const char *__haystack, __const char *__needle)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));







extern void *memmem (__const void *__haystack, size_t __haystacklen,
       __const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (__const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (__const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) throw ();
# 436 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));





extern char *strerror_l (int __errnum, __locale_t __l) throw ();





extern void __bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern void bcopy (__const void *__src, void *__dest, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 487 "/usr/include/string.h" 3 4
extern char *index (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 515 "/usr/include/string.h" 3 4
extern char *rindex (__const char *__s, int __c)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern int ffs (int __i) throw () __attribute__ ((__const__));




extern int ffsl (long int __l) throw () __attribute__ ((__const__));

__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));




extern int strcasecmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (__const char *__s1, __const char *__s2,
    __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (__const char *__s1, __const char *__s2,
     size_t __n, __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       __const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));
# 604 "/usr/include/string.h" 3 4
extern char *basename (__const char *__filename) throw () __attribute__ ((__nonnull__ (1)));
# 644 "/usr/include/string.h" 3 4
}
# 45 "/usr/include/c++/4.4/cstring" 2 3
# 73 "/usr/include/c++/4.4/cstring" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;


  inline void*
  memchr(void* __p, int __c, size_t __n)
  { return memchr(const_cast<const void*>(__p), __c, __n); }

  inline char*
  strchr(char* __s1, int __n)
  { return __builtin_strchr(const_cast<const char*>(__s1), __n); }

  inline char*
  strpbrk(char* __s1, const char* __s2)
  { return __builtin_strpbrk(const_cast<const char*>(__s1), __s2); }

  inline char*
  strrchr(char* __s1, int __n)
  { return __builtin_strrchr(const_cast<const char*>(__s1), __n); }

  inline char*
  strstr(char* __s1, const char* __s2)
  { return __builtin_strstr(const_cast<const char*>(__s1), __s2); }


}
# 12 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fvector.hh" 2


# 1 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/array.hh" 1
# 12 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/array.hh"
# 1 "/usr/include/c++/4.4/iomanip" 1 3
# 38 "/usr/include/c++/4.4/iomanip" 3
# 38 "/usr/include/c++/4.4/iomanip" 3





namespace std __attribute__ ((__visibility__ ("default"))) {




  struct _Resetiosflags { ios_base::fmtflags _M_mask; };
# 57 "/usr/include/c++/4.4/iomanip" 3
  inline _Resetiosflags
  resetiosflags(ios_base::fmtflags __mask)
  {
    _Resetiosflags __x;
    __x._M_mask = __mask;
    return __x;
  }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Resetiosflags __f)
    {
      __is.setf(ios_base::fmtflags(0), __f._M_mask);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Resetiosflags __f)
    {
      __os.setf(ios_base::fmtflags(0), __f._M_mask);
      return __os;
    }


  struct _Setiosflags { ios_base::fmtflags _M_mask; };
# 91 "/usr/include/c++/4.4/iomanip" 3
  inline _Setiosflags
  setiosflags(ios_base::fmtflags __mask)
  {
    _Setiosflags __x;
    __x._M_mask = __mask;
    return __x;
  }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setiosflags __f)
    {
      __is.setf(__f._M_mask);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setiosflags __f)
    {
      __os.setf(__f._M_mask);
      return __os;
    }


  struct _Setbase { int _M_base; };
# 126 "/usr/include/c++/4.4/iomanip" 3
  inline _Setbase
  setbase(int __base)
  {
    _Setbase __x;
    __x._M_base = __base;
    return __x;
  }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setbase __f)
    {
      __is.setf(__f._M_base == 8 ? ios_base::oct :
  __f._M_base == 10 ? ios_base::dec :
  __f._M_base == 16 ? ios_base::hex :
  ios_base::fmtflags(0), ios_base::basefield);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setbase __f)
    {
      __os.setf(__f._M_base == 8 ? ios_base::oct :
  __f._M_base == 10 ? ios_base::dec :
  __f._M_base == 16 ? ios_base::hex :
  ios_base::fmtflags(0), ios_base::basefield);
      return __os;
    }


  template<typename _CharT>
    struct _Setfill { _CharT _M_c; };
# 167 "/usr/include/c++/4.4/iomanip" 3
  template<typename _CharT>
    inline _Setfill<_CharT>
    setfill(_CharT __c)
    {
      _Setfill<_CharT> __x;
      __x._M_c = __c;
      return __x;
    }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setfill<_CharT> __f)
    {
      __is.fill(__f._M_c);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setfill<_CharT> __f)
    {
      __os.fill(__f._M_c);
      return __os;
    }


  struct _Setprecision { int _M_n; };
# 202 "/usr/include/c++/4.4/iomanip" 3
  inline _Setprecision
  setprecision(int __n)
  {
    _Setprecision __x;
    __x._M_n = __n;
    return __x;
  }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setprecision __f)
    {
      __is.precision(__f._M_n);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setprecision __f)
    {
      __os.precision(__f._M_n);
      return __os;
    }


  struct _Setw { int _M_n; };
# 236 "/usr/include/c++/4.4/iomanip" 3
  inline _Setw
  setw(int __n)
  {
    _Setw __x;
    __x._M_n = __n;
    return __x;
  }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setw __f)
    {
      __is.width(__f._M_n);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setw __f)
    {
      __os.width(__f._M_n);
      return __os;
    }





  extern template ostream& operator<<(ostream&, _Setfill<char>);
  extern template ostream& operator<<(ostream&, _Setiosflags);
  extern template ostream& operator<<(ostream&, _Resetiosflags);
  extern template ostream& operator<<(ostream&, _Setbase);
  extern template ostream& operator<<(ostream&, _Setprecision);
  extern template ostream& operator<<(ostream&, _Setw);
  extern template istream& operator>>(istream&, _Setfill<char>);
  extern template istream& operator>>(istream&, _Setiosflags);
  extern template istream& operator>>(istream&, _Resetiosflags);
  extern template istream& operator>>(istream&, _Setbase);
  extern template istream& operator>>(istream&, _Setprecision);
  extern template istream& operator>>(istream&, _Setw);


  extern template wostream& operator<<(wostream&, _Setfill<wchar_t>);
  extern template wostream& operator<<(wostream&, _Setiosflags);
  extern template wostream& operator<<(wostream&, _Resetiosflags);
  extern template wostream& operator<<(wostream&, _Setbase);
  extern template wostream& operator<<(wostream&, _Setprecision);
  extern template wostream& operator<<(wostream&, _Setw);
  extern template wistream& operator>>(wistream&, _Setfill<wchar_t>);
  extern template wistream& operator>>(wistream&, _Setiosflags);
  extern template wistream& operator>>(wistream&, _Resetiosflags);
  extern template wistream& operator>>(wistream&, _Setbase);
  extern template wistream& operator>>(wistream&, _Setprecision);
  extern template wistream& operator>>(wistream&, _Setw);



}
# 13 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/array.hh" 2






# 1 "/usr/include/c++/4.4/algorithm" 1 3
# 59 "/usr/include/c++/4.4/algorithm" 3
# 59 "/usr/include/c++/4.4/algorithm" 3


# 1 "/usr/include/c++/4.4/bits/stl_algo.h" 1 3
# 60 "/usr/include/c++/4.4/bits/stl_algo.h" 3
# 1 "/usr/include/c++/4.4/cstdlib" 1 3
# 41 "/usr/include/c++/4.4/cstdlib" 3
# 41 "/usr/include/c++/4.4/cstdlib" 3


# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 44 "/usr/include/c++/4.4/cstdlib" 2 3
# 61 "/usr/include/c++/4.4/bits/stl_algo.h" 2 3
# 1 "/usr/include/c++/4.4/bits/algorithmfwd.h" 1 3
# 33 "/usr/include/c++/4.4/bits/algorithmfwd.h" 3
# 33 "/usr/include/c++/4.4/bits/algorithmfwd.h" 3






namespace std __attribute__ ((__visibility__ ("default"))) {
# 197 "/usr/include/c++/4.4/bits/algorithmfwd.h" 3
  template<typename _FIter, typename _Tp>
    bool
    binary_search(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    bool
    binary_search(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _IIter, typename _OIter>
    _OIter
    copy(_IIter, _IIter, _OIter);

  template<typename _BIter1, typename _BIter2>
    _BIter2
    copy_backward(_BIter1, _BIter1, _BIter2);
# 226 "/usr/include/c++/4.4/bits/algorithmfwd.h" 3
  template<typename _FIter, typename _Tp>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _FIter, typename _Tp>
    void
    fill(_FIter, _FIter, const _Tp&);
# 245 "/usr/include/c++/4.4/bits/algorithmfwd.h" 3
  template<typename _OIter, typename _Size, typename _Tp>
    _OIter
    fill_n(_OIter, _Size, const _Tp&);



  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);
# 272 "/usr/include/c++/4.4/bits/algorithmfwd.h" 3
  template<typename _IIter1, typename _IIter2>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _BIter>
    void
    inplace_merge(_BIter, _BIter, _BIter);

  template<typename _BIter, typename _Compare>
    void
    inplace_merge(_BIter, _BIter, _BIter, _Compare);
# 326 "/usr/include/c++/4.4/bits/algorithmfwd.h" 3
  template<typename _FIter1, typename _FIter2>
    void
    iter_swap(_FIter1, _FIter2);

  template<typename _FIter, typename _Tp>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _RAIter>
    void
    make_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    make_heap(_RAIter, _RAIter, _Compare);

  template<typename _Tp>
    const _Tp&
    max(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    const _Tp&
    max(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    const _Tp&
    min(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    const _Tp&
    min(const _Tp&, const _Tp&, _Compare);
# 411 "/usr/include/c++/4.4/bits/algorithmfwd.h" 3
  template<typename _BIter>
    bool
    next_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    next_permutation(_BIter, _BIter, _Compare);
# 428 "/usr/include/c++/4.4/bits/algorithmfwd.h" 3
  template<typename _IIter, typename _RAIter>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);

  template<typename _IIter, typename _RAIter, typename _Compare>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);
# 449 "/usr/include/c++/4.4/bits/algorithmfwd.h" 3
  template<typename _RAIter>
    void
    pop_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    pop_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter>
    bool
    prev_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    prev_permutation(_BIter, _BIter, _Compare);

  template<typename _RAIter>
    void
    push_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    push_heap(_RAIter, _RAIter, _Compare);



  template<typename _FIter, typename _Tp>
    _FIter
    remove(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Predicate>
    _FIter
    remove_if(_FIter, _FIter, _Predicate);

  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    remove_copy(_IIter, _IIter, _OIter, const _Tp&);

  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    remove_copy_if(_IIter, _IIter, _OIter, _Predicate);



  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    replace_copy(_IIter, _IIter, _OIter, const _Tp&, const _Tp&);

  template<typename _Iter, typename _OIter, typename _Predicate, typename _Tp>
    _OIter
    replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp&);



  template<typename _BIter>
    void
    reverse(_BIter, _BIter);

  template<typename _BIter, typename _OIter>
    _OIter
    reverse_copy(_BIter, _BIter, _OIter);

  template<typename _FIter>
    void
    rotate(_FIter, _FIter, _FIter);

  template<typename _FIter, typename _OIter>
    _OIter
    rotate_copy(_FIter, _FIter, _FIter, _OIter);
# 526 "/usr/include/c++/4.4/bits/algorithmfwd.h" 3
  template<typename _RAIter>
    void
    sort_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    stable_partition(_BIter, _BIter, _Predicate);

  template<typename _Tp>
    void
    swap(_Tp&, _Tp&);

  template<typename _Tp, size_t _Nm>
    void
    swap(_Tp (&)[_Nm], _Tp (&)[_Nm]);

  template<typename _FIter1, typename _FIter2>
    _FIter2
    swap_ranges(_FIter1, _FIter1, _FIter2);



  template<typename _FIter>
    _FIter
    unique(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    unique(_FIter, _FIter, _BinaryPredicate);



  template<typename _FIter, typename _Tp>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&, _Compare);

}

namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _FIter>
    _FIter
    adjacent_find(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    adjacent_find(_FIter, _FIter, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    typename iterator_traits<_IIter>::difference_type
    count(_IIter, _IIter, const _Tp&);

  template<typename _IIter, typename _Predicate>
    typename iterator_traits<_IIter>::difference_type
    count_if(_IIter, _IIter, _Predicate);

  template<typename _IIter1, typename _IIter2>
    bool
    equal(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    bool
    equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    _IIter
    find(_IIter, _IIter, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _IIter, typename _Predicate>
    _IIter
    find_if(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Funct>
    _Funct
    for_each(_IIter, _IIter, _Funct);

  template<typename _FIter, typename _Generator>
    void
    generate(_FIter, _FIter, _Generator);
# 629 "/usr/include/c++/4.4/bits/algorithmfwd.h" 3
  template<typename _OIter, typename _Size, typename _Generator>
    _OIter
    generate_n(_OIter, _Size, _Generator);

  template<typename _IIter1, typename _IIter2>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _FIter>
    _FIter
    max_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    max_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _FIter>
    _FIter
    min_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    min_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _RAIter>
    void
    nth_element(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    nth_element(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    partial_sort(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    partition(_BIter, _BIter, _Predicate);

  template<typename _RAIter>
    void
    random_shuffle(_RAIter, _RAIter);

  template<typename _RAIter, typename _Generator>
    void
    random_shuffle(_RAIter, _RAIter, _Generator&);

  template<typename _FIter, typename _Tp>
    void
    replace(_FIter, _FIter, const _Tp&, const _Tp&);

  template<typename _FIter, typename _Predicate, typename _Tp>
    void
    replace_if(_FIter, _FIter, _Predicate, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _FIter, typename _Size, typename _Tp>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&);

  template<typename _FIter, typename _Size, typename _Tp,
    typename _BinaryPredicate>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&, _BinaryPredicate);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2,
        _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _RAIter>
    void
    sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    stable_sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    stable_sort(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _OIter, typename _UnaryOperation>
    _OIter
    transform(_IIter, _IIter, _OIter, _UnaryOperation);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _BinaryOperation>
    _OIter
    transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);

  template<typename _IIter, typename _OIter>
    _OIter
    unique_copy(_IIter, _IIter, _OIter);

  template<typename _IIter, typename _OIter, typename _BinaryPredicate>
    _OIter
    unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);

}
# 62 "/usr/include/c++/4.4/bits/stl_algo.h" 2 3
# 1 "/usr/include/c++/4.4/bits/stl_heap.h" 1 3
# 62 "/usr/include/c++/4.4/bits/stl_heap.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {






  template<typename _RandomAccessIterator, typename _Distance>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__first[__parent] < __first[__child])
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n,
      _Compare __comp)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first[__parent], __first[__child]))
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }



  template<typename _RandomAccessIterator, typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    { return std::__is_heap_until(__first, __n) == __n; }

  template<typename _RandomAccessIterator, typename _Compare,
    typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
    { return std::__is_heap_until(__first, __n, __comp) == __n; }

  template<typename _RandomAccessIterator>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    { return std::__is_heap(__first, __comp, std::distance(__first, __last)); }




  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && *(__first + __parent) < __value)
 {
   *(__first + __holeIndex) = (*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = (__value);
    }
# 152 "/usr/include/c++/4.4/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;





                                                     ;
                                                  ;

      _ValueType __value = (*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), (__value));
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
    typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
  _Distance __topIndex, _Tp __value, _Compare __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex
      && __comp(*(__first + __parent), __value))
 {
   *(__first + __holeIndex) = (*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = (__value);
    }
# 201 "/usr/include/c++/4.4/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;




                                                     ;
                                                               ;

      _ValueType __value = (*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), (__value), __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = (*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = (*(__first + (__secondChild - 1)));

   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex,
         (__value));
    }

  template<typename _RandomAccessIterator>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = (*__result);
      *__result = (*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    (__value));
    }
# 274 "/usr/include/c++/4.4/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                     ;
                                              ;

      --__last;
      std::__pop_heap(__first, __last, __last);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (__comp(*(__first + __secondChild),
       *(__first + (__secondChild - 1))))
     __secondChild--;
   *(__first + __holeIndex) = (*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = (*(__first + (__secondChild - 1)));

   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex,
         (__value), __comp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = (*__result);
      *__result = (*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    (__value), __comp);
    }
# 348 "/usr/include/c++/4.4/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {



                                                     ;
                                                           ;

      --__last;
      std::__pop_heap(__first, __last, __last, __comp);
    }
# 371 "/usr/include/c++/4.4/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;





                                                     ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = (*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, (__value));
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 411 "/usr/include/c++/4.4/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;




                                                     ;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = (*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, (__value),
        __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 450 "/usr/include/c++/4.4/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {





                                                     ;
                                              ;

      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last);
 }
    }
# 479 "/usr/include/c++/4.4/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {



                                                     ;
                                                           ;

      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
# 576 "/usr/include/c++/4.4/bits/stl_heap.h" 3
}
# 63 "/usr/include/c++/4.4/bits/stl_algo.h" 2 3
# 1 "/usr/include/c++/4.4/bits/stl_tempbuf.h" 1 3
# 61 "/usr/include/c++/4.4/bits/stl_tempbuf.h" 3
# 1 "/usr/include/c++/4.4/bits/stl_construct.h" 1 3
# 62 "/usr/include/c++/4.4/bits/stl_construct.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {





  template<typename _T1, typename _T2>
    inline void
    _Construct(_T1* __p, const _T2& __value)
    {


      ::new(static_cast<void*>(__p)) _T1(__value);
    }




  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(&*__first);
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }







  template <typename _Tp> class allocator;

  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      for (; __first != __last; ++__first)
 __alloc.destroy(&*__first);
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }

}
# 62 "/usr/include/c++/4.4/bits/stl_tempbuf.h" 2 3
# 1 "/usr/include/c++/4.4/bits/stl_uninitialized.h" 1 3
# 60 "/usr/include/c++/4.4/bits/stl_uninitialized.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<bool>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        uninitialized_copy(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++__first, ++__cur)
  ::new(static_cast<void*>(&*__cur)) typename
      iterator_traits<_ForwardIterator>::value_type(*__first);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__result, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        uninitialized_copy(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 105 "/usr/include/c++/4.4/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;

      return std::__uninitialized_copy<(__is_pod(_ValueType1)
     && __is_pod(_ValueType2))>::
 uninitialized_copy(__first, __last, __result);
    }


  template<bool>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        uninitialized_fill(_ForwardIterator __first,
      _ForwardIterator __last, const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(&*__cur, __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        uninitialized_fill(_ForwardIterator __first,
      _ForwardIterator __last, const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 162 "/usr/include/c++/4.4/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill<__is_pod(_ValueType)>::
 uninitialized_fill(__first, __last, __x);
    }


  template<bool>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        uninitialized_fill_n(_ForwardIterator __first, _Size __n,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(&*__cur, __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        uninitialized_fill_n(_ForwardIterator __first, _Size __n,
        const _Tp& __x)
        { std::fill_n(__first, __n, __x); }
    };
# 216 "/usr/include/c++/4.4/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill_n<__is_pod(_ValueType)>::
 uninitialized_fill_n(__first, __n, __x);
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __first != __last; ++__first, ++__cur)
     __alloc.construct(&*__cur, *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a((__first),
      (__last),
      __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __cur != __last; ++__cur)
     __alloc.construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __n > 0; --__n, ++__cur)
     __alloc.construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill_n(__first, __n, __x); }
# 330 "/usr/include/c++/4.4/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }
# 476 "/usr/include/c++/4.4/bits/stl_uninitialized.h" 3
}
# 63 "/usr/include/c++/4.4/bits/stl_tempbuf.h" 2 3

namespace std __attribute__ ((__visibility__ ("default"))) {
# 83 "/usr/include/c++/4.4/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len)
    {
      const ptrdiff_t __max =
 __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       std::nothrow));
   if (__tmp != 0)
     return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 110 "/usr/include/c++/4.4/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, std::nothrow); }







  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {



    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };

  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {
      try
 {
   std::pair<pointer, size_type> __p(std::get_temporary_buffer<
         value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if (!__is_pod(_Tp) && _M_len > 0)
     std::uninitialized_fill_n(_M_buffer, _M_len, *__first);
 }
      catch(...)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   throw;
 }
    }

}
# 64 "/usr/include/c++/4.4/bits/stl_algo.h" 2 3





namespace std __attribute__ ((__visibility__ ("default"))) {
# 83 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _Tp>
    inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c)
    {


      if (__a < __b)
 if (__b < __c)
   return __b;
 else if (__a < __c)
   return __c;
 else
   return __a;
      else if (__a < __c)
 return __a;
      else if (__b < __c)
 return __c;
      else
 return __b;
    }
# 117 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c, _Compare __comp)
    {



      if (__comp(__a, __b))
 if (__comp(__b, __c))
   return __b;
 else if (__comp(__a, __c))
   return __c;
 else
   return __a;
      else if (__comp(__a, __c))
 return __a;
      else if (__comp(__b, __c))
 return __c;
      else
 return __b;
    }




  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    __find(_InputIterator __first, _InputIterator __last,
    const _Tp& __val, input_iterator_tag)
    {
      while (__first != __last && !(*__first == __val))
 ++__first;
      return __first;
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !bool(__pred(*__first)))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __find(_RandomAccessIterator __first, _RandomAccessIterator __last,
    const _Tp& __val, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;

   if (*__first == __val)
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (*__first == __val)
     return __first;
   ++__first;
 case 2:
   if (*__first == __val)
     return __first;
   ++__first;
 case 1:
   if (*__first == __val)
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;

   if (__pred(*__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }
# 338 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        std::forward_iterator_tag)
    {
      __first = std::find(__first, __last, __val);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && *__i == __val)
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::find(++__i, __last, __val);
 }
      return __last;
    }






  template<typename _RandomAccessIter, typename _Integer, typename _Tp>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        std::random_access_iterator_tag)
    {

      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      const _DistanceType __pattSize = __count;

      if (__tailSize < __pattSize)
        return __last;

      const _DistanceType __skipOffset = __pattSize - 1;
      _RandomAccessIter __lookAhead = __first + __skipOffset;
      __tailSize -= __pattSize;

      while (1)
 {


   while (!(*__lookAhead == __val))
     {
       if (__tailSize < __pattSize)
  return __last;
       __lookAhead += __pattSize;
       __tailSize -= __pattSize;
     }
   _DistanceType __remainder = __skipOffset;
   for (_RandomAccessIter __backTrack = __lookAhead - 1;
        *__backTrack == __val; --__backTrack)
     {
       if (--__remainder == 0)
  return (__lookAhead - __skipOffset);
     }
   if (__remainder > __tailSize)
     return __last;
   __lookAhead += __remainder;
   __tailSize -= __remainder;
 }
    }
# 423 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::forward_iterator_tag)
    {
      while (__first != __last && !bool(__binary_pred(*__first, __val)))
        ++__first;

      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && bool(__binary_pred(*__i, __val)))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = ++__i;
   while (__first != __last
   && !bool(__binary_pred(*__first, __val)))
     ++__first;
 }
      return __last;
    }







  template<typename _RandomAccessIter, typename _Integer, typename _Tp,
    typename _BinaryPredicate>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::random_access_iterator_tag)
    {

      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      const _DistanceType __pattSize = __count;

      if (__tailSize < __pattSize)
        return __last;

      const _DistanceType __skipOffset = __pattSize - 1;
      _RandomAccessIter __lookAhead = __first + __skipOffset;
      __tailSize -= __pattSize;

      while (1)
 {


   while (!bool(__binary_pred(*__lookAhead, __val)))
     {
       if (__tailSize < __pattSize)
  return __last;
       __lookAhead += __pattSize;
       __tailSize -= __pattSize;
     }
   _DistanceType __remainder = __skipOffset;
   for (_RandomAccessIter __backTrack = __lookAhead - 1;
        __binary_pred(*__backTrack, __val); --__backTrack)
     {
       if (--__remainder == 0)
  return (__lookAhead - __skipOffset);
     }
   if (__remainder > __tailSize)
     return __last;
   __lookAhead += __remainder;
   __tailSize -= __remainder;
 }
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2, __last2);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2,
      __last2, __comp);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag)
    {






      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1),
             __rlast1,
             _RevIterator2(__last2),
             __rlast2);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }

  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {






      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
         _RevIterator2(__last2), __rlast2,
         __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
# 661 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {






                                                       ;
                                                       ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2));
    }
# 707 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {






                                                       ;
                                                       ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __comp);
    }
# 886 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {






                                                     ;

      for (; __first != __last; ++__first)
 if (!(*__first == __value))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 923 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {






                                                     ;

      for (; __first != __last; ++__first)
 if (!bool(__pred(*__first)))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 1098 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {





                                                     ;

      __first = std::find(__first, __last, __value);
      if(__first == __last)
        return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for(; __first != __last; ++__first)
        if(!(*__first == __value))
          {
            *__result = (*__first);
            ++__result;
          }
      return __result;
    }
# 1141 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      __first = std::find_if(__first, __last, __pred);
      if(__first == __last)
        return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for(; __first != __last; ++__first)
        if(!bool(__pred(*__first)))
          {
            *__result = (*__first);
            ++__result;
          }
      return __result;
    }
# 1181 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {





                                                     ;


      __first = std::adjacent_find(__first, __last);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!(*__dest == *__first))
   *++__dest = (*__first);
      return ++__dest;
    }
# 1221 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
           _BinaryPredicate __binary_pred)
    {






                                                     ;


      __first = std::adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!bool(__binary_pred(*__dest, *__first)))
   *++__dest = (*__first);
      return ++__dest;
    }






  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result,
    forward_iterator_tag, output_iterator_tag)
    {

      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!(*__first == *__next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }






  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result,
    input_iterator_tag, output_iterator_tag)
    {

      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!(__value == *__first))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }






  template<typename _InputIterator, typename _ForwardIterator>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result,
    input_iterator_tag, forward_iterator_tag)
    {

      *__result = *__first;
      while (++__first != __last)
 if (!(*__result == *__first))
   *++__result = *__first;
      return ++__result;
    }







  template<typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag)
    {





      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!bool(__binary_pred(*__first, *__next)))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag)
    {





      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!bool(__binary_pred(__value, *__first)))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag)
    {





      *__result = *__first;
      while (++__first != __last)
 if (!bool(__binary_pred(*__result, *__first)))
   *++__result = *__first;
      return ++__result;
    }






  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }






  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
# 1449 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {



                                                     ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
# 1476 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
   _OutputIterator __result)
    {





                                                     ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }





  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }


  template<typename _ForwardIterator>
    void
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle || __last == __middle)
 return;

      _ForwardIterator __first2 = __middle;
      do
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      __first2 = __middle;

      while (__first2 != __last)
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
    }


  template<typename _BidirectionalIterator>
    void
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {




      if (__first == __middle || __last == __middle)
 return;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 {
   std::iter_swap(__first, --__last);
   ++__first;
 }

      if (__first == __middle)
 std::__reverse(__middle, __last, bidirectional_iterator_tag());
      else
 std::__reverse(__first, __middle, bidirectional_iterator_tag());
    }


  template<typename _RandomAccessIterator>
    void
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {




      if (__first == __middle || __last == __middle)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      const _Distance __n = __last - __first;
      const _Distance __k = __middle - __first;
      const _Distance __l = __n - __k;

      if (__k == __l)
 {
   std::swap_ranges(__first, __middle, __middle);
   return;
 }

      const _Distance __d = std::__gcd(__n, __k);

      for (_Distance __i = 0; __i < __d; __i++)
 {
   _ValueType __tmp = (*__first);
   _RandomAccessIterator __p = __first;

   if (__k < __l)
     {
       for (_Distance __j = 0; __j < __l / __d; __j++)
  {
    if (__p > __first + __l)
      {
        *__p = (*(__p - __l));
        __p -= __l;
      }

    *__p = (*(__p + __k));
    __p += __k;
  }
     }
   else
     {
       for (_Distance __j = 0; __j < __k / __d - 1; __j ++)
  {
    if (__p < __last - __k)
      {
        *__p = (*(__p + __k));
        __p += __k;
      }
    *__p = (*(__p - __l));
    __p -= __l;
  }
     }

   *__p = (__tmp);
   ++__first;
 }
    }
# 1669 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline void
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {



                                                       ;
                                                      ;

      typedef typename iterator_traits<_ForwardIterator>::iterator_category
 _IterType;
      std::__rotate(__first, __middle, __last, _IterType());
    }
# 1703 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                _ForwardIterator __last, _OutputIterator __result)
    {




                                                       ;
                                                      ;

      return std::copy(__first, __middle,
                       std::copy(__middle, __last, __result));
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred, forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     std::iter_swap(__first, __next);
     ++__first;
   }

      return __first;
    }


  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred, bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!bool(__pred(*__last)))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }




  template<typename _ForwardIterator, typename _Predicate, typename _Distance>
    _ForwardIterator
    __inplace_stable_partition(_ForwardIterator __first,
          _ForwardIterator __last,
          _Predicate __pred, _Distance __len)
    {
      if (__len == 1)
 return __pred(*__first) ? __last : __first;
      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __begin = std::__inplace_stable_partition(__first,
         __middle,
         __pred,
         __len / 2);
      _ForwardIterator __end = std::__inplace_stable_partition(__middle, __last,
              __pred,
              __len
              - __len / 2);
      std::rotate(__begin, __middle, __end);
      std::advance(__begin, std::distance(__middle, __end));
      return __begin;
    }


  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;
   for (; __first != __last; ++__first)
     if (__pred(*__first))
       {
  *__result1 = *__first;
  ++__result1;
       }
     else
       {
  *__result2 = *__first;
  ++__result2;
       }
   std::copy(__buffer, __result2, __result1);
   return __result1;
 }
      else
 {
   _ForwardIterator __middle = __first;
   std::advance(__middle, __len / 2);
   _ForwardIterator __begin =
     std::__stable_partition_adaptive(__first, __middle, __pred,
          __len / 2, __buffer,
          __buffer_size);
   _ForwardIterator __end =
     std::__stable_partition_adaptive(__middle, __last, __pred,
          __len - __len / 2,
          __buffer, __buffer_size);
   std::rotate(__begin, __middle, __end);
   std::advance(__begin, std::distance(__middle, __end));
   return __begin;
 }
    }
# 1861 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      if (__first == __last)
 return __first;
      else
 {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;
   typedef typename iterator_traits<_ForwardIterator>::difference_type
     _DistanceType;

   _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first,
        __last);
 if (__buf.size() > 0)
   return
     std::__stable_partition_adaptive(__first, __last, __pred,
       _DistanceType(__buf.requested_size()),
       __buf.begin(),
       _DistanceType(__buf.size()));
 else
   return
     std::__inplace_stable_partition(__first, __last, __pred,
      _DistanceType(__buf.requested_size()));
 }
    }


  template<typename _RandomAccessIterator>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last)
    {
      std::make_heap(__first, __middle);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (*__i < *__first)
   std::__pop_heap(__first, __middle, __i);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp)
    {
      std::make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(*__i, *__first))
   std::__pop_heap(__first, __middle, __i, __comp);
    }
# 1943 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
# 1963 "/usr/include/c++/4.4/bits/stl_algo.h" 3
                                                     ;
                                                                   ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last);
      while (__first != __last)
 {
   if (*__first < *__result_first)
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first));
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last);
      return __result_real_last;
    }
# 2009 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
# 2033 "/usr/include/c++/4.4/bits/stl_algo.h" 3
                                                     ;
                                                                   ;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(*__first, *__result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first),
          __comp);
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }


  template<typename _RandomAccessIterator, typename _Tp>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last, _Tp __val)
    {
      _RandomAccessIterator __next = __last;
      --__next;
      while (__val < *__next)
 {
   *__last = *__next;
   __last = __next;
   --__next;
 }
      *__last = __val;
    }


  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last, _Tp __val,
         _Compare __comp)
    {
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, *__next))
 {
   *__last = *__next;
   __last = __next;
   --__next;
 }
      *__last = __val;
    }


  template<typename _RandomAccessIterator>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last)
    {
      if (__first == __last)
 return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   typename iterator_traits<_RandomAccessIterator>::value_type
     __val = *__i;
   if (__val < *__first)
     {
       std::copy_backward(__first, __i, __i + 1);
       *__first = __val;
     }
   else
     std::__unguarded_linear_insert(__i, __val);
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   typename iterator_traits<_RandomAccessIterator>::value_type
     __val = *__i;
   if (__comp(__val, *__first))
     {
       std::copy_backward(__first, __i, __i + 1);
       *__first = __val;
     }
   else
     std::__unguarded_linear_insert(__i, __val, __comp);
 }
    }


  template<typename _RandomAccessIterator>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, _ValueType(*__i));
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, _ValueType(*__i), __comp);
    }





  enum { _S_threshold = 16 };


  template<typename _RandomAccessIterator>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold));
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last);
 }
      else
 std::__insertion_sort(__first, __last);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }


  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Tp __pivot)
    {
      while (true)
 {
   while (*__first < __pivot)
     ++__first;
   --__last;
   while (__pivot < *__last)
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     _Tp __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(*__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, *__last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator, typename _Size>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last
          - 1))));
   std::__introsort_loop(__cut, __last, __depth_limit);
   __last = __cut;
 }
    }


  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last - 1),
        __comp)),
           __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }


  template<typename _Size>
    inline _Size
    __lg(_Size __n)
    {
      _Size __k;
      for (__k = 0; __n != 0; __n >>= 1)
 ++__k;
      return __k - 1;
    }

  inline int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }



  template<typename _RandomAccessIterator, typename _Size>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last);


       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last
          - 1))));
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last, __comp);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition(__first, __last,
           _ValueType(std::__median(*__first,
        *(__first
          + (__last
             - __first)
          / 2),
        *(__last - 1),
        __comp)),
           __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
# 2418 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;




                                                                  ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 2469 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;






                    ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 2518 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;




                                                                  ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__val < *__middle)
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2569 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;






                    ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2624 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;





                                                                  ;
                                                                  ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__val < *__middle)
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2686 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val,
  _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;
# 2704 "/usr/include/c++/4.4/bits/stl_algo.h" 3
                    ;

                    ;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val, __comp);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val, __comp);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2747 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




                                                                  ;
                                                                  ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val);
      return __i != __last && !(__val < *__i);
    }
# 2780 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;






                    ;

                    ;

      _ForwardIterator __i = std::lower_bound(__first, __last, __val, __comp);
      return __i != __last && !bool(__comp(__val, *__i));
    }




  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (*__last2 < *__last1)
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(*__last2, *__last1))
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   __buffer_end = std::copy(__middle, __last, __buffer);
   std::copy_backward(__first, __middle, __last);
   return std::copy(__buffer, __buffer_end, __first);
 }
      else if (__len1 <= __buffer_size)
 {
   __buffer_end = std::copy(__first, __middle, __buffer);
   std::copy(__middle, __last, __first);
   return std::copy_backward(__buffer, __buffer_end, __last);
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::merge(__buffer, __buffer_end, __middle, __last,
    __first);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__merge_backward(__first, __middle, __buffer,
    __buffer_end, __last);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last,
           *__first_cut);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle,
          *__second_cut);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer, __buffer_size);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer, typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__first, __middle, __buffer);
   std::merge(__buffer, __buffer_end, __middle, __last,
    __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::copy(__middle, __last, __buffer);
   std::__merge_backward(__first, __middle, __buffer, __buffer_end,
    __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last, *__first_cut,
           __comp);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle, *__second_cut,
          __comp);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (*__middle < *__first)
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22);
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
                           _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (__comp(*__middle, *__first))
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut,
       __comp);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut,
      __comp);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }
# 3128 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;





                                                  ;
                                                 ;

      if (__first == __middle || __middle == __last)
 return;

      _DistanceType __len1 = std::distance(__first, __middle);
      _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1, __len2);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()));
    }
# 3183 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;






                                                               ;
                                                              ;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1,
        __len2, __comp);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()),
         __comp);
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result,
        _Distance __step_size)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::merge(__first, __first + __step_size,
        __first + __step_size,
        __first + __two_step,
        __result);
   __first += __two_step;
 }

      __step_size = std::min(_Distance(__last - __first), __step_size);
      std::merge(__first, __first + __step_size,
       __first + __step_size, __last,
       __result);
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::merge(__first, __first + __step_size,
    __first + __step_size, __first + __two_step,
    __result,
    __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::merge(__first, __first + __step_size,
       __first + __step_size, __last, __result, __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Pointer>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer, __step_size);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle,
          __buffer, __buffer_size);
   std::__stable_sort_adaptive(__middle, __last,
          __buffer, __buffer_size);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer);
   std::__merge_sort_with_buffer(__middle, __last, __buffer);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size);
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size,
                           _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }


  template<typename _RandomAccessIterator>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle);
      std::__inplace_stable_sort(__middle, __last);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
# 3468 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;






                                                                ;
                                                                ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first2 < *__first1)
   return false;
 else if(*__first1 < *__first2)
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 3517 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 3536 "/usr/include/c++/4.4/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first2, *__first1))
   return false;
 else if(__comp(*__first1, *__first2))
   ++__first1;
 else
   ++__first1, ++__first2;

      return __first2 == __last2;
    }
# 3572 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {





                                                     ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__i < *__ii)
     {
       _BidirectionalIterator __j = __last;
       while (!(*__i < *--__j))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3629 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {






                                                     ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__i, *__ii))
     {
       _BidirectionalIterator __j = __last;
       while (!bool(__comp(*__i, *--__j)))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3685 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {





                                                     ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__ii < *__i)
     {
       _BidirectionalIterator __j = __last;
       while (!(*--__j < *__i))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3742 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {






                                                     ;

      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__ii, *__i))
     {
       _BidirectionalIterator __j = __last;
       while (!bool(__comp(*--__j, *__i)))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
# 3802 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {






                                                     ;

      for (; __first != __last; ++__first, ++__result)
 if (*__first == __old_value)
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 3839 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {






                                                     ;

      for (; __first != __last; ++__first, ++__result)
 if (__pred(*__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 4176 "/usr/include/c++/4.4/bits/stl_algo.h" 3
}

namespace std __attribute__ ((__visibility__ ("default"))) {
# 4192 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {


                                                     ;
      for (; __first != __last; ++__first)
 __f(*__first);
      return __f;
    }
# 4213 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {




                                                     ;
      return std::__find(__first, __last, __val,
           std::__iterator_category(__first));
    }
# 4237 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {




                                                     ;
      return std::__find_if(__first, __last, __pred,
       std::__iterator_category(__first));
    }
# 4266 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {






                                                       ;
                                                       ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
# 4305 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {






                                                       ;
                                                       ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
# 4337 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (*__first == *__next)
     return __first;
   __first = __next;
 }
      return __last;
    }
# 4369 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {





                                                     ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (__binary_pred(*__first, *__next))
     return __first;
   __first = __next;
 }
      return __last;
    }
# 4401 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {




                                                     ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (*__first == __value)
   ++__n;
      return __n;
    }
# 4426 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {




                                                     ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(*__first))
   ++__n;
      return __n;
    }
# 4466 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {






                                                       ;
                                                       ;


      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::find(__first1, __last1, *__first2);


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   __first1 = std::find(__first1, __last1, *__first2);
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (*__current == *__p)
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 4537 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {






                                                       ;
                                                       ;


      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 {
   while (__first1 != __last1
   && !bool(__predicate(*__first1, *__first2)))
     ++__first1;
   return __first1;
 }


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   while (__first1 != __last1
   && !bool(__predicate(*__first1, *__first2)))
     ++__first1;
   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(*__current, *__p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
# 4611 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {




                                                     ;

      if (__count <= 0)
 return __first;
      if (__count == 1)
 return std::find(__first, __last, __val);
      return std::__search_n(__first, __last, __count, __val,
        std::__iterator_category(__first));
    }
# 4647 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {




                                                     ;

      if (__count <= 0)
 return __first;
      if (__count == 1)
 {
   while (__first != __last && !bool(__binary_pred(*__first, __val)))
     ++__first;
   return __first;
 }
      return std::__search_n(__first, __last, __count, __val, __binary_pred,
        std::__iterator_category(__first));
    }
# 4689 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {





                                                     ;

      for (; __first != __last; ++__first, ++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
# 4725 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {






                                                       ;

      for (; __first1 != __last1; ++__first1, ++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 4758 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {







                                                     ;

      for (; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
# 4790 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {







                                                     ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
# 4822 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {




                                                     ;

      for (; __first != __last; ++__first)
 *__first = __gen();
    }
# 4850 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {





      for (; __n > 0; --__n, ++__first)
 *__first = __gen();
      return __first;
    }
# 4886 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {






                                                     ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4925 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {




                                                     ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result, __binary_pred,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4957 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {



                                                     ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   std::iter_swap(__i, __first + (std::rand() % ((__i - __first) + 1)));
    }
# 4985 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _RandomNumberGenerator& __rand)
    {



                                                     ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __rand((__i - __first) + 1));
    }
# 5017 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {





                                                     ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }
# 5051 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                       ;
                                                      ;

      std::__heap_select(__first, __middle, __last);
      std::sort_heap(__first, __middle);
    }
# 5090 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;






                                                       ;
                                                      ;

      std::__heap_select(__first, __middle, __last, __comp);
      std::sort_heap(__first, __middle, __comp);
    }
# 5128 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                    ;
                                                   ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2);
    }
# 5167 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;






                                                    ;
                                                   ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2, __comp);
    }
# 5205 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;





                                                     ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2);
   std::__final_insertion_sort(__first, __last);
 }
    }
# 5241 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;






                                                     ;

      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2, __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }
# 5282 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5302 "/usr/include/c++/4.4/bits/stl_algo.h" 3
                                                                ;
                                                                ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5345 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5366 "/usr/include/c++/4.4/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5405 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;





                                                     ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()));
    }
# 5447 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;







                                                     ;

      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()), __comp);
    }
# 5493 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5514 "/usr/include/c++/4.4/bits/stl_algo.h" 3
                                                                ;
                                                                ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first1 < *__first2)
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5560 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5583 "/usr/include/c++/4.4/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first1, *__first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
# 5627 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5646 "/usr/include/c++/4.4/bits/stl_algo.h" 3
                                                                ;
                                                                ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   ++__first1;
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 5684 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5705 "/usr/include/c++/4.4/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   ++__first1;
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 5742 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5761 "/usr/include/c++/4.4/bits/stl_algo.h" 3
                                                                ;
                                                                ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 5803 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5824 "/usr/include/c++/4.4/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 5861 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5882 "/usr/include/c++/4.4/bits/stl_algo.h" 3
                                                                ;
                                                                ;

      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2, std::copy(__first1,
          __last1, __result));
    }
# 5927 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
# 5951 "/usr/include/c++/4.4/bits/stl_algo.h" 3
                                                                             ;
                                                                             ;

      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5984 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__first < *__result)
   __result = __first;
      return __result;
    }
# 6012 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {





                                                     ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__first, *__result))
   __result = __first;
      return __result;
    }
# 6040 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {




                                                     ;

      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__result < *__first)
   __result = __first;
      return __result;
    }
# 6068 "/usr/include/c++/4.4/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {





                                                     ;

      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__result, *__first))
   __result = __first;
      return __result;
    }

}
# 62 "/usr/include/c++/4.4/algorithm" 2 3
# 20 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/array.hh" 2


# 1 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/deprecated.hh" 1
# 23 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/array.hh" 2

namespace Dune
{
# 39 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/array.hh"
  template<class T, size_t N>
  class array {
  public:


      typedef T value_type;


      typedef value_type& reference;


      typedef const value_type& const_reference;


      typedef value_type* iterator;


      typedef const value_type* const_iterator;


      typedef std::size_t size_type;


      typedef std::ptrdiff_t difference_type;


      typedef std::reverse_iterator<iterator> reverse_iterator;


      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;


      size_type size() const {return N;}


      array<T,N>& operator= (const T& t)
      {
          fill(t);
          return (*this);
      }


      void assign(const T& t) __attribute__((deprecated))
      {
          fill(t);
      }


      void fill(const T& t)
      {
          for (size_type i=0; i<N; i++) a[i]=t;
      }


      reference operator[] (size_type i)
      {
          return a[i];
      }


      const_reference operator[] (size_type i) const
      {
          return a[i];
      }

      iterator begin ()
      {
        return a;
      }

      const_iterator begin () const
      {
        return a;
      }

      iterator end ()
      {
        return a + N;
      }

      const_iterator end () const
      {
        return a + N;
      }

      T a[(N > 0) ? N : 1];
  };






  template< class T, size_t N >
  inline bool operator< ( const array< T, N > &a, const array< T, N > &b )
  {
    return std::lexicographical_compare( a.begin(), a.end(), b.begin(), b.end() );
  }

  template< class T, size_t N >
  inline bool operator> ( const array< T, N > &a, const array< T, N > &b )
  {
    return b < a;
  }

  template< class T, size_t N >
  inline bool operator<= ( const array< T, N > &a, const array< T, N > &b )
  {
    return !(a > b);
  }

  template< class T, size_t N >
  inline bool operator>= ( const array< T, N > &a, const array< T, N > &b )
  {
    return !(a < b);
  }



  template < class T, size_t N >
  inline std::ostream& operator<< (std::ostream& s, const array<T,N>& e)
  {
    s << "[";
    for (size_t i=0; i<N-1; i++) s << e[i] << ",";
    s << e[N-1] << "]";
    return s;
  }


  template<class T>
  array<T, 1> make_array(const T &t0) {
    array<T, 1> result = { t0 };
    return result;
  }

  template<class T>
  array<T, 2> make_array(const T &t0, const T &t1) {
    array<T, 2> result = { t0, t1 };
    return result;
  }

  template<class T>
  array<T, 3> make_array(const T &t0, const T &t1, const T &t2) {
    array<T, 3> result = { t0, t1, t2 };
    return result;
  }

  template<class T>
  array<T, 4> make_array(const T &t0, const T &t1, const T &t2, const T &t3) {
    array<T, 4> result = { t0, t1, t2, t3 };
    return result;
  }

  template<class T>
  array<T, 5> make_array(const T &t0, const T &t1, const T &t2, const T &t3,
                         const T &t4)
  {
    array<T, 5> result = { t0, t1, t2, t3, t4 };
    return result;
  }

  template<class T>
  array<T, 6> make_array(const T &t0, const T &t1, const T &t2, const T &t3,
                         const T &t4, const T &t5)
  {
    array<T, 6> result = { t0, t1, t2, t3, t4, t5 };
    return result;
  }

  template<class T>
  array<T, 7> make_array(const T &t0, const T &t1, const T &t2, const T &t3,
                         const T &t4, const T &t5, const T &t6)
  {
    array<T, 7> result = { t0, t1, t2, t3, t4, t5, t6 };
    return result;
  }

  template<class T>
  array<T, 8> make_array(const T &t0, const T &t1, const T &t2, const T &t3,
                         const T &t4, const T &t5, const T &t6, const T &t7)
  {
    array<T, 8> result = { t0, t1, t2, t3, t4, t5, t6, t7 };
    return result;
  }

  template<class T>
  array<T, 9> make_array(const T &t0, const T &t1, const T &t2, const T &t3,
                         const T &t4, const T &t5, const T &t6, const T &t7,
                         const T &t8)
  {
    array<T, 9> result = { t0, t1, t2, t3, t4, t5, t6, t7, t8 };
    return result;
  }
# 241 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/array.hh"
  template<class T>
  array<T, 10> make_array(const T &t0, const T &t1, const T &t2, const T &t3,
                          const T &t4, const T &t5, const T &t6, const T &t7,
                          const T &t8, const T &t9)
  {
    array<T, 10> result = { t0, t1, t2, t3, t4, t5, t6, t7, t8, t9 };
    return result;
  }



}
# 15 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fvector.hh" 2
# 1 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densevector.hh" 1





# 1 "/usr/include/c++/4.4/limits" 1 3
# 41 "/usr/include/c++/4.4/limits" 3
# 41 "/usr/include/c++/4.4/limits" 3
# 145 "/usr/include/c++/4.4/limits" 3
namespace std __attribute__ ((__visibility__ ("default"))) {






  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 187 "/usr/include/c++/4.4/limits" 3
  struct __numeric_limits_base
  {


    static const bool is_specialized = false;




    static const int digits = 0;

    static const int digits10 = 0;

    static const bool is_signed = false;



    static const bool is_integer = false;




    static const bool is_exact = false;


    static const int radix = 0;



    static const int min_exponent = 0;


    static const int min_exponent10 = 0;



    static const int max_exponent = 0;


    static const int max_exponent10 = 0;


    static const bool has_infinity = false;


    static const bool has_quiet_NaN = false;


    static const bool has_signaling_NaN = false;

    static const float_denorm_style has_denorm = denorm_absent;


    static const bool has_denorm_loss = false;



    static const bool is_iec559 = false;



    static const bool is_bounded = false;




    static const bool is_modulo = false;


    static const bool traps = false;

    static const bool tinyness_before = false;



    static const float_round_style round_style = round_toward_zero;
  };
# 276 "/usr/include/c++/4.4/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static _Tp min() throw() { return static_cast<_Tp>(0); }

      static _Tp max() throw() { return static_cast<_Tp>(0); }


      static _Tp epsilon() throw() { return static_cast<_Tp>(0); }

      static _Tp round_error() throw() { return static_cast<_Tp>(0); }

      static _Tp infinity() throw() { return static_cast<_Tp>(0); }

      static _Tp quiet_NaN() throw() { return static_cast<_Tp>(0); }


      static _Tp signaling_NaN() throw() { return static_cast<_Tp>(0); }



      static _Tp denorm_min() throw() { return static_cast<_Tp>(0); }
    };





  template<>
    struct numeric_limits<bool>
    {
      static const bool is_specialized = true;

      static bool min() throw()
      { return false; }
      static bool max() throw()
      { return true; }

      static const int digits = 1;
      static const int digits10 = 0;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static bool epsilon() throw()
      { return false; }
      static bool round_error() throw()
      { return false; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static bool infinity() throw()
      { return false; }
      static bool quiet_NaN() throw()
      { return false; }
      static bool signaling_NaN() throw()
      { return false; }
      static bool denorm_min() throw()
      { return false; }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;




      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static const bool is_specialized = true;

      static char min() throw()
      { return (((char)(-1) < 0) ? (char)1 << (sizeof(char) * 8 - ((char)(-1) < 0)) : (char)0); }
      static char max() throw()
      { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }

      static const int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static const int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = ((char)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static char epsilon() throw()
      { return 0; }
      static char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static char infinity() throw()
      { return char(); }
      static char quiet_NaN() throw()
      { return char(); }
      static char signaling_NaN() throw()
      { return char(); }
      static char denorm_min() throw()
      { return static_cast<char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static const bool is_specialized = true;

      static signed char min() throw()
      { return -127 - 1; }
      static signed char max() throw()
      { return 127; }

      static const int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static const int digits10 = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static signed char epsilon() throw()
      { return 0; }
      static signed char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static signed char infinity() throw()
      { return static_cast<signed char>(0); }
      static signed char quiet_NaN() throw()
      { return static_cast<signed char>(0); }
      static signed char signaling_NaN() throw()
      { return static_cast<signed char>(0); }
      static signed char denorm_min() throw()
      { return static_cast<signed char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static const bool is_specialized = true;

      static unsigned char min() throw()
      { return 0; }
      static unsigned char max() throw()
      { return 127 * 2U + 1; }

      static const int digits = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned char epsilon() throw()
      { return 0; }
      static unsigned char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned char infinity() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char quiet_NaN() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char signaling_NaN() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char denorm_min() throw()
      { return static_cast<unsigned char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static const bool is_specialized = true;

      static wchar_t min() throw()
      { return (((wchar_t)(-1) < 0) ? (wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) : (wchar_t)0); }
      static wchar_t max() throw()
      { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }

      static const int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static const int digits10 = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = ((wchar_t)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static wchar_t epsilon() throw()
      { return 0; }
      static wchar_t round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static wchar_t infinity() throw()
      { return wchar_t(); }
      static wchar_t quiet_NaN() throw()
      { return wchar_t(); }
      static wchar_t signaling_NaN() throw()
      { return wchar_t(); }
      static wchar_t denorm_min() throw()
      { return wchar_t(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
# 668 "/usr/include/c++/4.4/limits" 3
  template<>
    struct numeric_limits<short>
    {
      static const bool is_specialized = true;

      static short min() throw()
      { return -32767 - 1; }
      static short max() throw()
      { return 32767; }

      static const int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static const int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static short epsilon() throw()
      { return 0; }
      static short round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static short infinity() throw()
      { return short(); }
      static short quiet_NaN() throw()
      { return short(); }
      static short signaling_NaN() throw()
      { return short(); }
      static short denorm_min() throw()
      { return short(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static const bool is_specialized = true;

      static unsigned short min() throw()
      { return 0; }
      static unsigned short max() throw()
      { return 32767 * 2U + 1; }

      static const int digits = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned short epsilon() throw()
      { return 0; }
      static unsigned short round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned short infinity() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short quiet_NaN() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short signaling_NaN() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short denorm_min() throw()
      { return static_cast<unsigned short>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static const bool is_specialized = true;

      static int min() throw()
      { return -2147483647 - 1; }
      static int max() throw()
      { return 2147483647; }

      static const int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static const int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static int epsilon() throw()
      { return 0; }
      static int round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static int infinity() throw()
      { return static_cast<int>(0); }
      static int quiet_NaN() throw()
      { return static_cast<int>(0); }
      static int signaling_NaN() throw()
      { return static_cast<int>(0); }
      static int denorm_min() throw()
      { return static_cast<int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static const bool is_specialized = true;

      static unsigned int min() throw()
      { return 0; }
      static unsigned int max() throw()
      { return 2147483647 * 2U + 1; }

      static const int digits = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned int epsilon() throw()
      { return 0; }
      static unsigned int round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned int infinity() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int quiet_NaN() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int signaling_NaN() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int denorm_min() throw()
      { return static_cast<unsigned int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static const bool is_specialized = true;

      static long min() throw()
      { return -9223372036854775807L - 1; }
      static long max() throw()
      { return 9223372036854775807L; }

      static const int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static const int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long epsilon() throw()
      { return 0; }
      static long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static long infinity() throw()
      { return static_cast<long>(0); }
      static long quiet_NaN() throw()
      { return static_cast<long>(0); }
      static long signaling_NaN() throw()
      { return static_cast<long>(0); }
      static long denorm_min() throw()
      { return static_cast<long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static const bool is_specialized = true;

      static unsigned long min() throw()
      { return 0; }
      static unsigned long max() throw()
      { return 9223372036854775807L * 2UL + 1; }

      static const int digits = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long epsilon() throw()
      { return 0; }
      static unsigned long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long infinity() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long quiet_NaN() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long signaling_NaN() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long denorm_min() throw()
      { return static_cast<unsigned long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static const bool is_specialized = true;

      static long long min() throw()
      { return -9223372036854775807LL - 1; }
      static long long max() throw()
      { return 9223372036854775807LL; }

      static const int digits = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static const int digits10 = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long long epsilon() throw()
      { return 0; }
      static long long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static long long infinity() throw()
      { return static_cast<long long>(0); }
      static long long quiet_NaN() throw()
      { return static_cast<long long>(0); }
      static long long signaling_NaN() throw()
      { return static_cast<long long>(0); }
      static long long denorm_min() throw()
      { return static_cast<long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static const bool is_specialized = true;

      static unsigned long long min() throw()
      { return 0; }
      static unsigned long long max() throw()
      { return 9223372036854775807LL * 2ULL + 1; }

      static const int digits = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643 / 2136);
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long long epsilon() throw()
      { return 0; }
      static unsigned long long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long long infinity() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long quiet_NaN() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long signaling_NaN() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long denorm_min() throw()
      { return static_cast<unsigned long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<float>
    {
      static const bool is_specialized = true;

      static float min() throw()
      { return 1.17549435e-38F; }
      static float max() throw()
      { return 3.40282347e+38F; }

      static const int digits = 24;
      static const int digits10 = 6;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static float epsilon() throw()
      { return 1.19209290e-7F; }
      static float round_error() throw()
      { return 0.5F; }

      static const int min_exponent = (-125);
      static const int min_exponent10 = (-37);
      static const int max_exponent = 128;
      static const int max_exponent10 = 38;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;

      static float infinity() throw()
      { return __builtin_huge_valf (); }
      static float quiet_NaN() throw()
      { return __builtin_nanf (""); }
      static float signaling_NaN() throw()
      { return __builtin_nansf (""); }
      static float denorm_min() throw()
      { return 1.40129846e-45F; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static const bool is_specialized = true;

      static double min() throw()
      { return 2.2250738585072014e-308; }
      static double max() throw()
      { return 1.7976931348623157e+308; }

      static const int digits = 53;
      static const int digits10 = 15;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static double epsilon() throw()
      { return 2.2204460492503131e-16; }
      static double round_error() throw()
      { return 0.5; }

      static const int min_exponent = (-1021);
      static const int min_exponent10 = (-307);
      static const int max_exponent = 1024;
      static const int max_exponent10 = 308;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;

      static double infinity() throw()
      { return __builtin_huge_val(); }
      static double quiet_NaN() throw()
      { return __builtin_nan (""); }
      static double signaling_NaN() throw()
      { return __builtin_nans (""); }
      static double denorm_min() throw()
      { return 4.9406564584124654e-324; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static const bool is_specialized = true;

      static long double min() throw()
      { return 3.36210314311209350626e-4932L; }
      static long double max() throw()
      { return 1.18973149535723176502e+4932L; }

      static const int digits = 64;
      static const int digits10 = 18;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static long double epsilon() throw()
      { return 1.08420217248550443401e-19L; }
      static long double round_error() throw()
      { return 0.5L; }

      static const int min_exponent = (-16381);
      static const int min_exponent10 = (-4931);
      static const int max_exponent = 16384;
      static const int max_exponent10 = 4932;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
 = false;

      static long double infinity() throw()
      { return __builtin_huge_vall (); }
      static long double quiet_NaN() throw()
      { return __builtin_nanl (""); }
      static long double signaling_NaN() throw()
      { return __builtin_nansl (""); }
      static long double denorm_min() throw()
      { return 3.64519953188247460253e-4951L; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };





}
# 7 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densevector.hh" 2

# 1 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/genericiterator.hh" 1




# 1 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/iteratorfacades.hh" 1



# 1 "/usr/include/c++/4.4/iterator" 1 3
# 58 "/usr/include/c++/4.4/iterator" 3
# 58 "/usr/include/c++/4.4/iterator" 3


# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 61 "/usr/include/c++/4.4/iterator" 2 3





# 1 "/usr/include/c++/4.4/bits/stream_iterator.h" 1 3
# 33 "/usr/include/c++/4.4/bits/stream_iterator.h" 3
# 33 "/usr/include/c++/4.4/bits/stream_iterator.h" 3



namespace std __attribute__ ((__visibility__ ("default"))) {


  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT>, typename _Dist = ptrdiff_t>
    class istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Dist, const _Tp*, const _Tp&>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_istream<_CharT, _Traits> istream_type;

    private:
      istream_type* _M_stream;
      _Tp _M_value;
      bool _M_ok;

    public:

      istream_iterator()
      : _M_stream(0), _M_value(), _M_ok(false) {}


      istream_iterator(istream_type& __s)
      : _M_stream(&__s)
      { _M_read(); }

      istream_iterator(const istream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_value(__obj._M_value),
        _M_ok(__obj._M_ok)
      { }

      const _Tp&
      operator*() const
      {


                        ;
 return _M_value;
      }

      const _Tp*
      operator->() const { return &(operator*()); }

      istream_iterator&
      operator++()
      {


                        ;
 _M_read();
 return *this;
      }

      istream_iterator
      operator++(int)
      {


                        ;
 istream_iterator __tmp = *this;
 _M_read();
 return __tmp;
      }

      bool
      _M_equal(const istream_iterator& __x) const
      { return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream); }

    private:
      void
      _M_read()
      {
 _M_ok = (_M_stream && *_M_stream) ? true : false;
 if (_M_ok)
   {
     *_M_stream >> _M_value;
     _M_ok = *_M_stream ? true : false;
   }
      }
    };


  template<typename _Tp, typename _CharT, typename _Traits, typename _Dist>
    inline bool
    operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return __x._M_equal(__y); }


  template <class _Tp, class _CharT, class _Traits, class _Dist>
    inline bool
    operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return !__x._M_equal(__y); }
# 144 "/usr/include/c++/4.4/bits/stream_iterator.h" 3
  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT> >
    class ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:


      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


    private:
      ostream_type* _M_stream;
      const _CharT* _M_string;

    public:

      ostream_iterator(ostream_type& __s) : _M_stream(&__s), _M_string(0) {}
# 175 "/usr/include/c++/4.4/bits/stream_iterator.h" 3
      ostream_iterator(ostream_type& __s, const _CharT* __c)
      : _M_stream(&__s), _M_string(__c) { }


      ostream_iterator(const ostream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_string(__obj._M_string) { }



      ostream_iterator&
      operator=(const _Tp& __value)
      {


                        ;
 *_M_stream << __value;
 if (_M_string) *_M_stream << _M_string;
 return *this;
      }

      ostream_iterator&
      operator*()
      { return *this; }

      ostream_iterator&
      operator++()
      { return *this; }

      ostream_iterator&
      operator++(int)
      { return *this; }
    };

}
# 67 "/usr/include/c++/4.4/iterator" 2 3
# 5 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/iteratorfacades.hh" 2
# 1 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/typetraits.hh" 1








# 1 "/usr/include/c++/4.4/tr1/type_traits" 1 3
# 32 "/usr/include/c++/4.4/tr1/type_traits" 3
# 32 "/usr/include/c++/4.4/tr1/type_traits" 3





# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 38 "/usr/include/c++/4.4/tr1/type_traits" 2 3








# 1 "/usr/include/c++/4.4/tr1_impl/type_traits" 1 3
# 30 "/usr/include/c++/4.4/tr1_impl/type_traits" 3
namespace std
{
namespace tr1 {
# 43 "/usr/include/c++/4.4/tr1_impl/type_traits" 3
  struct __sfinae_types
  {
    typedef char __one;
    typedef struct { char __arr[2]; } __two;
  };
# 66 "/usr/include/c++/4.4/tr1_impl/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static const _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
    };


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<typename _Tp, _Tp __v>
    const _Tp integral_constant<_Tp, __v>::value;


  template<typename>
    struct remove_cv;

  template<typename>
    struct __is_void_helper
    : public false_type { };
  template<> struct __is_void_helper<void> : public integral_constant<bool, true> { };




  template<typename _Tp>
    struct is_void
    : public integral_constant<bool, (__is_void_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };
  template<> struct __is_integral_helper<bool> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<char> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<signed char> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<unsigned char> : public integral_constant<bool, true> { };

  template<> struct __is_integral_helper<wchar_t> : public integral_constant<bool, true> { };





  template<> struct __is_integral_helper<short> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<unsigned short> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<int> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<unsigned int> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<long> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<unsigned long> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<long long> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<unsigned long long> : public integral_constant<bool, true> { };


  template<typename _Tp>
    struct is_integral
    : public integral_constant<bool, (__is_integral_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };
  template<> struct __is_floating_point_helper<float> : public integral_constant<bool, true> { };
  template<> struct __is_floating_point_helper<double> : public integral_constant<bool, true> { };
  template<> struct __is_floating_point_helper<long double> : public integral_constant<bool, true> { };


  template<typename _Tp>
    struct is_floating_point
    : public integral_constant<bool, (__is_floating_point_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };
  template<typename _Tp> struct __is_pointer_helper<_Tp*> : public integral_constant<bool, true> { };


  template<typename _Tp>
    struct is_pointer
    : public integral_constant<bool, (__is_pointer_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };


  template<typename _Tp>
    struct is_reference;


  template<typename _Tp>
    struct is_function;

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };
  template<typename _Tp, typename _Cp> struct __is_member_object_pointer_helper<_Tp _Cp::*> : public integral_constant<bool, !is_function<_Tp>::value> { };



  template<typename _Tp>
    struct is_member_object_pointer
    : public integral_constant<bool, (__is_member_object_pointer_helper<
          typename remove_cv<_Tp>::type>::value)>
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };
  template<typename _Tp, typename _Cp> struct __is_member_function_pointer_helper<_Tp _Cp::*> : public integral_constant<bool, is_function<_Tp>::value> { };



  template<typename _Tp>
    struct is_member_function_pointer
    : public integral_constant<bool, (__is_member_function_pointer_helper<
          typename remove_cv<_Tp>::type>::value)>
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename>
    struct is_function
    : public false_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...)>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......)>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile>
    : public true_type { };




  template<typename _Tp>
    struct is_arithmetic
    : public integral_constant<bool, (is_integral<_Tp>::value
          || is_floating_point<_Tp>::value)>
    { };


  template<typename _Tp>
    struct is_fundamental
    : public integral_constant<bool, (is_arithmetic<_Tp>::value
          || is_void<_Tp>::value)>
    { };


  template<typename _Tp>
    struct is_object
    : public integral_constant<bool, !(is_function<_Tp>::value
           || is_reference<_Tp>::value
           || is_void<_Tp>::value)>
    { };


  template<typename _Tp>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public integral_constant<bool, (is_arithmetic<_Tp>::value
          || is_enum<_Tp>::value
          || is_pointer<_Tp>::value
          || is_member_pointer<_Tp>::value)>
    { };


  template<typename _Tp>
    struct is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };


  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };
  template<typename _Tp, typename _Cp> struct __is_member_pointer_helper<_Tp _Cp::*> : public integral_constant<bool, true> { };

  template<typename _Tp>
  struct is_member_pointer
    : public integral_constant<bool, (__is_member_pointer_helper<
          typename remove_cv<_Tp>::type>::value)>
    { };



  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };


  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };


  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };


  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, __alignof__(_Tp)> { };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint = 0>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };




  template<typename, typename>
    struct is_same
    : public false_type { };

  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };




  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };




  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };



  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };

  template<typename>
    struct remove_reference;


  template<typename _Tp>
    struct add_pointer
    { typedef typename remove_reference<_Tp>::type* type; };







}
}
# 47 "/usr/include/c++/4.4/tr1/type_traits" 2 3






namespace std
{
namespace tr1
{





  template<typename>
    struct is_reference
    : public false_type { };

  template<typename _Tp>
    struct is_reference<_Tp&>
    : public true_type { };

  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp) || is_void<_Tp>::value>
    { };

  template<typename _Tp>
    struct has_trivial_constructor
    : public integral_constant<bool, is_pod<_Tp>::value>
    { };

  template<typename _Tp>
    struct has_trivial_copy
    : public integral_constant<bool, is_pod<_Tp>::value>
    { };

  template<typename _Tp>
    struct has_trivial_assign
    : public integral_constant<bool, is_pod<_Tp>::value>
    { };

  template<typename _Tp>
    struct has_trivial_destructor
    : public integral_constant<bool, is_pod<_Tp>::value>
    { };

  template<typename _Tp>
    struct has_nothrow_constructor
    : public integral_constant<bool, is_pod<_Tp>::value>
    { };

  template<typename _Tp>
    struct has_nothrow_copy
    : public integral_constant<bool, is_pod<_Tp>::value>
    { };

  template<typename _Tp>
    struct has_nothrow_assign
    : public integral_constant<bool, is_pod<_Tp>::value>
    { };

  template<typename>
    struct __is_signed_helper
    : public false_type { };
  template<> struct __is_signed_helper<signed char> : public true_type { };
  template<> struct __is_signed_helper<short> : public true_type { };
  template<> struct __is_signed_helper<int> : public true_type { };
  template<> struct __is_signed_helper<long> : public true_type { };
  template<> struct __is_signed_helper<long long> : public true_type { };

  template<typename _Tp>
    struct is_signed
    : public integral_constant<bool, (__is_signed_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };

  template<typename>
    struct __is_unsigned_helper
    : public false_type { };
  template<> struct __is_unsigned_helper<unsigned char> : public true_type { };
  template<> struct __is_unsigned_helper<unsigned short> : public true_type { };
  template<> struct __is_unsigned_helper<unsigned int> : public true_type { };
  template<> struct __is_unsigned_helper<unsigned long> : public true_type { };
  template<> struct __is_unsigned_helper<unsigned long long> : public true_type { };

  template<typename _Tp>
    struct is_unsigned
    : public integral_constant<bool, (__is_unsigned_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };

  template<typename _Base, typename _Derived>
    struct __is_base_of_helper
    {
      typedef typename remove_cv<_Base>::type _NoCv_Base;
      typedef typename remove_cv<_Derived>::type _NoCv_Derived;
      static const bool __value = (is_same<_Base, _Derived>::value
       || (__is_base_of(_Base, _Derived)
           && !is_same<_NoCv_Base,
                       _NoCv_Derived>::value));
    };

  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool,
          __is_base_of_helper<_Base, _Derived>::__value>
    { };

  template<typename _From, typename _To>
    struct __is_convertible_simple
    : public __sfinae_types
    {
    private:
      static __one __test(_To);
      static __two __test(...);
      static _From __makeFrom();

    public:
      static const bool __value = sizeof(__test(__makeFrom())) == 1;
    };

  template<typename _Tp>
    struct add_reference;

  template<typename _Tp>
    struct __is_int_or_cref
    {
      typedef typename remove_reference<_Tp>::type __rr_Tp;
      static const bool __value = (is_integral<_Tp>::value
       || (is_integral<__rr_Tp>::value
           && is_const<__rr_Tp>::value
           && !is_volatile<__rr_Tp>::value));
    };

  template<typename _From, typename _To,
    bool = (is_void<_From>::value || is_void<_To>::value
     || is_function<_To>::value || is_array<_To>::value

     || (is_floating_point<typename
         remove_reference<_From>::type>::value
         && __is_int_or_cref<_To>::__value))>
    struct __is_convertible_helper
    {

      static const bool __value = (__is_convertible_simple<typename
       add_reference<_From>::type, _To>::__value);
    };

  template<typename _From, typename _To>
    struct __is_convertible_helper<_From, _To, true>
    { static const bool __value = (is_void<_To>::value
       || (__is_int_or_cref<_To>::__value
           && !is_void<_From>::value)); };

  template<typename _From, typename _To>
    struct is_convertible
    : public integral_constant<bool,
          __is_convertible_helper<_From, _To>::__value>
    { };


  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };


  template<typename _Tp, bool = (is_void<_Tp>::value
     || is_reference<_Tp>::value)>
    struct __add_reference_helper
    { typedef _Tp& type; };

  template<typename _Tp>
    struct __add_reference_helper<_Tp, true>
    { typedef _Tp type; };

  template<typename _Tp>
    struct add_reference
    : public __add_reference_helper<_Tp>
    { };


  template<std::size_t _Len, std::size_t _Align>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };


}
}
# 10 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/typetraits.hh" 2


namespace Dune
{
# 28 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/typetraits.hh"
  struct Empty {};





  template <typename T>
  class TypeTraits
  {
  private:
    template <class U>
    struct PointerTraits {
      enum { result = false };
      typedef Empty PointeeType;
    };

    template <class U>
    struct PointerTraits<U*> {
      enum { result = true };
      typedef U PointeeType;
    };

    template <class U> struct ReferenceTraits
    {
      enum { result = false };
      typedef U ReferredType;
    };

    template <class U> struct ReferenceTraits<U&>
    {
      enum { result = true };
      typedef U ReferredType;
    };

  public:
    enum { isPointer = PointerTraits<T>::result };
    typedef typename PointerTraits<T>::PointeeType PointeeType;

    enum { isReference = ReferenceTraits<T>::result };
    typedef typename ReferenceTraits<T>::ReferredType ReferredType;
 };





  template<typename T>
  struct ConstantVolatileTraits
  {
    enum{

      isVolatile=false,

 isConst=false
 };


    typedef T UnqualifiedType;

    typedef const T ConstType;

    typedef const volatile T ConstVolatileType;
  };

  template<typename T>
  struct ConstantVolatileTraits<const T>
  {
    enum{
      isVolatile=false, isConst=true
 };
    typedef T UnqualifiedType;
    typedef const UnqualifiedType ConstType;
    typedef const volatile UnqualifiedType ConstVolatileType;
  };


  template<typename T>
  struct ConstantVolatileTraits<volatile T>
  {
    enum{
      isVolatile=true, isConst=false
 };
    typedef T UnqualifiedType;
    typedef const UnqualifiedType ConstType;
    typedef const volatile UnqualifiedType ConstVolatileType;
  };

  template<typename T>
  struct ConstantVolatileTraits<const volatile T>
  {
    enum{
      isVolatile=true, isConst=true
 };
    typedef T UnqualifiedType;
    typedef const UnqualifiedType ConstType;
    typedef const volatile UnqualifiedType ConstVolatileType;
  };


  template<typename T>
  struct IsVolatile
  {
    enum{

      value=ConstantVolatileTraits<T>::isVolatile
 };
  };


  template<typename T>
  struct IsConst
  {
    enum{

      value=ConstantVolatileTraits<T>::isConst
 };
  };

  template<typename T, bool isVolatile>
  struct RemoveConstHelper
  {
    typedef typename ConstantVolatileTraits<T>::UnqualifiedType Type;
  };

  template<typename T>
  struct RemoveConstHelper<T,true>
  {
    typedef volatile typename ConstantVolatileTraits<T>::UnqualifiedType Type;
  };




    using std::tr1::remove_const;
# 176 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/typetraits.hh"
  using std::tr1::remove_reference;
# 203 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/typetraits.hh"
  template<class From, class To>
  class Conversion
  {
    typedef char Small;
    struct Big{char dummy[2];};
    static Small test(To);
    static Big test(...);
    static typename TypeTraits< From >::ReferredType &makeFrom ();

  public:
    enum {

      exists = sizeof(test(makeFrom())) == sizeof(Small),

      isTwoWay = exists && Conversion<To,From>::exists,

      sameType = false
    };
    Conversion(){}

  };

  template <class From>
  class Conversion<From, void>
  {
  public:
    enum {
      exists = false,
      isTwoWay = false,
      sameType = false
    };
  };

  template <class To>
  class Conversion<void, To>
  {
  public:
    enum {
      exists = false,
      isTwoWay = false,
      sameType = false
    };
  };

  template<>
  class Conversion< int, double >
  {
  public:
    enum {
      exists = true,
      isTwoWay = false,
      sameType = false
    };
  };

  template<class T>
  class Conversion<T,T>{
  public:
    enum{ exists=true, isTwoWay=true, sameType=true};
  };
# 273 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/typetraits.hh"
  template <class Base, class Derived>
  class IsBaseOf
  {
    typedef typename ConstantVolatileTraits< typename TypeTraits< Base >::ReferredType >::UnqualifiedType RawBase;
    typedef typename ConstantVolatileTraits< typename TypeTraits< Derived >::ReferredType >::UnqualifiedType RawDerived;
    typedef char Small;
    struct Big{char dummy[2];};
    static Small test(RawBase*);
    static Big test(...);
    static RawDerived* &makePtr ();
  public:
    enum {

      value = sizeof(test(makePtr())) == sizeof(Small)
    };
    IsBaseOf(){}

  };







  template<class T1, class T2>
  struct IsInteroperable
  {
    enum{




      value = Conversion<T1,T2>::exists || Conversion<T2,T1>::exists
 };
  };
# 319 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/typetraits.hh"
  template<bool b, typename T=void>
  struct enable_if
  {
    typedef T type;
  };

  template<typename T>
  struct enable_if<false,T>
  {};
# 336 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/typetraits.hh"
  template<class T1, class T2, class Type>
  struct EnableIfInterOperable
    : public enable_if<IsInteroperable<T1,T2>::value, Type>
  {};




  using std::tr1::is_same;
# 376 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/typetraits.hh"
  template<bool first, class T1, class T2>
  struct SelectType
  {






    typedef T1 Type;
  };

  template<class T1, class T2>
  struct SelectType<false,T1,T2>
  {
    typedef T2 Type;
  };
# 403 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/typetraits.hh"
  using std::tr1::integral_constant;
  using std::tr1::true_type;
  using std::tr1::false_type;
# 431 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/typetraits.hh"
}
# 6 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/iteratorfacades.hh" 2

namespace Dune
{
# 133 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/iteratorfacades.hh"
  template<class T, class V, class R = V&, class D = std::ptrdiff_t>
  class ForwardIteratorFacade :
    public std::iterator< std::forward_iterator_tag,
     typename remove_const<V>::type,
     D,
     V*,
     R>
  {

  public:
# 164 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/iteratorfacades.hh"
    typedef T DerivedType;




    typedef V Value;




    typedef V* Pointer;




    typedef D DifferenceType;




    typedef R Reference;


    Reference operator*() const
    {
      return static_cast<DerivedType const*>(this)->dereference();
    }

    Pointer operator->() const
    {
      return &(static_cast<const DerivedType *>(this)->dereference());
    }


    DerivedType& operator++()
    {
      static_cast<DerivedType *>(this)->increment();
      return *static_cast<DerivedType *>(this);
    }


    DerivedType operator++(int)
    {
      DerivedType tmp(static_cast<DerivedType const&>(*this));
      this->operator++();
      return tmp;
    }
  };
# 223 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/iteratorfacades.hh"
  template<class T1, class V1, class R1, class D,
    class T2, class V2, class R2>
  inline typename EnableIfInterOperable<T1,T2,bool>::type
  operator==(const ForwardIteratorFacade<T1,V1,R1,D>& lhs,
      const ForwardIteratorFacade<T2,V2,R2,D>& rhs)
  {
    if(Conversion<T2,T1>::exists)
      return static_cast<const T1&>(lhs).equals(static_cast<const T2&>(rhs));
    else
      return static_cast<const T2&>(rhs).equals(static_cast<const T1&>(lhs));
  }
# 245 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/iteratorfacades.hh"
  template<class T1, class V1, class R1, class D,
    class T2, class V2, class R2>
  inline typename EnableIfInterOperable<T1,T2,bool>::type
  operator!=(const ForwardIteratorFacade<T1,V1,R1,D>& lhs,
      const ForwardIteratorFacade<T2,V2,R2,D>& rhs)
  {
    if(Conversion<T2,T1>::exists)
      return !static_cast<const T1&>(lhs).equals(static_cast<const T2&>(rhs));
    else
      return !static_cast<const T2&>(rhs).equals(static_cast<const T1&>(lhs));
  }





  template<class T, class V, class R = V&, class D = std::ptrdiff_t>
  class BidirectionalIteratorFacade :
    public std::iterator< std::bidirectional_iterator_tag,
     typename remove_const<V>::type,
     D,
     V*,
     R>
  {

  public:
# 296 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/iteratorfacades.hh"
    typedef T DerivedType;




    typedef V Value;




    typedef V* Pointer;




    typedef D DifferenceType;




    typedef R Reference;


    Reference operator*() const
    {
      return static_cast<DerivedType const*>(this)->dereference();
    }

    Pointer operator->() const
    {
      return &(static_cast<const DerivedType *>(this)->dereference());
    }


    DerivedType& operator++()
    {
      static_cast<DerivedType *>(this)->increment();
      return *static_cast<DerivedType *>(this);
    }


    DerivedType operator++(int)
    {
      DerivedType tmp(static_cast<DerivedType const&>(*this));
      this->operator++();
      return tmp;
    }



    DerivedType& operator--()
    {
      static_cast<DerivedType *>(this)->decrement();
      return *static_cast<DerivedType *>(this);
    }


    DerivedType operator--(int)
    {
      DerivedType tmp(static_cast<DerivedType const&>(*this));
      this->operator--();
      return tmp;
    }
  };
# 368 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/iteratorfacades.hh"
  template<class T1, class V1, class R1, class D,
    class T2, class V2, class R2>
  inline typename enable_if<Conversion<T2,T1>::exists,bool>::type
  operator==(const BidirectionalIteratorFacade<T1,V1,R1,D>& lhs,
      const BidirectionalIteratorFacade<T2,V2,R2,D>& rhs)
  {
    return static_cast<const T1&>(lhs).equals(static_cast<const T2&>(rhs));
  }
# 385 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/iteratorfacades.hh"
  template<class T1, class V1, class R1, class D,
           class T2, class V2, class R2>
  inline
  typename enable_if<Conversion<T1,T2>::exists && !Conversion<T2,T1>::exists,
                     bool>::type
  operator==(const BidirectionalIteratorFacade<T1,V1,R1,D>& lhs,
             const BidirectionalIteratorFacade<T2,V2,R2,D>& rhs)
  {
    return static_cast<const T2&>(rhs).equals(static_cast<const T1&>(lhs));
  }
# 406 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/iteratorfacades.hh"
  template<class T1, class V1, class R1, class D,
    class T2, class V2, class R2>
  inline typename EnableIfInterOperable<T1,T2,bool>::type
  operator!=(const BidirectionalIteratorFacade<T1,V1,R1,D>& lhs,
      const BidirectionalIteratorFacade<T2,V2,R2,D>& rhs)
  {
    return !(lhs == rhs);
  }





  template<class T, class V, class R = V&, class D = std::ptrdiff_t>
  class RandomAccessIteratorFacade :
    public std::iterator< std::random_access_iterator_tag,
     typename remove_const<V>::type,
     D,
     V*,
     R>
  {

  public:
# 462 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/iteratorfacades.hh"
    typedef T DerivedType;




    typedef V Value;




    typedef V* Pointer;




    typedef D DifferenceType;




    typedef R Reference;


    Reference operator*() const
    {
      return static_cast<DerivedType const*>(this)->dereference();
    }

    Pointer operator->() const
    {
      return &(static_cast<const DerivedType *>(this)->dereference());
    }






    Reference operator[](DifferenceType n) const
    {
      return static_cast<const DerivedType *>(this)->elementAt(n);
    }


    DerivedType& operator++()
    {
      static_cast<DerivedType *>(this)->increment();
      return *static_cast<DerivedType *>(this);
    }


    DerivedType operator++(int)
    {
      DerivedType tmp(static_cast<DerivedType const&>(*this));
      this->operator++();
      return tmp;
    }

    DerivedType& operator+=(DifferenceType n)
    {
      static_cast<DerivedType *>(this)->advance(n);
      return *static_cast<DerivedType *>(this);
    }

    DerivedType operator+(DifferenceType n) const
    {
      DerivedType tmp(static_cast<DerivedType const&>(*this));
      tmp.advance(n);
      return tmp;
    }



    DerivedType& operator--()
    {
      static_cast<DerivedType *>(this)->decrement();
      return *static_cast<DerivedType *>(this);
    }


    DerivedType operator--(int)
    {
      DerivedType tmp(static_cast<DerivedType const&>(*this));
      this->operator--();
      return tmp;
    }

    DerivedType& operator-=(DifferenceType n)
    {
      static_cast<DerivedType *>(this)->advance(-n);
      return *static_cast<DerivedType *>(this);
    }

    DerivedType operator-(DifferenceType n) const
    {
      DerivedType tmp(static_cast<DerivedType const&>(*this));
      tmp.advance(-n);
      return tmp;
    }


  };
# 575 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/iteratorfacades.hh"
  template<class T1, class V1, class R1, class D,
    class T2, class V2, class R2>
  inline typename EnableIfInterOperable<T1,T2,bool>::type
  operator==(const RandomAccessIteratorFacade<T1,V1,R1,D>& lhs,
      const RandomAccessIteratorFacade<T2,V2,R2,D>& rhs)
  {
    if(Conversion<T2,T1>::exists)
      return static_cast<const T1&>(lhs).equals(static_cast<const T2&>(rhs));
    else
      return static_cast<const T2&>(rhs).equals(static_cast<const T1&>(lhs));
  }
# 597 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/iteratorfacades.hh"
  template<class T1, class V1, class R1, class D,
    class T2, class V2, class R2>
  inline typename EnableIfInterOperable<T1,T2,bool>::type
  operator!=(const RandomAccessIteratorFacade<T1,V1,R1,D>& lhs,
      const RandomAccessIteratorFacade<T2,V2,R2,D>& rhs)
  {
    if(Conversion<T2,T1>::exists)
      return !static_cast<const T1&>(lhs).equals(static_cast<const T2&>(rhs));
    else
      return !static_cast<const T2&>(rhs).equals(static_cast<const T1&>(lhs));
  }
# 619 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/iteratorfacades.hh"
  template<class T1, class V1, class R1, class D,
    class T2, class V2, class R2>
  inline typename EnableIfInterOperable<T1,T2,bool>::type
  operator<(const RandomAccessIteratorFacade<T1,V1,R1,D>& lhs,
      const RandomAccessIteratorFacade<T2,V2,R2,D>& rhs)
  {
    if(Conversion<T2,T1>::exists)
      return static_cast<const T1&>(lhs).distanceTo(static_cast<const T2&>(rhs))>0;
    else
      return static_cast<const T2&>(rhs).distanceTo(static_cast<const T1&>(lhs))<0;
  }
# 642 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/iteratorfacades.hh"
  template<class T1, class V1, class R1, class D,
    class T2, class V2, class R2>
  inline typename EnableIfInterOperable<T1,T2,bool>::type
  operator<=(const RandomAccessIteratorFacade<T1,V1,R1,D>& lhs,
      const RandomAccessIteratorFacade<T2,V2,R2,D>& rhs)
  {
    if(Conversion<T2,T1>::exists)
      return static_cast<const T1&>(lhs).distanceTo(static_cast<const T2&>(rhs))>=0;
    else
      return static_cast<const T2&>(rhs).distanceTo(static_cast<const T1&>(lhs))<=0;
  }
# 665 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/iteratorfacades.hh"
  template<class T1, class V1, class R1, class D,
    class T2, class V2, class R2>
  inline typename EnableIfInterOperable<T1,T2,bool>::type
  operator>(const RandomAccessIteratorFacade<T1,V1,R1,D>& lhs,
      const RandomAccessIteratorFacade<T2,V2,R2,D>& rhs)
  {
    if(Conversion<T2,T1>::exists)
      return static_cast<const T1&>(lhs).distanceTo(static_cast<const T2&>(rhs))<0;
    else
      return static_cast<const T2&>(rhs).distanceTo(static_cast<const T1&>(lhs))>0;
  }
# 687 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/iteratorfacades.hh"
  template<class T1, class V1, class R1, class D,
    class T2, class V2, class R2>
  inline typename EnableIfInterOperable<T1,T2,bool>::type
  operator>=(const RandomAccessIteratorFacade<T1,V1,R1,D>& lhs,
      const RandomAccessIteratorFacade<T2,V2,R2,D>& rhs)
  {
    if(Conversion<T2,T1>::exists)
      return static_cast<const T1&>(lhs).distanceTo(static_cast<const T2&>(rhs))<=0;
    else
      return static_cast<const T2&>(rhs).distanceTo(static_cast<const T1&>(lhs))>=0;
  }
# 709 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/iteratorfacades.hh"
  template<class T1, class V1, class R1, class D,
    class T2, class V2, class R2>
  inline typename EnableIfInterOperable<T1,T2,D>::type
  operator-(const RandomAccessIteratorFacade<T1,V1,R1,D>& lhs,
      const RandomAccessIteratorFacade<T2,V2,R2,D>& rhs)
  {
    if(Conversion<T2,T1>::exists)
      return -static_cast<const T1&>(lhs).distanceTo(static_cast<const T2&>(rhs));
    else
      return static_cast<const T2&>(rhs).distanceTo(static_cast<const T1&>(lhs));
  }


}
# 6 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/genericiterator.hh" 2
# 1 "/usr/include/c++/4.4/cassert" 1 3
# 43 "/usr/include/c++/4.4/cassert" 3
# 43 "/usr/include/c++/4.4/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 68 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 45 "/usr/include/c++/4.4/cassert" 2 3
# 7 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/genericiterator.hh" 2

namespace Dune {
# 82 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/genericiterator.hh"
  template<class R>
  struct const_reference
  {
    typedef const R type;
  };

  template<class R>
  struct const_reference<const R>
  {
    typedef const R type;
  };

  template<class R>
  struct const_reference<R&>
  {
    typedef const R& type;
  };

  template<class R>
  struct const_reference<const R&>
  {
    typedef const R& type;
  };






  template<class R>
  struct mutable_reference
  {
    typedef R type;
  };

  template<class R>
  struct mutable_reference<const R>
  {
    typedef R type;
  };

  template<class R>
  struct mutable_reference<R&>
  {
    typedef R& type;
  };

  template<class R>
  struct mutable_reference<const R&>
  {
    typedef R& type;
  };
# 146 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/genericiterator.hh"
  template<class C, class T, class R=T&, class D = std::ptrdiff_t,
           template<class,class,class,class> class IteratorFacade=RandomAccessIteratorFacade>
class GenericIterator :
    public IteratorFacade<GenericIterator<C,T,R,D,IteratorFacade>,T,R,D>
{
  friend class GenericIterator<typename remove_const<C>::type, typename remove_const<T>::type, typename mutable_reference<R>::type, D, IteratorFacade>;
  friend class GenericIterator<const typename remove_const<C>::type, const typename remove_const<T>::type, typename const_reference<R>::type, D, IteratorFacade>;

  typedef GenericIterator<typename remove_const<C>::type, typename remove_const<T>::type, typename mutable_reference<R>::type, D, IteratorFacade> MutableIterator;
  typedef GenericIterator<const typename remove_const<C>::type, const typename remove_const<T>::type, typename const_reference<R>::type, D, IteratorFacade> ConstIterator;

public:
# 167 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/genericiterator.hh"
  typedef C Container;






  typedef T Value;




  typedef D DifferenceType;




  typedef R Reference;


  GenericIterator(): container_(0), position_(0)
  {}
# 197 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/genericiterator.hh"
  GenericIterator(Container& cont, DifferenceType pos)
    : container_(&cont), position_(pos)
  {}
# 208 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/genericiterator.hh"
  GenericIterator(const MutableIterator& other): container_(other.container_), position_(other.position_)
  {}
# 220 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/genericiterator.hh"
  GenericIterator(const ConstIterator& other): container_(other.container_), position_(other.position_)
  {}


  bool equals(const MutableIterator & other) const
  {
    return position_ == other.position_ && container_ == other.container_;
  }

  bool equals(const ConstIterator & other) const
  {
    return position_ == other.position_ && container_ == other.container_;
  }

  Reference dereference() const{
    return container_->operator[](position_);
  }

  void increment(){
    ++position_;
  }


  void decrement(){
    --position_;
  }


  Reference elementAt(DifferenceType i)const{
    return container_->operator[](position_+i);
  }

  void advance(DifferenceType n){
    position_=position_+n;
  }

  DifferenceType distanceTo(const MutableIterator& other)const
  {
    ((other.container_==container_) ? static_cast<void> (0) : __assert_fail ("other.container_==container_", "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/genericiterator.hh", 258, __PRETTY_FUNCTION__));
    return other.position_ - position_;
  }

  DifferenceType distanceTo(const ConstIterator& other)const
  {
    ((other.container_==container_) ? static_cast<void> (0) : __assert_fail ("other.container_==container_", "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/genericiterator.hh", 264, __PRETTY_FUNCTION__));
    return other.position_ - position_;
  }

private:
  Container *container_;
  DifferenceType position_;
};



}
# 9 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densevector.hh" 2
# 1 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/ftraits.hh" 1






namespace Dune {
# 16 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/ftraits.hh"
template<class T>
struct FieldTraits
{

 typedef T field_type;

 typedef T real_type;
};

template<class T>
struct FieldTraits<const T>
{
    typedef typename FieldTraits<T>::field_type field_type;
    typedef typename FieldTraits<T>::real_type real_type;
};

template<class T>
struct FieldTraits< std::complex<T> >
{
    typedef std::complex<T> field_type;
    typedef T real_type;
};

}
# 10 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densevector.hh" 2
# 1 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/matvectraits.hh" 1




namespace Dune {
# 23 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/matvectraits.hh"
template<class T>
struct DenseMatVecTraits {};

}
# 11 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densevector.hh" 2

namespace Dune {


  template<typename V> class DenseVector;

  template<typename V>
  struct FieldTraits< DenseVector<V> >
  {
    typedef typename FieldTraits< typename DenseMatVecTraits<V>::value_type >::field_type field_type;
    typedef typename FieldTraits< typename DenseMatVecTraits<V>::value_type >::real_type real_type;
  };
# 33 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densevector.hh"
  namespace fvmeta
  {




    template<class K>
    inline typename FieldTraits<K>::real_type absreal (const K& k)
    {
      return std::abs(k);
    }





    template<class K>
    inline typename FieldTraits<K>::real_type absreal (const std::complex<K>& c)
    {
      return std::abs(c.real()) + std::abs(c.imag());
    }





    template<class K>
    inline typename FieldTraits<K>::real_type abs2 (const K& k)
    {
      return k*k;
    }





    template<class K>
    inline typename FieldTraits<K>::real_type abs2 (const std::complex<K>& c)
    {
      return c.real()*c.real() + c.imag()*c.imag();
    }





    template<class K, bool isInteger = std::numeric_limits<K>::is_integer>
    struct Sqrt
    {
      static inline typename FieldTraits<K>::real_type sqrt (const K& k)
      {
        return std::sqrt(k);
      }
    };





    template<class K>
    struct Sqrt<K, true>
    {
      static inline typename FieldTraits<K>::real_type sqrt (const K& k)
      {
        return typename FieldTraits<K>::real_type(std::sqrt(double(k)));
      }
    };





    template<class K>
    inline typename FieldTraits<K>::real_type sqrt (const K& k)
    {
      return Sqrt<K>::sqrt(k);
    }

  }





  template<class C, class T>
  class DenseIterator :
    public Dune::RandomAccessIteratorFacade<DenseIterator<C,T>,T, T&, std::ptrdiff_t>
  {
    friend class DenseIterator<typename remove_const<C>::type, typename remove_const<T>::type >;
    friend class DenseIterator<const typename remove_const<C>::type, const typename remove_const<T>::type >;

  public:




    typedef std::ptrdiff_t DifferenceType;




    typedef typename C::size_type SizeType;


    DenseIterator()
      : container_(0), position_()
    {}

    DenseIterator(C& cont, SizeType pos)
      : container_(&cont), position_(pos)
    {}

    DenseIterator(const DenseIterator<typename remove_const<C>::type, typename remove_const<T>::type >& other)
      : container_(other.container_), position_(other.position_)
    {}


    bool equals(const DenseIterator<typename remove_const<C>::type,typename remove_const<T>::type>& other) const
    {
      return position_ == other.position_ && container_ == other.container_;
    }


    bool equals(const DenseIterator<const typename remove_const<C>::type,const typename remove_const<T>::type>& other) const
    {
      return position_ == other.position_ && container_ == other.container_;
    }

    T& dereference() const{
      return container_->operator[](position_);
    }

    void increment(){
      ++position_;
    }


    void decrement(){
      --position_;
    }


    T& elementAt(DifferenceType i)const{
      return container_->operator[](position_+i);
    }

    void advance(DifferenceType n){
      position_=position_+n;
    }

    DifferenceType distanceTo(DenseIterator<const typename remove_const<C>::type,const typename remove_const<T>::type> other)const
    {
      ((other.container_==container_) ? static_cast<void> (0) : __assert_fail ("other.container_==container_", "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densevector.hh", 185, __PRETTY_FUNCTION__));
      return other.position_ - position_;
    }

    DifferenceType distanceTo(DenseIterator<typename remove_const<C>::type, typename remove_const<T>::type> other)const
    {
      ((other.container_==container_) ? static_cast<void> (0) : __assert_fail ("other.container_==container_", "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densevector.hh", 191, __PRETTY_FUNCTION__));
      return other.position_ - position_;
    }


    SizeType index () const
    {
      return this->position_;
    }

  private:
    C *container_;
    SizeType position_;
  };
# 219 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densevector.hh"
  template<typename V>
  class DenseVector
  {
    typedef DenseMatVecTraits<V> Traits;



    V & asImp() { return static_cast<V&>(*this); }
    const V & asImp() const { return static_cast<const V&>(*this); }

  public:



    typedef typename Traits::derived_type derived_type;


    typedef typename Traits::value_type value_type;


    typedef typename Traits::value_type field_type;


    typedef typename Traits::value_type block_type;


    typedef typename Traits::size_type size_type;


    enum {

      blocklevel = 1
    };



    inline derived_type& operator= (const value_type& k)
    {
      for (size_type i=0; i<size(); i++)
        asImp()[i] = k;
      return asImp();
    }




    value_type & operator[] (size_type i)
    {
      return asImp().vec_access(i);
    }

    const value_type & operator[] (size_type i) const
    {
      return asImp().vec_access(i);
    }


    size_type size() const
    {
      return asImp().vec_size();
    }


    typedef DenseIterator<DenseVector,value_type> Iterator;

    typedef Iterator iterator;


    Iterator begin ()
    {
      return Iterator(*this,0);
    }


    Iterator end ()
    {
      return Iterator(*this,size());
    }





    Iterator rbegin() __attribute__((deprecated))
    {
      return beforeBegin();
    }



    Iterator beforeEnd ()
    {
      return Iterator(*this,size()-1);
    }





    Iterator rend () __attribute__((deprecated))
    {
      return beforeBegin();
    }



    Iterator beforeBegin ()
    {
      return Iterator(*this,-1);
    }


    Iterator find (size_type i)
    {
      return Iterator(*this,std::min(i,size()));
    }


    typedef DenseIterator<const DenseVector,const value_type> ConstIterator;

    typedef ConstIterator const_iterator;


    ConstIterator begin () const
    {
      return ConstIterator(*this,0);
    }


    ConstIterator end () const
    {
      return ConstIterator(*this,size());
    }





    ConstIterator rbegin() const __attribute__((deprecated))
    {
      return beforeEnd();
    }



    ConstIterator beforeEnd () const
    {
      return ConstIterator(*this,size()-1);
    }





    ConstIterator rend () const __attribute__((deprecated))
    {
      return beforeBegin();
    }



    ConstIterator beforeBegin () const
    {
      return ConstIterator(*this,-1);
    }


    ConstIterator find (size_type i) const
    {
      return ConstIterator(*this,std::min(i,size()));
    }




    derived_type& operator+= (const DenseVector& y)
    {
      ((y.size() == size()) ? static_cast<void> (0) : __assert_fail ("y.size() == size()", "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densevector.hh", 396, __PRETTY_FUNCTION__));
      for (size_type i=0; i<size(); i++)
        (*this)[i] += y[i];
      return asImp();
    }


    derived_type& operator-= (const DenseVector& y)
    {
      ((y.size() == size()) ? static_cast<void> (0) : __assert_fail ("y.size() == size()", "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densevector.hh", 405, __PRETTY_FUNCTION__));
      for (size_type i=0; i<size(); i++)
        (*this)[i] -= y[i];
      return asImp();
    }


    derived_type operator+ (const DenseVector& b) const
    {
      derived_type z = asImp();
      return (z+=b);
    }


    derived_type operator- (const DenseVector& b) const
    {
      derived_type z = asImp();
      return (z-=b);
    }


    derived_type& operator+= (const value_type& k)
    {
      for (size_type i=0; i<size(); i++)
        (*this)[i] += k;
      return asImp();
    }


    derived_type& operator-= (const value_type& k)
    {
      for (size_type i=0; i<size(); i++)
        (*this)[i] -= k;
      return asImp();
    }


    derived_type& operator*= (const value_type& k)
    {
      for (size_type i=0; i<size(); i++)
        (*this)[i] *= k;
      return asImp();
    }


    derived_type& operator/= (const value_type& k)
    {
      for (size_type i=0; i<size(); i++)
        (*this)[i] /= k;
      return asImp();
    }


    bool operator== (const DenseVector& y) const
    {
      ((y.size() == size()) ? static_cast<void> (0) : __assert_fail ("y.size() == size()", "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densevector.hh", 460, __PRETTY_FUNCTION__));
      for (size_type i=0; i<size(); i++)
        if ((*this)[i]!=y[i])
          return false;

      return true;
    }


    bool operator!= (const DenseVector& y) const
    {
      return !operator==(y);
    }



    derived_type& axpy (const value_type& a, const DenseVector& y)
    {
      ((y.size() == size()) ? static_cast<void> (0) : __assert_fail ("y.size() == size()", "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densevector.hh", 478, __PRETTY_FUNCTION__));
      for (size_type i=0; i<size(); i++)
        (*this)[i] += a*y[i];
      return asImp();
    }




    value_type operator* (const DenseVector& y) const
    {
      ((y.size() == size()) ? static_cast<void> (0) : __assert_fail ("y.size() == size()", "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densevector.hh", 489, __PRETTY_FUNCTION__));
      value_type result( 0 );
      for (size_type i=0; i<size(); i++)
        result += (*this)[i]*y[i];
      return result;
    }




    typename FieldTraits<value_type>::real_type one_norm() const {
      typename FieldTraits<value_type>::real_type result( 0 );
      for (size_type i=0; i<size(); i++)
        result += std::abs((*this)[i]);
      return result;
    }



    typename FieldTraits<value_type>::real_type one_norm_real () const
    {
      typename FieldTraits<value_type>::real_type result( 0 );
      for (size_type i=0; i<size(); i++)
        result += fvmeta::absreal((*this)[i]);
      return result;
    }


    typename FieldTraits<value_type>::real_type two_norm () const
    {
      typename FieldTraits<value_type>::real_type result( 0 );
      for (size_type i=0; i<size(); i++)
        result += fvmeta::abs2((*this)[i]);
      return fvmeta::sqrt(result);
    }


    typename FieldTraits<value_type>::real_type two_norm2 () const
    {
      typename FieldTraits<value_type>::real_type result( 0 );
      for (size_type i=0; i<size(); i++)
        result += fvmeta::abs2((*this)[i]);
      return result;
    }


    typename FieldTraits<value_type>::real_type infinity_norm () const
    {
      typename FieldTraits<value_type>::real_type result( 0 );
      for (size_type i=0; i<size(); i++)
        result = std::max(result, std::abs((*this)[i]));
      return result;
    }


    typename FieldTraits<value_type>::real_type infinity_norm_real () const
    {
      typename FieldTraits<value_type>::real_type result( 0 );
      for (size_type i=0; i<size(); i++)
        result = std::max(result, fvmeta::absreal((*this)[i]));
      return result;
    }




    size_type N () const
    {
      return size();
    }


    size_type dim () const
    {
      return size();
    }

  };
# 576 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densevector.hh"
  template<typename V>
  std::ostream& operator<< (std::ostream& s, const DenseVector<V>& v)
  {
    for (typename DenseVector<V>::size_type i=0; i<v.size(); i++)
      s << ((i>0) ? " " : "") << v[i];
    return s;
  }



}
# 16 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fvector.hh" 2

namespace Dune {
# 28 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fvector.hh"
  template< class K, int SIZE > class FieldVector;
  template< class K, int SIZE >
  struct DenseMatVecTraits< FieldVector<K,SIZE> >
  {
    typedef FieldVector<K,SIZE> derived_type;
    typedef Dune::array<K,SIZE> container_type;
    typedef K value_type;
    typedef typename container_type::size_type size_type;
  };

  template< class K, int SIZE >
  struct FieldTraits< FieldVector<K,SIZE> >
  {
    typedef typename FieldTraits<K>::field_type field_type;
    typedef typename FieldTraits<K>::real_type real_type;
  };






  template< class K, int SIZE >
  class FieldVector :
    public DenseVector< FieldVector<K,SIZE> >
  {
    Dune::array<K,SIZE> _data;
    typedef DenseVector< FieldVector<K,SIZE> > Base;
  public:

 enum {

      dimension = SIZE,

   size = SIZE
 };

    typedef typename Base::size_type size_type;
    typedef typename Base::value_type value_type;


 FieldVector() {}


 explicit FieldVector (const K& t)
 {
      fill(t);
 }


 FieldVector (const FieldVector & x) : _data(x._data)
 {}


    template<class C>
 FieldVector (const DenseVector<C> & x)
 {
      ((x.size() == SIZE) ? static_cast<void> (0) : __assert_fail ("x.size() == SIZE", "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fvector.hh", 85, __PRETTY_FUNCTION__));
      for (size_type i = 0; i<SIZE; i++)
        _data[i] = x[i];
    }

    using Base::operator=;


    size_type vec_size() const { return SIZE; }
    K & vec_access(size_type i) { return _data[i]; }
    const K & vec_access(size_type i) const { return _data[i]; }
  private:
    void fill(const K& t)
    {
      for (int i=0; i<SIZE; i++) _data[i]=t;
    }
  };
# 114 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fvector.hh"
  template<class K, int SIZE>
  inline std::istream &operator>> ( std::istream &in,
    FieldVector<K, SIZE> &v )
  {
    FieldVector<K, SIZE> w;
    for( typename FieldVector<K, SIZE>::size_type i = 0; i < SIZE; ++i )
      in >> w[ i ];
    if(in)
      v = w;
    return in;
  }


  template< class K >
  struct DenseMatVecTraits< FieldVector<K,1> >
  {
    typedef FieldVector<K,1> derived_type;
    typedef K container_type;
    typedef K value_type;
    typedef size_t size_type;
  };



  template<class K>
  class FieldVector<K, 1> :
    public DenseVector< FieldVector<K,1> >
  {
    K _data;
    typedef DenseVector< FieldVector<K,1> > Base;
  public:

 enum {

      dimension = 1,

   size = 1
 };

    typedef typename Base::size_type size_type;




 FieldVector () {}


 FieldVector (const K& k) : _data(k) {}


    template<class C>
 FieldVector (const DenseVector<C> & x)
 {
      ((x.size() == 1) ? static_cast<void> (0) : __assert_fail ("x.size() == 1", "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fvector.hh", 167, __PRETTY_FUNCTION__));
      _data = x[0];
    }


    inline FieldVector& operator= (const K& k)
    {
      _data = k;
      return *this;
    }


    size_type vec_size() const { return 1; }
    K & vec_access(size_type i)
    {
      ((i == 0) ? static_cast<void> (0) : __assert_fail ("i == 0", "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fvector.hh", 182, __PRETTY_FUNCTION__));
      return _data;
    }
    const K & vec_access(size_type i) const
    {
      ((i == 0) ? static_cast<void> (0) : __assert_fail ("i == 0", "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fvector.hh", 187, __PRETTY_FUNCTION__));
      return _data;
    }




 operator K () { return _data; }


 operator K () const { return _data; }
  };







  template<class K>
  inline FieldVector<K,1> operator+ (const FieldVector<K,1>& a, const K b)
  {
    return a[0]+b;
  }


  template<class K>
  inline FieldVector<K,1> operator- (const FieldVector<K,1>& a, const K b)
  {
    return a[0]-b;
  }


  template<class K>
  inline FieldVector<K,1> operator* (const FieldVector<K,1>& a, const K b)
  {
    return a[0]*b;
  }


  template<class K>
  inline FieldVector<K,1> operator/ (const FieldVector<K,1>& a, const K b)
  {
    return a[0]/b;
  }


  template<class K>
  inline bool operator> (const FieldVector<K,1>& a, const K b)
  {
    return a[0]>b;
  }


  template<class K>
  inline bool operator>= (const FieldVector<K,1>& a, const K b)
  {
    return a[0]>=b;
  }


  template<class K>
  inline bool operator< (const FieldVector<K,1>& a, const K b)
  {
    return a[0]<b;
  }


  template<class K>
  inline bool operator<= (const FieldVector<K,1>& a, const K b)
  {
    return a[0]<=b;
  }


  template<class K>
  inline bool operator== (const FieldVector<K,1>& a, const K b)
  {
    return a[0]==b;
  }


  template<class K>
  inline bool operator!= (const FieldVector<K,1>& a, const K b)
  {
    return a[0]!=b;
  }




  template<class K>
  inline FieldVector<K,1> operator+ (const K a, const FieldVector<K,1>& b)
  {
    return a+b[0];
  }


  template<class K>
  inline FieldVector<K,1> operator- (const K a, const FieldVector<K,1>& b)
  {
    return a-b[0];
  }


  template<class K>
  inline FieldVector<K,1> operator* (const K a, const FieldVector<K,1>& b)
  {
    return a*b[0];
  }


  template<class K>
  inline FieldVector<K,1> operator/ (const K a, const FieldVector<K,1>& b)
  {
    return a/b[0];
  }


  template<class K>
  inline bool operator> (const K a, const FieldVector<K,1>& b)
  {
    return a>b[0];
  }


  template<class K>
  inline bool operator>= (const K a, const FieldVector<K,1>& b)
  {
    return a>=b[0];
  }


  template<class K>
  inline bool operator< (const K a, const FieldVector<K,1>& b)
  {
    return a<b[0];
  }


  template<class K>
  inline bool operator<= (const K a, const FieldVector<K,1>& b)
  {
    return a<=b[0];
  }


  template<class K>
  inline bool operator== (const K a, const FieldVector<K,1>& b)
  {
    return a==b[0];
  }


  template<class K>
  inline bool operator!= (const K a, const FieldVector<K,1>& b)
  {
    return a!=b[0];
  }




}
# 14 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/test/test-edges0.5.cc" 2
# 1 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/geometrytype.hh" 1






# 1 "/usr/include/c++/4.4/cassert" 1 3
# 43 "/usr/include/c++/4.4/cassert" 3
# 43 "/usr/include/c++/4.4/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 45 "/usr/include/c++/4.4/cassert" 2 3
# 8 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/geometrytype.hh" 2







namespace Dune {
# 24 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/geometrytype.hh"
    class GeometryType
    {
    public:


        enum BasicType {
    simplex,
    cube,
    pyramid,
    prism,
          extended,
    none
  };


        enum Binary {
            b0001 = 1,
            b0011 = 3,
            b0101 = 5,
            b0111 = 7
        };
    private:


        unsigned int topologyId_;


        unsigned char dim_ : 7;


        bool none_ : 1;

    public:

        GeometryType ()
            : topologyId_(0), dim_(0), none_(true)
        {}


        GeometryType(BasicType basicType, unsigned int dim)
            : topologyId_(0), dim_(dim), none_(false)
        {
            if (dim < 2)
                return;
            switch( basicType )
            {
                case GeometryType::simplex:
                    makeSimplex(dim);
                    break;
                case GeometryType::cube:
                    makeCube(dim);
                    break;
                case GeometryType::pyramid:
                    if (dim == 3)
                        makePyramid();
                    break;
                case GeometryType::prism:
                    if (dim == 3)
                        makePrism();
                    break;
                case GeometryType::none:
                    makeNone(dim);
                    break;
                default:
                    do { RangeError th__ex; std::ostringstream th__out; th__out << "RangeError" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/geometrytype.hh" << ":" << 89 << "]: " << "Invalid basic geometry type: " << basicType << " for dimension " << dim << "."; th__ex.message(th__out.str()); throw th__ex; } while (0);

            }
        }


        GeometryType(unsigned int topologyId, unsigned int dim)
            : topologyId_(topologyId), dim_(dim), none_(false)
        {}
# 108 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/geometrytype.hh"
        template<class TopologyType>
        explicit GeometryType(TopologyType t)
            : topologyId_(TopologyType::id), dim_(TopologyType::dimension), none_(false)
        {}


        explicit GeometryType(unsigned int dim)
            : topologyId_(0), dim_(dim), none_(false)
        {
            ((dim < 2) ? static_cast<void> (0) : __assert_fail ("dim < 2", "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/geometrytype.hh", 117, __PRETTY_FUNCTION__));
        }


        explicit GeometryType(int dim)
            : topologyId_(0), dim_(dim), none_(false)
        {
            ((dim < 2) ? static_cast<void> (0) : __assert_fail ("dim < 2", "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/geometrytype.hh", 124, __PRETTY_FUNCTION__));
        }





        void makeVertex() {
            none_ = false;
            dim_ = 0;
            topologyId_ = 0;
        }


        void makeLine() {
            none_ = false;
            dim_ = 1;
            topologyId_ = 0;
        }


        void makeTriangle() {
            makeSimplex(2);
        }


        void makeQuadrilateral() {
            makeCube(2);
        }


        void makeTetrahedron() {
            makeSimplex(3);
        }


        void makePyramid() {
            none_ = false;
            dim_ = 3;
            topologyId_ = b0011;
        }


        void makePrism() {
            none_ = false;
            dim_ = 3;
            topologyId_ = b0101;
        }


        void makeHexahedron() {
            makeCube(3);
        }


        void makeSimplex(unsigned int dim) {
            none_ = false;
            dim_ = dim;
            topologyId_ = 0;
        }


        void makeCube(unsigned int dim) {
            none_ = false;
            dim_ = dim;
            topologyId_ = ((dim>1) ? ((1 << dim) - 1) : 0);
        }


        void makeNone(unsigned int dim) {
            none_ = true;
            dim_ = dim;
            topologyId_ = 0;
        }







        bool isVertex() const {
            return dim_==0;
        }


        bool isLine() const {
            return dim_==1;
        }


        bool isTriangle() const {
            return ! none_ && dim_==2 && (topologyId_ | 1) == b0001;
        }


        bool isQuadrilateral() const {
            return ! none_ && dim_==2 && (topologyId_ | 1) == b0011;
        }


        bool isTetrahedron() const {
            return ! none_ && dim_==3 && (topologyId_ | 1) == b0001;
        }


        bool isPyramid() const {
            return ! none_ && dim_==3 && (topologyId_ | 1) == b0011;
        }


        bool isPrism() const {
            return ! none_ && dim_==3 && (topologyId_ | 1) == b0101;
        }


        bool isHexahedron() const {
            return ! none_ && dim_==3 && (topologyId_ | 1) == b0111;
        }


        bool isSimplex() const {
            return ! none_ && (topologyId_ | 1) == 1;
        }


        bool isCube() const {
            return ! none_ && ((topologyId_ ^ ((1 << dim_)-1)) >> 1 == 0);
        }


        bool isNone() const {
            return none_;
        }


        unsigned int dim() const {
            return dim_;
        }


        BasicType basicType() const __attribute__((deprecated)) {
            if (isSimplex())
                return GeometryType::simplex;
            if (isCube())
                return GeometryType::cube;
            if (isPyramid())
                return GeometryType::pyramid;
            if (isPrism())
                return GeometryType::prism;
            if (isNone())
                return GeometryType::none;
            return GeometryType::extended;
        }


        unsigned int id() const {
            return topologyId_;
        }






        bool operator==(const GeometryType& other) const {
            return ( ( none_ == other.none_ )
                && ( ( none_ == true )
                    || ( ( dim_ == other.dim_ )
                        && ( (topologyId_ >> 1) == (other.topologyId_ >> 1) )
                        )
                    )
                );
        }


        bool operator!=(const GeometryType& other) const {
            return ! ((*this)==other);
        }


        bool operator < (const GeometryType& other) const {
            return ( ( none_ < other.none_ )
                     || ( !( other.none_ < none_ )
                          && ( ( dim_ < other.dim_ )
                               || ( (other.dim_ == dim_)
                                    && ((topologyId_ >> 1) < (other.topologyId_ >> 1) )
                                  )
                             )
                        )
                   );
        }
    };


    inline std::ostream& operator<< (std::ostream& s, const GeometryType& a)
    {
        if (a.isSimplex())
        {
            s << "(simplex, " << a.dim() << ")";
            return s;
        }
        if (a.isCube())
        {
            s << "(cube, " << a.dim() << ")";
            return s;
        }
        if (a.isPyramid())
        {
            s << "(pyramid, 3)";
            return s;
        }
        if (a.isPrism())
        {
            s << "(prism, 3)";
            return s;
        }
        if (a.isNone())
        {
            s << "(none, " << a.dim() << ")";
            return s;
        }
        s << "(other [" << a.id() << "], " << a.dim() << ")";
        return s;
    }


    inline std::ostream& operator<< (std::ostream& s, GeometryType::BasicType type)
    {
        switch (type) {
            case GeometryType::simplex:
                s << "simplex";
                break;
            case GeometryType::cube:
                s << "cube";
                break;
            case GeometryType::pyramid:
                s << "pyramid";
                break;
            case GeometryType::prism:
                s << "prism";
                break;
            case GeometryType::extended:
                s << "other";
            case GeometryType::none:
                s << "none";
                break;
            default:
                do { Exception th__ex; std::ostringstream th__out; th__out << "Exception" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/geometrytype.hh" << ":" << 372 << "]: " << "invalid GeometryType::BasicType"; th__ex.message(th__out.str()); throw th__ex; } while (0);
        }
        return s;
    }
}
# 15 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/test/test-edges0.5.cc" 2
# 1 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/static_assert.hh" 1
# 26 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/static_assert.hh"
template <bool x> struct static_assert_failure;

template <> struct static_assert_failure<true> { };

template<int x> struct static_assert_test{};
# 81 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/static_assert.hh"
namespace Dune {
# 122 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/static_assert.hh"
  template<typename T>
  struct AlwaysFalse {

    static const bool value = false;
  };
# 135 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/static_assert.hh"
  template<typename T>
  struct AlwaysTrue {

    static const bool value = true;
  };
}
# 16 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/test/test-edges0.5.cc" 2

# 1 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/utility/mockgeometry.hh" 1






# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 8 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/utility/mockgeometry.hh" 2

# 1 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fmatrix.hh" 1






# 1 "/usr/include/c++/4.4/cmath" 1 3
# 41 "/usr/include/c++/4.4/cmath" 3
# 41 "/usr/include/c++/4.4/cmath" 3
# 8 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fmatrix.hh" 2
# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 9 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fmatrix.hh" 2


# 1 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/misc.hh" 1
# 11 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/misc.hh"
# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 12 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/misc.hh" 2
# 1 "/usr/include/c++/4.4/cstring" 1 3
# 41 "/usr/include/c++/4.4/cstring" 3
# 41 "/usr/include/c++/4.4/cstring" 3


# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 44 "/usr/include/c++/4.4/cstring" 2 3
# 13 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/misc.hh" 2
# 1 "/usr/include/c++/4.4/cstdio" 1 3
# 41 "/usr/include/c++/4.4/cstdio" 3
# 41 "/usr/include/c++/4.4/cstdio" 3


# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 44 "/usr/include/c++/4.4/cstdio" 2 3
# 1 "/usr/include/stdio.h" 1 3 4
# 30 "/usr/include/stdio.h" 3 4
extern "C" {




# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 35 "/usr/include/stdio.h" 2 3 4
# 75 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 32 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
# 21 "/usr/include/_G_config.h" 2 3 4

typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 53 "/usr/include/_G_config.h" 3 4
typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
# 33 "/usr/include/libio.h" 2 3 4
# 170 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 180 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 203 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 271 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 319 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 328 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 364 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 460 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
# 490 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
# 552 "/usr/include/libio.h" 3 4
}
# 76 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 91 "/usr/include/stdio.h" 3 4
typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;
# 141 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 142 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (__const char *__filename) throw ();

extern int rename (__const char *__old, __const char *__new) throw ();




extern int renameat (int __oldfd, __const char *__old, int __newfd,
       __const char *__new) throw ();
# 172 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void) ;
# 182 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;





extern char *tmpnam_r (char *__s) throw () ;
# 204 "/usr/include/stdio.h" 3 4
extern char *tempnam (__const char *__dir, __const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;
# 214 "/usr/include/stdio.h" 3 4
extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 229 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 239 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 249 "/usr/include/stdio.h" 3 4
extern FILE *fopen (__const char *__restrict __filename,
      __const char *__restrict __modes) ;




extern FILE *freopen (__const char *__restrict __filename,
        __const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 274 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (__const char *__restrict __filename,
        __const char *__restrict __modes) ;
extern FILE *freopen64 (__const char *__restrict __filename,
   __const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, __const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     __const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, __const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();
# 333 "/usr/include/stdio.h" 3 4
extern int fprintf (FILE *__restrict __stream,
      __const char *__restrict __format, ...);




extern int printf (__const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      __const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (__const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg) throw ();





extern int snprintf (char *__restrict __s, size_t __maxlen,
       __const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        __const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, __const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
# 394 "/usr/include/stdio.h" 3 4
extern int vdprintf (int __fd, __const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, __const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));
# 407 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream,
     __const char *__restrict __format, ...) ;




extern int scanf (__const char *__restrict __format, ...) ;

extern int sscanf (__const char *__restrict __s,
     __const char *__restrict __format, ...) throw ();
# 453 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (__const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (__const char *__restrict __s,
      __const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
# 513 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);
# 532 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 543 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 555 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 576 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);
# 604 "/usr/include/stdio.h" 3 4
extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
          ;






extern char *gets (char *__s) ;
# 622 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 638 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;
# 662 "/usr/include/stdio.h" 3 4
extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);





extern int puts (__const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s) ;
# 699 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (__const char *__restrict __s,
      FILE *__restrict __stream);
# 710 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream) ;
# 722 "/usr/include/stdio.h" 3 4
extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 746 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 771 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, __const fpos_t *__pos);
# 791 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, __const fpos64_t *__pos);




extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;




extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;
# 819 "/usr/include/stdio.h" 3 4
extern void perror (__const char *__s);







# 1 "/usr/include/bits/sys_errlist.h" 1 3 4
# 27 "/usr/include/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern __const char *__const sys_errlist[];


extern int _sys_nerr;
extern __const char *__const _sys_errlist[];
# 827 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
# 846 "/usr/include/stdio.h" 3 4
extern FILE *popen (__const char *__command, __const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      __const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       __const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
# 916 "/usr/include/stdio.h" 3 4
}
# 45 "/usr/include/c++/4.4/cstdio" 2 3
# 92 "/usr/include/c++/4.4/cstdio" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;

}
# 149 "/usr/include/c++/4.4/cstdio" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
# 164 "/usr/include/c++/4.4/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;


}

namespace std __attribute__ ((__visibility__ ("default"))) {

  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;

}
# 14 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/misc.hh" 2
# 24 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/misc.hh"
namespace Dune {
# 62 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/misc.hh"
template <int N>
struct __attribute__((deprecated)) Int2Type :
    public integral_constant<int,N>
{





  static const int __attribute__((deprecated)) value = N;






  __attribute__((deprecated))
  Int2Type() { }
};



template <int N> const int Int2Type<N>::value;
# 93 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/misc.hh"
template<class K>
inline K conjugateComplex (const K& x)
{
    return x;
}



template<class K>
inline std::complex<K> conjugateComplex (const std::complex<K>& c)
{
    return std::complex<K>(c.real(),-c.imag());
}



template <class T>
int sign(const T& val)
{
  return (val < 0 ? -1 : 1);
}







template<class T>
T SQR (T t)
{
  return t*t;
}


template <int m, int p>
struct Power_m_p
{

  enum { power = (m * Power_m_p<m,p-1>::power ) };
};


template <int m>
struct Power_m_p< m , 0>
{

  enum { power = 1 };
};


template <int m>
struct Factorial
{

  enum { factorial = m * Factorial<m-1>::factorial };
};


template <>
struct Factorial<0>
{

  enum { factorial = 1 };
};
# 166 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/misc.hh"
inline std::string genFilename(const std::string& path,
                               const std::string& fn,
                               int ntime,
                               int precision = 6)
{
  std::ostringstream name;

  if(path.size() > 0)
  {
    name << path;
    name << "/";
  }
  name << fn << std::setw(precision) << std::setfill('0') << ntime;


  return name.str();
}
# 195 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/misc.hh"
template<typename C>
bool hasPrefix(const C& c, const char* prefix) {
  std::size_t len = std::strlen(prefix);
  return c.size() >= len &&
    std::equal(prefix, prefix+len, c.begin());
}
# 211 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/misc.hh"
template<typename C>
bool hasSuffix(const C& c, const char* suffix) {
  std::size_t len = std::strlen(suffix);
  if(c.size() < len) return false;
  typename C::const_iterator it = c.begin();
  std::advance(it, c.size() - len);
  return std::equal(suffix, suffix+len, it);
}


}
# 12 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fmatrix.hh" 2


# 1 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densematrix.hh" 1






# 1 "/usr/include/c++/4.4/cmath" 1 3
# 41 "/usr/include/c++/4.4/cmath" 3
# 41 "/usr/include/c++/4.4/cmath" 3
# 8 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densematrix.hh" 2
# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 9 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densematrix.hh" 2

# 1 "/usr/include/c++/4.4/vector" 1 3
# 59 "/usr/include/c++/4.4/vector" 3
# 59 "/usr/include/c++/4.4/vector" 3





# 1 "/usr/include/c++/4.4/bits/stl_vector.h" 1 3
# 65 "/usr/include/c++/4.4/bits/stl_vector.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {


  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _Vector_impl
      : public _Tp_alloc_type
      {
 typename _Tp_alloc_type::pointer _M_start;
 typename _Tp_alloc_type::pointer _M_finish;
 typename _Tp_alloc_type::pointer _M_end_of_storage;

 _Vector_impl()
 : _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }

 _Vector_impl(_Tp_alloc_type const& __a)
 : _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base()
      : _M_impl() { }

      _Vector_base(const allocator_type& __a)
      : _M_impl(__a) { }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
# 131 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      typename _Tp_alloc_type::pointer
      _M_allocate(size_t __n)
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(typename _Tp_alloc_type::pointer __p, size_t __n)
      {
 if (__p)
   _M_impl.deallocate(__p, __n);
      }
    };
# 169 "/usr/include/c++/4.4/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;



      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:





      vector()
      : _Base() { }





      explicit
      vector(const allocator_type& __a)
      : _Base(__a) { }
# 226 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const value_type& __value = value_type(),
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_fill_initialize(__n, __value); }
# 241 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(), __x._M_get_Tp_allocator())
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 296 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      template<typename _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }







      ~vector()
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator()); }
# 324 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 373 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 389 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }
# 416 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      using _Base::get_allocator;







      iterator
      begin()
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end()
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }
# 531 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      size_type
      size() const
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const
      { return _M_get_Tp_allocator().max_size(); }
# 551 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
 if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
 else
   insert(end(), __new_size - size(), __x);
      }





      size_type
      capacity() const
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const
      { return begin() == end(); }
# 594 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 609 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      reference
      operator[](size_type __n)
      { return *(this->_M_impl._M_start + __n); }
# 624 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const
      { return *(this->_M_impl._M_start + __n); }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("vector::_M_range_check"));
      }

    public:
# 649 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 667 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      { return *(end() - 1); }





      const_reference
      back() const
      { return *(end() - 1); }
# 713 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      pointer
      data()
      { return pointer(this->_M_impl._M_start); }

      const_pointer
      data() const
      { return const_pointer(this->_M_impl._M_start); }
# 732 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     this->_M_impl.construct(this->_M_impl._M_finish, __x);
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(end(), __x);
      }
# 763 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      void
      pop_back()
      {
 --this->_M_impl._M_finish;
 this->_M_impl.destroy(this->_M_impl._M_finish);
      }
# 799 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 849 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 867 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 892 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      iterator
      erase(iterator __position);
# 913 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 925 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      void



      swap(vector& __x)

      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_end_of_storage,
    __x._M_impl._M_end_of_storage);



 std::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
          __x._M_get_Tp_allocator());
      }







      void
      clear()
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
        {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }
# 984 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
   this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
   this->_M_impl._M_end_of_storage =
     this->_M_impl._M_start + static_cast<size_type>(__n);
   _M_fill_initialize(static_cast<size_type>(__n), __value);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
       _InputIterator __last, std::input_iterator_tag)
        {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag)
        {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
          _M_get_Tp_allocator());
 this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
      }
# 1048 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);
# 1088 "/usr/include/c++/4.4/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
        { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_insert(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);



      void
      _M_insert_aux(iterator __position, const value_type& __x);







      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }





      void
      _M_erase_at_end(pointer __pos)
      {
 std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
 this->_M_impl._M_finish = __pos;
      }
    };
# 1166 "/usr/include/c++/4.4/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 1183 "/usr/include/c++/4.4/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    { __x.swap(__y); }
# 1231 "/usr/include/c++/4.4/bits/stl_vector.h" 3
}
# 65 "/usr/include/c++/4.4/vector" 2 3
# 1 "/usr/include/c++/4.4/bits/stl_bvector.h" 1 3
# 62 "/usr/include/c++/4.4/bits/stl_bvector.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() : _M_p(0), _M_mask(0) { }

    operator bool() const
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x)
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x)
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip()
    { *_M_p ^= _M_mask; }
  };

  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
  {
    for (; __first != __last; ++__first)
      *__first = __x;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
 __fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
 __fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      __fill_bvector(__first, __last, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename _Alloc::template rebind<_Bit_type>::other
        _Bit_alloc_type;

      struct _Bvector_impl
      : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_type* _M_end_of_storage;

 _Bvector_impl()
 : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }

 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }
      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator()
      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Bit_allocator()); }

      _Bvector_base()
      : _M_impl() { }

      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }
# 429 "/usr/include/c++/4.4/bits/stl_bvector.h" 3
      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_type*
      _M_allocate(size_t __n)
      { return _M_impl.allocate((__n + int(_S_word_bit) - 1)
    / int(_S_word_bit)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   _M_impl.deallocate(_M_impl._M_start._M_p,
        _M_impl._M_end_of_storage - _M_impl._M_start._M_p);
      }
    };

}




namespace std __attribute__ ((__visibility__ ("default"))) {
# 473 "/usr/include/c++/4.4/bits/stl_bvector.h" 3
template<typename _Alloc>
  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
  {
    typedef _Bvector_base<_Alloc> _Base;

  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;
    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef _Alloc allocator_type;

    allocator_type get_allocator() const
    { return _Base::get_allocator(); }

  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_M_get_Bit_allocator;

  public:
    vector()
    : _Base() { }

    explicit
    vector(const allocator_type& __a)
    : _Base(__a) { }

    explicit
    vector(size_type __n, const bool& __value = bool(),
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage,
  __value ? ~0 : 0);
    }

    vector(const vector& __x)
    : _Base(__x._M_get_Bit_allocator())
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }
# 538 "/usr/include/c++/4.4/bits/stl_bvector.h" 3
    template<typename _InputIterator>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_initialize_dispatch(__first, __last, _Integral());
      }

    ~vector() { }

    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;
      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
      begin());
      return *this;
    }
# 586 "/usr/include/c++/4.4/bits/stl_bvector.h" 3
    void
    assign(size_type __n, const bool& __x)
    { _M_fill_assign(__n, __x); }

    template<typename _InputIterator>
      void
      assign(_InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_assign_dispatch(__first, __last, _Integral());
      }







    iterator
    begin()
    { return this->_M_impl._M_start; }

    const_iterator
    begin() const
    { return this->_M_impl._M_start; }

    iterator
    end()
    { return this->_M_impl._M_finish; }

    const_iterator
    end() const
    { return this->_M_impl._M_finish; }

    reverse_iterator
    rbegin()
    { return reverse_iterator(end()); }

    const_reverse_iterator
    rbegin() const
    { return const_reverse_iterator(end()); }

    reverse_iterator
    rend()
    { return reverse_iterator(begin()); }

    const_reverse_iterator
    rend() const
    { return const_reverse_iterator(begin()); }
# 654 "/usr/include/c++/4.4/bits/stl_bvector.h" 3
    size_type
    size() const
    { return size_type(end() - begin()); }

    size_type
    max_size() const
    {
      const size_type __isize =
 __gnu_cxx::__numeric_traits<difference_type>::__max
 - int(_S_word_bit) + 1;
      const size_type __asize = _M_get_Bit_allocator().max_size();
      return (__asize <= __isize / int(_S_word_bit)
       ? __asize * int(_S_word_bit) : __isize);
    }

    size_type
    capacity() const
    { return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0)
         - begin()); }

    bool
    empty() const
    { return begin() == end(); }

    reference
    operator[](size_type __n)
    {
      return *iterator(this->_M_impl._M_start._M_p
         + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

    const_reference
    operator[](size_type __n) const
    {
      return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

  protected:
    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
        __throw_out_of_range(("vector<bool>::_M_range_check"));
    }

  public:
    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    void
    reserve(size_type __n);

    reference
    front()
    { return *begin(); }

    const_reference
    front() const
    { return *begin(); }

    reference
    back()
    { return *(end() - 1); }

    const_reference
    back() const
    { return *(end() - 1); }






    void
    data() { }

    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void



    swap(vector& __x)

    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);



      std::__alloc_swap<typename _Base::_Bit_alloc_type>::
 _S_do_it(_M_get_Bit_allocator(), __x._M_get_Bit_allocator());
    }


    static void
    swap(reference __x, reference __y)
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator
    insert(iterator __position, const bool& __x = bool())
    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }

    template<typename _InputIterator>
      void
      insert(iterator __position,
      _InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_insert_dispatch(__position, __first, __last, _Integral());
      }

    void
    insert(iterator __position, size_type __n, const bool& __x)
    { _M_fill_insert(__position, __n, __x); }






    void
    pop_back()
    { --this->_M_impl._M_finish; }

    iterator
    erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

    iterator
    erase(iterator __first, iterator __last)
    {
      _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }

    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        _M_erase_at_end(begin() + difference_type(__new_size));
      else
        insert(end(), __new_size - size(), __x);
    }

    void
    flip()
    {
      for (_Bit_type * __p = this->_M_impl._M_start._M_p;
    __p != this->_M_impl._M_end_of_storage; ++__p)
        *__p = ~*__p;
    }

    void
    clear()
    { _M_erase_at_end(begin()); }


  protected:

    iterator
    _M_copy_aligned(const_iterator __first, const_iterator __last,
      iterator __result)
    {
      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
      return std::copy(const_iterator(__last._M_p, 0), __last,
         iterator(__q, 0));
    }

    void
    _M_initialize(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_end_of_storage = (__q
      + ((__n + int(_S_word_bit) - 1)
         / int(_S_word_bit)));
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }





    template<typename _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
 _M_initialize(static_cast<size_type>(__n));
 std::fill(this->_M_impl._M_start._M_p,
    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
      }

    template<typename _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }

    template<typename _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   push_back(*__first);
      }

    template<typename _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 _M_initialize(__n);
 std::copy(__first, __last, this->_M_impl._M_start);
      }



    template<typename _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign(__n, __val); }

    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   _M_erase_at_end(begin() + __n);
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
 }
    }

    template<typename _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

    template<typename _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len < size())
   _M_erase_at_end(std::copy(__first, __last, begin()));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, begin());
     insert(end(), __mid, __last);
   }
      }





    template<typename _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
    __true_type)
      { _M_fill_insert(__pos, __n, __x); }

    template<typename _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
    _InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_insert_range(__pos, __first, __last,
   std::__iterator_category(__first)); }

    void
    _M_fill_insert(iterator __position, size_type __n, bool __x);

    template<typename _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

    template<typename _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag);

    void
    _M_insert_aux(iterator __position, bool __x);

    size_type
    _M_check_len(size_type __n, const char* __s) const
    {
      if (max_size() - size() < __n)
 __throw_length_error((__s));

      const size_type __len = size() + std::max(size(), __n);
      return (__len < size() || __len > max_size()) ? max_size() : __len;
    }

    void
    _M_erase_at_end(iterator __pos)
    { this->_M_impl._M_finish = __pos; }
  };

}
# 66 "/usr/include/c++/4.4/vector" 2 3


# 1 "/usr/include/c++/4.4/bits/vector.tcc" 1 3
# 60 "/usr/include/c++/4.4/bits/vector.tcc" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
   (this->_M_impl._M_start),
   (this->_M_impl._M_finish));
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }
# 104 "/usr/include/c++/4.4/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
   && __position == end())
 {
   this->_M_impl.construct(this->_M_impl._M_finish, __x);
   ++this->_M_impl._M_finish;
 }
      else
 {
# 126 "/usr/include/c++/4.4/bits/vector.tcc" 3
     _M_insert_aux(__position, __x);
 }
      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __position)
    {
      if (__position + 1 != end())
 std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      this->_M_impl.destroy(this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__last != end())
 std::copy(__last, end(), __first);
      _M_erase_at_end(__first.base() + (end() - __last));
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {
   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp.swap(*this);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
     __n - size(), __val,
     _M_get_Tp_allocator());
   this->_M_impl._M_finish += __n - size();
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
   }
      }
# 293 "/usr/include/c++/4.4/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_insert_aux(iterator __position, const _Tp& __x)

    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 {
   this->_M_impl.construct(this->_M_impl._M_finish,
      (*(this->_M_impl._M_finish - 1)));

   ++this->_M_impl._M_finish;

   _Tp __x_copy = __x;

   std::copy_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1);



   *__position = __x_copy;



 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector::_M_insert_aux");
   const size_type __elems_before = __position - begin();
   pointer __new_start(this->_M_allocate(__len));
   pointer __new_finish(__new_start);
   try
     {




       this->_M_impl.construct(__new_start + __elems_before,



                               __x);

       __new_finish = 0;

       __new_finish =
  std::__uninitialized_move_a(this->_M_impl._M_start,
         __position.base(), __new_start,
         _M_get_Tp_allocator());
       ++__new_finish;

       __new_finish =
  std::__uninitialized_move_a(__position.base(),
         this->_M_impl._M_finish,
         __new_finish,
         _M_get_Tp_allocator());
     }
          catch(...)
     {
       if (!__new_finish)
  this->_M_impl.destroy(__new_start + __elems_before);
       else
  std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
       _M_deallocate(__new_start, __len);
       throw;
     }
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __new_start;
   this->_M_impl._M_finish = __new_finish;
   this->_M_impl._M_end_of_storage = __new_start + __len;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       value_type __x_copy = __x;
       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    std::copy_backward(__position.base(), __old_finish - __n, __old_finish);

    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
      __n - __elems_after,
      __x_copy,
      _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n - __elems_after;
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __position - begin();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {

    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = 0;

    __new_finish =
      std::__uninitialized_move_a(this->_M_impl._M_start,
      __position.base(),
      __new_start,
      _M_get_Tp_allocator());
    __new_finish += __n;

    __new_finish =
      std::__uninitialized_move_a(__position.base(),
      this->_M_impl._M_finish,
      __new_finish,
      _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      std::copy_backward(__position.base(), __old_finish - __n, __old_finish);

      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish =
        std::__uninitialized_move_a(this->_M_impl._M_start,
        __position.base(),
        __new_start,
        _M_get_Tp_allocator());
      __new_finish =
        std::__uninitialized_copy_a(__first, __last,
        __new_finish,
        _M_get_Tp_allocator());
      __new_finish =
        std::__uninitialized_move_a(__position.base(),
        this->_M_impl._M_finish,
        __new_finish,
        _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }




  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   _Bit_type* __q = this->_M_allocate(__n);
   this->_M_impl._M_finish = _M_copy_aligned(begin(), end(),
          iterator(__q, 0));
   this->_M_deallocate();
   this->_M_impl._M_start = iterator(__q, 0);
   this->_M_impl._M_end_of_storage = (__q + (__n + int(_S_word_bit) - 1)
          / int(_S_word_bit));
 }
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   std::fill(__i, __i + difference_type(__n), __x);
   this->_M_impl._M_finish = std::copy(__position, end(),
           __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_type * __q = this->_M_allocate(__len);
  iterator __i = _M_copy_aligned(begin(), __position,
            iterator(__q, 0));
  __i = std::copy(__first, __last, __i);
  this->_M_impl._M_finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = (__q
         + ((__len
             + int(_S_word_bit) - 1)
            / int(_S_word_bit)));
  this->_M_impl._M_start = iterator(__q, 0);
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   *__i++ = __x;
   this->_M_impl._M_finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

}
# 69 "/usr/include/c++/4.4/vector" 2 3
# 11 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densematrix.hh" 2




# 1 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/precision.hh" 1





namespace Dune {
# 16 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/precision.hh"
  template <class ctype = double>
  class FMatrixPrecision {
  public:

 static ctype pivoting_limit ()
 {
   return _pivoting;
 }


 static void set_pivoting_limit (ctype pivthres)
 {
   _pivoting = pivthres;
 }


 static ctype singular_limit ()
 {
   return _singular;
 }


 static void set_singular_limit (ctype singthres)
 {
   _singular = singthres;
 }


 static ctype absolute_limit ()
 {
   return _absolute;
 }


 static void set_absolute_limit (ctype absthres)
 {
   _absolute = absthres;
 }

  private:

 static ctype _pivoting;
 static ctype _singular;
 static ctype _absolute;
  };

  template <class ctype>
  ctype FMatrixPrecision<ctype>::_pivoting = 1E-8;
  template <class ctype>
  ctype FMatrixPrecision<ctype>::_singular = 1E-14;
  template <class ctype>
  ctype FMatrixPrecision<ctype>::_absolute = 1E-80;



}
# 16 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densematrix.hh" 2

# 1 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/classname.hh" 1
# 10 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/classname.hh"
# 1 "/usr/include/c++/4.4/typeinfo" 1 3
# 36 "/usr/include/c++/4.4/typeinfo" 3
#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 80 "/usr/include/c++/4.4/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const
    { return __name; }
# 117 "/usr/include/c++/4.4/typeinfo" 3
    bool before(const type_info& __arg) const
    { return __name < __arg.__name; }

    bool operator==(const type_info& __arg) const
    { return __name == __arg.__name; }

    bool operator!=(const type_info& __arg) const
    { return !operator==(__arg); }


    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() throw() { }



    virtual ~bad_cast() throw();


    virtual const char* what() const throw();
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () throw() { }



    virtual ~bad_typeid() throw();


    virtual const char* what() const throw();
  };
}

#pragma GCC visibility pop

}
# 11 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/classname.hh" 2





namespace Dune {


    template <class T>
    std::string className(T &t)
    {




        return typeid(t).name();

    };


    template <class T>
    std::string className()
    {




        return typeid(T).name();

    };

}
# 18 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densematrix.hh" 2

namespace Dune
{

  template<typename M> class DenseMatrix;

  template<typename M>
  struct FieldTraits< DenseMatrix<M> >
  {
    typedef const typename FieldTraits< typename DenseMatVecTraits<M>::value_type >::field_type field_type;
    typedef const typename FieldTraits< typename DenseMatVecTraits<M>::value_type >::real_type real_type;
  };





  template<class K, int N, int M> class FieldMatrix;
  template<class K, int N> class FieldVector;
  namespace {
    template<class V>
    struct VectorSize
    {
      static typename V::size_type size(const V & v) { return v.size(); }
    };

    template<class K, int N>
    struct VectorSize< const FieldVector<K,N> >
    {
      typedef FieldVector<K,N> V;
      static typename V::size_type size(const V &) { return N; }
    };
  };
# 67 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densematrix.hh"
  template<typename M, typename T>
  void istl_assign_to_fmatrix(DenseMatrix<M>&, const T&)
  {
    do { NotImplemented th__ex; std::ostringstream th__out; th__out << "NotImplemented" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densematrix.hh" << ":" << 72 << "]: " << "You need to specialise the method istl_assign_to_fmatrix(DenseMatrix<M>& f, const T& t) " << "(with M being " << className<M>() << ") " << "for T == " << className<T>() << "!"; th__ex.message(th__out.str()); throw th__ex; } while (0);


  }

  namespace
  {
    template<bool b>
    struct DenseMatrixAssigner
    {
      template<typename M, typename T>
      static void assign(DenseMatrix<M>& fm, const T& t)
      {
        istl_assign_to_fmatrix(fm, t);
      }

    };


    template<>
    struct DenseMatrixAssigner<true>
    {
      template<typename M, typename T>
      static void assign(DenseMatrix<M>& fm, const T& t)
      {
        fm = static_cast<const typename DenseMatVecTraits<M>::value_type>(t);
      }
    };
  }


  class FMatrixError : public Exception {};
# 113 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densematrix.hh"
  template<typename MAT>
  class DenseMatrix
  {
    typedef DenseMatVecTraits<MAT> Traits;


    MAT & asImp() { return static_cast<MAT&>(*this); }
    const MAT & asImp() const { return static_cast<const MAT&>(*this); }

  public:



    typedef typename Traits::derived_type derived_type;


    typedef typename Traits::value_type value_type;


    typedef typename Traits::value_type field_type;


    typedef typename Traits::value_type block_type;


    typedef typename Traits::size_type size_type;


    typedef typename Traits::row_type row_type;


    enum {

      blocklevel = 1
    };




    row_type & operator[] (size_type i)
    {
      return asImp().mat_access(i);
    }

    const row_type & operator[] (size_type i) const
    {
      return asImp().mat_access(i);
    }


    size_type size() const
    {
      return rows();
    }



    typedef DenseIterator<DenseMatrix,row_type> Iterator;

    typedef Iterator iterator;

    typedef Iterator RowIterator;

    typedef typename row_type::Iterator ColIterator;


    Iterator begin ()
    {
      return Iterator(*this,0);
    }


    Iterator end ()
    {
      return Iterator(*this,rows());
    }





    Iterator rbegin() __attribute__((deprecated))
    {
      return beforeBegin();
    }



    Iterator beforeEnd ()
    {
      return Iterator(*this,rows()-1);
    }





    Iterator rend () __attribute__((deprecated))
    {
      return beforeBegin();
    }



    Iterator beforeBegin ()
    {
      return Iterator(*this,-1);
    }


    typedef DenseIterator<const DenseMatrix,const row_type> ConstIterator;

    typedef ConstIterator const_iterator;

    typedef ConstIterator ConstRowIterator;

    typedef typename row_type::ConstIterator ConstColIterator;


    ConstIterator begin () const
    {
      return ConstIterator(*this,0);
    }


    ConstIterator end () const
    {
      return ConstIterator(*this,rows());
    }





    ConstIterator rbegin() const __attribute__((deprecated))
    {
      return beforeEnd();
    }



    ConstIterator beforeEnd () const
    {
      return ConstIterator(*this,rows()-1);
    }





    ConstIterator rend () const __attribute__((deprecated))
    {
      return beforeBegin();
    }



    ConstIterator beforeBegin () const
    {
      return ConstIterator(*this,-1);
    }


    DenseMatrix& operator= (const field_type& f)
    {
      for (size_type i=0; i<rows(); i++)
        (*this)[i] = f;
      return *this;
    }

    template<typename T>
    DenseMatrix& operator= (const T& t)
    {
      DenseMatrixAssigner<Conversion<T,field_type>::exists>::assign(*this, t);
      return *this;
    }



    DenseMatrix& operator+= (const DenseMatrix& y)
    {
      for (size_type i=0; i<rows(); i++)
        (*this)[i] += y[i];
      return *this;
    }


    DenseMatrix& operator-= (const DenseMatrix& y)
    {
      for (size_type i=0; i<rows(); i++)
        (*this)[i] -= y[i];
      return *this;
    }


    DenseMatrix& operator*= (const field_type& k)
    {
      for (size_type i=0; i<rows(); i++)
        (*this)[i] *= k;
      return *this;
    }


    DenseMatrix& operator/= (const field_type& k)
    {
      for (size_type i=0; i<rows(); i++)
        (*this)[i] /= k;
      return *this;
    }


    DenseMatrix &axpy (const field_type &k, const DenseMatrix &y )
    {
      for( size_type i = 0; i < rows(); ++i )
        (*this)[ i ].axpy( k, y[ i ] );
      return *this;
    }


    bool operator== (const DenseMatrix& y) const
    {
      for (size_type i=0; i<rows(); i++)
        if ((*this)[i]!=y[i])
          return false;
      return true;
    }

    bool operator!= (const DenseMatrix& y) const
    {
      return !operator==(y);
    }





    template<class X, class Y>
    void mv (const X& x, Y& y) const
    {





      for (size_type i=0; i<rows(); ++i)
      {
        y[i] = 0;
        for (size_type j=0; j<cols(); j++)
          y[i] += (*this)[i][j] * x[j];
      }
    }


    template< class X, class Y >
    void mtv ( const X &x, Y &y ) const
    {
# 379 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densematrix.hh"
      for( size_type i = 0; i < cols(); ++i )
      {
        y[ i ] = 0;
        for( size_type j = 0; j < rows(); ++j )
          y[ i ] += (*this)[ j ][ i ] * x[ j ];
      }
    }


    template<class X, class Y>
    void umv (const X& x, Y& y) const
    {




      for (size_type i=0; i<rows(); i++)
        for (size_type j=0; j<cols(); j++)
          y[i] += (*this)[i][j] * x[j];
    }


    template<class X, class Y>
    void umtv (const X& x, Y& y) const
    {





      for (size_type i=0; i<rows(); i++)
        for (size_type j=0; j<cols(); j++)
          y[j] += (*this)[i][j]*x[i];
    }


    template<class X, class Y>
    void umhv (const X& x, Y& y) const
    {





      for (size_type i=0; i<rows(); i++)
        for (size_type j=0; j<cols(); j++)
          y[j] += conjugateComplex((*this)[i][j])*x[i];
    }


    template<class X, class Y>
    void mmv (const X& x, Y& y) const
    {




      for (size_type i=0; i<rows(); i++)
        for (size_type j=0; j<cols(); j++)
          y[i] -= (*this)[i][j] * x[j];
    }


    template<class X, class Y>
    void mmtv (const X& x, Y& y) const
    {





      for (size_type i=0; i<rows(); i++)
        for (size_type j=0; j<cols(); j++)
          y[j] -= (*this)[i][j]*x[i];
    }


    template<class X, class Y>
    void mmhv (const X& x, Y& y) const
    {





      for (size_type i=0; i<rows(); i++)
        for (size_type j=0; j<cols(); j++)
          y[j] -= conjugateComplex((*this)[i][j])*x[i];
    }


    template<class X, class Y>
    void usmv (const field_type& alpha, const X& x, Y& y) const
    {




      for (size_type i=0; i<rows(); i++)
        for (size_type j=0; j<cols(); j++)
          y[i] += alpha * (*this)[i][j] * x[j];
    }


    template<class X, class Y>
    void usmtv (const field_type& alpha, const X& x, Y& y) const
    {





      for (size_type i=0; i<rows(); i++)
        for (size_type j=0; j<cols(); j++)
          y[j] += alpha*(*this)[i][j]*x[i];
    }


    template<class X, class Y>
    void usmhv (const field_type& alpha, const X& x, Y& y) const
    {





      for (size_type i=0; i<rows(); i++)
        for (size_type j=0; j<cols(); j++)
          y[j] += alpha*conjugateComplex((*this)[i][j])*x[i];
    }




    typename FieldTraits<value_type>::real_type frobenius_norm () const
    {
      typename FieldTraits<value_type>::real_type sum=(0.0);
      for (size_type i=0; i<rows(); ++i) sum += (*this)[i].two_norm2();
      return fvmeta::sqrt(sum);
    }


    typename FieldTraits<value_type>::real_type frobenius_norm2 () const
    {
      typename FieldTraits<value_type>::real_type sum=(0.0);
      for (size_type i=0; i<rows(); ++i) sum += (*this)[i].two_norm2();
      return sum;
    }


    typename FieldTraits<value_type>::real_type infinity_norm () const
    {
      typename remove_const< typename FieldTraits<value_type>::real_type >::type max=(0.0);
      for (size_type i=0; i<rows(); ++i) max = std::max(max,(*this)[i].one_norm());
      return max;
    }


    typename FieldTraits<value_type>::real_type infinity_norm_real () const
    {
      typename FieldTraits<value_type>::real_type max(0.0);
      for (size_type i=0; i<rows(); ++i) max = std::max(max,(*this)[i].one_norm_real());
      return max;
    }







    template <class V>
    void solve (V& x, const V& b) const;





    void invert();


    field_type determinant () const;


    template<typename M2>
    MAT& leftmultiply (const DenseMatrix<M2>& M)
    {
      ((M.rows() == M.cols() && M.rows() == rows()) ? static_cast<void> (0) : __assert_fail ("M.rows() == M.cols() && M.rows() == rows()", "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densematrix.hh", 566, __PRETTY_FUNCTION__));
      MAT C(asImp());

      for (size_type i=0; i<rows(); i++)
        for (size_type j=0; j<cols(); j++) {
          (*this)[i][j] = 0;
          for (size_type k=0; k<rows(); k++)
            (*this)[i][j] += M[i][k]*C[k][j];
        }

      return asImp();
    }


    template<typename M2>
    MAT& rightmultiply (const DenseMatrix<M2>& M)
    {
      ((M.rows() == M.cols() && M.cols() == cols()) ? static_cast<void> (0) : __assert_fail ("M.rows() == M.cols() && M.cols() == cols()", "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densematrix.hh", 583, __PRETTY_FUNCTION__));
      MAT C(asImp());

      for (size_type i=0; i<rows(); i++)
        for (size_type j=0; j<cols(); j++) {
          (*this)[i][j] = 0;
          for (size_type k=0; k<cols(); k++)
            (*this)[i][j] += C[i][k]*M[k][j];
        }
      return asImp();
    }
# 632 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densematrix.hh"
    size_type N () const
    {
      return rows();
    }


    size_type M () const
    {
      return cols();
    }


    size_type rows() const
    {
      return asImp().mat_rows();
    }


    size_type cols() const
    {
      return asImp().mat_cols();
    }
# 664 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densematrix.hh"
    bool exists (size_type, size_type) const
    {

      return true;
    }

  private:


    struct ElimPivot
    {
      ElimPivot(std::vector<size_type> & pivot);

      void swap(int i, int j);

      template<typename T>
      void operator()(const T&, int, int)
      {}

      std::vector<size_type> & pivot_;
    };

    template<typename V>
    struct Elim
    {
      Elim(V& rhs);

      void swap(int i, int j);

      void operator()(const typename V::field_type& factor, int k, int i);

      V* rhs_;
    };

    struct ElimDet
    {
      ElimDet(field_type& sign) : sign_(sign)
      { sign_ = 1; }

      void swap(int, int)
      { sign_ *= -1; }

      void operator()(const field_type&, int, int)
      {}

      field_type& sign_;
    };


    template<class Func>
    void luDecomposition(DenseMatrix<MAT>& A, Func func) const;
  };


  template<typename MAT>
  DenseMatrix<MAT>::ElimPivot::ElimPivot(std::vector<size_type> & pivot)
    : pivot_(pivot)
  {
    typedef typename std::vector<size_type>::size_type size_type;
    for(size_type i=0; i < pivot_.size(); ++i) pivot_[i]=i;
  }

  template<typename MAT>
  void DenseMatrix<MAT>::ElimPivot::swap(int i, int j)
  {
    pivot_[i]=j;
  }

  template<typename MAT>
  template<typename V>
  DenseMatrix<MAT>::Elim<V>::Elim(V& rhs)
    : rhs_(&rhs)
  {}

  template<typename MAT>
  template<typename V>
  void DenseMatrix<MAT>::Elim<V>::swap(int i, int j)
  {
    std::swap((*rhs_)[i], (*rhs_)[j]);
  }

  template<typename MAT>
  template<typename V>
  void DenseMatrix<MAT>::
  Elim<V>::operator()(const typename V::field_type& factor, int k, int i)
  {
    (*rhs_)[k] -= factor*(*rhs_)[i];
  }
  template<typename MAT>
  template<typename Func>
  inline void DenseMatrix<MAT>::luDecomposition(DenseMatrix<MAT>& A, Func func) const
  {
    typedef typename FieldTraits<value_type>::real_type
      real_type;
    typename FieldTraits<value_type>::real_type norm =
      A.infinity_norm_real();
    typename FieldTraits<value_type>::real_type pivthres =
      std::max(FMatrixPrecision<real_type>::absolute_limit(),norm*FMatrixPrecision<>::pivoting_limit());
    typename FieldTraits<value_type>::real_type singthres =
      std::max(FMatrixPrecision<real_type>::absolute_limit(),norm*FMatrixPrecision<>::singular_limit());


    for (size_type i=0; i<rows(); i++)
    {
      typename FieldTraits<value_type>::real_type pivmax=fvmeta::absreal(A[i][i]);


      if (pivmax<pivthres)
      {

        size_type imax=i;
        typename FieldTraits<value_type>::real_type abs(0.0);
        for (size_type k=i+1; k<rows(); k++)
          if ((abs=fvmeta::absreal(A[k][i]))>pivmax)
          {
            pivmax = abs; imax = k;
          }

        if (imax!=i){
          for (size_type j=0; j<rows(); j++)
            std::swap(A[i][j],A[imax][j]);
          func.swap(i, imax);
        }
      }


      if (pivmax<singthres)
        do { FMatrixError th__ex; std::ostringstream th__out; th__out << "FMatrixError" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densematrix.hh" << ":" << 791 << "]: " << "matrix is singular"; th__ex.message(th__out.str()); throw th__ex; } while (0);


      for (size_type k=i+1; k<rows(); k++)
      {
        field_type factor = A[k][i]/A[i][i];
        A[k][i] = factor;
        for (size_type j=i+1; j<rows(); j++)
          A[k][j] -= factor*A[i][j];
        func(factor, k, i);
      }
    }
  }

  template<typename MAT>
  template <class V>
  inline void DenseMatrix<MAT>::solve(V& x, const V& b) const
  {

    if (rows()!=cols())
      do { FMatrixError th__ex; std::ostringstream th__out; th__out << "FMatrixError" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densematrix.hh" << ":" << 811 << "]: " << "Can't solve for a " << rows() << "x" << cols() << " matrix!"; th__ex.message(th__out.str()); throw th__ex; } while (0);

    if (rows()==1) {





      x[0] = b[0]/(*this)[0][0];

    }
    else if (rows()==2) {

      field_type detinv = (*this)[0][0]*(*this)[1][1]-(*this)[0][1]*(*this)[1][0];




      detinv = 1.0/detinv;

      x[0] = detinv*((*this)[1][1]*b[0]-(*this)[0][1]*b[1]);
      x[1] = detinv*((*this)[0][0]*b[1]-(*this)[1][0]*b[0]);

    }
    else if (rows()==3) {

      field_type d = determinant();





      x[0] = (b[0]*(*this)[1][1]*(*this)[2][2] - b[0]*(*this)[2][1]*(*this)[1][2]
        - b[1] *(*this)[0][1]*(*this)[2][2] + b[1]*(*this)[2][1]*(*this)[0][2]
        + b[2] *(*this)[0][1]*(*this)[1][2] - b[2]*(*this)[1][1]*(*this)[0][2]) / d;

      x[1] = ((*this)[0][0]*b[1]*(*this)[2][2] - (*this)[0][0]*b[2]*(*this)[1][2]
        - (*this)[1][0] *b[0]*(*this)[2][2] + (*this)[1][0]*b[2]*(*this)[0][2]
        + (*this)[2][0] *b[0]*(*this)[1][2] - (*this)[2][0]*b[1]*(*this)[0][2]) / d;

      x[2] = ((*this)[0][0]*(*this)[1][1]*b[2] - (*this)[0][0]*(*this)[2][1]*b[1]
        - (*this)[1][0] *(*this)[0][1]*b[2] + (*this)[1][0]*(*this)[2][1]*b[0]
        + (*this)[2][0] *(*this)[0][1]*b[1] - (*this)[2][0]*(*this)[1][1]*b[0]) / d;

    }
    else {

      V& rhs = x;
      rhs = b;
      Elim<V> elim(rhs);
      MAT A(asImp());

      luDecomposition(A, elim);


      for(int i=rows()-1; i>=0; i--){
        for (size_type j=i+1; j<rows(); j++)
          rhs[i] -= A[i][j]*x[j];
        x[i] = rhs[i]/A[i][i];
      }
    }
  }

  template<typename MAT>
  inline void DenseMatrix<MAT>::invert()
  {

    if (rows()!=cols())
      do { FMatrixError th__ex; std::ostringstream th__out; th__out << "FMatrixError" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densematrix.hh" << ":" << 879 << "]: " << "Can't invert a " << rows() << "x" << cols() << " matrix!"; th__ex.message(th__out.str()); throw th__ex; } while (0);

    if (rows()==1) {





      (*this)[0][0] = 1.0/(*this)[0][0];

    }
    else if (rows()==2) {

      field_type detinv = (*this)[0][0]*(*this)[1][1]-(*this)[0][1]*(*this)[1][0];




      detinv = 1.0/detinv;

      field_type temp=(*this)[0][0];
      (*this)[0][0] = (*this)[1][1]*detinv;
      (*this)[0][1] = -(*this)[0][1]*detinv;
      (*this)[1][0] = -(*this)[1][0]*detinv;
      (*this)[1][1] = temp*detinv;

    }
    else {

      MAT A(asImp());
      std::vector<size_type> pivot(rows());
      luDecomposition(A, ElimPivot(pivot));
      DenseMatrix<MAT>& L=A;
      DenseMatrix<MAT>& U=A;


      *this=field_type();

      for(size_type i=0; i<rows(); ++i)
        (*this)[i][i]=1;


      for (size_type i=0; i<rows(); i++)
        for (size_type j=0; j<i; j++)
          for (size_type k=0; k<rows(); k++)
            (*this)[i][k] -= L[i][j]*(*this)[j][k];


      for (size_type i=rows(); i>0;){
        --i;
        for (size_type k=0; k<rows(); k++){
          for (size_type j=i+1; j<rows(); j++)
            (*this)[i][k] -= U[i][j]*(*this)[j][k];
          (*this)[i][k] /= U[i][i];
        }
      }

      for(size_type i=rows(); i>0; ){
        --i;
        if(i!=pivot[i])
          for(size_type j=0; j<rows(); ++j)
            std::swap((*this)[j][pivot[i]], (*this)[j][i]);
      }
    }
  }


  template<typename MAT>
  inline typename DenseMatrix<MAT>::field_type
  DenseMatrix<MAT>::determinant() const
  {

    if (rows()!=cols())
      do { FMatrixError th__ex; std::ostringstream th__out; th__out << "FMatrixError" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densematrix.hh" << ":" << 952 << "]: " << "There is no determinant for a " << rows() << "x" << cols() << " matrix!"; th__ex.message(th__out.str()); throw th__ex; } while (0);

    if (rows()==1)
      return (*this)[0][0];

    if (rows()==2)
      return (*this)[0][0]*(*this)[1][1] - (*this)[0][1]*(*this)[1][0];

    if (rows()==3) {

      field_type t4 = (*this)[0][0] * (*this)[1][1];
      field_type t6 = (*this)[0][0] * (*this)[1][2];
      field_type t8 = (*this)[0][1] * (*this)[1][0];
      field_type t10 = (*this)[0][2] * (*this)[1][0];
      field_type t12 = (*this)[0][1] * (*this)[2][0];
      field_type t14 = (*this)[0][2] * (*this)[2][0];

      return (t4*(*this)[2][2]-t6*(*this)[2][1]-t8*(*this)[2][2]+
        t10*(*this)[2][1]+t12*(*this)[1][2]-t14*(*this)[1][1]);

    }

    MAT A(asImp());
    field_type det;
    try
    {
      luDecomposition(A, ElimDet(det));
    }
    catch (FMatrixError&)
    {
      return 0;
    }
    for (size_type i = 0; i < rows(); ++i)
      det *= A[i][i];
    return det;
  }



  namespace DenseMatrixHelp {
# 1132 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densematrix.hh"
    template <typename MAT, typename V1, typename V2>
    static inline void multAssign(const DenseMatrix<MAT> &matrix, const DenseVector<V1> & x, DenseVector<V2> & ret)
    {
      ((x.size() == matrix.cols()) ? static_cast<void> (0) : __assert_fail ("x.size() == matrix.cols()", "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densematrix.hh", 1135, __PRETTY_FUNCTION__));
      ((ret.size() == matrix.rows()) ? static_cast<void> (0) : __assert_fail ("ret.size() == matrix.rows()", "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densematrix.hh", 1136, __PRETTY_FUNCTION__));
      typedef typename DenseMatrix<MAT>::size_type size_type;

      for(size_type i=0; i<matrix.rows(); ++i)
      {
        ret[i] = 0.0;
        for(size_type j=0; j<matrix.cols(); ++j)
        {
          ret[i] += matrix[i][j]*x[j];
        }
      }
    }
# 1183 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/densematrix.hh"
  }


  template<typename MAT>
  std::ostream& operator<< (std::ostream& s, const DenseMatrix<MAT>& a)
  {
    for (typename DenseMatrix<MAT>::size_type i=0; i<a.rows(); i++)
      s << a[i] << std::endl;
    return s;
  }



}
# 15 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fmatrix.hh" 2



namespace Dune
{
# 32 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fmatrix.hh"
  template< class K, int ROWS, int COLS > class FieldMatrix;
  template< class K, int ROWS, int COLS >
  struct DenseMatVecTraits< FieldMatrix<K,ROWS,COLS> >
  {
    typedef FieldMatrix<K,ROWS,COLS> derived_type;
    typedef FieldVector<K,COLS> row_type;
    typedef Dune::array<row_type,ROWS> container_type;
    typedef K value_type;
    typedef typename container_type::size_type size_type;
  };

  template< class K, int ROWS, int COLS >
  struct FieldTraits< FieldMatrix<K,ROWS,COLS> >
  {
    typedef typename FieldTraits<K>::field_type field_type;
    typedef typename FieldTraits<K>::real_type real_type;
  };
# 58 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fmatrix.hh"
  template<class K, int ROWS, int COLS>
  class FieldMatrix : public DenseMatrix< FieldMatrix<K,ROWS,COLS> >
  {
    Dune::array< FieldVector<K,COLS>, ROWS > _data;
    typedef DenseMatrix< FieldMatrix<K,ROWS,COLS> > Base;
  public:


    enum {

      rows = ROWS,

      cols = COLS
    };

    typedef typename Base::size_type size_type;
    typedef typename Base::row_type row_type;




    FieldMatrix () {}



    explicit FieldMatrix (const K& k)
    {
      for (size_type i=0; i<rows; i++) _data[i] = k;
    }

    template<typename T>
    explicit FieldMatrix (const T& t)
    {
      DenseMatrixAssigner<Conversion<T,K>::exists>::assign(*this, t);
    }


    using Base::operator=;
# 116 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fmatrix.hh"
    template<int l>
    FieldMatrix<K,l,cols> leftmultiplyany (const FieldMatrix<K,l,rows>& M) const
    {
      FieldMatrix<K,l,cols> C;

      for (size_type i=0; i<l; i++) {
        for (size_type j=0; j<cols; j++) {
          C[i][j] = 0;
          for (size_type k=0; k<rows; k++)
            C[i][j] += M[i][k]*(*this)[k][j];
        }
      }
      return C;
    }


    FieldMatrix& rightmultiply (const FieldMatrix<K,cols,cols>& M)
    {
      FieldMatrix<K,rows,cols> C(*this);

      for (size_type i=0; i<rows; i++)
        for (size_type j=0; j<cols; j++) {
          (*this)[i][j] = 0;
          for (size_type k=0; k<cols; k++)
            (*this)[i][j] += C[i][k]*M[k][j];
        }
      return *this;
    }


    template<int l>
    FieldMatrix<K,rows,l> rightmultiplyany (const FieldMatrix<K,cols,l>& M) const
    {
      FieldMatrix<K,rows,l> C;

      for (size_type i=0; i<rows; i++) {
        for (size_type j=0; j<l; j++) {
          C[i][j] = 0;
          for (size_type k=0; k<cols; k++)
            C[i][j] += (*this)[i][k]*M[k][j];
        }
      }
      return C;
    }


    size_type mat_rows() const { return ROWS; }
    size_type mat_cols() const { return COLS; }
    row_type & mat_access(size_type i) {
      ((i < ROWS) ? static_cast<void> (0) : __assert_fail ("i < ROWS", "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fmatrix.hh", 165, __PRETTY_FUNCTION__));
      return _data[i];
    }
    const row_type & mat_access(size_type i) const {
      ((i < ROWS) ? static_cast<void> (0) : __assert_fail ("i < ROWS", "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fmatrix.hh", 169, __PRETTY_FUNCTION__));
      return _data[i];
    }
  };




  template<class K>
  class FieldMatrix<K,1,1> : public DenseMatrix< FieldMatrix<K,1,1> >
  {
    FieldVector<K,1> _data;
    typedef DenseMatrix< FieldMatrix<K,1,1> > Base;
  public:





    typedef typename Base::size_type size_type;


    enum {


      blocklevel = 1
    };


    typedef FieldVector<K,1> row_type;


    enum {


      rows = 1,


      cols = 1
    };




    FieldMatrix () {}



    FieldMatrix (const K& k)
    {
      _data[0] = k;
    }
    template<typename T>
    FieldMatrix(const T& t)
    {
      DenseMatrixAssigner<Conversion<T,K>::exists>::assign(*this, t);
    }




    template<int l>
    FieldMatrix<K,l,1> leftmultiplyany (const FieldMatrix<K,l,1>& M) const
    {
      FieldMatrix<K,l,1> C;
      for (size_type j=0; j<l; j++)
        C[j][0] = M[j][0]*(*this)[0][0];
      return C;
    }


    FieldMatrix& rightmultiply (const FieldMatrix& M)
    {
      _data[0] *= M[0][0];
      return *this;
    }


    template<int l>
    FieldMatrix<K,1,l> rightmultiplyany (const FieldMatrix<K,1,l>& M) const
    {
      FieldMatrix<K,1,l> C;

      for (size_type j=0; j<l; j++)
        C[0][j] = M[0][j]*_data[0];
      return C;
    }


    size_type mat_rows() const { return 1; }
    size_type mat_cols() const { return 1; }
    row_type & mat_access(size_type i) {
      ((i == 0) ? static_cast<void> (0) : __assert_fail ("i == 0", "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fmatrix.hh", 261, __PRETTY_FUNCTION__));
      return _data;
    }
    const row_type & mat_access(size_type i) const {
      ((i == 0) ? static_cast<void> (0) : __assert_fail ("i == 0", "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fmatrix.hh", 265, __PRETTY_FUNCTION__));
      return _data;
    }


    FieldMatrix& operator+= (const K& k)
    {
      _data[0] += k;
      return (*this);
    }


    FieldMatrix& operator-= (const K& k)
    {
      _data[0] -= k;
      return (*this);
    }


    FieldMatrix& operator*= (const K& k)
    {
      _data[0] *= k;
      return (*this);
    }


    FieldMatrix& operator/= (const K& k)
    {
      _data[0] /= k;
      return (*this);
    }



    operator K () const { return _data[0]; }

  };


  template<typename K>
  std::ostream& operator<< (std::ostream& s, const FieldMatrix<K,1,1>& a)
  {
    s << a[0][0];
    return s;
  }



namespace FMatrixHelp {


template <typename K>
static inline K invertMatrix (const FieldMatrix<K,1,1> &matrix, FieldMatrix<K,1,1> &inverse)
{
  inverse[0][0] = 1.0/matrix[0][0];
  return matrix[0][0];
}


template <typename K>
static inline K invertMatrix_retTransposed (const FieldMatrix<K,1,1> &matrix, FieldMatrix<K,1,1> &inverse)
{
  return invertMatrix(matrix,inverse);
}



template <typename K>
static inline K invertMatrix (const FieldMatrix<K,2,2> &matrix, FieldMatrix<K,2,2> &inverse)
{

  K det = (matrix[0][0]*matrix[1][1] - matrix[0][1]*matrix[1][0]);
  K det_1 = 1.0/det;
  inverse[0][0] = matrix[1][1] * det_1;
  inverse[0][1] = - matrix[0][1] * det_1;
  inverse[1][0] = - matrix[1][0] * det_1;
  inverse[1][1] = matrix[0][0] * det_1;
  return det;
}



template <typename K>
static inline K invertMatrix_retTransposed (const FieldMatrix<K,2,2> &matrix, FieldMatrix<K,2,2> &inverse)
{

  K det = (matrix[0][0]*matrix[1][1] - matrix[0][1]*matrix[1][0]);
  K det_1 = 1.0/det;
  inverse[0][0] = matrix[1][1] * det_1;
  inverse[1][0] = - matrix[0][1] * det_1;
  inverse[0][1] = - matrix[1][0] * det_1;
  inverse[1][1] = matrix[0][0] * det_1;
  return det;
}


template <typename K>
static inline K invertMatrix (const FieldMatrix<K,3,3> &matrix, FieldMatrix<K,3,3> &inverse)
{

  K t4 = matrix[0][0] * matrix[1][1];
  K t6 = matrix[0][0] * matrix[1][2];
  K t8 = matrix[0][1] * matrix[1][0];
  K t10 = matrix[0][2] * matrix[1][0];
  K t12 = matrix[0][1] * matrix[2][0];
  K t14 = matrix[0][2] * matrix[2][0];

  K det = (t4*matrix[2][2]-t6*matrix[2][1]-t8*matrix[2][2]+
           t10*matrix[2][1]+t12*matrix[1][2]-t14*matrix[1][1]);
  K t17 = 1.0/det;

  inverse[0][0] = (matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[2][1])*t17;
  inverse[0][1] = -(matrix[0][1] * matrix[2][2] - matrix[0][2] * matrix[2][1])*t17;
  inverse[0][2] = (matrix[0][1] * matrix[1][2] - matrix[0][2] * matrix[1][1])*t17;
  inverse[1][0] = -(matrix[1][0] * matrix[2][2] - matrix[1][2] * matrix[2][0])*t17;
  inverse[1][1] = (matrix[0][0] * matrix[2][2] - t14) * t17;
  inverse[1][2] = -(t6-t10) * t17;
  inverse[2][0] = (matrix[1][0] * matrix[2][1] - matrix[1][1] * matrix[2][0]) * t17;
  inverse[2][1] = -(matrix[0][0] * matrix[2][1] - t12) * t17;
  inverse[2][2] = (t4-t8) * t17;

  return det;
}


template <typename K>
static inline K invertMatrix_retTransposed (const FieldMatrix<K,3,3> &matrix, FieldMatrix<K,3,3> &inverse)
{

  K t4 = matrix[0][0] * matrix[1][1];
  K t6 = matrix[0][0] * matrix[1][2];
  K t8 = matrix[0][1] * matrix[1][0];
  K t10 = matrix[0][2] * matrix[1][0];
  K t12 = matrix[0][1] * matrix[2][0];
  K t14 = matrix[0][2] * matrix[2][0];

  K det = (t4*matrix[2][2]-t6*matrix[2][1]-t8*matrix[2][2]+
           t10*matrix[2][1]+t12*matrix[1][2]-t14*matrix[1][1]);
  K t17 = 1.0/det;

  inverse[0][0] = (matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[2][1])*t17;
  inverse[1][0] = -(matrix[0][1] * matrix[2][2] - matrix[0][2] * matrix[2][1])*t17;
  inverse[2][0] = (matrix[0][1] * matrix[1][2] - matrix[0][2] * matrix[1][1])*t17;
  inverse[0][1] = -(matrix[1][0] * matrix[2][2] - matrix[1][2] * matrix[2][0])*t17;
  inverse[1][1] = (matrix[0][0] * matrix[2][2] - t14) * t17;
  inverse[2][1] = -(t6-t10) * t17;
  inverse[0][2] = (matrix[1][0] * matrix[2][1] - matrix[1][1] * matrix[2][0]) * t17;
  inverse[1][2] = -(matrix[0][0] * matrix[2][1] - t12) * t17;
  inverse[2][2] = (t4-t8) * t17;

  return det;
}


template< class K, int m, int n, int p >
static inline void multMatrix ( const FieldMatrix< K, m, n > &A,
                                const FieldMatrix< K, n, p > &B,
                                FieldMatrix< K, m, p > &ret )
{
  typedef typename FieldMatrix< K, m, p > :: size_type size_type;

  for( size_type i = 0; i < m; ++i )
  {
    for( size_type j = 0; j < p; ++j )
    {
      ret[ i ][ j ] = K( 0 );
      for( size_type k = 0; k < n; ++k )
        ret[ i ][ j ] += A[ i ][ k ] * B[ k ][ j ];
    }
  }
}


template <typename K, int rows, int cols>
static inline void multTransposedMatrix(const FieldMatrix<K,rows,cols> &matrix, FieldMatrix<K,cols,cols>& ret)
{
  typedef typename FieldMatrix<K,rows,cols>::size_type size_type;

  for(size_type i=0; i<cols; i++)
    for(size_type j=0; j<cols; j++)
    {
      ret[i][j]=0.0;
      for(size_type k=0; k<rows; k++)
        ret[i][j]+=matrix[k][i]*matrix[k][j];
    }
}
# 469 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fmatrix.hh"
using Dune::DenseMatrixHelp::multAssign;



template <typename K, int rows, int cols>
static inline void multAssignTransposed( const FieldMatrix<K,rows,cols> &matrix, const FieldVector<K,rows> & x, FieldVector<K,cols> & ret)
{
  typedef typename FieldMatrix<K,rows,cols>::size_type size_type;

  for(size_type i=0; i<cols; ++i)
  {
    ret[i] = 0.0;
    for(size_type j=0; j<rows; ++j)
      ret[i] += matrix[j][i]*x[j];
  }
}


template <typename K, int rows, int cols>
static inline FieldVector<K,rows> mult(const FieldMatrix<K,rows,cols> &matrix, const FieldVector<K,cols> & x)
{
  FieldVector<K,rows> ret;
  multAssign(matrix,x,ret);
  return ret;
}


template <typename K, int rows, int cols>
static inline FieldVector<K,cols> multTransposed(const FieldMatrix<K,rows,cols> &matrix, const FieldVector<K,rows> & x)
{
  FieldVector<K,cols> ret;
  multAssignTransposed( matrix, x, ret );
  return ret;
}

}



}


# 1 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fmatrixev.hh" 1




# 1 "/usr/include/c++/4.4/cmath" 1 3
# 41 "/usr/include/c++/4.4/cmath" 3
# 41 "/usr/include/c++/4.4/cmath" 3
# 6 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fmatrixev.hh" 2
# 1 "/usr/include/c++/4.4/cassert" 1 3
# 43 "/usr/include/c++/4.4/cassert" 3
# 43 "/usr/include/c++/4.4/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 45 "/usr/include/c++/4.4/cassert" 2 3
# 7 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fmatrixev.hh" 2



# 1 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fmatrix.hh" 1
# 11 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fmatrixev.hh" 2
# 21 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fmatrixev.hh"
extern "C" {
# 73 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fmatrixev.hh"
extern void dsyev_(const char* jobz, const char* uplo, const long
    int* n, double* a, const long int* lda, double* w,
    double* work, const long int* lwork, long int* info);

}


namespace Dune {






namespace FMatrixHelp {






template <typename K>
static void eigenValues(const FieldMatrix<K, 1, 1>& matrix,
                        FieldVector<K, 1>& eigenvalues)
{
  eigenvalues[0] = matrix[0][0];
}






template <typename K>
static void eigenValues(const FieldMatrix<K, 2, 2>& matrix,
                        FieldVector<K, 2>& eigenvalues)
{
  const K detM = matrix[0][0] * matrix[1][1] - matrix[1][0] * matrix[0][1];
  const K p = 0.5 * (matrix[0][0] + matrix [1][1]);
  K q = p * p - detM;
  if( q < 0 && q > -1e-14 ) q = 0;
  if (p < 0 || q < 0)
  {
    std::cout << p << " p | q " << q << "\n";
    std::cout << matrix << std::endl;
    std::cout << "something went wrong in Eigenvalues for matrix!" << std::endl;
    ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fmatrixev.hh", 119, __PRETTY_FUNCTION__));
    abort();
  }


  q = std :: sqrt(q);


  eigenvalues[0] = p - q;
  eigenvalues[1] = p + q;
}
# 139 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fmatrixev.hh"
template <int dim, typename K>
static void eigenValues(const FieldMatrix<K, dim, dim>& matrix,
                        FieldVector<K, dim>& eigenvalues)
{
  {
    const long int N = dim ;
    const char jobz = 'n';
    const char uplo = 'u';


    const long int w = N * N ;


    double matrixVector[dim * dim];


    int row = 0;
    for(int i=0; i<dim; ++i)
    {
      for(int j=0; j<dim; ++j, ++row)
      {
        matrixVector[ row ] = matrix[ i ][ j ];
      }
    }


    double workSpace[dim * dim];


    long int info = 0;


    dsyev_(&jobz, &uplo, &N, &matrixVector[0], &N,
        &eigenvalues[0], &workSpace[0], &w, &info);

    if( info != 0 )
    {
      std::cerr << "For matrix " << matrix << " eigenvalue calculation failed! " << std::endl;
      do { InvalidStateException th__ex; std::ostringstream th__out; th__out << "InvalidStateException" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fmatrixev.hh" << ":" << 177 << "]: " << "eigenValues: Eigenvalue calculation failed!"; th__ex.message(th__out.str()); throw th__ex; } while (0);
    }
  }
}


}



}
# 511 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/fmatrix.hh" 2
# 10 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/utility/mockgeometry.hh" 2


# 1 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/geometry.hh" 1







# 1 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/nullptr.hh" 1
# 16 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/nullptr.hh"
const
class dune_nullptr_t {
public:
  template<class T>
    operator T*() const
    { return 0; }
  template<class C, class T>
    operator T C::*() const
    { return 0; }
private:
  void operator&() const;
} nullptr = {};

namespace Dune {
    typedef dune_nullptr_t nullptr_t;
}

template<class T>
bool operator == (T* t, dune_nullptr_t)
{
    return (t == static_cast<T*>(nullptr));
}

template<class T>
bool operator == (dune_nullptr_t, T* t)
{
    return (t == static_cast<T*>(nullptr));
}
# 9 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/geometry.hh" 2

# 1 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/geometry.hh" 1







# 1 "/usr/include/c++/4.4/cassert" 1 3
# 43 "/usr/include/c++/4.4/cassert" 3
# 43 "/usr/include/c++/4.4/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 45 "/usr/include/c++/4.4/cassert" 2 3
# 9 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/geometry.hh" 2




# 1 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh" 1






# 1 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/forloop.hh" 1








namespace Dune
{




  template< template< class, class > class Operation, template< int > class Value, int first, int last >
  class GenericForLoop
  : public Operation< Value< first >, GenericForLoop< Operation, Value, first+1, last > >
  {
    typedef static_assert_test< sizeof(static_assert_failure< (bool)( (first <= last) )>) > dune_static_assert_typedef_19;
  };

  template< template< class, class > class Operation, template< int > class Value, int last >
  class GenericForLoop< Operation, Value, last, last >
  : public Value< last >
  {};






  namespace ForLoopHelper
  {

    template< class A, class B >
    struct Apply
    {
      static void apply ()
      {
        A::apply();
        B::apply();
      }

      template< class T1 >
      static void apply ( T1 &p1 )
      {
        A::apply( p1 );
        B::apply( p1 );
      }

      template< class T1, class T2 >
      static void apply ( T1 &p1, T2 &p2 )
      {
        A::apply( p1, p2 );
        B::apply( p1, p2 );
      }

      template< class T1, class T2, class T3 >
      static void apply ( T1 &p1, T2 &p2, T3 &p3 )
      {
        A::apply( p1, p2, p3 );
        B::apply( p1, p2, p3 );
      }

      template< class T1, class T2, class T3, class T4 >
      static void apply ( T1 &p1, T2 &p2, T3 &p3, T4 &p4 )
      {
        A::apply( p1, p2, p3, p4 );
        B::apply( p1, p2, p3, p4 );
      }

      template< class T1, class T2, class T3, class T4, class T5 >
      static void apply ( T1 &p1, T2 &p2, T3 &p3, T4 &p4, T5 &p5 )
      {
        A::apply( p1, p2, p3, p4, p5 );
        B::apply( p1, p2, p3, p4, p5 );
      }

      template< class T1, class T2, class T3, class T4, class T5, class T6 >
      static void apply ( T1 &p1, T2 &p2, T3 &p3, T4 &p4, T5 &p5, T6 &p6 )
      {
        A::apply( p1, p2, p3, p4, p5, p6 );
        B::apply( p1, p2, p3, p4, p5, p6 );
      }

      template< class T1, class T2, class T3, class T4, class T5, class T6,
                class T7 >
      static void apply ( T1 &p1, T2 &p2, T3 &p3, T4 &p4, T5 &p5, T6 &p6,
                          T7 &p7 )
      {
        A::apply( p1, p2, p3, p4, p5, p6, p7 );
        B::apply( p1, p2, p3, p4, p5, p6, p7 );
      }

      template< class T1, class T2, class T3, class T4, class T5, class T6,
                class T7, class T8 >
      static void apply ( T1 &p1, T2 &p2, T3 &p3, T4 &p4, T5 &p5, T6 &p6,
                          T7 &p7, T8 &p8 )
      {
        A::apply( p1, p2, p3, p4, p5, p6, p7, p8 );
        B::apply( p1, p2, p3, p4, p5, p6, p7, p8 );
      }

      template< class T1, class T2, class T3, class T4, class T5, class T6,
                class T7, class T8, class T9 >
      static void apply ( T1 &p1, T2 &p2, T3 &p3, T4 &p4, T5 &p5, T6 &p6,
                          T7 &p7, T8 &p8, T9 &p9 )
      {
        A::apply( p1, p2, p3, p4, p5, p6, p7, p8, p9 );
        B::apply( p1, p2, p3, p4, p5, p6, p7, p8, p9 );
      }

      template< class T1, class T2, class T3, class T4, class T5, class T6,
                class T7, class T8, class T9, class T10 >
      static void apply ( T1 &p1, T2 &p2, T3 &p3, T4 &p4, T5 &p5, T6 &p6,
                          T7 &p7, T8 &p8, T9 &p9, T10 &p10 )
      {
        A::apply( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10 );
        B::apply( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10 );
      }

      template< class T1, class T2, class T3, class T4, class T5, class T6,
                class T7, class T8, class T9, class T10, class T11 >
      static void apply ( T1 &p1, T2 &p2, T3 &p3, T4 &p4, T5 &p5, T6 &p6,
                          T7 &p7, T8 &p8, T9 &p9, T10 &p10, T11 &p11 )
      {
        A::apply( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11 );
        B::apply( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11 );
      }

      template< class T1, class T2, class T3, class T4, class T5, class T6,
                class T7, class T8, class T9, class T10, class T11, class T12 >
      static void apply ( T1 &p1, T2 &p2, T3 &p3, T4 &p4, T5 &p5, T6 &p6,
                          T7 &p7, T8 &p8, T9 &p9, T10 &p10, T11 &p11,
                          T12 &p12 )
      {
        A::apply( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12 );
        B::apply( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12 );
      }

      template< class T1, class T2, class T3, class T4, class T5, class T6,
                class T7, class T8, class T9, class T10, class T11, class T12,
                class T13>
      static void apply ( T1 &p1, T2 &p2, T3 &p3, T4 &p4, T5 &p5, T6 &p6,
                          T7 &p7, T8 &p8, T9 &p9, T10 &p10, T11 &p11,
                          T12 &p12, T13 &p13 )
      {
        A::apply( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13 );
        B::apply( p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13 );
      }
    };

  }
# 216 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/forloop.hh"
  template< template< int > class Operation, int first, int last >
  class ForLoop
  : public GenericForLoop< ForLoopHelper::Apply, Operation, first, last >
  {
    typedef static_assert_test< sizeof(static_assert_failure< (bool)( (first <= last) )>) > dune_static_assert_typedef_220;
  };

}
# 8 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh" 2


# 1 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/subtopologies.hh" 1



# 1 "/usr/include/c++/4.4/cassert" 1 3
# 43 "/usr/include/c++/4.4/cassert" 3
# 43 "/usr/include/c++/4.4/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 45 "/usr/include/c++/4.4/cassert" 2 3
# 5 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/subtopologies.hh" 2






# 1 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/topologytypes.hh" 1








namespace Dune
{

  namespace GenericGeometry
  {

    struct Point
    {
      static const unsigned int dimension = 0;
      static const unsigned int numCorners = 1;

      static const unsigned int id = 0;

      static std :: string name ()
      {
        return "p";
      }
    };


    template< class BaseTopology >
    struct Prism
    {
      static const unsigned int dimension = BaseTopology :: dimension + 1;
      static const unsigned int numCorners = 2 * BaseTopology :: numCorners;

      static const unsigned int id = BaseTopology :: id + (1 << (dimension-1));

      static std :: string name ()
      {
        return BaseTopology :: name() + "l";

      }
    };


    template< class BaseTopology >
    struct Pyramid
    {
      static const unsigned int dimension = BaseTopology :: dimension + 1;
      static const unsigned int numCorners = BaseTopology :: numCorners + 1;

      static const unsigned int id = BaseTopology :: id;

      static std :: string name ()
      {
        return BaseTopology :: name() + "o";

      }
    };



    template< class Topology >
    struct BaseTopology;

    template< class Base >
    struct BaseTopology< Prism< Base > >
    {
      typedef Base type;
    };

    template< class Base >
    struct BaseTopology< Pyramid< Base > >
    {
      typedef Base type;
    };



    template< class Topology >
    struct IsSimplex
    {
      static const bool value = ((Topology::id >> 1) == 0);
    };

    template< class Topology >
    struct IsCube
    {
      static const bool value = ((Topology::id | 1) == (1 << Topology::dimension) - 1);
    };

    template< class Topology >
    struct IsHybrid
    {
      static const bool value
        = !(IsSimplex< Topology >::value || IsCube< Topology >::value);
    };

    template< class Topology >
    struct IsGeneralizedPrism
    {
      static const bool value = false;
    };

    template< class BaseTopology >
    struct IsGeneralizedPrism< Prism< BaseTopology > >
    {
      static const bool value
        = (IsGeneralizedPrism< BaseTopology >::value || IsSimplex< BaseTopology >::value);
    };






    template< unsigned int dim >
    struct SimplexTopology
    {
      typedef Pyramid< typename SimplexTopology< dim-1 >::type > type;
    };

    template<>
    struct SimplexTopology< 0 >
    {
      typedef Point type;
    };






    template< unsigned int dim >
    struct CubeTopology
    {
      typedef Prism< typename CubeTopology< dim-1 >::type > type;
    };

    template<>
    struct CubeTopology< 0 >
    {
      typedef Point type;
    };






    template< unsigned int dim >
    struct PyramidTopology
    {
      typedef Pyramid< typename CubeTopology< dim-1 >::type > type;
    };






    template< unsigned int dim >
    struct PrismTopology
    {
      typedef Prism< typename SimplexTopology< dim-1 >::type > type;
    };






    template< unsigned int id, unsigned int dim >
    class Topology
    {
      static const unsigned int dimension = dim;

      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (id < (1 << dimension)) )>) > dune_static_assert_typedef_177;

      static const bool isPrism = ((id >> (dimension-1)) != 0);

      typedef typename Topology< (id & ~(1 << (dimension-1))), dimension-1 >::type
        BaseTopology;

      template< bool >
      struct Prism
      {
        typedef GenericGeometry :: Prism< BaseTopology > type;
      };

      template< bool >
      struct Pyramid
      {
        typedef GenericGeometry :: Pyramid< BaseTopology > type;
      };

    public:
      typedef typename SelectType< isPrism, Prism<true>, Pyramid<false> >::Type::type type;
    };

    template< unsigned int id >
    class Topology< id, 0 >
    {
      static const unsigned int dimension = 0;

      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (id < (1 << dimension)) )>) > dune_static_assert_typedef_205;

    public:
      typedef Point type;
    };






    template< template< class > class Operation, int dim, class Topology = Point >
    class IfTopology
    {
      typedef IfTopology< Operation, dim-1, Prism< Topology > > IfPrism;
      typedef IfTopology< Operation, dim-1, Pyramid< Topology > > IfPyramid;

    public:
      static void apply ( const unsigned int topologyId )
      {
        if( topologyId & 1 )
          IfPrism::apply( topologyId >> 1 );
        else
          IfPyramid::apply( topologyId >> 1 );
      }

      template< class T1 >
      static void apply ( const unsigned int topologyId, T1 &p1 )
      {
        if( topologyId & 1 )
          IfPrism::apply( topologyId >> 1, p1 );
        else
          IfPyramid::apply( topologyId >> 1, p1 );
      }

      template< class T1, class T2 >
      static void apply ( const unsigned int topologyId, T1 &p1, T2 &p2 )
      {
        if( topologyId & 1 )
          IfPrism::apply( topologyId >> 1, p1, p2 );
        else
          IfPyramid::apply( topologyId >> 1, p1, p2 );
      }

      template< class T1, class T2, class T3 >
      static void apply ( const unsigned int topologyId, T1 &p1, T2 &p2, T3 &p3 )
      {
        if( topologyId & 1 )
          IfPrism::apply( topologyId >> 1, p1, p2, p3 );
        else
          IfPyramid::apply( topologyId >> 1, p1, p2, p3 );
      }

      template< class T1, class T2, class T3, class T4 >
      static void apply ( const unsigned int topologyId, T1 &p1, T2 &p2, T3 &p3, T4 &p4 )
      {
        if( topologyId & 1 )
          IfPrism::apply( topologyId >> 1, p1, p2, p3, p4 );
        else
          IfPyramid::apply( topologyId >> 1, p1, p2, p3, p4 );
      }
    };

    template< template< class > class Operation, class Topology >
    class IfTopology< Operation, 0, Topology >
    {
    public:
      static void apply ( const unsigned int topologyId )
      {
        Operation< Topology >::apply();
      }

      template< class T1 >
      static void apply ( const unsigned int topologyId, T1 &p1 )
      {
        Operation< Topology >::apply( p1 );
      }

      template< class T1, class T2 >
      static void apply ( const unsigned int topologyId, T1 &p1, T2 &p2 )
      {
        Operation< Topology >::apply( p1, p2 );
      }

      template< class T1, class T2, class T3 >
      static void apply ( const unsigned int topologyId, T1 &p1, T2 &p2, T3 &p3 )
      {
        Operation< Topology >::apply( p1, p2, p3 );
      }

      template< class T1, class T2, class T3, class T4 >
      static void apply ( const unsigned int topologyId, T1 &p1, T2 &p2, T3 &p3, T4 &p4 )
      {
        Operation< Topology >::apply( p1, p2, p3, p4 );
      }
    };

  }

}
# 12 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/subtopologies.hh" 2
# 1 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/codimtable.hh" 1







# 1 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tupleutility.hh" 1






# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 8 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tupleutility.hh" 2




# 1 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tuples.hh" 1
# 16 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tuples.hh"
# 1 "/usr/include/c++/4.4/tr1/tuple" 1 3
# 35 "/usr/include/c++/4.4/tr1/tuple" 3
# 35 "/usr/include/c++/4.4/tr1/tuple" 3

# 1 "/usr/include/c++/4.4/utility" 1 3
# 59 "/usr/include/c++/4.4/utility" 3
# 59 "/usr/include/c++/4.4/utility" 3


# 1 "/usr/include/c++/4.4/bits/stl_relops.h" 1 3
# 67 "/usr/include/c++/4.4/bits/stl_relops.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  namespace rel_ops
  {
# 83 "/usr/include/c++/4.4/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 96 "/usr/include/c++/4.4/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 109 "/usr/include/c++/4.4/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 122 "/usr/include/c++/4.4/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }

  }

}
# 62 "/usr/include/c++/4.4/utility" 2 3
# 37 "/usr/include/c++/4.4/tr1/tuple" 2 3

namespace std
{
namespace tr1
{

  template<typename _Tp>
    struct __add_c_ref
    { typedef const _Tp& type; };

  template<typename _Tp>
    struct __add_c_ref<_Tp&>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct __add_ref
    { typedef _Tp& type; };

  template<typename _Tp>
    struct __add_ref<_Tp&>
    { typedef _Tp& type; };
# 68 "/usr/include/c++/4.4/tr1/tuple" 3
  template<int _Idx, typename... _Elements>
    struct _Tuple_impl;





  template<int _Idx>
    struct _Tuple_impl<_Idx> { };






  template<int _Idx, typename _Head, typename... _Tail>
    struct _Tuple_impl<_Idx, _Head, _Tail...>
    : public _Tuple_impl<_Idx + 1, _Tail...>
    {
      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;

      _Head _M_head;

      _Inherited& _M_tail() { return *this; }
      const _Inherited& _M_tail() const { return *this; }

      _Tuple_impl() : _Inherited(), _M_head() { }

      explicit
      _Tuple_impl(typename __add_c_ref<_Head>::type __head,
    typename __add_c_ref<_Tail>::type... __tail)
      : _Inherited(__tail...), _M_head(__head) { }

      template<typename... _UElements>
      _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
      : _Inherited(__in._M_tail()), _M_head(__in._M_head) { }

      _Tuple_impl(const _Tuple_impl& __in)
      : _Inherited(__in._M_tail()), _M_head(__in._M_head) { }

      template<typename... _UElements>
        _Tuple_impl&
        operator=(const _Tuple_impl<_Idx, _UElements...>& __in)
        {
   _M_head = __in._M_head;
   _M_tail() = __in._M_tail();
   return *this;
 }

      _Tuple_impl&
      operator=(const _Tuple_impl& __in)
      {
 _M_head = __in._M_head;
 _M_tail() = __in._M_tail();
 return *this;
      }
    };

  template<typename... _Elements>
    class tuple : public _Tuple_impl<0, _Elements...>
    {
      typedef _Tuple_impl<0, _Elements...> _Inherited;

    public:
      tuple() : _Inherited() { }

      explicit
      tuple(typename __add_c_ref<_Elements>::type... __elements)
      : _Inherited(__elements...) { }

      template<typename... _UElements>
        tuple(const tuple<_UElements...>& __in)
 : _Inherited(__in) { }

      tuple(const tuple& __in)
      : _Inherited(__in) { }

      template<typename... _UElements>
        tuple&
        operator=(const tuple<_UElements...>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }
    };

  template<> class tuple<> { };


  template<typename _T1, typename _T2>
    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>
    {
      typedef _Tuple_impl<0, _T1, _T2> _Inherited;

    public:
      tuple() : _Inherited() { }

      explicit
      tuple(typename __add_c_ref<_T1>::type __a1,
     typename __add_c_ref<_T2>::type __a2)
      : _Inherited(__a1, __a2) { }

      template<typename _U1, typename _U2>
        tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(__in) { }

      tuple(const tuple& __in)
      : _Inherited(__in) { }

      template<typename _U1, typename _U2>
        tuple(const pair<_U1, _U2>& __in)
 : _Inherited(_Tuple_impl<0,
       typename __add_c_ref<_U1>::type,
       typename __add_c_ref<_U2>::type>(__in.first,
            __in.second))
        { }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const tuple<_U1, _U2>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const pair<_U1, _U2>& __in)
        {
   this->_M_head = __in.first;
   this->_M_tail()._M_head = __in.second;
   return *this;
 }
    };



  template<int __i, typename _Tp>
    struct tuple_element;





  template<int __i, typename _Head, typename... _Tail>
    struct tuple_element<__i, tuple<_Head, _Tail...> >
    : tuple_element<__i - 1, tuple<_Tail...> > { };




  template<typename _Head, typename... _Tail>
    struct tuple_element<0, tuple<_Head, _Tail...> >
    {
      typedef _Head type;
    };


  template<typename _Tp>
    struct tuple_size;


  template<typename... _Elements>
    struct tuple_size<tuple<_Elements...> >
    {
      static const int value = sizeof...(_Elements);
    };

  template<typename... _Elements>
    const int tuple_size<tuple<_Elements...> >::value;

  template<int __i, typename _Head, typename... _Tail>
    inline typename __add_ref<_Head>::type
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t)
    {
      return __t._M_head;
    }

  template<int __i, typename _Head, typename... _Tail>
    inline typename __add_c_ref<_Head>::type
    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t)
    {
      return __t._M_head;
    }



  template<int __i, typename... _Elements>
    inline typename __add_ref<
                      typename tuple_element<__i, tuple<_Elements...> >::type
                    >::type
    get(tuple<_Elements...>& __t)
    {
      return __get_helper<__i>(__t);
    }

  template<int __i, typename... _Elements>
    inline typename __add_c_ref<
                      typename tuple_element<__i, tuple<_Elements...> >::type
                    >::type
    get(const tuple<_Elements...>& __t)
    {
      return __get_helper<__i>(__t);
    }


  template<int __check_equal_size, int __i, int __j,
    typename _Tp, typename _Up>
    struct __tuple_compare;

  template<int __i, int __j, typename _Tp, typename _Up>
    struct __tuple_compare<0, __i, __j, _Tp, _Up>
    {
      static bool __eq(const _Tp& __t, const _Up& __u)
      {
 return (get<__i>(__t) == get<__i>(__u) &&
  __tuple_compare<0, __i+1, __j, _Tp, _Up>::__eq(__t, __u));
      }

      static bool __less(const _Tp& __t, const _Up& __u)
      {
 return ((get<__i>(__t) < get<__i>(__u))
  || !(get<__i>(__u) < get<__i>(__t)) &&
  __tuple_compare<0, __i+1, __j, _Tp, _Up>::__less(__t, __u));
      }
    };

  template<int __i, typename _Tp, typename _Up>
    struct __tuple_compare<0, __i, __i, _Tp, _Up>
    {
      static bool __eq(const _Tp&, const _Up&)
      { return true; }

      static bool __less(const _Tp&, const _Up&)
      { return false; }
    };

  template<typename... _TElements, typename... _UElements>
    bool
    operator==(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    {
      typedef tuple<_TElements...> _Tp;
      typedef tuple<_UElements...> _Up;
      return (__tuple_compare<tuple_size<_Tp>::value - tuple_size<_Up>::value,
       0, tuple_size<_Tp>::value, _Tp, _Up>::__eq(__t, __u));
    }

  template<typename... _TElements, typename... _UElements>
    bool
    operator<(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    {
      typedef tuple<_TElements...> _Tp;
      typedef tuple<_UElements...> _Up;
      return (__tuple_compare<tuple_size<_Tp>::value - tuple_size<_Up>::value,
       0, tuple_size<_Tp>::value, _Tp, _Up>::__less(__t, __u));
    }

  template<typename... _TElements, typename... _UElements>
    inline bool
    operator!=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t == __u); }

  template<typename... _TElements, typename... _UElements>
    inline bool
    operator>(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    { return __u < __t; }

  template<typename... _TElements, typename... _UElements>
    inline bool
    operator<=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__u < __t); }

  template<typename... _TElements, typename... _UElements>
    inline bool
    operator>=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t < __u); }

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<const reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename... _Elements>
    inline tuple<typename __strip_reference_wrapper<_Elements>::__type...>
    make_tuple(_Elements... __args)
    {
      typedef tuple<typename __strip_reference_wrapper<_Elements>::__type...>
        __result_type;
      return __result_type(__args...);
    }

  template<typename... _Elements>
    inline tuple<_Elements&...>
    tie(_Elements&... __args)
    {
      return tuple<_Elements&...>(__args...);
    }



  struct _Swallow_assign
  {
    template<class _Tp>
      _Swallow_assign&
      operator=(const _Tp&)
      { return *this; }
  };


  namespace
  {
    _Swallow_assign ignore;
  };
}
}
# 17 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tuples.hh" 2


namespace Dune{
# 38 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tuples.hh"
  template<class T>
  struct TupleAccessTraits
  {
    typedef typename ConstantVolatileTraits<T>::ConstType& ConstType;
    typedef T& NonConstType;
    typedef const typename ConstantVolatileTraits<T>::UnqualifiedType& ParameterType;
  };

  template<class T>
  struct TupleAccessTraits<T*>
  {
    typedef typename ConstantVolatileTraits<T>::ConstType* ConstType;
    typedef T* NonConstType;
    typedef T* ParameterType;
  };

  template<class T>
  struct TupleAccessTraits<T&>
  {
    typedef T& ConstType;
    typedef T& NonConstType;
    typedef T& ParameterType;
  };




  using std::tr1::tuple;
# 403 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tuples.hh"
  using std::tr1::tuple_element;
# 443 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tuples.hh"
template< int N, class T >
struct ElementType
{
  typedef typename tuple_element< N, T > :: type Type __attribute__((deprecated));
};







  using std::tr1::get;



  template<int i>
  struct Element{
    template<typename T1>
    static typename TupleAccessTraits<typename tuple_element<i,T1>::type>::NonConstType get(T1& t)
    {
      return std::tr1::get<i>(t);
    }

    template<typename T1>
    static typename TupleAccessTraits<typename tuple_element<i,T1>::type>::ConstType get(const T1& t)
    {
      return std::tr1::get<i>(t);
    }
  };
# 563 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tuples.hh"
  using std::tr1::tuple_size;
# 599 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tuples.hh"
  template<typename T>
  struct Size : public tuple_size<T>
  {
  };






  using std::tr1::tie;
  using std::tr1::make_tuple;



  template<int i>
  struct tuple_writer
  {
    template<class T>
    static std::ostream& put(std::ostream& os, const T& t, const char* delim=", ")
    {
      return tuple_writer<i-1>::put(os,t,delim)<<delim<<Dune::get<i-1>(t);
    }

    template< class T >
    static std::istream &get ( std::istream &is, T &t, const char *delim = "," )
    {
      tuple_writer< i-1 >::get( is, t, delim );
      for( const char *it = delim; is && (*it != 0); ++it )
      {
        char c = 0;
        is >> c;
        if( c != *it )
          is.setstate( std::ios::failbit );
      }
      return is >> Dune::get< i-1 >( t );
    }
  };

   template<>
  struct tuple_writer<1>
  {
    template<class T>
    static std::ostream& put(std::ostream& os, const T& t, const char* delim=", ")
    {
      return os<<Dune::get<0>(t);
    }

    template< class T >
    static std::istream &get ( std::istream &is, T &t, const char *delim = ", " )
    {
      return is >> Dune::get< 0 >( t );
    }
   };

  template<>
  struct tuple_writer<0>
  {
    template<class T>
    static std::ostream& put(std::ostream& os, const T& t, const char* delim=", ")
    {
      return os;
    }

    template< class T >
    static std::istream &get ( std::istream &is, T &t, const char *delim = ", " )
    {
      return is;
    }
  };





  template<typename T1>
  inline std::ostream& operator<<( std::ostream& os, const tuple<T1> & t)
  {
    typedef tuple<T1> TupleT;
    return tuple_writer<tuple_size<TupleT>::value>::put(os, t);
  }

  template<typename T1, typename T2>
  inline std::ostream& operator<<( std::ostream& os, const tuple<T1,T2> & t)
  {
    typedef tuple<T1,T2> TupleT;
    return tuple_writer<tuple_size<TupleT>::value>::put(os, t);
  }

  template<typename T1, typename T2, typename T3>
  inline std::ostream& operator<<( std::ostream& os, const tuple<T1,T2,T3> & t)
  {
    typedef tuple<T1,T2,T3> TupleT;
    return tuple_writer<tuple_size<TupleT>::value>::put(os, t);
  }

  template<typename T1, typename T2, typename T3, typename T4>
  inline std::ostream& operator<<( std::ostream& os, const tuple<T1,T2,T3,T4> & t)
  {
    typedef tuple<T1,T2,T3,T4> TupleT;
    return tuple_writer<tuple_size<TupleT>::value>::put(os, t);
  }

  template<typename T1, typename T2, typename T3, typename T4, typename T5>
  inline std::ostream& operator<<( std::ostream& os, const tuple<T1,T2,T3,T4,T5> & t)
  {
    typedef tuple<T1,T2,T3,T4,T5> TupleT;
    return tuple_writer<tuple_size<TupleT>::value>::put(os, t);
  }

  template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
  inline std::ostream& operator<<( std::ostream& os, const tuple<T1,T2,T3,T4,T5,T6> & t)
  {
    typedef tuple<T1,T2,T3,T4,T5,T6> TupleT;
    return tuple_writer<tuple_size<TupleT>::value>::put(os, t);
  }

  template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
  inline std::ostream& operator<<( std::ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7> & t)
  {
    typedef tuple<T1,T2,T3,T4,T5,T6,T7> TupleT;
    return tuple_writer<tuple_size<TupleT>::value>::put(os, t);
  }

  template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7,
    typename T8>
  inline std::ostream& operator<<( std::ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7,T8> & t)
  {
    typedef tuple<T1,T2,T3,T4,T5,T6,T7,T8> TupleT;
    return tuple_writer<tuple_size<TupleT>::value>::put(os, t);
  }

  template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7,
    typename T8, typename T9>
  inline std::ostream& operator<<( std::ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7,T8,T9> & t)
  {
    typedef tuple<T1,T2,T3,T4,T5,T6,T7,T8,T9> TupleT;
    return tuple_writer<tuple_size<TupleT>::value>::put(os, t);
  }

  template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7,
           typename T8, typename T9, typename T10>
  inline std::ostream& operator<<( std::ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10> & t)
  {
    typedef tuple<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10> TupleT;
    return tuple_writer<tuple_size<TupleT>::value>::put(os, t);
  }




  template<typename T1>
  inline std::istream& operator>>( std::istream& is, tuple<T1> & t)
  {
    typedef tuple<T1> TupleT;
    return tuple_writer<tuple_size<TupleT>::value>::get(is, t);
  }

  template<typename T1, typename T2>
  inline std::istream& operator>>( std::istream& is, tuple<T1,T2> & t)
  {
    typedef tuple<T1,T2> TupleT;
    return tuple_writer<tuple_size<TupleT>::value>::get(is, t);
  }

  template<typename T1, typename T2, typename T3>
  inline std::istream& operator>>( std::istream& is, tuple<T1,T2,T3> & t)
  {
    typedef tuple<T1,T2,T3> TupleT;
    return tuple_writer<tuple_size<TupleT>::value>::get(is, t);
  }

  template<typename T1, typename T2, typename T3, typename T4>
  inline std::istream& operator>>( std::istream& is, tuple<T1,T2,T3,T4> & t)
  {
    typedef tuple<T1,T2,T3,T4> TupleT;
    return tuple_writer<tuple_size<TupleT>::value>::get(is, t);
  }

  template<typename T1, typename T2, typename T3, typename T4, typename T5>
  inline std::istream& operator>>( std::istream& is, tuple<T1,T2,T3,T4,T5> & t)
  {
    typedef tuple<T1,T2,T3,T4,T5> TupleT;
    return tuple_writer<tuple_size<TupleT>::value>::get(is, t);
  }

  template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
  inline std::istream& operator>>( std::istream& is, tuple<T1,T2,T3,T4,T5,T6> & t)
  {
    typedef tuple<T1,T2,T3,T4,T5,T6> TupleT;
    return tuple_writer<tuple_size<TupleT>::value>::get(is, t);
  }

  template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
  inline std::istream& operator>>( std::istream& is, tuple<T1,T2,T3,T4,T5,T6,T7> & t)
  {
    typedef tuple<T1,T2,T3,T4,T5,T6,T7> TupleT;
    return tuple_writer<tuple_size<TupleT>::value>::get(is, t);
  }

  template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7,
    typename T8>
  inline std::istream& operator>>( std::istream& is, tuple<T1,T2,T3,T4,T5,T6,T7,T8> & t)
  {
    typedef tuple<T1,T2,T3,T4,T5,T6,T7,T8> TupleT;
    return tuple_writer<tuple_size<TupleT>::value>::get(is, t);
  }

  template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7,
    typename T8, typename T9>
  inline std::istream& operator>>( std::istream& is, tuple<T1,T2,T3,T4,T5,T6,T7,T8,T9> & t)
  {
    typedef tuple<T1,T2,T3,T4,T5,T6,T7,T8,T9> TupleT;
    return tuple_writer<tuple_size<TupleT>::value>::get(is, t);
  }

  template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7,
           typename T8, typename T9, typename T10>
  inline std::istream& operator>>( std::istream& is, tuple<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10> & t)
  {
    typedef tuple<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10> TupleT;
    return tuple_writer<tuple_size<TupleT>::value>::get(is, t);
  }
# 1224 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tuples.hh"
}
# 13 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tupleutility.hh" 2

namespace Dune {
# 33 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tupleutility.hh"
  template <class Tuple>
  class NullPointerInitialiser {
    typedef static_assert_test< sizeof(static_assert_failure< (bool)( AlwaysFalse<Tuple>::value )>) > dune_static_assert_typedef_42;







  public:

    typedef Tuple ResultType;

    static ResultType apply();
  };


  template<class Tuple>
  struct NullPointerInitialiser<const Tuple>
    : public NullPointerInitialiser<Tuple>
  {
    typedef const Tuple ResultType;
  };

  template<>
  struct NullPointerInitialiser<tuple<> > {
    typedef tuple<> ResultType;
    static ResultType apply() {
      return ResultType();
    }
  };

  template<class T0>
  struct NullPointerInitialiser<tuple<T0*> > {
    typedef tuple<T0*> ResultType;
    static ResultType apply() {
      return ResultType(static_cast<T0*>(0));
    }
  };

  template<class T0, class T1>
  struct NullPointerInitialiser<tuple<T0*, T1*> > {
    typedef tuple<T0*, T1*> ResultType;
    static ResultType apply() {
      return ResultType(static_cast<T0*>(0), static_cast<T1*>(0));
    }
  };

  template<class T0, class T1, class T2>
  struct NullPointerInitialiser<tuple<T0*, T1*, T2*> > {
    typedef tuple<T0*, T1*, T2*> ResultType;
    static ResultType apply() {
      return ResultType(static_cast<T0*>(0), static_cast<T1*>(0),
                        static_cast<T2*>(0));
    }
  };

  template<class T0, class T1, class T2, class T3>
  struct NullPointerInitialiser<tuple<T0*, T1*, T2*, T3*> > {
    typedef tuple<T0*, T1*, T2*, T3*> ResultType;
    static ResultType apply() {
      return ResultType(static_cast<T0*>(0), static_cast<T1*>(0),
                        static_cast<T2*>(0), static_cast<T3*>(0));
    }
  };

  template<class T0, class T1, class T2, class T3, class T4>
  struct NullPointerInitialiser<tuple<T0*, T1*, T2*, T3*, T4*> > {
    typedef tuple<T0*, T1*, T2*, T3*, T4*> ResultType;
    static ResultType apply() {
      return ResultType(static_cast<T0*>(0), static_cast<T1*>(0),
                        static_cast<T2*>(0), static_cast<T3*>(0),
                        static_cast<T4*>(0));
    }
  };

  template<class T0, class T1, class T2, class T3, class T4, class T5>
  struct NullPointerInitialiser<tuple<T0*, T1*, T2*, T3*, T4*, T5*> > {
    typedef tuple<T0*, T1*, T2*, T3*, T4*, T5*> ResultType;
    static ResultType apply() {
      return ResultType(static_cast<T0*>(0), static_cast<T1*>(0),
                        static_cast<T2*>(0), static_cast<T3*>(0),
                        static_cast<T4*>(0), static_cast<T5*>(0));
    }
  };

  template<class T0, class T1, class T2, class T3, class T4, class T5,
           class T6>
  struct NullPointerInitialiser<tuple<T0*, T1*, T2*, T3*, T4*, T5*, T6*> > {
    typedef tuple<T0*, T1*, T2*, T3*, T4*, T5*, T6*> ResultType;
    static ResultType apply() {
      return ResultType(static_cast<T0*>(0), static_cast<T1*>(0),
                        static_cast<T2*>(0), static_cast<T3*>(0),
                        static_cast<T4*>(0), static_cast<T5*>(0),
                        static_cast<T6*>(0));
    }
  };

  template<class T0, class T1, class T2, class T3, class T4, class T5,
           class T6, class T7>
  struct NullPointerInitialiser<tuple<T0*, T1*, T2*, T3*, T4*, T5*, T6*,
                                      T7*> > {
    typedef tuple<T0*, T1*, T2*, T3*, T4*, T5*, T6*, T7*> ResultType;
    static ResultType apply() {
      return ResultType(static_cast<T0*>(0), static_cast<T1*>(0),
                        static_cast<T2*>(0), static_cast<T3*>(0),
                        static_cast<T4*>(0), static_cast<T5*>(0),
                        static_cast<T6*>(0), static_cast<T7*>(0));
    }
  };

  template<class T0, class T1, class T2, class T3, class T4, class T5,
           class T6, class T7, class T8>
  struct NullPointerInitialiser<tuple<T0*, T1*, T2*, T3*, T4*, T5*, T6*,
                                      T7*, T8*> > {
    typedef tuple<T0*, T1*, T2*, T3*, T4*, T5*, T6*, T7*, T8*> ResultType;
    static ResultType apply() {
      return ResultType(static_cast<T0*>(0), static_cast<T1*>(0),
                        static_cast<T2*>(0), static_cast<T3*>(0),
                        static_cast<T4*>(0), static_cast<T5*>(0),
                        static_cast<T6*>(0), static_cast<T7*>(0),
                        static_cast<T8*>(0));
    }
  };
# 177 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tupleutility.hh"
  template <class Tuple>
  struct Length
  {
    enum{
      value=tuple_size<Tuple>::value
 };
  };
# 206 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tupleutility.hh"
  template <template <class> class TypeEvaluator, class TupleType>
  class ForEachType {
    typedef static_assert_test< sizeof(static_assert_failure< (bool)( AlwaysFalse<TupleType>::value )>) > dune_static_assert_typedef_214;






    struct ImplementationDefined {};
  public:

    typedef ImplementationDefined Type;
  };


  template <template <class> class TE, class Tuple>
  struct ForEachType<TE, const Tuple> {
    typedef const typename ForEachType<TE, Tuple>::Type Type;
  };

  template <template <class> class TE>
  struct ForEachType<TE, tuple<> > {
    typedef tuple<> Type;
  };

  template <template <class> class TE, class T0>
  struct ForEachType<TE, tuple<T0> > {
    typedef tuple<typename TE<T0>::Type> Type;
  };

  template <template <class> class TE, class T0, class T1>
  struct ForEachType<TE, tuple<T0, T1> > {
    typedef tuple<typename TE<T0>::Type, typename TE<T1>::Type> Type;
  };

  template <template <class> class TE, class T0, class T1, class T2>
  struct ForEachType<TE, tuple<T0, T1, T2> > {
    typedef tuple<typename TE<T0>::Type, typename TE<T1>::Type,
                  typename TE<T2>::Type> Type;
  };

  template <template <class> class TE, class T0, class T1, class T2, class T3>
  struct ForEachType<TE, tuple<T0, T1, T2, T3> > {
    typedef tuple<typename TE<T0>::Type, typename TE<T1>::Type,
                  typename TE<T2>::Type, typename TE<T3>::Type> Type;
  };

  template <template <class> class TE, class T0, class T1, class T2, class T3,
            class T4>
  struct ForEachType<TE, tuple<T0, T1, T2, T3, T4> > {
    typedef tuple<typename TE<T0>::Type, typename TE<T1>::Type,
                  typename TE<T2>::Type, typename TE<T3>::Type,
                  typename TE<T4>::Type> Type;
  };

  template <template <class> class TE, class T0, class T1, class T2, class T3,
            class T4, class T5>
  struct ForEachType<TE, tuple<T0, T1, T2, T3, T4, T5> > {
    typedef tuple<typename TE<T0>::Type, typename TE<T1>::Type,
                  typename TE<T2>::Type, typename TE<T3>::Type,
                  typename TE<T4>::Type, typename TE<T5>::Type> Type;
  };

  template <template <class> class TE, class T0, class T1, class T2, class T3,
            class T4, class T5, class T6>
  struct ForEachType<TE, tuple<T0, T1, T2, T3, T4, T5, T6> > {
    typedef tuple<typename TE<T0>::Type, typename TE<T1>::Type,
                  typename TE<T2>::Type, typename TE<T3>::Type,
                  typename TE<T4>::Type, typename TE<T5>::Type,
                  typename TE<T6>::Type> Type;
  };

  template <template <class> class TE, class T0, class T1, class T2, class T3,
            class T4, class T5, class T6, class T7>
  struct ForEachType<TE, tuple<T0, T1, T2, T3, T4, T5, T6, T7> > {
    typedef tuple<typename TE<T0>::Type, typename TE<T1>::Type,
                  typename TE<T2>::Type, typename TE<T3>::Type,
                  typename TE<T4>::Type, typename TE<T5>::Type,
                  typename TE<T6>::Type, typename TE<T7>::Type> Type;
  };

  template <template <class> class TE, class T0, class T1, class T2, class T3,
            class T4, class T5, class T6, class T7, class T8>
  struct ForEachType<TE, tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8> > {
    typedef tuple<typename TE<T0>::Type, typename TE<T1>::Type,
                  typename TE<T2>::Type, typename TE<T3>::Type,
                  typename TE<T4>::Type, typename TE<T5>::Type,
                  typename TE<T6>::Type, typename TE<T7>::Type,
                  typename TE<T8>::Type> Type;
  };
# 347 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tupleutility.hh"
  template<class Functor>
  typename ForEachType<Functor::template TypeEvaluator,
                       tuple<> >::Type
  genericTransformTupleBackend
  (const tuple<>& t, const Functor& f)
  {
    return typename ForEachType<Functor::template TypeEvaluator,
      tuple<> >::Type
      ();
  }


  template<class T0, class Functor>
  typename ForEachType<Functor::template TypeEvaluator,
                       tuple<T0> >::Type
  genericTransformTupleBackend
  (tuple<T0>& t, Functor& f)
  {
    return typename ForEachType<Functor::template TypeEvaluator,
      tuple<T0> >::Type
      (f(get<0>(t)));
  }
  template<class T0, class Functor>
  typename ForEachType<Functor::template TypeEvaluator,
                       tuple<T0> >::Type
  genericTransformTupleBackend
  (const tuple<T0>& t, Functor& f)
  {
    return typename ForEachType<Functor::template TypeEvaluator,
      tuple<T0> >::Type
      (f(get<0>(t)));
  }


  template<class T0, class T1, class Functor>
  typename ForEachType<Functor::template TypeEvaluator,
                       tuple<T0, T1> >::Type
  genericTransformTupleBackend
  (tuple<T0, T1>& t, Functor& f)
  {
    return typename ForEachType<Functor::template TypeEvaluator,
      tuple<T0, T1> >::Type
      (f(get<0>(t)), f(get<1>(t)));
  }
  template<class T0, class T1, class Functor>
  typename ForEachType<Functor::template TypeEvaluator,
                       tuple<T0, T1> >::Type
  genericTransformTupleBackend
  (const tuple<T0, T1>& t, Functor& f)
  {
    return typename ForEachType<Functor::template TypeEvaluator,
      tuple<T0, T1> >::Type
      (f(get<0>(t)), f(get<1>(t)));
  }


  template<class T0, class T1, class T2, class Functor>
  typename ForEachType<Functor::template TypeEvaluator,
                       tuple<T0, T1, T2> >::Type
  genericTransformTupleBackend
  (tuple<T0, T1, T2>& t, Functor& f)
  {
    return typename ForEachType<Functor::template TypeEvaluator,
      tuple<T0, T1, T2> >::Type
      (f(get<0>(t)), f(get<1>(t)), f(get<2>(t)));
  }
  template<class T0, class T1, class T2, class Functor>
  typename ForEachType<Functor::template TypeEvaluator,
                       tuple<T0, T1, T2> >::Type
  genericTransformTupleBackend
  (const tuple<T0, T1, T2>& t, Functor& f)
  {
    return typename ForEachType<Functor::template TypeEvaluator,
      tuple<T0, T1, T2> >::Type
      (f(get<0>(t)), f(get<1>(t)), f(get<2>(t)));
  }


  template<class T0, class T1, class T2, class T3, class Functor>
  typename ForEachType<Functor::template TypeEvaluator,
                       tuple<T0, T1, T2, T3> >::Type
  genericTransformTupleBackend
  (tuple<T0, T1, T2, T3>& t, Functor& f)
  {
    return typename ForEachType<Functor::template TypeEvaluator,
      tuple<T0, T1, T2, T3> >::Type
      (f(get<0>(t)), f(get<1>(t)), f(get<2>(t)), f(get<3>(t)));
  }
  template<class T0, class T1, class T2, class T3, class Functor>
  typename ForEachType<Functor::template TypeEvaluator,
                       tuple<T0, T1, T2, T3> >::Type
  genericTransformTupleBackend
  (const tuple<T0, T1, T2, T3>& t, Functor& f)
  {
    return typename ForEachType<Functor::template TypeEvaluator,
      tuple<T0, T1, T2, T3> >::Type
      (f(get<0>(t)), f(get<1>(t)), f(get<2>(t)), f(get<3>(t)));
  }


  template<class T0, class T1, class T2, class T3, class T4, class Functor>
  typename ForEachType<Functor::template TypeEvaluator,
                       tuple<T0, T1, T2, T3, T4> >::Type
  genericTransformTupleBackend
  (tuple<T0, T1, T2, T3, T4>& t, Functor& f)
  {
    return typename ForEachType<Functor::template TypeEvaluator,
      tuple<T0, T1, T2, T3, T4> >::Type
      (f(get<0>(t)), f(get<1>(t)), f(get<2>(t)), f(get<3>(t)), f(get<4>(t)));
  }
  template<class T0, class T1, class T2, class T3, class T4, class Functor>
  typename ForEachType<Functor::template TypeEvaluator,
                       tuple<T0, T1, T2, T3, T4> >::Type
  genericTransformTupleBackend
  (const tuple<T0, T1, T2, T3, T4>& t, Functor& f)
  {
    return typename ForEachType<Functor::template TypeEvaluator,
      tuple<T0, T1, T2, T3, T4> >::Type
      (f(get<0>(t)), f(get<1>(t)), f(get<2>(t)), f(get<3>(t)), f(get<4>(t)));
  }


  template<class T0, class T1, class T2, class T3, class T4, class T5,
           class Functor>
  typename ForEachType<Functor::template TypeEvaluator,
                       tuple<T0, T1, T2, T3, T4, T5> >::Type
  genericTransformTupleBackend
  (tuple<T0, T1, T2, T3, T4, T5>& t, Functor& f)
  {
    return typename ForEachType<Functor::template TypeEvaluator,
      tuple<T0, T1, T2, T3, T4, T5> >::Type
      (f(get<0>(t)), f(get<1>(t)), f(get<2>(t)), f(get<3>(t)), f(get<4>(t)),
       f(get<5>(t)));
  }
  template<class T0, class T1, class T2, class T3, class T4, class T5,
           class Functor>
  typename ForEachType<Functor::template TypeEvaluator,
                       tuple<T0, T1, T2, T3, T4, T5> >::Type
  genericTransformTupleBackend
  (const tuple<T0, T1, T2, T3, T4, T5>& t, Functor& f)
  {
    return typename ForEachType<Functor::template TypeEvaluator,
      tuple<T0, T1, T2, T3, T4, T5> >::Type
      (f(get<0>(t)), f(get<1>(t)), f(get<2>(t)), f(get<3>(t)), f(get<4>(t)),
       f(get<5>(t)));
  }


  template<class T0, class T1, class T2, class T3, class T4, class T5,
           class T6, class Functor>
  typename ForEachType<Functor::template TypeEvaluator,
                       tuple<T0, T1, T2, T3, T4, T5, T6> >::Type
  genericTransformTupleBackend
  (tuple<T0, T1, T2, T3, T4, T5, T6>& t, Functor& f)
  {
    return typename ForEachType<Functor::template TypeEvaluator,
      tuple<T0, T1, T2, T3, T4, T5, T6> >::Type
      (f(get<0>(t)), f(get<1>(t)), f(get<2>(t)), f(get<3>(t)), f(get<4>(t)),
       f(get<5>(t)), f(get<6>(t)));
  }
  template<class T0, class T1, class T2, class T3, class T4, class T5,
           class T6, class Functor>
  typename ForEachType<Functor::template TypeEvaluator,
                       tuple<T0, T1, T2, T3, T4, T5, T6> >::Type
  genericTransformTupleBackend
  (const tuple<T0, T1, T2, T3, T4, T5, T6>& t, Functor& f)
  {
    return typename ForEachType<Functor::template TypeEvaluator,
      tuple<T0, T1, T2, T3, T4, T5, T6> >::Type
      (f(get<0>(t)), f(get<1>(t)), f(get<2>(t)), f(get<3>(t)), f(get<4>(t)),
       f(get<5>(t)), f(get<6>(t)));
  }


  template<class T0, class T1, class T2, class T3, class T4, class T5,
           class T6, class T7, class Functor>
  typename ForEachType<Functor::template TypeEvaluator,
                       tuple<T0, T1, T2, T3, T4, T5, T6, T7> >::Type
  genericTransformTupleBackend
  (tuple<T0, T1, T2, T3, T4, T5, T6, T7>& t, Functor& f)
  {
    return typename ForEachType<Functor::template TypeEvaluator,
      tuple<T0, T1, T2, T3, T4, T5, T6, T7> >::Type
      (f(get<0>(t)), f(get<1>(t)), f(get<2>(t)), f(get<3>(t)), f(get<4>(t)),
       f(get<5>(t)), f(get<6>(t)), f(get<7>(t)));
  }
  template<class T0, class T1, class T2, class T3, class T4, class T5,
           class T6, class T7, class Functor>
  typename ForEachType<Functor::template TypeEvaluator,
                       tuple<T0, T1, T2, T3, T4, T5, T6, T7> >::Type
  genericTransformTupleBackend
  (const tuple<T0, T1, T2, T3, T4, T5, T6, T7>& t, Functor& f)
  {
    return typename ForEachType<Functor::template TypeEvaluator,
      tuple<T0, T1, T2, T3, T4, T5, T6, T7> >::Type
      (f(get<0>(t)), f(get<1>(t)), f(get<2>(t)), f(get<3>(t)), f(get<4>(t)),
       f(get<5>(t)), f(get<6>(t)), f(get<7>(t)));
  }


  template<class T0, class T1, class T2, class T3, class T4, class T5,
           class T6, class T7, class T8, class Functor>
  typename ForEachType<Functor::template TypeEvaluator,
                       tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8> >::Type
  genericTransformTupleBackend
  (tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8>& t, Functor& f)
  {
    return typename ForEachType<Functor::template TypeEvaluator,
      tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8> >::Type
      (f(get<0>(t)), f(get<1>(t)), f(get<2>(t)), f(get<3>(t)), f(get<4>(t)),
       f(get<5>(t)), f(get<6>(t)), f(get<7>(t)), f(get<8>(t)));
  }
  template<class T0, class T1, class T2, class T3, class T4, class T5,
           class T6, class T7, class T8, class Functor>
  typename ForEachType<Functor::template TypeEvaluator,
                       tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8> >::Type
  genericTransformTupleBackend
  (const tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8>& t, Functor& f)
  {
    return typename ForEachType<Functor::template TypeEvaluator,
      tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8> >::Type
      (f(get<0>(t)), f(get<1>(t)), f(get<2>(t)), f(get<3>(t)), f(get<4>(t)),
       f(get<5>(t)), f(get<6>(t)), f(get<7>(t)), f(get<8>(t)));
  }
# 641 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tupleutility.hh"
  template<class Tuple, class Functor>
  typename ForEachType<Functor::template TypeEvaluator, Tuple>::Type
  genericTransformTuple(Tuple& t, Functor& f) {
    return genericTransformTupleBackend(t, f);
  }

  template<class Tuple, class Functor>
  typename ForEachType<Functor::template TypeEvaluator, Tuple>::Type
  genericTransformTuple(const Tuple& t, Functor& f) {
    return genericTransformTupleBackend(t, f);
  }
  template<class Tuple, class Functor>
  typename ForEachType<Functor::template TypeEvaluator, Tuple>::Type
  genericTransformTuple(Tuple& t, const Functor& f) {
    return genericTransformTupleBackend(t, f);
  }
  template<class Tuple, class Functor>
  typename ForEachType<Functor::template TypeEvaluator, Tuple>::Type
  genericTransformTuple(const Tuple& t, const Functor& f) {
    return genericTransformTupleBackend(t, f);
  }
# 701 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tupleutility.hh"
  template<template<class> class TE, class A0 = void, class A1 = void,
           class A2 = void, class A3 = void, class A4 = void, class A5 = void,
           class A6 = void, class A7 = void, class A8 = void, class A9 = void>
  class TransformTupleFunctor {
    A0& a0; A1& a1; A2& a2; A3& a3; A4& a4; A5& a5; A6& a6; A7& a7; A8& a8;
    A9& a9;

  public:

    template<class T> struct TypeEvaluator : public TE<T> {};







    TransformTupleFunctor(A0& a0_, A1& a1_, A2& a2_, A3& a3_, A4& a4_, A5& a5_,
                          A6& a6_, A7& a7_, A8& a8_, A9& a9_)
      : a0(a0_), a1(a1_), a2(a2_), a3(a3_), a4(a4_), a5(a5_), a6(a6_), a7(a7_),
        a8(a8_), a9(a9_)
    { }
# 733 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tupleutility.hh"
    template<class T>
    typename TE<T>::Type operator()(T& t) const {
      return TE<T>::apply(t, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    }
  };
# 792 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tupleutility.hh"
  template<template<class> class TE, class A0, class A1, class A2, class A3,
           class A4, class A5, class A6, class A7, class A8, class A9>
  TransformTupleFunctor<TE, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>
  makeTransformTupleFunctor(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5,
                            A6& a6, A7& a7, A8& a8, A9& a9) {
    return TransformTupleFunctor<TE, A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>
      (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
  }



  template<template<class> class TE>
  struct TransformTupleFunctor<TE>
  {
    template<class T> struct TypeEvaluator : public TE<T> {};

    template<class T>
    typename TE<T>::Type operator()(T& t) const {
      return TE<T>::apply(t);
    }
  };
  template<template<class> class TE>
  TransformTupleFunctor<TE>
  makeTransformTupleFunctor() {
    return TransformTupleFunctor<TE>
      ();
  }


  template<template<class> class TE, class A0>
  class TransformTupleFunctor<TE, A0>
  {
    A0& a0;

  public:
    template<class T> struct TypeEvaluator : public TE<T> {};

    TransformTupleFunctor(A0& a0_)
      : a0(a0_)
    { }

    template<class T>
    typename TE<T>::Type operator()(T& t) const {
      return TE<T>::apply(t, a0);
    }
  };
  template<template<class> class TE, class A0>
  TransformTupleFunctor<TE, A0>
  makeTransformTupleFunctor(A0& a0) {
    return TransformTupleFunctor<TE, A0>
      (a0);
  }


  template<template<class> class TE, class A0, class A1>
  class TransformTupleFunctor<TE, A0, A1>
  {
    A0& a0; A1& a1;

  public:
    template<class T> struct TypeEvaluator : public TE<T> {};

    TransformTupleFunctor(A0& a0_, A1& a1_)
      : a0(a0_), a1(a1_)
    { }

    template<class T>
    typename TE<T>::Type operator()(T& t) const {
      return TE<T>::apply(t, a0, a1);
    }
  };
  template<template<class> class TE, class A0, class A1>
  TransformTupleFunctor<TE, A0, A1>
  makeTransformTupleFunctor(A0& a0, A1& a1) {
    return TransformTupleFunctor<TE, A0, A1>
      (a0, a1);
  }


  template<template<class> class TE, class A0, class A1, class A2>
  class TransformTupleFunctor<TE, A0, A1, A2>
  {
    A0& a0; A1& a1; A2& a2;

  public:
    template<class T> struct TypeEvaluator : public TE<T> {};

    TransformTupleFunctor(A0& a0_, A1& a1_, A2& a2_)
      : a0(a0_), a1(a1_), a2(a2_)
    { }

    template<class T>
    typename TE<T>::Type operator()(T& t) const {
      return TE<T>::apply(t, a0, a1, a2);
    }
  };
  template<template<class> class TE, class A0, class A1, class A2>
  TransformTupleFunctor<TE, A0, A1, A2>
  makeTransformTupleFunctor(A0& a0, A1& a1, A2& a2) {
    return TransformTupleFunctor<TE, A0, A1, A2>
      (a0, a1, a2);
  }


  template<template<class> class TE, class A0, class A1, class A2, class A3>
  class TransformTupleFunctor<TE, A0, A1, A2, A3>
  {
    A0& a0; A1& a1; A2& a2; A3& a3;

  public:
    template<class T> struct TypeEvaluator : public TE<T> {};

    TransformTupleFunctor(A0& a0_, A1& a1_, A2& a2_, A3& a3_)
      : a0(a0_), a1(a1_), a2(a2_), a3(a3_)
    { }

    template<class T>
    typename TE<T>::Type operator()(T& t) const {
      return TE<T>::apply(t, a0, a1, a2, a3);
    }
  };
  template<template<class> class TE, class A0, class A1, class A2, class A3>
  TransformTupleFunctor<TE, A0, A1, A2, A3>
  makeTransformTupleFunctor(A0& a0, A1& a1, A2& a2, A3& a3) {
    return TransformTupleFunctor<TE, A0, A1, A2, A3>
      (a0, a1, a2, a3);
  }


  template<template<class> class TE, class A0, class A1, class A2, class A3,
           class A4>
  class TransformTupleFunctor<TE, A0, A1, A2, A3, A4>
  {
    A0& a0; A1& a1; A2& a2; A3& a3; A4& a4;

  public:
    template<class T> struct TypeEvaluator : public TE<T> {};

    TransformTupleFunctor(A0& a0_, A1& a1_, A2& a2_, A3& a3_, A4& a4_)
      : a0(a0_), a1(a1_), a2(a2_), a3(a3_), a4(a4_)
    { }

    template<class T>
    typename TE<T>::Type operator()(T& t) const {
      return TE<T>::apply(t, a0, a1, a2, a3, a4);
    }
  };
  template<template<class> class TE, class A0, class A1, class A2, class A3,
           class A4>
  TransformTupleFunctor<TE, A0, A1, A2, A3, A4>
  makeTransformTupleFunctor(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4) {
    return TransformTupleFunctor<TE, A0, A1, A2, A3, A4>
      (a0, a1, a2, a3, a4);
  }


  template<template<class> class TE, class A0, class A1, class A2, class A3,
           class A4, class A5>
  class TransformTupleFunctor<TE, A0, A1, A2, A3, A4, A5>
  {
    A0& a0; A1& a1; A2& a2; A3& a3; A4& a4; A5& a5;

  public:
    template<class T> struct TypeEvaluator : public TE<T> {};

    TransformTupleFunctor(A0& a0_, A1& a1_, A2& a2_, A3& a3_, A4& a4_, A5& a5_)
      : a0(a0_), a1(a1_), a2(a2_), a3(a3_), a4(a4_), a5(a5_)
    { }

    template<class T>
    typename TE<T>::Type operator()(T& t) const {
      return TE<T>::apply(t, a0, a1, a2, a3, a4, a5);
    }
  };
  template<template<class> class TE, class A0, class A1, class A2, class A3,
           class A4, class A5>
  TransformTupleFunctor<TE, A0, A1, A2, A3, A4, A5>
  makeTransformTupleFunctor(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5) {
    return TransformTupleFunctor<TE, A0, A1, A2, A3, A4, A5>
      (a0, a1, a2, a3, a4, a5);
  }


  template<template<class> class TE, class A0, class A1, class A2, class A3,
           class A4, class A5, class A6>
  class TransformTupleFunctor<TE, A0, A1, A2, A3, A4, A5, A6>
  {
    A0& a0; A1& a1; A2& a2; A3& a3; A4& a4; A5& a5; A6& a6;

  public:
    template<class T> struct TypeEvaluator : public TE<T> {};

    TransformTupleFunctor(A0& a0_, A1& a1_, A2& a2_, A3& a3_, A4& a4_, A5& a5_,
                          A6& a6_)
      : a0(a0_), a1(a1_), a2(a2_), a3(a3_), a4(a4_), a5(a5_), a6(a6_)
    { }

    template<class T>
    typename TE<T>::Type operator()(T& t) const {
      return TE<T>::apply(t, a0, a1, a2, a3, a4, a5, a6);
    }
  };
  template<template<class> class TE, class A0, class A1, class A2, class A3,
           class A4, class A5, class A6>
  TransformTupleFunctor<TE, A0, A1, A2, A3, A4, A5, A6>
  makeTransformTupleFunctor(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5,
                            A6& a6) {
    return TransformTupleFunctor<TE, A0, A1, A2, A3, A4, A5, A6>
      (a0, a1, a2, a3, a4, a5, a6);
  }


  template<template<class> class TE, class A0, class A1, class A2, class A3,
           class A4, class A5, class A6, class A7>
  class TransformTupleFunctor<TE, A0, A1, A2, A3, A4, A5, A6, A7>
  {
    A0& a0; A1& a1; A2& a2; A3& a3; A4& a4; A5& a5; A6& a6; A7& a7;

  public:
    template<class T> struct TypeEvaluator : public TE<T> {};

    TransformTupleFunctor(A0& a0_, A1& a1_, A2& a2_, A3& a3_, A4& a4_, A5& a5_,
                          A6& a6_, A7& a7_)
      : a0(a0_), a1(a1_), a2(a2_), a3(a3_), a4(a4_), a5(a5_), a6(a6_), a7(a7_)
    { }

    template<class T>
    typename TE<T>::Type operator()(T& t) const {
      return TE<T>::apply(t, a0, a1, a2, a3, a4, a5, a6, a7);
    }
  };
  template<template<class> class TE, class A0, class A1, class A2, class A3,
           class A4, class A5, class A6, class A7>
  TransformTupleFunctor<TE, A0, A1, A2, A3, A4, A5, A6, A7>
  makeTransformTupleFunctor(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5,
                            A6& a6, A7& a7) {
    return TransformTupleFunctor<TE, A0, A1, A2, A3, A4, A5, A6, A7>
      (a0, a1, a2, a3, a4, a5, a6, a7);
  }


  template<template<class> class TE, class A0, class A1, class A2, class A3,
           class A4, class A5, class A6, class A7, class A8>
  class TransformTupleFunctor<TE, A0, A1, A2, A3, A4, A5, A6, A7, A8>
  {
    A0& a0; A1& a1; A2& a2; A3& a3; A4& a4; A5& a5; A6& a6; A7& a7; A8& a8;

  public:
    template<class T> struct TypeEvaluator : public TE<T> {};

    TransformTupleFunctor(A0& a0_, A1& a1_, A2& a2_, A3& a3_, A4& a4_, A5& a5_,
                          A6& a6_, A7& a7_, A8& a8_)
      : a0(a0_), a1(a1_), a2(a2_), a3(a3_), a4(a4_), a5(a5_), a6(a6_), a7(a7_),
        a8(a8_)
    { }

    template<class T>
    typename TE<T>::Type operator()(T& t) const {
      return TE<T>::apply(t, a0, a1, a2, a3, a4, a5, a6, a7, a8);
    }
  };
  template<template<class> class TE, class A0, class A1, class A2, class A3,
           class A4, class A5, class A6, class A7, class A8>
  TransformTupleFunctor<TE, A0, A1, A2, A3, A4, A5, A6, A7, A8>
  makeTransformTupleFunctor(A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5,
                            A6& a6, A7& a7, A8& a8) {
    return TransformTupleFunctor<TE, A0, A1, A2, A3, A4, A5, A6, A7, A8>
      (a0, a1, a2, a3, a4, a5, a6, a7, a8);
  }
# 1158 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tupleutility.hh"
  template<template<class> class TypeEvaluator, class Tuple, class A0,
           class A1, class A2, class A3, class A4, class A5, class A6,
           class A7, class A8, class A9>
  typename remove_const<typename ForEachType<TypeEvaluator, Tuple>::Type>::type
  transformTuple(Tuple& orig, A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5,
                 A6& a6, A7& a7, A8& a8, A9& a9) {
    return genericTransformTuple
      ( orig,
        makeTransformTupleFunctor<TypeEvaluator>(a0, a1, a2, a3, a4, a5, a6,
                                                 a7, a8, a9));
  }



  template<template<class> class TypeEvaluator, class Tuple>
  typename remove_const<typename ForEachType<TypeEvaluator, Tuple>::Type>::type
  transformTuple(Tuple& orig) {
    return genericTransformTuple
      ( orig,
        makeTransformTupleFunctor<TypeEvaluator>());
  }


  template<template<class> class TypeEvaluator, class Tuple, class A0>
  typename remove_const<typename ForEachType<TypeEvaluator, Tuple>::Type>::type
  transformTuple(Tuple& orig, A0& a0) {
    return genericTransformTuple
      ( orig,
        makeTransformTupleFunctor<TypeEvaluator>(a0));
  }


  template<template<class> class TypeEvaluator, class Tuple, class A0,
           class A1>
  typename remove_const<typename ForEachType<TypeEvaluator, Tuple>::Type>::type
  transformTuple(Tuple& orig, A0& a0, A1& a1) {
    return genericTransformTuple
      ( orig,
        makeTransformTupleFunctor<TypeEvaluator>(a0, a1));
  }


  template<template<class> class TypeEvaluator, class Tuple, class A0,
           class A1, class A2>
  typename remove_const<typename ForEachType<TypeEvaluator, Tuple>::Type>::type
  transformTuple(Tuple& orig, A0& a0, A1& a1, A2& a2) {
    return genericTransformTuple
      ( orig,
        makeTransformTupleFunctor<TypeEvaluator>(a0, a1, a2));
  }


  template<template<class> class TypeEvaluator, class Tuple, class A0,
           class A1, class A2, class A3>
  typename remove_const<typename ForEachType<TypeEvaluator, Tuple>::Type>::type
  transformTuple(Tuple& orig, A0& a0, A1& a1, A2& a2, A3& a3) {
    return genericTransformTuple
      ( orig,
        makeTransformTupleFunctor<TypeEvaluator>(a0, a1, a2, a3));
  }


  template<template<class> class TypeEvaluator, class Tuple, class A0,
           class A1, class A2, class A3, class A4>
  typename remove_const<typename ForEachType<TypeEvaluator, Tuple>::Type>::type
  transformTuple(Tuple& orig, A0& a0, A1& a1, A2& a2, A3& a3, A4& a4) {
    return genericTransformTuple
      ( orig,
        makeTransformTupleFunctor<TypeEvaluator>(a0, a1, a2, a3, a4));
  }


  template<template<class> class TypeEvaluator, class Tuple, class A0,
           class A1, class A2, class A3, class A4, class A5>
  typename remove_const<typename ForEachType<TypeEvaluator, Tuple>::Type>::type
  transformTuple(Tuple& orig, A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5) {
    return genericTransformTuple
      ( orig,
        makeTransformTupleFunctor<TypeEvaluator>(a0, a1, a2, a3, a4, a5));
  }


  template<template<class> class TypeEvaluator, class Tuple, class A0,
           class A1, class A2, class A3, class A4, class A5, class A6>
  typename remove_const<typename ForEachType<TypeEvaluator, Tuple>::Type>::type
  transformTuple(Tuple& orig, A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5,
                 A6& a6) {
    return genericTransformTuple
      ( orig,
        makeTransformTupleFunctor<TypeEvaluator>(a0, a1, a2, a3, a4, a5, a6));
  }


  template<template<class> class TypeEvaluator, class Tuple, class A0,
           class A1, class A2, class A3, class A4, class A5, class A6,
           class A7>
  typename remove_const<typename ForEachType<TypeEvaluator, Tuple>::Type>::type
  transformTuple(Tuple& orig, A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5,
                 A6& a6, A7& a7) {
    return genericTransformTuple
      ( orig,
        makeTransformTupleFunctor<TypeEvaluator>(a0, a1, a2, a3, a4, a5, a6,
                                                 a7));
  }


  template<template<class> class TypeEvaluator, class Tuple, class A0,
           class A1, class A2, class A3, class A4, class A5, class A6,
           class A7, class A8>
  typename remove_const<typename ForEachType<TypeEvaluator, Tuple>::Type>::type
  transformTuple(Tuple& orig, A0& a0, A1& a1, A2& a2, A3& a3, A4& a4, A5& a5,
                 A6& a6, A7& a7, A8& a8) {
    return genericTransformTuple
      ( orig,
        makeTransformTupleFunctor<TypeEvaluator>(a0, a1, a2, a3, a4, a5, a6,
                                                 a7, a8));
  }
# 1287 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tupleutility.hh"
  template<class T>
  struct AddRefTypeEvaluator {
    typedef T& Type;
    static Type apply(T& t) { return t; }
  };






  template<class T>
  struct AddPtrTypeEvaluator {
    typedef typename remove_reference<T>::type* Type;
    static Type apply(T& t) { return &t; }
  };


  template<class T>
  struct AddPtrTypeEvaluator<T&> {
    typedef typename remove_reference<T>::type* Type;
    static Type apply(T& t) { return &t; }
  };

  namespace
  {
    template<int i, typename T1,typename F>
    struct Visitor
    {
      static inline void visit(F& func, T1& t1)
      {
 func.visit(get<tuple_size<T1>::value-i>(t1));
 Visitor<i-1,T1,F>::visit(func, t1);
      }
    };

    template<typename T1,typename F>
    struct Visitor<0,T1,F>
    {
      static inline void visit(F& func, T1& t1)
      {}
    };

    template<int i, typename T1, typename T2,typename F>
    struct PairVisitor
    {
      static inline void visit(F& func, T1& t1, T2& t2)
      {
 func.visit(get<tuple_size<T1>::value-i>(t1), get<tuple_size<T2>::value-i>(t2));
 PairVisitor<i-1,T1,T2,F>::visit(func, t1, t2);
      }
    };

    template<typename T1, typename T2, typename F>
    struct PairVisitor<0,T1,T2,F>
    {
      static inline void visit(F& func, T1& t1, T2& t2)
      {}
    };
  }
# 1382 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tupleutility.hh"
  template <class TupleType>
  class ForEachValue {
  public:


    ForEachValue(TupleType& tuple) : tuple_(tuple) {}



    template <class Functor>
    void apply(Functor& f) const {
      Visitor<tuple_size<TupleType>::value,TupleType,Functor>::visit(f, tuple_);
    }
  private:
    TupleType& tuple_;
  };
# 1415 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tupleutility.hh"
  template <class TupleType1, class TupleType2>
  class ForEachValuePair {
  public:



    ForEachValuePair(TupleType1& t1, TupleType2& t2) :
      tuple1_(t1),
      tuple2_(t2)
    {}



    template <class Functor>
    void apply(Functor& f) {
      PairVisitor<tuple_size<TupleType1>::value,TupleType1,TupleType2,Functor>
 ::visit(f, tuple1_, tuple2_);
    }
  private:
    TupleType1& tuple1_;
    TupleType2& tuple2_;
  };







  template <int N, class Tuple>
  struct AtType {
    typedef typename tuple_element<Length<Tuple>::value - N - 1,
                                   Tuple>::type Type;
  };
# 1457 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tupleutility.hh"
  template <int N>
  struct At
  {

    template<typename Tuple>
    static
    typename TupleAccessTraits<typename AtType<N, Tuple>::Type>::NonConstType
    get(Tuple& t)
    {
      return Dune::get<tuple_size<Tuple>::value - N - 1>(t);
    }

    template<typename Tuple>
    static
    typename TupleAccessTraits<typename AtType<N, Tuple>::Type>::ConstType
    get(const Tuple& t)
    {
      return Dune::get<tuple_size<Tuple>::value - N - 1>(t);
    }
  };







  template <class Tuple>
  class PointerPairDeletor
  {
    struct Deletor {
      template<typename P> void visit(const P& p) { delete p; }
    };

  public:
    static void apply(Tuple& t) {
      static Deletor deletor;
      ForEachValue<Tuple>(t).apply(deletor);
    }
  };
# 1522 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tupleutility.hh"
  template<class Tuple, template<class> class Predicate, std::size_t start = 0,
           std::size_t size = tuple_size<Tuple>::value>
  class FirstPredicateIndex :
    public SelectType<Predicate<typename tuple_element<start,
                                                       Tuple>::type>::value,
                      integral_constant<std::size_t, start>,
                      FirstPredicateIndex<Tuple, Predicate, start+1> >::Type
  {
    typedef static_assert_test< sizeof(static_assert_failure< (bool)( tuple_size<Tuple>::value == size )>) > dune_static_assert_typedef_1533;



  };


  template<class Tuple, template<class> class Predicate, std::size_t size>
  class FirstPredicateIndex<Tuple, Predicate, size, size>
  {
    typedef static_assert_test< sizeof(static_assert_failure< (bool)( AlwaysFalse<Tuple>::value )>) > dune_static_assert_typedef_1541;

  };
# 1554 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tupleutility.hh"
  template<class T>
  struct IsType {

    template<class U>
    struct Predicate : public is_same<T, U> {};
  };
# 1574 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tupleutility.hh"
  template<class Tuple, class T, std::size_t start = 0>
  struct FirstTypeIndex :
    public FirstPredicateIndex<Tuple, IsType<T>::template Predicate, start>
  { };
# 1598 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tupleutility.hh"
  template< class Tuple, class T>
  struct PushBackTuple
  {
    typedef static_assert_test< sizeof(static_assert_failure< (bool)( AlwaysFalse<Tuple>::value )>) > dune_static_assert_typedef_1607;
# 1615 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tupleutility.hh"
    typedef Tuple type;
  };




  template<class T>
  struct PushBackTuple< Dune::tuple<>, T>
  {
    typedef typename Dune::tuple<T> type;
  };

  template< class T1, class T>
  struct PushBackTuple< Dune::tuple<T1>, T>
  {
    typedef typename Dune::tuple<T1, T> type;
  };

  template< class T1, class T2, class T>
  struct PushBackTuple< Dune::tuple<T1, T2>, T>
  {
    typedef typename Dune::tuple<T1, T2, T> type;
  };

  template< class T1, class T2, class T3, class T>
  struct PushBackTuple< Dune::tuple<T1, T2, T3>, T>
  {
    typedef typename Dune::tuple<T1, T2, T3, T> type;
  };

  template< class T1, class T2, class T3, class T4, class T>
  struct PushBackTuple< Dune::tuple<T1, T2, T3, T4>, T>
  {
    typedef typename Dune::tuple<T1, T2, T3, T4, T> type;
  };

  template< class T1, class T2, class T3, class T4, class T5, class T>
  struct PushBackTuple< Dune::tuple<T1, T2, T3, T4, T5>, T>
  {
    typedef typename Dune::tuple<T1, T2, T3, T4, T5, T> type;
  };

  template< class T1, class T2, class T3, class T4, class T5, class T6, class T>
  struct PushBackTuple< Dune::tuple<T1, T2, T3, T4, T5, T6>, T>
  {
    typedef typename Dune::tuple<T1, T2, T3, T4, T5, T6, T> type;
  };

  template< class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T>
  struct PushBackTuple< Dune::tuple<T1, T2, T3, T4, T5, T6, T7>, T>
  {
    typedef typename Dune::tuple<T1, T2, T3, T4, T5, T6, T7, T> type;
  };

  template< class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T>
  struct PushBackTuple< Dune::tuple<T1, T2, T3, T4, T5, T6, T7, T8>, T>
  {
    typedef typename Dune::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T> type;
  };
# 1696 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tupleutility.hh"
  template< class Tuple, class T>
  struct PushFrontTuple
  {
    typedef static_assert_test< sizeof(static_assert_failure< (bool)( AlwaysFalse<Tuple>::value )>) > dune_static_assert_typedef_1705;
# 1713 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tupleutility.hh"
    typedef Tuple type;
  };




  template<class T>
  struct PushFrontTuple< Dune::tuple<>, T>
  {
    typedef typename Dune::tuple<T> type;
  };

  template< class T1, class T>
  struct PushFrontTuple< Dune::tuple<T1>, T>
  {
    typedef typename Dune::tuple<T, T1> type;
  };

  template< class T1, class T2, class T>
  struct PushFrontTuple< Dune::tuple<T1, T2>, T>
  {
    typedef typename Dune::tuple<T, T1, T2> type;
  };

  template< class T1, class T2, class T3, class T>
  struct PushFrontTuple< Dune::tuple<T1, T2, T3>, T>
  {
    typedef typename Dune::tuple<T, T1, T2, T3> type;
  };

  template< class T1, class T2, class T3, class T4, class T>
  struct PushFrontTuple< Dune::tuple<T1, T2, T3, T4>, T>
  {
    typedef typename Dune::tuple<T, T1, T2, T3, T4> type;
  };

  template< class T1, class T2, class T3, class T4, class T5, class T>
  struct PushFrontTuple< Dune::tuple<T1, T2, T3, T4, T5>, T>
  {
    typedef typename Dune::tuple<T, T1, T2, T3, T4, T5> type;
  };

  template< class T1, class T2, class T3, class T4, class T5, class T6, class T>
  struct PushFrontTuple< Dune::tuple<T1, T2, T3, T4, T5, T6>, T>
  {
    typedef typename Dune::tuple<T, T1, T2, T3, T4, T5, T6> type;
  };

  template< class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T>
  struct PushFrontTuple< Dune::tuple<T1, T2, T3, T4, T5, T6, T7>, T>
  {
    typedef typename Dune::tuple<T, T1, T2, T3, T4, T5, T6, T7> type;
  };

  template< class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T>
  struct PushFrontTuple< Dune::tuple<T1, T2, T3, T4, T5, T6, T7, T8>, T>
  {
    typedef typename Dune::tuple<T, T1, T2, T3, T4, T5, T6, T7, T8> type;
  };
# 1789 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tupleutility.hh"
  template<
    template <class, class> class F,
    class Tuple,
    class Seed=tuple<>,
    int N=tuple_size<Tuple>::value>
  struct ReduceTuple
  {
    typedef typename ReduceTuple<F, Tuple, Seed, N-1>::type Accumulated;
    typedef typename tuple_element<N-1, Tuple>::type Value;


    typedef typename F<Accumulated, Value>::type type;
  };
# 1813 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tupleutility.hh"
  template<
    template <class, class> class F,
    class Tuple,
    class Seed>
  struct ReduceTuple<F, Tuple, Seed, 0>
  {

    typedef Seed type;
  };
# 1834 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tupleutility.hh"
  template<class Head, class Tail>
  struct JoinTuples
  {

    typedef typename ReduceTuple< PushBackTuple, Tail, Head>::type type;
  };
# 1851 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/tupleutility.hh"
  template<class TupleTuple>
  struct FlattenTuple
  {

    typedef typename ReduceTuple< JoinTuples, TupleTuple>::type type;
  };

}
# 9 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/codimtable.hh" 2

namespace Dune
{

  namespace GenericGeometry
  {

    template< template< int > class Element, int dim >
    class CodimTable
    {
      friend class CodimTable< Element, dim+1 >;

      typedef typename PushBackTuple<
        typename CodimTable< Element, dim-1 >::ElementTuple,
        Element< dim > >::type ElementTuple;

      ElementTuple map_;

    public:

      template< int codim >
      const Element< codim > &
      operator[] ( const integral_constant< int, codim > codimVariable ) const
      {
        return Dune::get<codim>(map_);
      }

      template< int codim >
      Element< codim > &
      operator[] ( const integral_constant< int, codim > codimVariable )
      {
        return Dune::get<codim>(map_);
      }
    };


    template< template< int > class Element>
    class CodimTable< Element, -1 >
    {
      friend class CodimTable< Element, 0 >;
      typedef typename Dune::tuple<> ElementTuple;
    };

  }

}
# 13 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/subtopologies.hh" 2

namespace Dune
{

  namespace GenericGeometry
  {

    template< class Topology, unsigned int codim >
    struct Size;

    template< class Topology, unsigned int codim, unsigned int i >
    struct SubTopology;

    template< class Topology, unsigned int codim, unsigned int subcodim >
    class SubTopologySize;

    template< class Topology, unsigned int codim, unsigned int subcodim >
    class GenericSubTopologyNumbering;

    template< class Topology, unsigned int codim, unsigned int subcodim >
    class SubTopologyNumbering;






    template< class Topology, unsigned int dim, unsigned int codim >
    class SizeImpl;

    template< unsigned int dim, unsigned int codim >
    class SizeImpl< Point, dim, codim >
    {
      typedef Point Topology;
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (dim == Topology :: dimension) )>) > dune_static_assert_typedef_47;
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (codim <= dim) )>) > dune_static_assert_typedef_48;

    public:
      enum { value = 1 };
    };

    template< class BaseTopology, unsigned int dim, unsigned int codim >
    class SizeImpl< Prism< BaseTopology >, dim, codim >
    {
      typedef Prism< BaseTopology > Topology;
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (dim == Topology :: dimension) )>) > dune_static_assert_typedef_58;
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (codim <= dim) )>) > dune_static_assert_typedef_59;

      enum { m = Size< BaseTopology, codim-1 > :: value };
      enum { n = Size< BaseTopology, codim > :: value };

    public:
      enum { value = n + 2*m };
    };

    template< class BaseTopology, unsigned int dim >
    class SizeImpl< Prism< BaseTopology >, dim, 0 >
    {
      typedef Prism< BaseTopology > Topology;
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (dim == Topology :: dimension) )>) > dune_static_assert_typedef_72;

    public:
      enum { value = 1 };
    };

    template< class BaseTopology, unsigned int dim >
    class SizeImpl< Prism< BaseTopology >, dim, dim >
    {
      typedef Prism< BaseTopology > Topology;
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (dim == Topology :: dimension) )>) > dune_static_assert_typedef_82;

      enum { m = Size< BaseTopology, dim-1 > :: value };

    public:
      enum { value = 2*m };
    };

    template< class BaseTopology, unsigned int dim, unsigned int codim >
    class SizeImpl< Pyramid< BaseTopology >, dim, codim >
    {
      typedef Pyramid< BaseTopology > Topology;
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (dim == Topology :: dimension) )>) > dune_static_assert_typedef_94;
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (codim <= dim) )>) > dune_static_assert_typedef_95;

      enum { m = Size< BaseTopology, codim-1 > :: value };
      enum { n = Size< BaseTopology, codim > :: value };

    public:
      enum { value = m+n };
    };

    template< class BaseTopology, unsigned int dim >
    class SizeImpl< Pyramid< BaseTopology >, dim, 0 >
    {
      typedef Pyramid< BaseTopology > Topology;
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (dim == Topology :: dimension) )>) > dune_static_assert_typedef_108;

    public:
      enum { value = 1 };
    };

    template< class BaseTopology, unsigned int dim >
    class SizeImpl< Pyramid< BaseTopology >, dim, dim >
    {
      typedef Pyramid< BaseTopology > Topology;
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (dim == Topology :: dimension) )>) > dune_static_assert_typedef_118;

      enum { m = Size< BaseTopology, dim-1 > :: value };

    public:
      enum { value = m+1 };
    };


    template< class Topology, unsigned int codim >
    struct Size
    {
      enum { value = SizeImpl< Topology, Topology :: dimension, codim > :: value };
    };






    template< class Topology, unsigned int dim, unsigned int codim, unsigned int i >
    class SubTopologyImpl;

    template< unsigned int dim, unsigned int codim, unsigned int i >
    class SubTopologyImpl< Point, dim, codim, i >
    {
      typedef Point Topology;
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (dim == Topology :: dimension) )>) > dune_static_assert_typedef_145;
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (codim <= dim) )>) > dune_static_assert_typedef_146;
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (i < Size< Topology, codim > :: value) )>) > dune_static_assert_typedef_148;


    public:
      typedef Topology type;
    };

    template< class BaseTopology, unsigned int dim, unsigned int codim, unsigned int i >
    class SubTopologyImpl< Prism< BaseTopology >, dim, codim, i >
    {
      typedef Prism< BaseTopology > Topology;
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (dim == Topology :: dimension) )>) > dune_static_assert_typedef_158;
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (codim <= dim) )>) > dune_static_assert_typedef_159;
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (i < Size< Topology, codim > :: value) )>) > dune_static_assert_typedef_161;


      enum { m = Size< BaseTopology, codim-1 > :: value };
      enum { n = Size< BaseTopology, codim > :: value };

      enum { s = (i < n+m ? 0 : 1) };

      template< bool >
      struct PrismSub
      {
        typedef Prism< typename SubTopology< BaseTopology, codim, i > :: type > type;
      };

      template< bool >
      struct BaseSub
      {
        typedef typename SubTopology< BaseTopology, codim-1, i-(n+s*m) > :: type type;
      };

    public:
      typedef typename SelectType< (i < n), PrismSub<true>, BaseSub<false> > :: Type :: type type;
    };

    template< class BaseTopology, unsigned int dim, unsigned int i >
    class SubTopologyImpl< Prism< BaseTopology >, dim, 0, i >
    {
      typedef Prism< BaseTopology > Topology;
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (dim == Topology :: dimension) )>) > dune_static_assert_typedef_188;
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (i < Size< Topology, 0 > :: value) )>) > dune_static_assert_typedef_190;

    public:
      typedef Topology type;
    };

    template< class BaseTopology, unsigned int dim, unsigned int i >
    class SubTopologyImpl< Prism< BaseTopology >, dim, dim, i >
    {
      typedef Prism< BaseTopology > Topology;
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (dim == Topology :: dimension) )>) > dune_static_assert_typedef_199;
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (i < Size< Topology, dim > :: value) )>) > dune_static_assert_typedef_201;

    public:
      typedef Point type;
    };

    template< class BaseTopology, unsigned int dim, unsigned int codim, unsigned int i >
    class SubTopologyImpl< Pyramid< BaseTopology >, dim, codim, i >
    {
      typedef Pyramid< BaseTopology > Topology;
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (dim == Topology :: dimension) )>) > dune_static_assert_typedef_210;
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (codim <= dim) )>) > dune_static_assert_typedef_211;
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (i < Size< Topology, codim > :: value) )>) > dune_static_assert_typedef_213;


      enum { m = Size< BaseTopology, codim-1 > :: value };

      template< bool >
      struct BaseSub
      {
        typedef typename SubTopology< BaseTopology, codim-1, i > :: type type;
      };

      template< bool >
      struct PyramidSub
      {
        typedef Pyramid< typename SubTopology< BaseTopology, codim, i-m > :: type > type;
      };

    public:
      typedef typename SelectType< (i < m), BaseSub<true>, PyramidSub<false> > :: Type :: type type;
    };

    template< class BaseTopology, unsigned int dim, unsigned int i >
    class SubTopologyImpl< Pyramid< BaseTopology >, dim, 0, i >
    {
      typedef Pyramid< BaseTopology > Topology;
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (dim == Topology :: dimension) )>) > dune_static_assert_typedef_237;
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (i < Size< Topology, 0 > :: value) )>) > dune_static_assert_typedef_239;


    public:
      typedef Topology type;
    };

    template< class BaseTopology, unsigned int dim, unsigned int i >
    class SubTopologyImpl< Pyramid< BaseTopology >, dim, dim, i >
    {
      typedef Pyramid< BaseTopology > Topology;
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (dim == Topology :: dimension) )>) > dune_static_assert_typedef_249;
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (i < Size< Topology, dim > :: value) )>) > dune_static_assert_typedef_251;


    public:
      typedef Point type;
    };

    template< class Topology, unsigned int codim, unsigned int i >
    struct SubTopology
    {
      typedef typename SubTopologyImpl< Topology, Topology :: dimension, codim, i > :: type type;
    };






    template< class Topology, unsigned int codim, unsigned int subcodim >
    class SubTopologySize
    {
      template< int i >
      struct Builder;

      unsigned int size_[ Size< Topology, codim > :: value ];

      SubTopologySize ()
      {
        ForLoop< Builder, 0, Size< Topology, codim > :: value-1 >
          :: apply( *this );
      }

      SubTopologySize ( const SubTopologySize & );

      static const SubTopologySize &instance ()
      {
        static SubTopologySize inst;
        return inst;
      }

    public:
      static unsigned int size ( unsigned int i )
      {
        (((i < Size< Topology, codim > :: value)) ? static_cast<void> (0) : __assert_fail ("(i < Size< Topology, codim > :: value)", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/subtopologies.hh", 293, __PRETTY_FUNCTION__));
        return instance().size_[ i ];
      }
    };

    template< class Topology, unsigned int codim, unsigned int subcodim >
    template< int i >
    struct SubTopologySize< Topology, codim, subcodim > :: Builder
    {
      typedef GenericGeometry :: SubTopologySize< Topology, codim, subcodim >
        SubTopologySize;
      typedef typename GenericGeometry :: SubTopology< Topology, codim, i > :: type
        SubTopology;

      static void apply ( SubTopologySize &subTopologySize )
      {
        subTopologySize.size_[ i ] = Size< SubTopology, subcodim > :: value;
      }
    };






    template< class Topology, unsigned int codim,
              unsigned int subdim, unsigned int subcodim >
    struct GenericSubTopologyNumberingHelper;

    template< class BaseTopology, unsigned int codim,
              unsigned int subdim, unsigned int subcodim >
    struct GenericSubTopologyNumberingHelper
      < Prism< BaseTopology >, codim, subdim, subcodim >
    {
      typedef Prism< BaseTopology > Topology;

      enum { m = Size< BaseTopology, codim-1 > :: value };
      enum { n = Size< BaseTopology, codim > :: value };

      enum { mb = Size< BaseTopology, codim+subcodim-1 > :: value };
      enum { nb = Size< BaseTopology, codim+subcodim > :: value };

      static unsigned int number ( unsigned int i, unsigned int j )
      {
        const unsigned int s = (i < n+m ? 0 : 1);
        if( i < n )
        {
          const unsigned int ms = SubTopologySize< BaseTopology, codim, subcodim-1 > :: size( i );
          const unsigned int ns = SubTopologySize< BaseTopology, codim, subcodim > :: size( i );
          const unsigned int ss = (j < ns+ms ? 0 : 1);
          if( j < ns )
            return GenericSubTopologyNumbering< BaseTopology, codim, subcodim >
              :: number( i, j );
          else
            return GenericSubTopologyNumbering< BaseTopology, codim, subcodim-1 >
              :: number( i, j-(ns+ss*ms) ) + nb + ss*mb;
        }
        else
          return GenericSubTopologyNumbering< BaseTopology, codim-1, subcodim >
            :: number( i-(n+s*m), j ) + nb + s*mb;
      }
    };

    template< class BaseTopology, unsigned int codim, unsigned int subdim >
    struct GenericSubTopologyNumberingHelper
      < Prism< BaseTopology >, codim, subdim, 0 >
    {
      typedef Prism< BaseTopology > Topology;

      static unsigned int number ( unsigned int i, unsigned int j )
      {
        return i;
      }
    };

    template< class BaseTopology, unsigned int codim, unsigned int subdim >
    struct GenericSubTopologyNumberingHelper
      < Prism< BaseTopology >, codim, subdim, subdim >
    {
      typedef Prism< BaseTopology > Topology;

      enum { m = Size< BaseTopology, codim-1 > :: value };
      enum { n = Size< BaseTopology, codim > :: value };

      enum { mb = Size< BaseTopology, codim+subdim-1 > :: value };

      static unsigned int number ( unsigned int i, unsigned int j )
      {
        const unsigned int s = (i < n+m ? 0 : 1);
        if( i < n )
        {
          const unsigned int ms = SubTopologySize< BaseTopology, codim, subdim-1 > :: size( i );
          const unsigned int ss = (j < ms ? 0 : 1);
          return GenericSubTopologyNumbering< BaseTopology, codim, subdim-1 >
            :: number( i, j-ss*ms ) + ss*mb;
        }
        else
          return GenericSubTopologyNumbering< BaseTopology, codim-1, subdim >
            :: number( i-(n+s*m), j ) + s*mb;
      }
    };

    template< class BaseTopology, unsigned int codim,
              unsigned int subdim, unsigned int subcodim >
    struct GenericSubTopologyNumberingHelper
      < Pyramid< BaseTopology >, codim, subdim, subcodim >
    {
      typedef Pyramid< BaseTopology > Topology;

      enum { m = Size< BaseTopology, codim-1 > :: value };

      enum { mb = Size< BaseTopology, codim+subcodim-1 > :: value };

      static unsigned int number ( unsigned int i, unsigned int j )
      {
        if( i < m )
          return GenericSubTopologyNumbering< BaseTopology, codim-1, subcodim >
            :: number( i, j );
        else
        {
          const unsigned int ms = SubTopologySize< BaseTopology, codim, subcodim-1 > :: size( i-m );
          if( j < ms )
            return GenericSubTopologyNumbering< BaseTopology, codim, subcodim-1 >
              :: number( i-m, j );
          else
            return GenericSubTopologyNumbering< BaseTopology, codim, subcodim >
              :: number( i-m, j-ms ) + mb;
        }
      }
    };

    template< class BaseTopology, unsigned int codim, unsigned int subdim >
    struct GenericSubTopologyNumberingHelper
      < Pyramid< BaseTopology >, codim, subdim, 0 >
    {
      typedef Pyramid< BaseTopology > Topology;

      static unsigned int number ( unsigned int i, unsigned int j )
      {
        return i;
      }
    };

    template< class BaseTopology, unsigned int codim, unsigned int subdim >
    struct GenericSubTopologyNumberingHelper
      < Pyramid< BaseTopology >, codim, subdim, subdim >
    {
      typedef Pyramid< BaseTopology > Topology;

      enum { m = Size< BaseTopology, codim-1 > :: value };

      enum { mb = Size< BaseTopology, codim+subdim-1 > :: value };

      static unsigned int number ( unsigned int i, unsigned int j )
      {
        if( i < m )
          return GenericSubTopologyNumbering< BaseTopology, codim-1, subdim >
            :: number( i, j );
        else
        {
          const unsigned int ms = SubTopologySize< BaseTopology, codim, subdim-1 > :: size( i-m );
          if( j < ms )
            return GenericSubTopologyNumbering< BaseTopology, codim, subdim-1 >
              :: number( i-m, j );
          else
            return mb;
        }
      }
    };

    template< class Topology, unsigned int codim, unsigned int subcodim >
    class GenericSubTopologyNumbering
    {
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (codim <= Topology :: dimension) )>) > dune_static_assert_typedef_466;
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (codim + subcodim <= Topology :: dimension) )>) > dune_static_assert_typedef_468;


      template< bool >
      struct BorderCodim
      {
        static unsigned int number ( unsigned int i, unsigned int j )
        {
          return (codim == 0 ? j : i );
        }
      };

      template< bool >
      struct InnerCodim
      {
        static unsigned int number ( unsigned int i, unsigned int j )
        {
          return GenericSubTopologyNumberingHelper
            < Topology, codim, Topology :: dimension - codim, subcodim >
            :: number( i, j );
        }
      };

    public:
      static unsigned int number ( unsigned int i, unsigned int j )
      {
        (((j <= SubTopologySize< Topology, codim, subcodim > :: size( i ))) ? static_cast<void> (0) : __assert_fail ("(j <= SubTopologySize< Topology, codim, subcodim > :: size( i ))", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/subtopologies.hh", 493, __PRETTY_FUNCTION__));
        return SelectType
          < (codim == 0) || (codim == Topology :: dimension), BorderCodim<true>, InnerCodim<false> >
          :: Type :: number( i, j );
      }
    };






    template< class Topology, unsigned int codim, unsigned int subcodim >
    class SubTopologyNumbering
    {
      typedef GenericSubTopologyNumbering< Topology, codim, subcodim >
        GenericNumbering;

      std :: vector< unsigned int > numbering_[ Size< Topology, codim > :: value ];

    public:
      static unsigned int number ( unsigned int i, unsigned int j )
      {
        (((j <= SubTopologySize< Topology, codim, subcodim > :: size( i ))) ? static_cast<void> (0) : __assert_fail ("(j <= SubTopologySize< Topology, codim, subcodim > :: size( i ))", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/subtopologies.hh", 516, __PRETTY_FUNCTION__));
        return instance().numbering_[ i ][ j ];
      }

    private:
      SubTopologyNumbering ()
      {
        for( unsigned int i = 0; i < Size< Topology, codim > :: value; ++i )
        {
          const unsigned int size = SubTopologySize< Topology, codim, subcodim > :: size( i );
          numbering_[ i ].resize( size );
          for( unsigned int j = 0; j < size; ++j )
            numbering_[ i ][ j ] = GenericNumbering :: number( i, j );
        }
      }

      static const SubTopologyNumbering &instance ()
      {
        static SubTopologyNumbering inst;
        return inst;
      }
    };






    template< class Topology, unsigned int codim >
    struct IsCodimHybrid
    {
      static const bool value = (codim != 0) && IsHybrid< Topology >::value;
    };






    template< class Topology >
    class SubTopologyMapper
    {
      static const unsigned int dimension = Topology::dimension;

      template< class A, class B >
      struct StaticSum
      {
        static const unsigned int value = A::value + B::value;
      };

      template< int codim >
      struct Size
      {
        static const unsigned int value = GenericGeometry::Size< Topology, codim >::value;
      };

      template< int codim >
      struct CalcOffset
      {
        static void apply ( unsigned int (&offsets)[ dimension+2 ] )
        {
          offsets[ codim+1 ] = offsets[ codim ] + Size< codim >::value;
        }
      };

    public:
      static const unsigned int staticSize = GenericForLoop< StaticSum, Size, 0, dimension >::value;

      SubTopologyMapper ()
      {
        offsets_[ 0 ] = 0;
        ForLoop< CalcOffset, 0, dimension >::apply( offsets_ );
        ((size() == staticSize) ? static_cast<void> (0) : __assert_fail ("size() == staticSize", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/subtopologies.hh", 588, __PRETTY_FUNCTION__));
      };

      unsigned int operator() ( const unsigned int codim, const unsigned int subEntity ) const
      {
        const unsigned int offset = offsets_[ codim ];
        ((offset + subEntity < offsets_[ codim+1 ]) ? static_cast<void> (0) : __assert_fail ("offset + subEntity < offsets_[ codim+1 ]", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/subtopologies.hh", 594, __PRETTY_FUNCTION__));
        return offset + subEntity;
      }

      unsigned int size () const
      {
        return offsets_[ dimension+1 ];
      }

    private:
      unsigned int offsets_[ dimension+2 ];
    };

  }

}
# 11 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh" 2
# 1 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/referencedomain.hh" 1
# 11 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/referencedomain.hh"
namespace Dune
{

  namespace GenericGeometry
  {




    template< class Topology >
    struct ReferenceDomain;






    template< class Topology >
    class ReferenceDomainBase;


    template<>
    class ReferenceDomainBase< Point >
    {
      typedef Point Topology;

      friend struct ReferenceDomain< Topology >;
      friend class ReferenceDomainBase< Prism< Topology > >;
      friend class ReferenceDomainBase< Pyramid< Topology > >;

      static const unsigned int numNormals = 0;

      template< class ctype, int dim >
      static void corner ( unsigned int i, FieldVector< ctype, dim > &n )
      {
        ((i < Topology::numCorners) ? static_cast<void> (0) : __assert_fail ("i < Topology::numCorners", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/referencedomain.hh", 46, __PRETTY_FUNCTION__));
      }

      template< class ctype, int dim >
      static bool
      checkInside ( const FieldVector< ctype, dim > &x, ctype factor )
      {
        return true;
      }

      template< class ctype, int dim >
      static void
      integrationOuterNormal ( unsigned int i, FieldVector< ctype, dim > &n )
      {
        ((i < numNormals) ? static_cast<void> (0) : __assert_fail ("i < numNormals", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/referencedomain.hh", 60, __PRETTY_FUNCTION__));
      }

      template< class ctype >
      static ctype volume ()
      {
        return ctype( 1 );
      }
    };


    template< class BaseTopology >
    class ReferenceDomainBase< Prism< BaseTopology > >
    {
      typedef Prism< BaseTopology > Topology;

      friend struct ReferenceDomain< Topology >;
      friend class ReferenceDomainBase< Prism< Topology > >;
      friend class ReferenceDomainBase< Pyramid< Topology > >;

      static const unsigned int numNormals = Size< Topology, 1 >::value;

      static const unsigned int dimension = Topology::dimension;
      static const unsigned int myindex = dimension - 1;

      template< class ctype, int dim >
      static void corner ( unsigned int i, FieldVector< ctype, dim > &x )
      {
        ((i < Topology::numCorners) ? static_cast<void> (0) : __assert_fail ("i < Topology::numCorners", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/referencedomain.hh", 88, __PRETTY_FUNCTION__));
        const unsigned int j = i % BaseTopology::numCorners;
        ReferenceDomainBase< BaseTopology >::corner( j, x );
        if( i >= BaseTopology::numCorners )
          x[ myindex ] = ctype( 1 );
      }

      template< class ctype, int dim >
      static bool
      checkInside ( const FieldVector< ctype, dim > &x, ctype factor )
      {
        const ctype xn = x[ myindex ];
        const ctype cxn = factor - xn;
        return (xn > -1e-12) && (cxn > -1e-12)
               && ReferenceDomainBase< BaseTopology >::checkInside( x, factor );
      }

      template< class ctype, int dim >
      static void
      integrationOuterNormal ( unsigned int i, FieldVector< ctype, dim > &n )
      {
        typedef ReferenceDomainBase< BaseTopology > BaseReferenceDomain;

        if( i >= BaseReferenceDomain::numNormals )
        {
          const unsigned int j = i - BaseReferenceDomain::numNormals;
          n[ myindex ] = (j == 0 ? ctype( -1 ) : ctype( 1 ));
        }
        else
          BaseReferenceDomain::integrationOuterNormal( i, n );
      }

      template< class ctype >
      static ctype volume ()
      {
        typedef ReferenceDomainBase< BaseTopology > BaseReferenceDomain;
        return BaseReferenceDomain::template volume< ctype >();
      }
    };


    template< class BaseTopology >
    class ReferenceDomainBase< Pyramid< BaseTopology > >
    {
      typedef Pyramid< BaseTopology > Topology;

      friend struct ReferenceDomain< Topology >;
      friend class ReferenceDomainBase< Prism< Topology > >;
      friend class ReferenceDomainBase< Pyramid< Topology > >;

      static const unsigned int numNormals = Size< Topology, 1 >::value;

      static const unsigned int dimension = Topology::dimension;
      static const unsigned int myindex = dimension - 1;

      template< bool >
      struct MultiDimensional
      {
        template< class ctype, int dim >
        static void
        integrationOuterNormal ( unsigned int i, FieldVector< ctype, dim > &n )
        {
          multiDimensionalIntegrationOuterNormal( i, n );
        }
      };

      template< bool >
      struct OneDimensional
      {
        template< class ctype, int dim >
        static void
        integrationOuterNormal ( unsigned int i, FieldVector< ctype, dim > &n )
        {
          n[ myindex ] = (i > 0) ? ctype( 1 ) : ctype( -1 );
        }
      };

      template< class ctype, int dim >
      static void corner ( unsigned int i, FieldVector< ctype, dim > &x )
      {
        ((i < Topology::numCorners) ? static_cast<void> (0) : __assert_fail ("i < Topology::numCorners", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/referencedomain.hh", 168, __PRETTY_FUNCTION__));
        if( i < BaseTopology::numCorners )
          ReferenceDomainBase< BaseTopology >::corner( i, x );
        else
          x[ myindex ] = ctype( 1 );
      }

      template< class ctype, int dim >
      static bool
      checkInside ( const FieldVector< ctype, dim > &x, ctype factor )
      {
        const ctype xn = x[ myindex ];
        const ctype cxn = factor - xn;
        return (xn > -1e-12) && (cxn > -1e-12)
               && ReferenceDomainBase< BaseTopology >::checkInside( x, cxn );
      }

      template< class ctype, int dim >
      static void
      multiDimensionalIntegrationOuterNormal ( unsigned int i, FieldVector< ctype, dim > &n )
      {
        typedef ReferenceDomainBase< BaseTopology > BaseReferenceDomain;
        typedef SubTopologyNumbering< BaseTopology, 1, dimension-2 > Numbering;

        if( i > 0 )
        {
          const unsigned int j = Numbering::number( i-1, 0 );
          FieldVector< ctype, dim > x( ctype( 0 ) );
          BaseReferenceDomain::corner( j, x );

          BaseReferenceDomain::integrationOuterNormal ( i-1, n );
          n[ myindex ] = (x * n);
        }
        else
          n[ myindex ] = ctype( -1 );
      }

      template< class ctype, int dim >
      static void
      integrationOuterNormal ( unsigned int i, FieldVector< ctype, dim > &n )
      {
        SelectType< (dimension > 1), MultiDimensional<true>, OneDimensional<false> > :: Type
          ::integrationOuterNormal( i, n );
      }

      template< class ctype >
      static ctype volume ()
      {
        typedef ReferenceDomainBase< BaseTopology > BaseReferenceDomain;
        const ctype baseVolume = BaseReferenceDomain::template volume< ctype >();
        return baseVolume / ctype( (unsigned int)(dimension) );
      }
    };







    template< class Topology >
    struct ReferenceDomain
    {
      static const unsigned int numCorners = Topology::numCorners;
      static const unsigned int dimension = Topology::dimension;

      static const unsigned int numNormals
        = ReferenceDomainBase< Topology >::numNormals;

      template< class ctype >
      static void corner ( unsigned int i, FieldVector< ctype, dimension > &x )
      {
        x = ctype( 0 );
        ReferenceDomainBase< Topology >::corner( i, x );
      }

      template< class ctype >
      static bool checkInside ( const FieldVector< ctype, dimension > &x )
      {
        return ReferenceDomainBase< Topology >::checkInside( x, ctype( 1 ) );
      }

      template< class ctype >
      static void
      integrationOuterNormal ( unsigned int i, FieldVector< ctype, dimension > &n )
      {
        n = ctype( 0 );
        return ReferenceDomainBase< Topology >::integrationOuterNormal( i, n );
      }

      template< class ctype >
      static ctype volume ()
      {
        return ReferenceDomainBase< Topology >::template volume< ctype >();
      }
    };

  }

}
# 12 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh" 2
# 1 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/conversion.hh" 1
# 10 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/conversion.hh"
namespace Dune
{







  class deprecated_int
  {
    unsigned int i;
  public:


    operator unsigned int () { return i; }

    unsigned int value() { return i; };



    deprecated_int(unsigned int j) : i(j) {};
  };

  namespace GenericGeometry
  {
# 47 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/conversion.hh"
    template< class Topology, GeometryType::BasicType linetype >
    class DuneGeometryType;

    template< GeometryType::BasicType linetype >
    class DuneGeometryType< Point, linetype >
    {
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (linetype == GeometryType::simplex) || (linetype == GeometryType::cube) )>) > dune_static_assert_typedef_55;



    public:
      static const unsigned int dimension = 0;
      static const GeometryType::BasicType basicType = linetype;


      static GeometryType type () __attribute__((deprecated))
      {
        return GeometryType( basicType, dimension );
      }
    };

    template< class BaseTopology, GeometryType::BasicType linetype >
    class DuneGeometryType< Prism< BaseTopology >, linetype >
    {
      typedef DuneGeometryType< BaseTopology, linetype > DuneBaseGeometryType;

      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (linetype == GeometryType::simplex) || (linetype == GeometryType::cube) )>) > dune_static_assert_typedef_75;



      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (DuneBaseGeometryType::basicType == GeometryType::simplex) || (DuneBaseGeometryType::basicType == GeometryType::cube) )>) > dune_static_assert_typedef_79;



    public:
      static const unsigned int dimension = DuneBaseGeometryType::dimension + 1;
      static const GeometryType::BasicType basicType
        = ((dimension == 1)
           ? linetype
           : ((dimension == 2) || (DuneBaseGeometryType::basicType == GeometryType::cube))
             ? GeometryType::cube
             : GeometryType::prism);


      static GeometryType type () __attribute__((deprecated))
      {
        return GeometryType( basicType, dimension );
      }
    };

    template< class BaseTopology, GeometryType::BasicType linetype >
    class DuneGeometryType< Pyramid< BaseTopology >, linetype >
    {
      typedef DuneGeometryType< BaseTopology, linetype > DuneBaseGeometryType;

      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (linetype == GeometryType::simplex) || (linetype == GeometryType::cube) )>) > dune_static_assert_typedef_104;



      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (DuneBaseGeometryType::basicType == GeometryType::simplex) || (DuneBaseGeometryType::basicType == GeometryType::cube) )>) > dune_static_assert_typedef_108;



    public:
      static const unsigned int dimension = DuneBaseGeometryType::dimension + 1;
      static const GeometryType::BasicType basicType
        = ((dimension == 1)
           ? linetype
           : ((dimension == 2) || (DuneBaseGeometryType::basicType == GeometryType::simplex))
             ? GeometryType::simplex
             : GeometryType::pyramid);


      static GeometryType type () __attribute__((deprecated))
      {
        return GeometryType( basicType, dimension );
      }
    };
# 142 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/conversion.hh"
    template< unsigned int dim, GeometryType::BasicType linetype >
    struct DuneGeometryTypeProvider
    {

      static const unsigned int dimension = dim;


      static const unsigned int numTopologies = (1 << dimension);

    private:
      GeometryType types_[ (dimension>=1)? numTopologies / 2 : numTopologies ];


      DuneGeometryTypeProvider () __attribute__((deprecated))
      {
        if( dimension > 3 )
        {
          for( unsigned int i = 0; i < numTopologies / 2; ++i )
            types_[ i ].makeNone( dimension );
        }

        if( dimension >= 3 )
        {
          const unsigned int d = (dimension >= 2 ? dimension-2 : 0);
          types_[ 0 ].makeSimplex( dimension );
          types_[ (1 << d) ] = GeometryType( GeometryType::prism, dimension );
          types_[ (1 << d) - 1 ] = GeometryType( GeometryType::pyramid, dimension );
          types_[ (1 << (d+1)) - 1 ].makeCube( dimension );
        }
        else if( dimension == 2 )
        {
          types_[ 0 ].makeSimplex( dimension );
          types_[ 1 ].makeCube( dimension );
        }
        else
          types_[ 0 ] = GeometryType( linetype, dimension );
      }

      static const DuneGeometryTypeProvider &instance ()
      {
        static DuneGeometryTypeProvider inst;
        return inst;
      }

    public:






      static const GeometryType &type ( unsigned int topologyId )
      {
        ((topologyId < numTopologies) ? static_cast<void> (0) : __assert_fail ("topologyId < numTopologies", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/conversion.hh", 195, __PRETTY_FUNCTION__));
        return instance().types_[ topologyId / 2 ];
      }
    };






    template< class Topology >
    struct MapNumbering;


    struct MapNumberingIdentical
    {
      template< unsigned int codim >
      static unsigned int dune2generic ( unsigned int i )
      {
        return i;
      }

      template< unsigned int codim >
      static unsigned int generic2dune ( unsigned int i )
      {
        return i;
      }
    };


    template<>
    struct MapNumbering< Point >
    : public MapNumberingIdentical
    {};


    template<>
    struct MapNumbering< Prism< Point > >
    : public MapNumberingIdentical
    {};

    template<>
    struct MapNumbering< Pyramid< Point > >
    : public MapNumberingIdentical
    {};


    struct MapNumberingTriangle
    {
      template< unsigned int codim >
      static unsigned int dune2generic ( unsigned int i )
      {
        return (codim == 1 ? 2 - i : i);
      }

      template< unsigned int codim >
      static unsigned int generic2dune ( unsigned int i )
      {
        return dune2generic< codim >( i );
      }
    };

    template<>
    struct MapNumbering< Pyramid< Pyramid< Point > > >
    : public MapNumberingTriangle
    {};

    template<>
    struct MapNumbering< Pyramid< Prism< Point > > >
    : public MapNumberingTriangle
    {};



    template<>
    struct MapNumbering< Prism< Pyramid< Point > > >
    : public MapNumberingIdentical
    {};

    template<>
    struct MapNumbering< Prism< Prism< Point > > >
    : public MapNumberingIdentical
    {};


    struct MapNumberingTetrahedron
    {
      template< unsigned int codim >
      static unsigned int dune2generic ( unsigned int i )
      {
        static unsigned int edge[ 6 ] = { 0, 2, 1, 3, 4, 5 };
        return (codim == 1 ? 3 - i : (codim == 2 ? edge[ i ] : i));
      }

      template< unsigned int codim >
      static unsigned int generic2dune ( unsigned int i )
      {
        return dune2generic< codim >( i );
      }
    };

    template<>
    struct MapNumbering< Pyramid< Pyramid< Pyramid< Point > > > >
    : public MapNumberingTetrahedron
    {};

    template<>
    struct MapNumbering< Pyramid< Pyramid< Prism< Point > > > >
    : public MapNumberingTetrahedron
    {};


    struct MapNumberingCube
    {
      template< unsigned int codim >
      static unsigned int dune2generic ( unsigned int i )
      {
        static unsigned int edge[ 12 ] = { 0, 1, 2, 3, 4, 5, 8, 9, 6, 7, 10, 11 };
        return (codim == 2 ? edge[ i ] : i);
      }

      template< unsigned int codim >
      static unsigned int generic2dune ( unsigned int i )
      {
        return dune2generic< codim >( i );
      }
    };

    template<>
    struct MapNumbering< Prism< Prism< Pyramid< Point > > > >
    : public MapNumberingCube
    {};

    template<>
    struct MapNumbering< Prism< Prism< Prism< Point > > > >
    : public MapNumberingCube
    {};


    struct MapNumbering4DCube
    {
      template< unsigned int codim >
      static unsigned int dune2generic ( unsigned int i )
      {
        static unsigned int codim2[ 24 ] =
          { 0, 1, 2, 3, 4, 5, 8, 9, 12, 13, 18, 19,
            6, 7, 10, 11, 14, 15, 20, 21, 16, 17, 22, 23 };
        static unsigned int codim3[ 32 ] =
          { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 20, 21, 22, 23,
            12, 13, 16, 17, 24, 25, 28, 29, 14, 15, 18, 19, 26, 27, 30, 31 };
        if (codim == 2)
          return codim2[i];
        else if (codim == 3)
          return codim3[i];
        else
          return i;
      }

      template< unsigned int codim >
      static unsigned int generic2dune ( unsigned int i )
      {
        static unsigned int codim2[ 24 ] =
          { 0, 1, 2, 3, 4, 5, 12, 13, 6, 7, 14, 15,
            8, 9, 16, 17, 20, 21, 10, 11, 18, 19, 22, 23 };
        static unsigned int codim3[ 32 ] =
          { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 16, 17, 24, 25,
            18, 19, 26, 27, 12, 13, 14, 15, 20, 21, 28, 29, 22, 23, 30, 31 };
        if (codim == 2)
          return codim2[i];
        else if (codim == 3)
          return codim3[i];
        else
          return i;
      }
    };

    template<>
    struct MapNumbering< Prism< Prism< Prism< Pyramid< Point > > > > >
    : public MapNumbering4DCube
    {};

    template<>
    struct MapNumbering< Prism< Prism< Prism< Prism< Point > > > > >
    : public MapNumbering4DCube
    {};


    struct MapNumberingPyramid
    {
      template< unsigned int codim >
      static unsigned int dune2generic ( unsigned int i )
      {
        static unsigned int vertex[ 5 ] = { 0, 1, 3, 2, 4 };
        static unsigned int edge[ 8 ] = { 2, 1, 3, 0, 4, 5, 7, 6 };
        static unsigned int face[ 5 ] = { 0, 3, 2, 4, 1 };

        if( codim == 3 )
          return vertex[ i ];
        else if( codim == 2 )
          return edge[ i ];
        else if( codim == 1 )
          return face[ i ];
        else
          return i;
      }

      template< unsigned int codim >
      static unsigned int generic2dune ( unsigned int i )
      {
        static unsigned int vertex[ 5 ] = { 0, 1, 3, 2, 4 };
        static unsigned int edge[ 8 ] = { 3, 1, 0, 2, 4, 5, 7, 6 };
        static unsigned int face[ 5 ] = { 0, 4, 2, 1, 3 };

        if( codim == 3 )
          return vertex[ i ];
        else if( codim == 2 )
          return edge[ i ];
        else if( codim == 1 )
          return face[ i ];
        else
          return i;
      }
    };

    template<>
    struct MapNumbering< Pyramid< Prism< Pyramid< Point > > > >
    : public MapNumberingPyramid
    {};

    template<>
    struct MapNumbering< Pyramid< Prism< Prism< Point > > > >
    : public MapNumberingPyramid
    {};


    struct MapNumberingPrism
    {
      template< unsigned int codim >
      static unsigned int dune2generic ( unsigned int i )
      {
        static unsigned int edge[ 9 ] = { 3, 5, 4, 0, 1, 2, 6, 8, 7 };
        static unsigned int face[ 5 ] = { 3, 0, 2, 1, 4 };

        if( codim == 2 )
          return edge[ i ];
        else if( codim == 1 )
          return face[ i ];
        else
          return i;
      }

      template< unsigned int codim >
      static unsigned int generic2dune ( unsigned int i )
      {
        static unsigned int edge[ 9 ] = { 3, 4, 5, 0, 2, 1, 6, 8, 7 };
        static unsigned int face[ 5 ] = { 1, 3, 2, 0, 4 };

        if( codim == 2 )
          return edge[ i ];
        else if( codim == 1 )
          return face[ i ];
        else
          return i;
      }
    };

    template<>
    struct MapNumbering< Prism< Pyramid< Pyramid< Point > > > >
    : public MapNumberingPrism
    {};

    template<>
    struct MapNumbering< Prism< Pyramid< Prism< Point > > > >
    : public MapNumberingPrism
    {};






    template< unsigned int dim >
    struct MapNumberingProvider
    {
      static const unsigned int dimension = dim;
      static const unsigned int numTopologies = (1 << dimension);

    private:
      template< int i >
      struct Builder;

      typedef std :: vector< unsigned int > Map;

      Map dune2generic_[ numTopologies ][ dimension+1 ];
      Map generic2dune_[ numTopologies ][ dimension+1 ];

      MapNumberingProvider ()
      {
        ForLoop< Builder, 0, (1 << dim)-1 >::apply( dune2generic_, generic2dune_ );
      }

      static const MapNumberingProvider &instance ()
      {
        static MapNumberingProvider inst;
        return inst;
      }

    public:
      static unsigned int
      dune2generic ( unsigned int topologyId, unsigned int i, unsigned int codim )
      {
        (((topologyId < numTopologies) && (codim <= dimension)) ? static_cast<void> (0) : __assert_fail ("(topologyId < numTopologies) && (codim <= dimension)", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/conversion.hh", 506, __PRETTY_FUNCTION__));
        ((i < instance().dune2generic_[ topologyId ][ codim ].size()) ? static_cast<void> (0) : __assert_fail ("i < instance().dune2generic_[ topologyId ][ codim ].size()", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/conversion.hh", 507, __PRETTY_FUNCTION__));
        return instance().dune2generic_[ topologyId ][ codim ][ i ];
      }

      template< unsigned int codim >
      static unsigned int
      dune2generic ( unsigned int topologyId, unsigned int i )
      {
        return dune2generic( topologyId, i, codim );
      }

      static unsigned int
      generic2dune ( unsigned int topologyId, unsigned int i, unsigned int codim )
      {
        (((topologyId < numTopologies) && (codim <= dimension)) ? static_cast<void> (0) : __assert_fail ("(topologyId < numTopologies) && (codim <= dimension)", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/conversion.hh", 521, __PRETTY_FUNCTION__));
        ((i < instance().dune2generic_[ topologyId ][ codim ].size()) ? static_cast<void> (0) : __assert_fail ("i < instance().dune2generic_[ topologyId ][ codim ].size()", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/conversion.hh", 522, __PRETTY_FUNCTION__));
        return instance().generic2dune_[ topologyId ][ codim ][ i ];
      }

      template< unsigned int codim >
      static unsigned int
      generic2dune ( unsigned int topologyId, unsigned int i )
      {
        return generic2dune( topologyId, i, codim );
      }
    };


    template< unsigned int dim >
    template< int topologyId >
    struct MapNumberingProvider< dim >::Builder
    {
      typedef typename GenericGeometry::Topology< topologyId, dimension >::type Topology;
      typedef GenericGeometry::MapNumbering< Topology > MapNumbering;

      template< int codim >
      struct Codim;

      static void apply ( Map (&dune2generic)[ numTopologies ][ dimension+1 ],
                          Map (&generic2dune)[ numTopologies ][ dimension+1 ] )
      {
        ForLoop< Codim, 0, dimension >::apply( dune2generic[ topologyId ], generic2dune[ topologyId ] );
      }
    };

    template< unsigned int dim >
    template< int i >
    template< int codim >
    struct MapNumberingProvider< dim >::Builder< i >::Codim
    {
      static void apply ( Map (&dune2generic)[ dimension+1 ],
                          Map (&generic2dune)[ dimension+1 ] )
      {
        const unsigned int size = Size< Topology, codim >::value;

        Map &d2g = dune2generic[ codim ];
        d2g.resize( size );
        for( unsigned int j = 0; j < size; ++j )
          d2g[ j ] = MapNumbering::template dune2generic< codim >( j );

        Map &g2d = generic2dune[ codim ];
        g2d.resize( size );
        for( unsigned int j = 0; j < size; ++j )
          g2d[ j ] = MapNumbering::template generic2dune< codim >( j );
      }
    };






    template< GeometryType :: BasicType type, unsigned int dim >
    struct Convert;

    template< unsigned int dim >
    struct Convert< GeometryType :: simplex, dim >
    {
      typedef Pyramid
        < typename Convert< GeometryType :: simplex, dim-1 > :: type >
        type;

      template< unsigned int codim >
      static unsigned int map ( unsigned int i )
      {
        return MapNumbering<type>::template dune2generic<codim>(i);
      }
    };

    template<>
    struct Convert< GeometryType :: simplex, 0 >
    {
      typedef Point type;

      template< unsigned int codim >
      static unsigned int map ( unsigned int i )
      {
        return MapNumbering<type>::template dune2generic<codim>(i);
      }
    };

    template< unsigned int dim >
    struct Convert< GeometryType :: cube, dim >
    {
      typedef Prism< typename Convert< GeometryType :: cube, dim-1 > :: type >
        type;

      template< unsigned int codim >
      static unsigned int map ( unsigned int i )
      {
        return MapNumbering<type>::template dune2generic<codim>(i);
      }
    };

    template<>
    struct Convert< GeometryType :: cube, 0 >
    {
      typedef Point type;

      template< unsigned int codim >
      static unsigned int map ( unsigned int i )
      {
        return MapNumbering<type>::template dune2generic<codim>(i);
      }
    };

    template< unsigned int dim >
    struct Convert< GeometryType :: prism, dim >
    {
      typedef Prism
        < typename Convert< GeometryType :: simplex, dim-1 > :: type >
        type;

      template< unsigned int codim >
      static unsigned int map ( unsigned int i )
      {
        return MapNumbering<type>::template dune2generic<codim>(i);
      }

    private:

    };

    template< unsigned int dim >
    struct Convert< GeometryType :: pyramid, dim >
    {
      typedef Pyramid
        < typename Convert< GeometryType :: cube, dim-1 > :: type >
        type;



      template< unsigned int codim >
      static unsigned int map ( unsigned int i )
      {
        return MapNumbering<type>::template dune2generic<codim>(i);
      }

    private:

    };
# 683 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/conversion.hh"
    inline unsigned int topologyId ( const GeometryType &type ) __attribute__((deprecated));
    inline unsigned int topologyId ( const GeometryType &type )
    {
      return type.id();
    }






    inline bool
    hasGeometryType ( const unsigned int topologyId, const unsigned int dimension ) __attribute__((deprecated));
    inline bool
    hasGeometryType ( const unsigned int topologyId, const unsigned int dimension )
    {
      return true;
    }
# 709 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/conversion.hh"
    inline GeometryType
    geometryType ( const unsigned int topologyId, const unsigned int dimension ) __attribute__((deprecated));
    inline GeometryType
    geometryType ( const unsigned int topologyId, const unsigned int dimension )
    {
      return GeometryType( topologyId, dimension );
    }

  }

}
# 13 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh" 2
# 1 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/hybridmapping.hh" 1








# 1 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/geometrytraits.hh" 1





# 1 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/matrixhelper.hh" 1







namespace Dune
{

  namespace GenericGeometry
  {

    template< class Traits >
    struct MatrixHelper
    {
      typedef typename Traits :: ctype FieldType;

      template< int m, int n >
      static void
      Ax ( const typename Traits :: template Matrix< m, n > :: type &A,
           const typename Traits :: template Vector< n > :: type &x,
           typename Traits :: template Vector< m > :: type &ret )
      {
        for( int i = 0; i < m; ++i )
        {
          ret[ i ] = FieldType( 0 );
          for( int j = 0; j < n; ++j )
            ret[ i ] += A[ i ][ j ] * x[ j ];
        }
      }

      template< int m, int n >
      static void
      ATx ( const typename Traits :: template Matrix< m, n > :: type &A,
            const typename Traits :: template Vector< m > :: type &x,
            typename Traits :: template Vector< n > :: type &ret )
      {
        for( int i = 0; i < n; ++i )
        {
          ret[ i ] = FieldType( 0 );
          for( int j = 0; j < m; ++j )
            ret[ i ] += A[ j ][ i ] * x[ j ];
        }
      }

      template< int m, int n, int p >
      static void
      AB ( const typename Traits :: template Matrix< m, n > :: type &A,
           const typename Traits :: template Matrix< n, p > :: type &B,
           typename Traits :: template Matrix< m, p > :: type &ret )
      {
        for( int i = 0; i < m; ++i )
        {
          for( int j = 0; j < p; ++j )
          {
            ret[ i ][ j ] = FieldType( 0 );
            for( int k = 0; k < n; ++k )
              ret[ i ][ j ] += A[ i ][ k ] * B[ k ][ j ];
          }
        }
      }

      template< int m, int n, int p >
      static void
      ATBT ( const typename Traits :: template Matrix< m, n > :: type &A,
             const typename Traits :: template Matrix< p, m > :: type &B,
             typename Traits :: template Matrix< n, p > :: type &ret )
      {
        for( int i = 0; i < n; ++i )
        {
          for( int j = 0; j < p; ++j )
          {
            ret[ i ][ j ] = FieldType( 0 );
            for( int k = 0; k < m; ++k )
              ret[ i ][ j ] += A[ k ][ i ] * B[ j ][ k ];
          }
        }
      }

      template< int m, int n >
      static void
      ATA_L ( const typename Traits :: template Matrix< m, n > :: type &A,
              typename Traits :: template Matrix< n, n > :: type &ret )
      {
        for( int i = 0; i < n; ++i )
        {
          for( int j = 0; j <= i; ++j )
          {
            ret[ i ][ j ] = FieldType( 0 );
            for( int k = 0; k < m; ++k )
              ret[ i ][ j ] += A[ k ][ i ] * A[ k ][ j ];
          }
        }
      }

      template< int m, int n >
      static void
      ATA ( const typename Traits :: template Matrix< m, n > :: type &A,
            typename Traits :: template Matrix< n, n > :: type &ret )
      {
        for( int i = 0; i < n; ++i )
        {
          for( int j = 0; j <= i; ++j )
          {
            ret[ i ][ j ] = FieldType( 0 );
            for( int k = 0; k < m; ++k )
              ret[ i ][ j ] += A[ k ][ i ] * A[ k ][ j ];
            ret[ j ][ i ] = ret[ i ][ j ];
          }

          ret[ i ][ i ] = FieldType( 0 );
          for( int k = 0; k < m; ++k )
            ret[ i ][ i ] += A[ k ][ i ] * A[ k ][ i ];
        }
      }

      template< int m, int n >
      static void
      AAT_L ( const typename Traits :: template Matrix< m, n > :: type &A,
              typename Traits :: template Matrix< m, m > :: type &ret )
      {
# 131 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/matrixhelper.hh"
        for( int i = 0; i < m; ++i )
        {
          for( int j = 0; j <= i; ++j )
          {
            FieldType &retij = ret[ i ][ j ];
            retij = A[ i ][ 0 ] * A[ j ][ 0 ];
            for( int k = 1; k < n; ++k )
              retij += A[ i ][ k ] * A[ j ][ k ];
          }
        }
      }

      template< int m, int n >
      static void
      AAT ( const typename Traits :: template Matrix< m, n > :: type &A,
            typename Traits :: template Matrix< m, m > :: type &ret )
      {
        for( int i = 0; i < m; ++i )
        {
          for( int j = 0; j < i; ++j )
          {
            ret[ i ][ j ] = FieldType( 0 );
            for( int k = 0; k < n; ++k )
              ret[ i ][ j ] += A[ i ][ k ] * A[ j ][ k ];
            ret[ j ][ i ] = ret[ i ][ j ];
          }
          ret[ i ][ i ] = FieldType( 0 );
          for( int k = 0; k < n; ++k )
            ret[ i ][ i ] += A[ i ][ k ] * A[ i ][ k ];
        }
      }

      template< int n >
      static void
      Lx ( const typename Traits :: template Matrix< n, n > :: type &L,
           const typename Traits :: template Vector< n > :: type &x,
           typename Traits :: template Vector< n > :: type &ret )
      {
        for( int i = 0; i < n; ++i )
        {
          ret[ i ] = FieldType( 0 );
          for( int j = 0; j <= i; ++j )
            ret[ i ] += L[ i ][ j ] * x[ j ];
        }
      }

      template< int n >
      static void
      LTx ( const typename Traits :: template Matrix< n, n > :: type &L,
            const typename Traits :: template Vector< n > :: type &x,
            typename Traits :: template Vector< n > :: type &ret )
      {
        for( int i = 0; i < n; ++i )
        {
          ret[ i ] = FieldType( 0 );
          for( int j = i; j < n; ++j )
            ret[ i ] += L[ j ][ i ] * x[ j ];
        }
      }

      template< int n >
      static void
      LTL ( const typename Traits :: template Matrix< n, n > :: type &L,
            typename Traits :: template Matrix< n, n > :: type &ret )
      {
        for( int i = 0; i < n; ++i )
        {
          for( int j = 0; j < i; ++j )
          {
            ret[ i ][ j ] = FieldType( 0 );
            for( int k = i; k < n; ++k )
              ret[ i ][ j ] += L[ k ][ i ] * L[ k ][ j ];
            ret[ j ][ i ] = ret[ i ][ j ];
          }
          ret[ i ][ i ] = FieldType( 0 );
          for( int k = i; k < n; ++k )
            ret[ i ][ i ] += L[ k ][ i ] * L[ k ][ i ];
        }
      }

      template< int n >
      static void
      LLT ( const typename Traits :: template Matrix< n, n > :: type &L,
            typename Traits :: template Matrix< n, n > :: type &ret )
      {
        for( int i = 0; i < n; ++i )
        {
          for( int j = 0; j < i; ++j )
          {
            ret[ i ][ j ] = FieldType( 0 );
            for( int k = 0; k <= j; ++k )
              ret[ i ][ j ] += L[ i ][ k ] * L[ j ][ k ];
            ret[ j ][ i ] = ret[ i ][ j ];
          }
          ret[ i ][ i ] = FieldType( 0 );
          for( int k = 0; k <= i; ++k )
            ret[ i ][ i ] += L[ i ][ k ] * L[ i ][ k ];
        }
      }

      template< int n >
      static void
      cholesky_L ( const typename Traits :: template Matrix< n, n > :: type &A,
                   typename Traits :: template Matrix< n, n > :: type &ret )
      {
        for( int i = 0; i < n; ++i )
        {
          FieldType &rii = ret[ i ][ i ];

          FieldType x = A[ i ][ i ];
          for( int j = 0; j < i; ++j )
            x -= ret[ i ][ j ] * ret[ i ][ j ];
          ((x > FieldType( 0 )) ? static_cast<void> (0) : __assert_fail ("x > FieldType( 0 )", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/matrixhelper.hh", 243, __PRETTY_FUNCTION__));
          rii = sqrt( x );

          FieldType invrii = FieldType( 1 ) / rii;
          for( int k = i+1; k < n; ++k )
          {
            FieldType x = A[ k ][ i ];
            for( int j = 0; j < i; ++j )
              x -= ret[ i ][ j ] * ret[ k ][ j ];
            ret[ k ][ i ] = invrii * x;
          }
        }
      }

      template< int n >
      static FieldType
      detL ( const typename Traits :: template Matrix< n, n > :: type &L )
      {
        FieldType det = FieldType( 1 );
        for( int i = 0; i < n; ++i )
          det *= L[ i ][ i ];
        return det;
      }

      template< int n >
      static FieldType
      invL ( typename Traits :: template Matrix< n, n > :: type &L )
      {
        FieldType det = FieldType( 1 );
        for( int i = 0; i < n; ++i )
        {
          FieldType &lii = L[ i ][ i ];
          det *= lii;
          lii = FieldType( 1 ) / lii;
          for( int j = 0; j < i; ++j )
          {
            FieldType &lij = L[ i ][ j ];
            FieldType x = lij * L[ j ][ j ];
            for( int k = j+1; k < i; ++k )
              x += L[ i ][ k ] * L[ k ][ j ];
            lij = (-lii) * x;
          }
        }
        return det;
      }


      template< int n >
      static void
      invLx ( typename Traits :: template Matrix< n, n > :: type &L,
              typename Traits :: template Vector< n > :: type &x )
      {
        for( int i = 0; i < n; ++i )
        {
          for( int j = 0; j < i; ++j )
            x[ i ] -= L[ i ][ j ] * x[ j ];
          x[ i ] /= L[ i ][ i ];
        }
      }


      template< int n >
      static void
      invLTx ( typename Traits :: template Matrix< n, n > :: type &L,
               typename Traits :: template Vector< n > :: type &x )
      {
        for( int i = n; i > 0; --i )
        {
          for( int j = i; j < n; ++j )
            x[ i-1 ] -= L[ j ][ i-1 ] * x[ j ];
          x[ i-1 ] /= L[ i-1 ][ i-1 ];
        }
      }

      template< int n >
      static FieldType
      spdDetA ( const typename Traits :: template Matrix< n, n > :: type &A )
      {

        typename Traits :: template Matrix< n, n > :: type L;
        cholesky_L< n >( A, L );
        return detL< n >( L );
      }

      template< int n >
      static FieldType
      spdInvA ( typename Traits :: template Matrix< n, n > :: type &A )
      {
        typename Traits :: template Matrix< n, n > :: type L;
        cholesky_L< n >( A, L );
        const FieldType det = invL< n >( L );
        LTL< n >( L, A );
        return det;
      }


      template< int n >
      static void
      spdInvAx ( typename Traits :: template Matrix< n, n > :: type &A,
                 typename Traits :: template Vector< n > :: type &x )
      {
        typename Traits :: template Matrix< n, n > :: type L;
        cholesky_L< n >( A, L );
        invLx< n >( L, x );
        invLTx< n >( L, x );
      }

      template< int m, int n >
      static FieldType
      detATA ( const typename Traits :: template Matrix< m, n > :: type &A )
      {
        if( m >= n )
        {
          typename Traits :: template Matrix< n, n > :: type ata;
          ATA_L< m, n >( A, ata );
          return spdDetA< n >( ata );
        }
        else
          return FieldType( 0 );
      }






      template< int m, int n >
      static FieldType
      sqrtDetAAT ( const typename Traits::template Matrix< m, n >::type &A )
      {
        if( (n == 2) && (m == 2) )
        {

          return std::abs( A[ 0 ][ 0 ]*A[ 1 ][ 1 ] - A[ 1 ][ 0 ]*A[ 0 ][ 1 ] );
        }
        else if( (n == 3) && (m == 3) )
        {

          const FieldType v0 = A[ 0 ][ 1 ] * A[ 1 ][ 2 ] - A[ 1 ][ 1 ] * A[ 0 ][ 2 ];
          const FieldType v1 = A[ 0 ][ 2 ] * A[ 1 ][ 0 ] - A[ 1 ][ 2 ] * A[ 0 ][ 0 ];
          const FieldType v2 = A[ 0 ][ 0 ] * A[ 1 ][ 1 ] - A[ 1 ][ 0 ] * A[ 0 ][ 1 ];
          return std::abs( v0 * A[ 2 ][ 0 ] + v1 * A[ 2 ][ 1 ] + v2 * A[ 2 ][ 2 ] );
        }
        else if( n >= m )
        {

          typename Traits::template Matrix< m, m >::type aat;
          AAT_L< m, n >( A, aat );
          return spdDetA< m >( aat );
        }
        else
          return FieldType( 0 );
      }



      template< int m, int n >
      static FieldType
      leftInvA ( const typename Traits :: template Matrix< m, n > :: type &A,
                 typename Traits :: template Matrix< n, m > :: type &ret )
      {
        typedef static_assert_test< sizeof(static_assert_failure< (bool)( (m >= n) )>) > dune_static_assert_typedef_404;
        typename Traits :: template Matrix< n, n > :: type ata;
        ATA_L< m, n >( A, ata );
        const FieldType det = spdInvA< n >( ata );
        ATBT< n, n, m >( ata, A, ret );
        return det;
      }

      template< int m, int n >
      static void
      leftInvAx ( const typename Traits :: template Matrix< m, n > :: type &A,
                  const typename Traits :: template Vector< m > :: type &x,
                  typename Traits :: template Vector< n > :: type &y )
      {
        typedef static_assert_test< sizeof(static_assert_failure< (bool)( (m >= n) )>) > dune_static_assert_typedef_418;
        typename Traits :: template Matrix< n, n > :: type ata;
        ATx< m, n >( A, x, y );
        ATA_L< m, n >( A, ata );
        spdInvAx< n >( ata, y );
      }



      template< int m, int n >
      static FieldType
      rightInvA ( const typename Traits :: template Matrix< m, n > :: type &A,
                  typename Traits :: template Matrix< n, m > :: type &ret )
      {
        typedef static_assert_test< sizeof(static_assert_failure< (bool)( (n >= m) )>) > dune_static_assert_typedef_432;
        if( (n == 2) && (m == 2) )
        {
          const FieldType det = (A[ 0 ][ 0 ]*A[ 1 ][ 1 ] - A[ 1 ][ 0 ]*A[ 0 ][ 1 ]);
          const FieldType detInv = FieldType( 1 ) / det;
          ret[ 0 ][ 0 ] = A[ 1 ][ 1 ] * detInv;
          ret[ 1 ][ 1 ] = A[ 0 ][ 0 ] * detInv;
          ret[ 1 ][ 0 ] = -A[ 1 ][ 0 ] * detInv;
          ret[ 0 ][ 1 ] = -A[ 0 ][ 1 ] * detInv;
          return std::abs( det );
        }
        else
        {
          typename Traits :: template Matrix< m , m > :: type aat;
          AAT_L< m, n >( A, aat );
          const FieldType det = spdInvA< m >( aat );
          ATBT< m, n, m >( A , aat , ret );
          return det;
        }
      }

      template< int m, int n >
      static void
      xTRightInvA ( const typename Traits :: template Matrix< m, n > :: type &A,
                    const typename Traits :: template Vector< n > :: type &x,
                    typename Traits :: template Vector< m > :: type &y )
      {
        typedef static_assert_test< sizeof(static_assert_failure< (bool)( (n >= m) )>) > dune_static_assert_typedef_459;
        typename Traits :: template Matrix< m, m > :: type aat;
        Ax< m, n >( A, x, y );
        AAT_L< m, n >( A, aat );
        spdInvAx< m >( aat, y );
      }
    };

  }

}
# 7 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/geometrytraits.hh" 2
# 1 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/cornermapping.hh" 1




# 1 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/referenceelements.hh" 1
# 13 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/referenceelements.hh"
namespace Dune
{

  namespace GenericGeometry
  {




    template< class Topology, class ctype >
    struct ReferenceElement
    {
      static const unsigned int topologyId = Topology :: id;
      static const unsigned int dimension = Topology :: dimension;

      static const unsigned int numCorners = Topology :: numCorners;
      static const unsigned int numNormals = ReferenceDomain< Topology > :: numNormals;

      typedef FieldVector< ctype, dimension > CoordinateType;

      template< unsigned int codim >
      struct Codim
      {
        enum { size = Size< Topology, codim > :: value };
      };

      template< unsigned int codim, unsigned int subcodim >
      static unsigned int subNumbering ( unsigned int i, unsigned int j )
      {
        return SubTopologyNumbering< Topology, codim, subcodim > :: number( i, j );
      }

      template< unsigned int codim, unsigned int subcodim >
      static unsigned int size ( unsigned int i )
      {
        return SubTopologySize< Topology, codim, subcodim > :: size( i );
      }

      template< unsigned int codim >
      static const FieldVector< ctype, dimension > &
      baryCenter ( unsigned int i )
      {
        integral_constant< int, codim > codimVariable;
        return instance().baryCenters_[ codimVariable ][ i ];
      }

      static const CoordinateType &corner ( unsigned int i )
      {
        ((i < numCorners) ? static_cast<void> (0) : __assert_fail ("i < numCorners", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/referenceelements.hh", 61, __PRETTY_FUNCTION__));
        return instance().corners_[ i ];
      }

      static bool checkInside ( const CoordinateType &x )
      {
        return ReferenceDomain< Topology >::checkInside( x );
      }

      static const CoordinateType &
      integrationOuterNormal ( unsigned int i )
      {
        ((i < numNormals) ? static_cast<void> (0) : __assert_fail ("i < numNormals", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/referenceelements.hh", 73, __PRETTY_FUNCTION__));
        return instance().normals_[ i ];
      }

      static ctype volume ()
      {
        return ReferenceDomain< Topology > :: template volume< ctype >();
      }

      static const ReferenceElement &instance ()
      {
        static ReferenceElement inst;
        return inst;
      }

    private:
      template< int codim >
      class BaryCenterArray;

      ReferenceElement ()
      {
        for( unsigned int i = 0; i < numCorners; ++i )
          ReferenceDomain< Topology > :: corner( i, corners_[ i ] );
        for( unsigned int i = 0; i < numNormals; ++i )
          ReferenceDomain< Topology > :: integrationOuterNormal( i, normals_[ i ] );
      }

      Dune::array< CoordinateType, numCorners > corners_;
      CodimTable< BaryCenterArray, dimension > baryCenters_;
      Dune::array< CoordinateType, numNormals > normals_;
    };



    template< class Topology, class ctype >
    template< int codim >
    class ReferenceElement< Topology, ctype > :: BaryCenterArray
    {
      enum { Size = GenericGeometry :: Size< Topology, codim > :: value };

      typedef FieldVector< ctype, dimension > CoordinateType;

      template< int i >
      struct Builder;

      CoordinateType baryCenters_[ Size ];

    public:
      BaryCenterArray ()
      {
        ForLoop< Builder, 0, Size-1 > :: apply( baryCenters_ );
      }

      const CoordinateType &operator[] ( unsigned int i ) const
      {
        ((i < Size) ? static_cast<void> (0) : __assert_fail ("i < Size", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/referenceelements.hh", 128, __PRETTY_FUNCTION__));
        return baryCenters_[ i ];
      }

      static unsigned int size ()
      {
        return Size;
      }
    };

    template< class Topology, class ctype >
    template< int codim >
    template< int i >
    struct ReferenceElement< Topology, ctype > :: BaryCenterArray< codim > :: Builder
    {
      static void apply ( CoordinateType (&baryCenters)[ Size ] )
      {
        typedef SubTopologyNumbering< Topology, codim, dimension - codim > Numbering;
        typedef SubTopologySize< Topology, codim, dimension - codim > Size;

        CoordinateType &x = baryCenters[ i ];
        x = 0;
        const unsigned int numCorners = Size :: size( i );
        for( unsigned int k = 0; k < numCorners; ++k )
        {
          unsigned int j = Numbering :: number( i, k );

          CoordinateType y;
          ReferenceDomain< Topology > :: corner( j, y );
          x += y;
        }
        x *= ctype( 1 ) / ctype( numCorners );
      }
    };

  }

}
# 6 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/cornermapping.hh" 2


namespace Dune
{

  namespace GenericGeometry
  {




    template< class CT, unsigned int dim, unsigned int dimW >
    struct MappingTraits;







    template< class Topology, class Traits, bool affine, unsigned int offset = 0 >
    class GenericCornerMapping;

    template< class Traits, bool affine, unsigned int offset >
    class GenericCornerMapping < Point, Traits, affine, offset >
    {
      typedef Point Topology;

    public:
      static const unsigned int dim = Topology :: dimension;
      static const unsigned int dimW = Traits :: dimWorld;

      typedef typename Traits :: FieldType FieldType;
      typedef typename Traits :: LocalCoordinate LocalCoordinate;
      typedef typename Traits :: GlobalCoordinate GlobalCoordinate;
      typedef typename Traits :: JacobianTransposedType JacobianTransposedType;

      static const bool alwaysAffine = true;

      template< class CoordStorage >
      static const GlobalCoordinate &origin ( const CoordStorage &coords )
      {
        typedef static_assert_test< sizeof(static_assert_failure< (bool)( CoordStorage :: size )>) > dune_static_assert_typedef_48;
        return coords[ offset ];
      }

      template< class CoordStorage >
      static void phi_set ( const CoordStorage &coords,
                            const LocalCoordinate &x,
                            const FieldType &factor,
                            GlobalCoordinate &p )
      {
        const GlobalCoordinate &y = origin( coords );
        for( unsigned int i = 0; i < dimW; ++i )
          p[ i ] = factor * y[ i ];
      }

      template< class CoordStorage >
      static void phi_add ( const CoordStorage &coords,
                            const LocalCoordinate &x,
                            const FieldType &factor,
                            GlobalCoordinate &p )
      {
        const GlobalCoordinate &y = origin( coords );
        for( unsigned int i = 0; i < dimW; ++i )
          p[ i ] += factor * y[ i ];
      }

      template< class CoordStorage >
      static bool Dphi_set ( const CoordStorage &coords,
                             const LocalCoordinate &x,
                             const FieldType &factor,
                             JacobianTransposedType &J )
      {
        return true;
      }

      template< class CoordStorage >
      static bool Dphi_add ( const CoordStorage &coords,
                             const LocalCoordinate &x,
                             const FieldType &factor,
                             JacobianTransposedType &J )
      {
        return true;
      }
    };


    template< class BaseTopology, class Traits, bool affine, unsigned int offset >
    class GenericCornerMapping< Prism< BaseTopology >, Traits, affine, offset >
    {
      typedef Prism< BaseTopology > Topology;

      typedef GenericCornerMapping< BaseTopology, Traits, affine, offset >
        BottomMapping;
      typedef GenericCornerMapping
        < BaseTopology, Traits, affine, offset + BaseTopology :: numCorners >
        TopMapping;

    public:
      static const unsigned int dim = Topology :: dimension;
      static const unsigned int dimW = Traits :: dimWorld;

      typedef typename Traits :: FieldType FieldType;
      typedef typename Traits :: LocalCoordinate LocalCoordinate;
      typedef typename Traits :: GlobalCoordinate GlobalCoordinate;
      typedef typename Traits :: JacobianTransposedType JacobianTransposedType;

      static const bool alwaysAffine = ((dim < 2) || affine);

      template< class CoordStorage >
      static const GlobalCoordinate &origin ( const CoordStorage &coords )
      {
        return BottomMapping :: origin( coords );
      }

      template< class CoordStorage >
      static void phi_set ( const CoordStorage &coords,
                            const LocalCoordinate &x,
                            const FieldType &factor,
                            GlobalCoordinate &p )
      {
        const FieldType xn = x[ dim-1 ];
        const FieldType cxn = FieldType( 1 ) - xn;
        BottomMapping :: phi_set( coords, x, factor * cxn, p );
        TopMapping :: phi_add( coords, x, factor * xn, p );
      }

      template< class CoordStorage >
      static void phi_add ( const CoordStorage &coords,
                            const LocalCoordinate &x,
                            const FieldType &factor,
                            GlobalCoordinate &p )
      {
        const FieldType xn = x[ dim-1 ];
        const FieldType cxn = FieldType( 1 ) - xn;
        BottomMapping :: phi_add( coords, x, factor * cxn, p );
        TopMapping :: phi_add( coords, x, factor * xn, p );
      }

      template< class CoordStorage >
      static bool Dphi_set ( const CoordStorage &coords,
                             const LocalCoordinate &x,
                             const FieldType &factor,
                             JacobianTransposedType &J )
      {
        const FieldType xn = x[ dim-1 ];
        bool isAffine = true;
        if( alwaysAffine )
        {
          const FieldType cxn = FieldType( 1 ) - xn;
          BottomMapping :: Dphi_set( coords, x, factor * cxn, J );
          TopMapping :: Dphi_add( coords, x, factor * xn, J );
        }
        else
        {
          JacobianTransposedType Jtop;
          isAffine &= BottomMapping :: Dphi_set( coords, x, factor, J );
          isAffine &= TopMapping :: Dphi_set( coords, x, factor, Jtop );

          FieldType norm = FieldType( 0 );
          for( unsigned int i = 0; i < dim-1; ++i )
          {
            Jtop[ i ] -= J[ i ];
            norm += Jtop[ i ].two_norm2();
            J[ i ].axpy( xn, Jtop[ i ] );
          }
          isAffine &= (norm < 1e-12);
        }
        BottomMapping :: phi_set( coords, x, -factor, J[ dim-1 ] );
        TopMapping :: phi_add( coords, x, factor, J[ dim-1 ] );
        return isAffine;
      }

      template< class CoordStorage >
      static bool Dphi_add ( const CoordStorage &coords,
                             const LocalCoordinate &x,
                             const FieldType &factor,
                             JacobianTransposedType &J )
      {
        const FieldType xn = x[ dim-1 ];
        bool isAffine = true;
        if( alwaysAffine )
        {
          const FieldType cxn = FieldType( 1 ) - xn;
          BottomMapping :: Dphi_add( coords, x, factor * cxn, J );
          TopMapping :: Dphi_add( coords, x, factor * xn, J );
        }
        else
        {
          JacobianTransposedType Jbottom, Jtop;
          isAffine &= BottomMapping :: Dphi_set( coords, x, FieldType( 1 ), Jbottom );
          isAffine &= TopMapping :: Dphi_set( coords, x, FieldType( 1 ), Jtop );

          FieldType norm = FieldType( 0 );
          for( unsigned int i = 0; i < dim-1; ++i )
          {
            Jtop[ i ] -= Jbottom[ i ];
            norm += Jtop[ i ].two_norm2();
            J[ i ].axpy( factor, Jbottom[ i ] );
            J[ i ].axpy( factor*xn, Jtop[ i ] );
          }
          isAffine &= (norm < 1e-12);
        }
        BottomMapping :: phi_add( coords, x, -factor, J[ dim-1 ] );
        TopMapping :: phi_add( coords, x, factor, J[ dim-1 ] );
        return isAffine;
      }
    };


    template< class BaseTopology, class Traits, bool affine, unsigned int offset >
    class GenericCornerMapping < Pyramid< BaseTopology >, Traits, affine, offset >
    {
      typedef Pyramid< BaseTopology > Topology;

      typedef GenericCornerMapping< BaseTopology, Traits, affine, offset >
        BottomMapping;
      typedef GenericCornerMapping
        < Point, Traits, affine, offset + BaseTopology :: numCorners >
        TopMapping;

    public:
      static const unsigned int dim = Topology :: dimension;
      static const unsigned int dimW = Traits :: dimWorld;

      typedef typename Traits :: FieldType FieldType;
      typedef typename Traits :: LocalCoordinate LocalCoordinate;
      typedef typename Traits :: GlobalCoordinate GlobalCoordinate;
      typedef typename Traits :: JacobianTransposedType JacobianTransposedType;

      static const bool alwaysAffine = (BottomMapping :: alwaysAffine || affine);

      template< class CoordStorage >
      static const GlobalCoordinate &origin ( const CoordStorage &coords )
      {
        return BottomMapping :: origin( coords );
      }

      template< class CoordStorage >
      static void phi_set ( const CoordStorage &coords,
                            const LocalCoordinate &x,
                            const FieldType &factor,
                            GlobalCoordinate &p )
      {
        const FieldType xn = x[ dim-1 ];
        if( alwaysAffine )
        {
          const GlobalCoordinate &top = TopMapping :: origin( coords );
          const GlobalCoordinate &bottom = BottomMapping :: origin( coords );

          BottomMapping :: phi_set( coords, x, factor, p );
          for( unsigned int i = 0; i < dimW; ++i )
            p[ i ] += (factor * xn) * (top[ i ] - bottom[ i ]);
        }
        else
        {
          TopMapping :: phi_set( coords, x, factor * xn, p );
          const FieldType cxn = FieldType( 1 ) - xn;
          if( cxn > 1e-12 )
          {
            const FieldType icxn = FieldType( 1 ) / cxn;
            LocalCoordinate xb;
            for( unsigned int i = 0; i < dim-1; ++i )
              xb[ i ] = icxn * x[ i ];

            BottomMapping :: phi_add( coords, xb, factor * cxn, p );
          }
        }
      }

      template< class CoordStorage >
      static void phi_add ( const CoordStorage &coords,
                            const LocalCoordinate &x,
                            const FieldType &factor,
                            GlobalCoordinate &p )
      {
        const FieldType xn = x[ dim-1 ];
        if( alwaysAffine )
        {
          const GlobalCoordinate &top = TopMapping :: origin( coords );
          const GlobalCoordinate &bottom = BottomMapping :: origin( coords );

          BottomMapping :: phi_add( coords, x, factor, p );
          for( unsigned int i = 0; i < dimW; ++i )
            p[ i ] += (factor * xn) * (top[ i ] - bottom[ i ]);
        }
        else
        {
          TopMapping :: phi_add( coords, x, factor * xn, p );
          const FieldType cxn = FieldType( 1 ) - xn;
          if( cxn > 1e-12 )
          {
            const FieldType icxn = FieldType( 1 ) / cxn;
            LocalCoordinate xb;
            for( unsigned int i = 0; i < dim-1; ++i )
              xb[ i ] = icxn * x[ i ];

            BottomMapping :: phi_add( coords, xb, factor * cxn, p );
          }
        }
      }

      template< class CoordStorage >
      static bool Dphi_set ( const CoordStorage &coords,
                             const LocalCoordinate &x,
                             const FieldType &factor,
                             JacobianTransposedType &J )
      {
        GlobalCoordinate &q = J[ dim-1 ];
        bool isAffine;
        if( alwaysAffine )
        {
          const GlobalCoordinate &top = TopMapping :: origin( coords );
          const GlobalCoordinate &bottom = BottomMapping :: origin( coords );

          isAffine = BottomMapping :: Dphi_set( coords, x, factor, J );
          for( unsigned int i = 0; i < dimW; ++i )
            q[ i ] = factor * (top[ i ] - bottom[ i ]);
        }
        else
        {
          const FieldType xn = x[ dim-1 ];
          const FieldType cxn = FieldType( 1 ) - xn;
          const FieldType icxn = FieldType( 1 ) / cxn;
          LocalCoordinate xb;
          for( unsigned int i = 0; i < dim-1; ++i )
            xb[ i ] = icxn * x[ i ];
          isAffine = BottomMapping :: Dphi_set( coords, xb, factor, J );

          TopMapping :: phi_set( coords, x, factor, q );
          BottomMapping :: phi_add( coords, xb, -factor, q );
          xb *= factor;
          for( unsigned int j = 0; j < dim-1; ++j )
          {
            for( unsigned int i = 0; i < dimW; ++i )
              q[ i ] += J[ j ][ i ] * xb[ j ];
          }
        }
        return isAffine;
      }

      template< class CoordStorage >
      static bool Dphi_add ( const CoordStorage &coords,
                             const LocalCoordinate &x,
                             const FieldType &factor,
                             JacobianTransposedType &J )
      {
        GlobalCoordinate &q = J[ dim-1 ];
        bool isAffine;
        if( alwaysAffine )
        {
          const GlobalCoordinate &top = TopMapping :: origin( coords );
          const GlobalCoordinate &bottom = BottomMapping :: origin( coords );

          isAffine = BottomMapping :: Dphi_add( coords, x, factor, J );
          for( unsigned int i = 0; i < dimW; ++i )
            q[ i ] += factor * (top[ i ] - bottom[ i ]);
        }
        else
        {
          const FieldType xn = x[ dim-1 ];
          const FieldType cxn = FieldType( 1 ) - xn;
          const FieldType icxn = FieldType( 1 ) / cxn;
          LocalCoordinate xb;
          for( unsigned int i = 0; i < dim-1; ++i )
            xb[ i ] = icxn * x[ i ];
          isAffine = BottomMapping :: Dphi_add( coords, xb, factor, J );

          TopMapping :: phi_add( coords, x, factor, q );
          BottomMapping :: phi_add( coords, xb, -factor, q );
          xb *= factor;
          for( unsigned int j = 0; j < dim-1; ++j )
          {
            for( unsigned int i = 0; i < dimW; ++i )
              q[ i ] += J[ j ][ i ] * xb[ j ];
          }
        }
        return isAffine;
      }
    };






    template< class Mapping, unsigned int codim >
    class SubMappingCoords
    {
      typedef typename Mapping :: GlobalCoordinate GlobalCoordinate;
      typedef typename Mapping :: ReferenceElement ReferenceElement;

      static const unsigned int dimension = ReferenceElement :: dimension;

      const Mapping &mapping_;
      const unsigned int i_;

    public:
      SubMappingCoords ( const Mapping &mapping, unsigned int i )
      : mapping_( mapping ), i_( i )
      {}

      const GlobalCoordinate &operator[] ( unsigned int j ) const
      {
        const unsigned int k
          = ReferenceElement :: template subNumbering< codim, dimension - codim >( i_, j );
        return mapping_.corner( k );
      }
    };
# 426 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/cornermapping.hh"
    template< class CoordTraits, class Topology, unsigned int dimW >
    class CoordStorage
    {
      typedef CoordStorage< CoordTraits, Topology, dimW > This;

    public:
      static const unsigned int size = Topology :: numCorners;

      static const unsigned int dimWorld = dimW;

      typedef typename CoordTraits :: template Vector< dimWorld > :: type
        GlobalCoordinate;

      template< class SubTopology >
      struct SubStorage
      {
        typedef CoordStorage< CoordTraits, SubTopology, dimWorld > type;
      };

    private:
      GlobalCoordinate coords_[ size ];

    public:
      template< class CoordVector >
      explicit CoordStorage ( const CoordVector &coords )
      {
        for( unsigned int i = 0; i < size; ++i )
          coords_[ i ] = coords[ i ];
      }

      const GlobalCoordinate &operator[] ( unsigned int i ) const
      {
        return coords_[ i ];
      }
    };
# 471 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/cornermapping.hh"
    template< class CoordTraits, class Topology, unsigned int dimW >
    class CoordPointerStorage
    {
      typedef CoordPointerStorage< CoordTraits, Topology, dimW > This;

    public:
      static const unsigned int size = Topology :: numCorners;

      static const unsigned int dimWorld = dimW;

      typedef typename CoordTraits :: template Vector< dimWorld > :: type
        GlobalCoordinate;

      template< class SubTopology >
      struct SubStorage
      {
        typedef CoordPointerStorage< CoordTraits, SubTopology, dimWorld > type;
      };

    private:
      const GlobalCoordinate *coords_[ size ];

    public:
      template< class CoordVector >
      explicit CoordPointerStorage ( const CoordVector &coords )
      {
        for( unsigned int i = 0; i < size; ++i )
          coords_[ i ] = &(coords[ i ]);
      }

      const GlobalCoordinate &operator[] ( unsigned int i ) const
      {
        return *(coords_[ i ]);
      }
    };
# 517 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/cornermapping.hh"
    template< class CoordTraits, class Topo, unsigned int dimW,
              class CStorage = CoordStorage< CoordTraits, Topo, dimW >,
              bool affine = false >
    class CornerMapping
    {
      typedef CornerMapping< CoordTraits, Topo, dimW, CStorage, affine > This;

    public:
      typedef Topo Topology;
      typedef CStorage CornerStorage;
      typedef MappingTraits< CoordTraits, Topology :: dimension, dimW > Traits;

      static const unsigned int dimension = Traits :: dimension;
      static const unsigned int dimWorld = Traits :: dimWorld;

      typedef typename Traits :: FieldType FieldType;
      typedef typename Traits :: LocalCoordinate LocalCoordinate;
      typedef typename Traits :: GlobalCoordinate GlobalCoordinate;
      typedef typename Traits :: JacobianType JacobianType;
      typedef typename Traits :: JacobianTransposedType JacobianTransposedType;

      typedef GenericGeometry :: ReferenceElement< Topology, FieldType > ReferenceElement;

      template< unsigned int codim, unsigned int i >
      struct SubTopology
      {
        typedef typename GenericGeometry :: SubTopology< Topo, codim, i > :: type Topology;
        typedef typename CStorage::template SubStorage< Topology >::type CornerStorage;
        typedef CornerMapping< CoordTraits, Topology, dimWorld, CornerStorage, affine > Trace;
      };

    private:
      typedef GenericGeometry :: GenericCornerMapping< Topology, Traits, affine > GenericMapping;

    public:
      static const bool alwaysAffine = GenericMapping :: alwaysAffine;

    protected:
      CornerStorage coords_;

    public:
      template< class CoordVector >
      explicit CornerMapping ( const CoordVector &coords )
      : coords_( coords )
      {}

      const GlobalCoordinate &corner ( int i ) const
      {
        return coords_[ i ];
      }

      void global ( const LocalCoordinate &x, GlobalCoordinate &y ) const
      {
        GenericMapping :: phi_set( coords_, x, FieldType( 1 ), y );
      }

      bool jacobianTransposed ( const LocalCoordinate &x,
                                JacobianTransposedType &JT ) const
      {
        return GenericMapping :: Dphi_set( coords_, x, FieldType( 1 ), JT );
      }

      template< unsigned int codim, unsigned int i >
      typename SubTopology< codim, i > :: Trace trace () const
      {
        typedef typename SubTopology< codim, i > :: Trace Trace;
        typedef SubMappingCoords< This, codim > CoordVector;
        return Trace( CoordVector( *this, i ) );
      }
    };

  }

}
# 8 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/geometrytraits.hh" 2

namespace Dune
{

  namespace GenericGeometry
  {




    template< class ct >
    struct DuneCoordTraits
    {
      typedef ct ctype;

      template< int dim >
      struct Vector
      {
        typedef FieldVector< ctype, dim > type;
      };

      template< int rows, int cols >
      struct Matrix
      {
        typedef FieldMatrix< ctype, rows, cols > type;
      };



      static const ctype epsilon ()
      {
        return 1e-6;
      }
    };
# 51 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/geometrytraits.hh"
    template< class CT, unsigned int dim, unsigned int dimW >
    struct MappingTraits
    {
      typedef CT CoordTraits;

      static const unsigned int dimension = dim;
      static const unsigned int dimWorld = dimW;

      typedef typename CoordTraits :: ctype FieldType;
      typedef typename CoordTraits :: template Vector< dimension > :: type LocalCoordinate;
      typedef typename CoordTraits :: template Vector< dimWorld > :: type GlobalCoordinate;

      typedef typename CoordTraits :: template Matrix< dimWorld, dimension > :: type
        JacobianType;
      typedef typename CoordTraits :: template Matrix< dimension, dimWorld > :: type
        JacobianTransposedType;

      typedef GenericGeometry :: MatrixHelper< CoordTraits > MatrixHelper;

      template< unsigned int codim >
      struct Codim
      {
        typedef GenericGeometry :: MappingTraits< CoordTraits, dimension - codim, dimWorld >
          MappingTraits;
      };
    };







    enum EvaluationType
    {

      ComputeOnDemand,

      PreCompute
    };
# 114 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/geometrytraits.hh"
    template< class ctype, int dimG, int dimW, bool alwaysAffine = false >
    struct DefaultGeometryTraits
    {

      typedef DuneCoordTraits< ctype > CoordTraits;


      static const int dimGrid = dimG;

      static const int dimWorld = dimW;
# 144 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/geometrytraits.hh"
      static const bool hybrid = true;
# 157 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/geometrytraits.hh"
      template< class Topology >
      struct Mapping
      {
        typedef CoordStorage< CoordTraits, Topology, dimWorld > CornerStorage;
        typedef CornerMapping< CoordTraits, Topology, dimWorld, CornerStorage, alwaysAffine > type;
      };
# 175 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/geometrytraits.hh"
      struct Caching
      {
        static const EvaluationType evaluateJacobianTransposed = ComputeOnDemand;
        static const EvaluationType evaluateJacobianInverseTransposed = ComputeOnDemand;
        static const EvaluationType evaluateIntegrationElement = ComputeOnDemand;
      };

    };
# 238 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/geometrytraits.hh"
    template< class Grid >
    struct GlobalGeometryTraits;

    template< class Grid >
    struct GlobalGeometryTraits< const Grid >
    : public GlobalGeometryTraits< Grid >
    {};
# 300 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/geometrytraits.hh"
    template< class Grid >
    struct LocalGeometryTraits;

    template< class Grid >
    struct LocalGeometryTraits< const Grid >
    : public LocalGeometryTraits< Grid >
    {};
  }

}
# 10 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/hybridmapping.hh" 2
# 1 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/cachedmapping.hh" 1






# 1 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/mapping.hh" 1








namespace Dune
{

  namespace GenericGeometry
  {
# 27 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/mapping.hh"
    template< class CoordTraits, class Topo, int dimW, class Impl >
    class Mapping
    {
      typedef Mapping< CoordTraits, Topo, dimW, Impl > This;

      typedef Impl Implementation;

    public:
      typedef Topo Topology;
      typedef MappingTraits< CoordTraits, Topology :: dimension, dimW > Traits;

      static const unsigned int dimension = Traits :: dimension;
      static const unsigned int dimWorld = Traits :: dimWorld;

      typedef typename Traits :: FieldType FieldType;
      typedef typename Traits :: LocalCoordinate LocalCoordinate;
      typedef typename Traits :: GlobalCoordinate GlobalCoordinate;
      typedef typename Traits :: JacobianType JacobianType;
      typedef typename Traits :: JacobianTransposedType JacobianTransposedType;

      typedef typename Traits :: MatrixHelper MatrixHelper;

      typedef GenericGeometry :: ReferenceElement< Topology, FieldType > ReferenceElement;

      template< unsigned int codim, unsigned int i >
      struct SubTopology
      {
        typedef typename GenericGeometry :: SubTopology< Topo, codim, i > :: type Topology;
        typedef typename Implementation :: template SubTopology< codim, i > :: Trace TraceImpl;
        typedef Mapping< CoordTraits, Topology, dimWorld, TraceImpl > Trace;
      };

      static const bool alwaysAffine = Implementation :: alwaysAffine;

    protected:
      Implementation impl_;

    public:
      template< class CoordVector >
      explicit Mapping ( const CoordVector &coords )
      : impl_( coords )
      {}

      Mapping ( const Implementation &implementation )
      : impl_( implementation )
      {}

      const GlobalCoordinate &corner ( int i ) const
      {
        return implementation().corner( i );
      }

      void global ( const LocalCoordinate &x, GlobalCoordinate &y ) const
      {
        implementation().global( x, y );
      }

      void local ( const GlobalCoordinate &y, LocalCoordinate &x ) const
      {
        const FieldType epsilon = CoordTraits::epsilon();
        x = ReferenceElement::template baryCenter< 0 >( 0 );
        LocalCoordinate dx;
        do
        {

          JacobianTransposedType JT;
          jacobianTransposed( x, JT );
          GlobalCoordinate z;
          global( x, z );
          z -= y;
          MatrixHelper::template xTRightInvA< dimension, dimWorld >( JT, z, dx );
          x -= dx;
        } while( dx.two_norm2() > epsilon*epsilon );
      }

      bool jacobianTransposed ( const LocalCoordinate &x,
                                JacobianTransposedType &JT ) const
      {
        return implementation().jacobianTransposed( x, JT );
      }

      FieldType
      jacobianInverseTransposed ( const LocalCoordinate &x, JacobianType &JTInv ) const
      {
        JacobianTransposedType JT;
        jacobianTransposed( x, JT );
        return MatrixHelper :: template rightInvA< dimension, dimWorld >( JT, JTInv );
      }

      FieldType integrationElement ( const LocalCoordinate &x ) const
      {
        JacobianTransposedType JT;
        jacobianTransposed( x, JT );
        return MatrixHelper :: template sqrtDetAAT< dimension, dimWorld >( JT );
      }

      const Implementation &implementation () const
      {
        return impl_;
      }

      template< unsigned int codim, unsigned int i >
      typename SubTopology< codim, i > :: Trace trace () const
      {
        return impl_.template trace< codim, i >();
      }
    };

  }

}
# 8 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/cachedmapping.hh" 2
# 1 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/traceprovider.hh" 1







namespace Dune
{

  namespace GenericGeometry
  {




    template< class Topology, class GeometryTraits >
    class CachedMapping;

    template< unsigned int dim, class GeometryTraits >
    class HybridMapping;

    template< class Topology, class GeometryTraits >
    class VirtualMapping;






    template< class Topology, class GeometryTraits, unsigned int codim, bool forceHybrid >
    class TraceProvider
    {
      typedef TraceProvider< Topology, GeometryTraits, codim, forceHybrid > This;

    public:
      static const unsigned int dimension = Topology :: dimension;
      static const unsigned int codimension = codim;
      static const unsigned int mydimension = dimension - codimension;

      static const bool hybrid
        = (forceHybrid || IsCodimHybrid< Topology, codim > :: value);

      typedef typename CachedMapping< Topology, GeometryTraits > :: Mapping Mapping;

    private:
      static const unsigned int numSubTopologies
        = Mapping :: ReferenceElement :: template Codim< codimension > :: size;

      template< bool > class HybridFactory;
      template< bool > class NonHybridFactory;

      typedef typename SelectType< hybrid, HybridFactory<true>, NonHybridFactory<false> > :: Type Factory;

      template< int i > struct Builder;

    public:
      typedef typename Factory::Trace Trace;

      static Trace* construct ( const Mapping &mapping, unsigned int i, char *traceStorage )
      {
        return (*instance().construct_[ i ])( mapping, traceStorage );
      }

    private:
      typedef Trace* (*Construct) ( const Mapping &mapping, char *traceStorage );

      TraceProvider ()
      {
        ForLoop< Builder, 0, numSubTopologies-1 >::apply( construct_ );
      }

      static const This &instance ()
      {
        static This theInstance;
        return theInstance;
      }

      Construct construct_[ numSubTopologies ];
    };



    template< class Topology, class GeometryTraits, unsigned int codim, bool forceHybrid >
    template< bool >
    class TraceProvider< Topology, GeometryTraits, codim, forceHybrid > :: HybridFactory
    {
      template< unsigned int i >
      struct VirtualTrace
      {
        typedef typename GenericGeometry :: SubTopology< Topology, codim, i > :: type
          SubTopology;
        typedef VirtualMapping< SubTopology, GeometryTraits > type;
      };

    public:
      typedef HybridMapping< mydimension, GeometryTraits > Trace;

      template< int i >
      static Trace* construct ( const Mapping &mapping, char *traceStorage )
      {
        typedef typename VirtualTrace< i >::type TraceImpl;
        return new( traceStorage ) TraceImpl( mapping.template trace< codim, i >() );
      }
    };



    template< class Topology, class GeometryTraits, unsigned int codim, bool forceHybrid >
    template< bool >
    class TraceProvider< Topology, GeometryTraits, codim, forceHybrid > :: NonHybridFactory
    {
      typedef typename GenericGeometry :: SubTopology< Topology, codim, 0 > :: type
        SubTopology;

    public:
      typedef CachedMapping< SubTopology, GeometryTraits > Trace;

      template< int i >
      static Trace* construct ( const Mapping &mapping, char *traceStorage )
      {
        return new( traceStorage ) Trace( mapping.template trace< codim, i >() );
      }
    };



    template< class Topology, class GeometryTraits, unsigned int codim, bool forceHybrid >
    template< int i >
    struct TraceProvider< Topology, GeometryTraits, codim, forceHybrid > :: Builder
    {
      static void apply ( Construct (&construct)[ numSubTopologies ] )
      {
        construct[ i ] = &(Factory::template construct< i >);
      }
    };

  }

}
# 9 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/cachedmapping.hh" 2

namespace Dune
{

  namespace GenericGeometry
  {




    template< unsigned int, class >
    class CachedJacobianTransposed;

    template< unsigned int, class >
    class CachedJacobianInverseTransposed;






    template< unsigned int dim, class GeometryTraits >
    class CachedStorage
    {
      friend class CachedJacobianTransposed< dim, GeometryTraits >;

    public:
      static const unsigned int dimension = dim;
      static const unsigned int dimWorld = GeometryTraits::dimWorld;

      typedef MappingTraits< typename GeometryTraits::CoordTraits, dimension, dimWorld > Traits;

      typedef typename GeometryTraits::Caching Caching;

      typename Traits::JacobianTransposedType jacobianTransposed;
      typename Traits::JacobianType jacobianInverseTransposed;
      typename Traits::FieldType integrationElement;

      CachedStorage ()
      : affine( false ),
        jacobianTransposedComputed( false ),
        jacobianInverseTransposedComputed( false ),
        integrationElementComputed( false )
      {}

      bool affine;

      bool jacobianTransposedComputed;
      bool jacobianInverseTransposedComputed;
      bool integrationElementComputed;
    };






    template< unsigned int dim, class GeometryTraits >
    class CachedJacobianTransposed
    {
      friend class CachedJacobianInverseTransposed< dim, GeometryTraits >;

      typedef CachedStorage< dim, GeometryTraits > Storage;
      typedef typename Storage::Traits Traits;

      typedef typename Traits::MatrixHelper MatrixHelper;

    public:
      typedef typename Traits::FieldType ctype;

      static const int rows = Traits::dimension;
      static const int cols = Traits::dimWorld;

      typedef typename Traits::JacobianTransposedType FieldMatrix;

      operator bool () const
      {
        return storage().jacobianTransposedComputed;
      }

      operator const FieldMatrix & () const
      {
        return storage().jacobianTransposed;
      }

      template< class X, class Y >
      void mv ( const X &x, Y &y ) const
      {
        static_cast< const FieldMatrix & >( *this ).mv( x, y );
      }

      template< class X, class Y >
      void mtv ( const X &x, Y &y ) const
      {
        static_cast< const FieldMatrix & >( *this ).mtv( x, y );
      }

      template< class X, class Y >
      void umv ( const X &x, Y &y ) const
      {
        static_cast< const FieldMatrix & >( *this ).umv( x, y );
      }

      template< class X, class Y >
      void umtv ( const X &x, Y &y ) const
      {
        static_cast< const FieldMatrix & >( *this ).umtv( x, y );
      }

      template< class X, class Y >
      void mmv ( const X &x, Y &y ) const
      {
        static_cast< const FieldMatrix & >( *this ).mmv( x, y );
      }

      template< class X, class Y >
      void mmtv ( const X &x, Y &y ) const
      {
        static_cast< const FieldMatrix & >( *this ).mmtv( x, y );
      }

      ctype det () const
      {
        if( !storage().integrationElementComputed )
        {
          storage().integrationElement = MatrixHelper::template sqrtDetAAT< rows, cols >( storage().jacobianTransposed );
          storage().integrationElementComputed = storage().affine;
        }
        return storage().integrationElement;
      }

    private:
      Storage &storage () const { return storage_; }

      mutable Storage storage_;
    };






    template< unsigned int dim, class GeometryTraits >
    class CachedJacobianInverseTransposed
    {
      template< class, class > friend class CachedMapping;

      typedef CachedJacobianTransposed< dim, GeometryTraits > JacobianTransposed;
      typedef typename JacobianTransposed::Storage Storage;
      typedef typename JacobianTransposed::Traits Traits;

      typedef typename Traits::MatrixHelper MatrixHelper;

    public:
      typedef typename Traits::FieldType ctype;

      static const int rows = Traits::dimWorld;
      static const int cols = Traits::dimension;

      typedef typename Traits::JacobianType FieldMatrix;

      operator bool () const
      {
        return storage().jacobianInverseTransposedComputed;
      }

      operator const FieldMatrix & () const
      {
        return storage().jacobianInverseTransposed;
      }

      template< class X, class Y >
      void mv ( const X &x, Y &y ) const
      {
        static_cast< const FieldMatrix & >( *this ).mv( x, y );
      }

      template< class X, class Y >
      void mtv ( const X &x, Y &y ) const
      {
        static_cast< const FieldMatrix & >( *this ).mtv( x, y );
      }

      template< class X, class Y >
      void umv ( const X &x, Y &y ) const
      {
        static_cast< const FieldMatrix & >( *this ).umv( x, y );
      }

      template< class X, class Y >
      void umtv ( const X &x, Y &y ) const
      {
        static_cast< const FieldMatrix & >( *this ).umtv( x, y );
      }

      template< class X, class Y >
      void mmv ( const X &x, Y &y ) const
      {
        static_cast< const FieldMatrix & >( *this ).mmv( x, y );
      }

      template< class X, class Y >
      void mmtv ( const X &x, Y &y ) const
      {
        static_cast< const FieldMatrix & >( *this ).mmtv( x, y );
      }

      ctype det () const
      {

        return ctype( 1 ) / storage().integrationElement;
      }

    private:
      JacobianTransposed &jacobianTransposed () { return jacobianTransposed_; }
      const JacobianTransposed &jacobianTransposed () const { return jacobianTransposed_; }

      Storage &storage () const { return jacobianTransposed().storage(); }

      JacobianTransposed jacobianTransposed_;
    };
# 248 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/cachedmapping.hh"
    template< class Topology, class GeometryTraits >
    class CachedMapping
    {
      typedef CachedMapping< Topology, GeometryTraits > This;

      typedef typename GeometryTraits::template Mapping< Topology >::type
        MappingImpl;

    public:
      typedef MappingTraits
        < typename GeometryTraits::CoordTraits, Topology::dimension, GeometryTraits::dimWorld >
        Traits;

      typedef GenericGeometry::Mapping
        < typename GeometryTraits::CoordTraits, Topology, GeometryTraits::dimWorld, MappingImpl >
        Mapping;

      static const unsigned int dimension = Traits::dimension;
      static const unsigned int dimWorld = Traits::dimWorld;

      typedef typename Traits::FieldType FieldType;
      typedef typename Traits::LocalCoordinate LocalCoordinate;
      typedef typename Traits::GlobalCoordinate GlobalCoordinate;

      typedef CachedStorage< dimension, GeometryTraits > Storage;
      typedef CachedJacobianTransposed< dimension, GeometryTraits > JacobianTransposed;
      typedef CachedJacobianInverseTransposed< dimension, GeometryTraits > JacobianInverseTransposed;

      typedef GenericGeometry::ReferenceElement< Topology, FieldType > ReferenceElement;


      static const bool alwaysAffine = Mapping::alwaysAffine;

      template< unsigned int codim >
      struct Codim
      {
        typedef typename TraceProvider< Topology, GeometryTraits, codim, false >::Trace Trace;
      };

      typedef typename GeometryTraits::Caching Caching;

    private:
      typedef typename Traits::MatrixHelper MatrixHelper;

    public:
      template< class CoordVector >
      explicit CachedMapping ( const CoordVector &coords )
      : mapping_( coords )
      {
        if( alwaysAffine )
          storage().affine = true;
        else
          computeJacobianTransposed( baryCenter() );
        preCompute();
      }

      template< class CoordVector >
      explicit CachedMapping ( const std::pair< const CoordVector &, bool > &coords )
      : mapping_( coords.first )
      {
        storage().affine = coords.second;
        preCompute();
      }


      unsigned int topologyId () const
      {
        return ReferenceElement::topologyId;
      }


      const GlobalCoordinate &corner ( int i ) const
      {
        return mapping_.corner( i );
      }


      int numCorners () const
      {
        return ReferenceElement::numCorners;
      }






      GlobalCoordinate center () const
      {
        return global( ReferenceElement::template baryCenter< 0 >( 0 ) );
      }
# 347 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/cachedmapping.hh"
      static bool checkInside ( const LocalCoordinate &x )
      {
        return ReferenceElement::checkInside( x );
      }


      bool affine () const
      {
        return (alwaysAffine || storage().affine);
      }







      GlobalCoordinate global ( const LocalCoordinate &x ) const
      {
        GlobalCoordinate y;
        if( jacobianTransposed() )
        {
          y = corner( 0 );
          jacobianTransposed().umtv( x, y );


        }
        else
          mapping_.global( x, y );
        return y;
      }
# 390 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/cachedmapping.hh"
      LocalCoordinate local ( const GlobalCoordinate &y ) const
      {
        LocalCoordinate x;
        if( jacobianInverseTransposed() )
        {
          GlobalCoordinate z = y - corner( 0 );
          jacobianInverseTransposed().mtv( z, x );

        }
        else if( affine() )
        {
          const JacobianTransposed &JT = jacobianTransposed( baryCenter() );
          GlobalCoordinate z = y - corner( 0 );
          MatrixHelper::template xTRightInvA< dimension, dimWorld >( JT, z, x );
        }
        else
          mapping_.local( y, x );
        return x;
      }
# 419 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/cachedmapping.hh"
      const JacobianTransposed &jacobianTransposed ( const LocalCoordinate &x ) const
      {
        const EvaluationType evaluate = Caching::evaluateJacobianTransposed;
        if( (evaluate == PreCompute) && alwaysAffine )
          return jacobianTransposed();

        if( !jacobianTransposed() )
          computeJacobianTransposed( x );
        return jacobianTransposed();
      }
# 444 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/cachedmapping.hh"
      FieldType integrationElement ( const LocalCoordinate &x ) const
      {
        const EvaluationType evaluateI = Caching::evaluateIntegrationElement;
        const EvaluationType evaluateJ = Caching::evaluateJacobianInverseTransposed;
        if( ((evaluateI == PreCompute) || (evaluateJ == PreCompute)) && alwaysAffine )
          return storage().integrationElement;
        else
          return jacobianTransposed( x ).det();
      }







      const JacobianInverseTransposed &
      jacobianInverseTransposed ( const LocalCoordinate &x ) const
      {
        const EvaluationType evaluate = Caching::evaluateJacobianInverseTransposed;
        if( (evaluate == PreCompute) && alwaysAffine )
          return jacobianInverseTransposed();

        if( !jacobianInverseTransposed() )
          computeJacobianInverseTransposed( x );
        return jacobianInverseTransposed();
      }
# 480 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/cachedmapping.hh"
      FieldType volume () const
      {

        const FieldType refVolume = ReferenceElement::volume();
        return refVolume * integrationElement( baryCenter() );
      }

      This *clone () const
      {
        return new This( *this );
      }

      This* clone ( char *mappingStorage ) const
      {
        return new( mappingStorage ) This( *this );
      }

      template< unsigned int codim, bool hybrid >
      typename TraceProvider< Topology, GeometryTraits, codim, hybrid >::Trace*
      trace ( unsigned int i, char *mappingStorage ) const
      {
        return TraceProvider< Topology, GeometryTraits, codim, hybrid >::construct( mapping_, i, mappingStorage );
      }

    private:
      static const LocalCoordinate &baryCenter ()
      {
        return ReferenceElement::template baryCenter< 0 >( 0 );
      }

      Storage &storage () const
      {
        return jacobianInverseTransposed().storage();
      }

      const JacobianTransposed &jacobianTransposed () const
      {
        return jacobianInverseTransposed().jacobianTransposed();
      }

      const JacobianInverseTransposed &jacobianInverseTransposed () const
      {
        return jacobianInverseTransposed_;
      }

      void preCompute ()
      {
        ((affine() == mapping_.jacobianTransposed( baryCenter(), storage().jacobianTransposed )) ? static_cast<void> (0) : __assert_fail ("affine() == mapping_.jacobianTransposed( baryCenter(), storage().jacobianTransposed )", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/cachedmapping.hh", 527, __PRETTY_FUNCTION__));
        if( !affine() )
          return;

        if( (Caching::evaluateJacobianTransposed == PreCompute) && !jacobianTransposed() )
          computeJacobianTransposed( baryCenter() );

        if( Caching::evaluateJacobianInverseTransposed == PreCompute )
          computeJacobianInverseTransposed( baryCenter() );
        else if( Caching::evaluateIntegrationElement == PreCompute )
          jacobianTransposed().det();
      }

      void computeJacobianTransposed ( const LocalCoordinate &x ) const
      {
        storage().affine = mapping_.jacobianTransposed( x, storage().jacobianTransposed );
        storage().jacobianTransposedComputed = affine();
      }

      void computeJacobianInverseTransposed ( const LocalCoordinate &x ) const
      {
        storage().integrationElement
          = MatrixHelper::template rightInvA< dimension, dimWorld >( jacobianTransposed( x ), storage().jacobianInverseTransposed );
        storage().integrationElementComputed = affine();
        storage().jacobianInverseTransposedComputed = affine();
      }

    private:
      Mapping mapping_;
      JacobianInverseTransposed jacobianInverseTransposed_;
    };

  }

}
# 11 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/hybridmapping.hh" 2

namespace Dune
{

  namespace GenericGeometry
  {





    template< unsigned int dim, class GeometryTraits >
    class HybridMapping;

    template< class Topology, class GeometryTraits >
    class VirtualMapping;







    template< unsigned int dim, class GeometryTraits, unsigned int codim = dim >
    class HybridMappingBase;

    template< unsigned int dim, class GeometryTraits, unsigned int codim >
    class HybridMappingBase
    : public virtual HybridMappingBase< dim, GeometryTraits, codim-1 >
    {
      typedef HybridMapping< dim, GeometryTraits > Mapping;

    public:
      virtual ~HybridMappingBase() {}

    protected:
      using HybridMappingBase< dim, GeometryTraits, codim-1 > :: trace;

      virtual HybridMapping< dim - codim, GeometryTraits >*
      trace ( integral_constant< int, codim >, unsigned int i, char *mappingStorage ) const = 0;
    };

    template< unsigned int dim, class GeometryTraits >
    class HybridMappingBase< dim, GeometryTraits, 0 >
    {
      typedef HybridMapping< dim, GeometryTraits > Mapping;

    public:
      virtual ~HybridMappingBase() {}

    protected:
      virtual HybridMapping< dim, GeometryTraits >*
      trace ( integral_constant< int, 0 >, unsigned int i, char *mappingStorage ) const = 0;
    };
# 81 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/hybridmapping.hh"
    template< unsigned int dim, class GeometryTraits >
    class HybridMapping

    : public virtual HybridMappingBase< dim, GeometryTraits >

    {
      typedef HybridMapping< dim, GeometryTraits > This;

    protected:
      typedef MappingTraits
        < typename GeometryTraits::CoordTraits, dim, GeometryTraits::dimWorld >
        Traits;

    public:
      static const unsigned int dimension = Traits::dimension;
      static const unsigned int dimWorld = Traits::dimWorld;

      typedef typename Traits::FieldType FieldType;
      typedef typename Traits::LocalCoordinate LocalCoordinate;
      typedef typename Traits::GlobalCoordinate GlobalCoordinate;

      typedef CachedJacobianTransposed< dimension, GeometryTraits > JacobianTransposed;
      typedef CachedJacobianInverseTransposed< dimension, GeometryTraits > JacobianInverseTransposed;

      template< int codim >
      struct Codim
      {
        typedef HybridMapping< dimension - codim, GeometryTraits > Trace;
      };

      typedef typename GeometryTraits::Caching Caching;

      virtual ~HybridMapping ()
      {}


      virtual unsigned int topologyId () const = 0;


      virtual const GlobalCoordinate &corner ( int i ) const = 0;


      virtual int numCorners () const = 0;


      virtual GlobalCoordinate center () const = 0;


      virtual GlobalCoordinate global ( const LocalCoordinate &x ) const = 0;


      virtual LocalCoordinate local ( const GlobalCoordinate &y ) const = 0;


      virtual bool checkInside ( const LocalCoordinate &x ) const = 0;


      virtual bool affine () const = 0;


      virtual FieldType integrationElement ( const LocalCoordinate &x ) const = 0;


      virtual FieldType volume () const = 0;


      virtual const JacobianTransposed &
      jacobianTransposed ( const LocalCoordinate &x ) const = 0;


      virtual const JacobianInverseTransposed &
      jacobianInverseTransposed ( const LocalCoordinate &x ) const = 0;

    protected:
      using HybridMappingBase< dim, GeometryTraits >::trace;

    public:
      virtual This *clone () const = 0;
      virtual This *clone ( char *mappingStorage ) const = 0;

      template< int codim >
      typename Codim< codim >::Trace* trace ( unsigned int i, char *mappingStorage ) const
      {
        integral_constant< int, codim > codimVariable;
        return trace( codimVariable, i, mappingStorage );
      }
    };







    template< class Topology, class GeometryTraits, unsigned int codim = Topology :: dimension >
    class VirtualMappingBase;

    template< class Topology, class GeometryTraits, unsigned int codim >
    class VirtualMappingBase
    : public VirtualMappingBase< Topology, GeometryTraits, codim-1 >,
      public virtual HybridMappingBase< Topology :: dimension, GeometryTraits, codim >
    {
      typedef GenericGeometry :: VirtualMapping< Topology, GeometryTraits >
        VirtualMapping;

    protected:
      using VirtualMappingBase< Topology, GeometryTraits, codim-1 > :: trace;

      virtual HybridMapping< Topology::dimension - codim, GeometryTraits >*
      trace ( integral_constant< int, codim >, unsigned int i, char *mappingStorage) const
      {
        return static_cast< const VirtualMapping & >( *this ).template trace< codim >( i, mappingStorage );
      }
    };

    template< class Topology, class GeometryTraits >
    class VirtualMappingBase< Topology, GeometryTraits, 0 >
    : public virtual HybridMappingBase< Topology :: dimension, GeometryTraits, 0 >
    {
      typedef GenericGeometry :: VirtualMapping< Topology, GeometryTraits >
        VirtualMapping;

    protected:
      virtual HybridMapping< Topology::dimension, GeometryTraits >*
      trace ( integral_constant< int, 0 >, unsigned int i,
              char *mappingStorage ) const
      {
        return static_cast< const VirtualMapping & >( *this ).template trace< 0 >( i, mappingStorage );
      }
    };




    template< class Topology, class GeometryTraits >
    class VirtualMapping
    : public HybridMapping< Topology :: dimension, GeometryTraits >,

      public VirtualMappingBase< Topology, GeometryTraits >

    {
      typedef HybridMapping< Topology :: dimension, GeometryTraits > Base;
      typedef VirtualMapping< Topology, GeometryTraits > This;

      typedef typename Base :: Traits Traits;

      typedef CachedMapping< Topology, GeometryTraits > Mapping;

    public:
      static const unsigned int dimension = Traits :: dimension;
      static const unsigned int dimWorld = Traits :: dimWorld;

      typedef typename Traits::FieldType FieldType;
      typedef typename Traits::LocalCoordinate LocalCoordinate;
      typedef typename Traits::GlobalCoordinate GlobalCoordinate;

      typedef typename Base::JacobianTransposed JacobianTransposed;
      typedef typename Base::JacobianInverseTransposed JacobianInverseTransposed;

      typedef typename Mapping::ReferenceElement ReferenceElement;

      template< int codim >
      struct Codim
      {
        typedef HybridMapping< dimension - codim, GeometryTraits > Trace;
      };

      typedef typename GeometryTraits::Caching Caching;

    private:
      Mapping mapping_;

    public:
      template< class CoordVector >
      explicit VirtualMapping ( const CoordVector &coordVector )
      : mapping_( coordVector )
      {}

      virtual unsigned int topologyId () const
      {
        return mapping_.topologyId();
      }

      virtual const GlobalCoordinate &corner ( int i ) const
      {
        return mapping_.corner( i );
      }

      virtual int numCorners () const
      {
        return mapping_.numCorners();
      }

      virtual GlobalCoordinate center () const
      {
        return mapping_.center();
      }

      virtual GlobalCoordinate global ( const LocalCoordinate &local ) const
      {
        return mapping_.global( local );
      }

      virtual LocalCoordinate local ( const GlobalCoordinate &global ) const
      {
        return mapping_.local( global );
      }

      virtual bool checkInside ( const LocalCoordinate &local ) const
      {
        return mapping_.checkInside( local );
      }

      virtual bool affine () const
      {
        return mapping_.affine();
      }

      virtual FieldType integrationElement ( const LocalCoordinate &local ) const
      {
        return mapping_.integrationElement( local );
      }

      virtual FieldType volume () const
      {
        return mapping_.volume();
      }

      virtual const JacobianTransposed &
      jacobianTransposed ( const LocalCoordinate &local ) const
      {
        return mapping_.jacobianTransposed( local );
      }

      virtual const JacobianInverseTransposed &
      jacobianInverseTransposed ( const LocalCoordinate &local ) const
      {
        return mapping_.jacobianInverseTransposed( local );
      }

      virtual Base *clone () const
      {
        return new This( *this );
      }

      virtual Base* clone ( char *mappingStorage ) const
      {
        return new( mappingStorage ) This( *this );
      }

      template< int codim >
      typename Codim< codim >::Trace* trace ( unsigned int i, char *mappingStorage ) const
      {
        return mapping_.template trace< codim, true >( i, mappingStorage );
      }

    protected:
      using VirtualMappingBase< Topology, GeometryTraits > :: trace;
    };

  }

}
# 14 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh" 2
# 1 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/mappingprovider.hh" 1





# 1 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/maximum.hh" 1





namespace Dune
{

  namespace GenericGeometry
  {




    template< class A, class B >
    struct StaticMaximum
    {
      static const int v = (A::v > B::v ? A::v : B::v);
    };






    template< template< int > class Value, int first, int last >
    struct Maximum
    : public GenericForLoop< StaticMaximum, Value, first, last >
    {};

  }

}
# 7 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/mappingprovider.hh" 2




namespace Dune
{

  namespace GenericGeometry
  {




    template< class Topology, class GeometryTraits >
    class CachedMappingFactory
    {
      typedef CachedMappingFactory< Topology, GeometryTraits > This;

    public:
      typedef CachedMapping< Topology, GeometryTraits > Mapping;

      static const unsigned int maxMappingSize = sizeof( Mapping );

      template< class CoordVector >
      static Mapping*
      construct ( const unsigned int topologyId, const CoordVector &coords, char *mappingStorage )
      {
        (((topologyId >> 1) == (Topology::id >> 1)) ? static_cast<void> (0) : __assert_fail ("(topologyId >> 1) == (Topology::id >> 1)", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/mappingprovider.hh", 34, __PRETTY_FUNCTION__));
        return new( mappingStorage ) Mapping( coords );
      }

      static size_t mappingSize ( const unsigned int topologyId )
      {
        return sizeof( Mapping );
      }
    };






    template< unsigned int dim, class GeometryTraits >
    class VirtualMappingFactory
    {
      typedef VirtualMappingFactory< dim, GeometryTraits > This;

      static const unsigned int numTopologies = (1 << dim);

      template< int topologyId >
      struct MappingSize
      {
        typedef typename GenericGeometry::Topology< (unsigned int)topologyId, dim >::type Topology;
        static const int v = sizeof( VirtualMapping< Topology, GeometryTraits > );

        static void apply ( size_t (&mappingSize)[ numTopologies ] )
        {
          mappingSize[ topologyId ] = v;
        }
      };

      template< class CoordVector >
      class ConstructorTable;

      struct MappingSizeCache;

    public:
      typedef HybridMapping< dim, GeometryTraits > Mapping;

      static const unsigned int maxMappingSize = Maximum< MappingSize, 0, numTopologies-1 >::v;

      template< class CoordVector >
      static Mapping*
      construct ( const unsigned int topologyId, const CoordVector &coords, char *mappingStorage )
      {
        static ConstructorTable< CoordVector > construct;
        return construct[ topologyId ]( coords, mappingStorage );
      }

      static size_t mappingSize ( const unsigned int topologyId )
      {
        static MappingSizeCache mappingSize;
        return mappingSize[ topologyId ];
      }
    };





    template< unsigned int dim, class GeometryTraits >
    template< class CoordVector >
    class VirtualMappingFactory< dim, GeometryTraits >::ConstructorTable
    {
      typedef Mapping* (*Construct) ( const CoordVector &coords, char *mappingStorage );

      template< int i >
      struct Builder;

    public:
      ConstructorTable ()
      {
        ForLoop< Builder, 0, numTopologies-1 >::apply( construct_ );
      }

      Construct operator[] ( const unsigned int topologyId )
      {
        ((topologyId < numTopologies) ? static_cast<void> (0) : __assert_fail ("topologyId < numTopologies", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/mappingprovider.hh", 114, __PRETTY_FUNCTION__));
        return construct_[ topologyId ];
      }

    private:
      template< class Topology >
      static Mapping*
      construct ( const CoordVector &coords, char *mappingStorage )
      {
        typedef VirtualMapping< Topology, GeometryTraits > VMapping;
        return new( mappingStorage ) VMapping( coords );
      }

      Construct construct_[ numTopologies ];
    };





    template< unsigned int dim, class GeometryTraits >
    template< class CoordVector >
    template< int topologyId >
    struct VirtualMappingFactory< dim, GeometryTraits >::ConstructorTable< CoordVector >::Builder
    {
      static void apply ( Construct (&construct)[ numTopologies ] )
      {
        typedef typename GenericGeometry::Topology< (unsigned int)topologyId, dim >::type Topology;
        construct[ topologyId ] = ConstructorTable< CoordVector >::template construct< Topology >;
      }
    };






    template< unsigned int dim, class GeometryTraits >
    struct VirtualMappingFactory< dim, GeometryTraits >::MappingSizeCache
    {
      MappingSizeCache ()
      {
        ForLoop< MappingSize, 0, numTopologies-1 >::apply( size_ );
      }

      size_t operator[] ( const unsigned int topologyId )
      {
        ((topologyId < numTopologies) ? static_cast<void> (0) : __assert_fail ("topologyId < numTopologies", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/mappingprovider.hh", 161, __PRETTY_FUNCTION__));
        return size_[ topologyId ];
      }

    private:
      size_t size_[ numTopologies ];
    };






    template< class ElementMapping, unsigned int codim >
    class MappingProvider;


    template< unsigned int dim, class GeometryTraits, unsigned int codim >
    class MappingProvider< HybridMapping< dim, GeometryTraits >, codim >
    {
      typedef MappingProvider< HybridMapping< dim, GeometryTraits >, codim > This;

    public:
      static const unsigned int dimension = dim;
      static const unsigned int codimension = codim;
      static const unsigned int mydimension = dimension - codimension;

    private:
      typedef VirtualMappingFactory< mydimension, GeometryTraits > Factory;

    public:

      static const unsigned int maxMappingSize = Factory::maxMappingSize;

      typedef typename Factory::Mapping Mapping;

      template< class CoordVector >
      static Mapping*
      construct ( const unsigned int topologyId, const CoordVector &coords, char *mappingStorage )
      {
        return Factory::construct( topologyId, coords, mappingStorage );
      }

      template< class CoordVector >
      static Mapping *create ( const unsigned int topologyId, const CoordVector &coords )
      {
        char *mapping = new char[ mappingSize( topologyId ) ];
        return construct( topologyId, coords, mapping );
      }

      static size_t mappingSize ( const unsigned int topologyId )
      {
        return Factory::mappingSize( topologyId );
      }
    };


    template< class Topology, class GeometryTraits, unsigned int codim >
    class MappingProvider< CachedMapping< Topology, GeometryTraits >, codim >
    {
      typedef MappingProvider< CachedMapping< Topology, GeometryTraits >, codim > This;

    public:
      static const unsigned int dimension = Topology :: dimension;
      static const unsigned int codimension = codim;
      static const unsigned int mydimension = dimension - codimension;

      static const bool hybrid = IsCodimHybrid< Topology, codim > :: value;

    private:
      template< bool >
      struct HybridFactory
      : public VirtualMappingFactory< mydimension, GeometryTraits >
      {};

      template< bool >
      struct NonHybridFactory
      : public CachedMappingFactory
        < typename SubTopology< Topology, codim, 0 >::type, GeometryTraits >
      {};

      typedef typename SelectType< hybrid, HybridFactory<true>, NonHybridFactory<false> >::Type Factory;

    public:

      static const unsigned int maxMappingSize = Factory::maxMappingSize;

      typedef typename Factory::Mapping Mapping;

      template< class CoordVector >
      static Mapping*
      construct ( const unsigned int topologyId, const CoordVector &coords, char *mappingStorage )
      {
        return Factory::construct( topologyId, coords, mappingStorage );
      }

      template< class CoordVector >
      static Mapping *create ( const unsigned int topologyId, const CoordVector &coords )
      {
        Mapping *mapping = static_cast< Mapping * >( operator new( mappingSize( topologyId ) ) );
        construct( topologyId, coords, mapping );
        return mapping;
      }

      static size_t mappingSize ( const unsigned int topologyId )
      {
        return Factory::mappingsSize( topologyId );
      }
    };

  }

}
# 15 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh" 2

namespace Dune
{


  template< class ctype, int dim >
  class GenericReferenceElementContainer;
# 42 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh"
  template< class ctype, int dim >
  class GenericReferenceElement
  {
    typedef GenericReferenceElement< ctype, dim > This;

    friend class GenericReferenceElementContainer< ctype, dim >;


    GenericReferenceElement(const GenericReferenceElement &);


    GenericReferenceElement() {};

    ~GenericReferenceElement ()
    {
      ForLoop< Destroy, 0, dim >::apply( mappings_ );
    }

    class SubEntityInfo;
    template< class Topology > class CornerStorage;
    template< class Topology > struct Initialize;
    template< int codim > struct Destroy;

    struct GeometryTraits
      : public GenericGeometry::DefaultGeometryTraits< ctype, dim, dim >
    {
      typedef GenericGeometry::DefaultGeometryTraits< ctype, dim, dim > Base;

      typedef typename Base::CoordTraits CoordTraits;

      template< class Topology >
      struct Mapping
      {
        typedef GenericGeometry::CornerMapping< CoordTraits, Topology, dim, CornerStorage< Topology >, true > type;
      };

      struct Caching
      {
        static const GenericGeometry::EvaluationType evaluateJacobianTransposed = GenericGeometry::PreCompute;
        static const GenericGeometry::EvaluationType evaluateJacobianInverseTransposed = GenericGeometry::PreCompute;
        static const GenericGeometry::EvaluationType evaluateIntegrationElement = GenericGeometry::PreCompute;
        static const GenericGeometry::EvaluationType evaluateNormal = GenericGeometry::PreCompute;
      };

    };

  public:

    template< int codim >
    struct Codim
    {

      typedef GenericGeometry::HybridMapping< dim-codim, GeometryTraits > Mapping;
    };

  private:


    template< int codim >
    struct MappingArray
    : public std::vector< typename Codim< codim >::Mapping * >
    {};


    typedef GenericGeometry::CodimTable< MappingArray, dim > MappingsTable;

    std::vector< SubEntityInfo > info_[ dim+1 ];


    double volume_;
    std::vector< FieldVector< ctype, dim > > volumeNormals_;


    MappingsTable mappings_;

  public:




    int size ( int c ) const
    {
      (((c >= 0) && (c <= dim)) ? static_cast<void> (0) : __assert_fail ("(c >= 0) && (c <= dim)", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh", 124, __PRETTY_FUNCTION__));
      return info_[ c ].size();
    }
# 139 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh"
    int size ( int i, int c, int cc ) const
    {
      (((c >= 0) && (c <= dim)) ? static_cast<void> (0) : __assert_fail ("(c >= 0) && (c <= dim)", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh", 141, __PRETTY_FUNCTION__));
      return info_[ c ][ i ].size( cc );
    }
# 158 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh"
    int subEntity ( int i, int c, int ii, int cc ) const
    {
      (((c >= 0) && (c <= dim)) ? static_cast<void> (0) : __assert_fail ("(c >= 0) && (c <= dim)", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh", 160, __PRETTY_FUNCTION__));
      return info_[ c ][ i ].number( ii, cc );
    }
# 173 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh"
    const FieldVector< ctype, dim > &position( int i, int c ) const
    {
      (((c >= 0) && (c <= dim)) ? static_cast<void> (0) : __assert_fail ("(c >= 0) && (c <= dim)", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh", 175, __PRETTY_FUNCTION__));
      return info_[ c ][ i ].position();
    }
# 186 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh"
    bool checkInside ( const FieldVector< ctype, dim > &local ) const
    {
      return checkInside< 0 >( local, 0 );
    }
# 205 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh"
    template< int codim >
    bool checkInside ( const FieldVector< ctype, dim-codim > &local, int i ) const
    {
      return mapping< codim >( i ).checkInside( local );
    }
# 232 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh"
    template< int codim >
    FieldVector< ctype, dim >
    global( const FieldVector< ctype, dim-codim > &local, int i, int c ) const
    {
      if( c != codim )
        do { Exception th__ex; std::ostringstream th__out; th__out << "Exception" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh" << ":" << 237 << "]: " << "Local Coordinate Type does not correspond to codimension c."; th__ex.message(th__out.str()); throw th__ex; } while (0);
      ((c == codim) ? static_cast<void> (0) : __assert_fail ("c == codim", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh", 238, __PRETTY_FUNCTION__));
      return mapping< codim >( i ).global( local );
    }
# 260 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh"
    template< int codim >
    FieldVector< ctype, dim >
    global( const FieldVector< ctype, dim-codim > &local, int i ) const
    {
      return mapping< codim >( i ).global( local );
    }
# 282 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh"
    template< int codim >
    typename Codim< codim >::Mapping &mapping( int i ) const
    {
      integral_constant< int, codim > codimVariable;
      return *(mappings_[ codimVariable ][ i ]);
    }
# 297 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh"
    const GeometryType &type ( int i, int c ) const
    {
      (((c >= 0) && (c <= dim)) ? static_cast<void> (0) : __assert_fail ("(c >= 0) && (c <= dim)", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh", 299, __PRETTY_FUNCTION__));
      return info_[ c ][ i ].type();
    }

    unsigned int topologyId ( int i, int c ) const __attribute__((deprecated))
    {
      (((c >= 0) && (c <= dim)) ? static_cast<void> (0) : __assert_fail ("(c >= 0) && (c <= dim)", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh", 305, __PRETTY_FUNCTION__));
      return info_[ c ][ i ].topologyId();
    }


    double volume () const
    {
      return volume_;
    }
# 322 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh"
    const FieldVector< ctype, dim > &volumeOuterNormal ( int face ) const
    {
      (((face >= 0) && (face < int( volumeNormals_.size()))) ? static_cast<void> (0) : __assert_fail ("(face >= 0) && (face < int( volumeNormals_.size()))", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh", 324, __PRETTY_FUNCTION__));
      return volumeNormals_[ face ];
    }







    template< class Topology >
    void initializeTopology ()
    {
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (Topology::dimension == dim) )>) > dune_static_assert_typedef_338;

      typedef Initialize< Topology > Init;
      typedef GenericGeometry::VirtualMapping< Topology, GeometryTraits > VirtualMapping;


      integral_constant< int, 0 > codim0Variable;
      mappings_[ codim0Variable ].resize( 1 );
      mappings_[ codim0Variable ][ 0 ] = new VirtualMapping( codim0Variable );

      Dune::ForLoop< Init::template Codim, 0, dim >::apply( info_, mappings_ );


      typedef GenericGeometry::ReferenceDomain< Topology > ReferenceDomain;
      volume_ = ReferenceDomain::template volume< double >();


      volumeNormals_.resize( ReferenceDomain::numNormals );
      for( unsigned int i = 0; i < ReferenceDomain::numNormals; ++i )
        ReferenceDomain::integrationOuterNormal( i ,volumeNormals_[ i ] );
    }
  };





  template< class ctype, int dim >
  class GenericReferenceElement< ctype, dim >::SubEntityInfo
  {
    template< class Topology, int codim > struct Initialize
    {
      template< int subcodim > struct SubCodim;
    };

    int codim_;
    std::vector< int > numbering_[ dim+1 ];
    FieldVector< ctype, dim > baryCenter_;
    GeometryType type_;

  public:
    int size ( int cc ) const
    {
      (((cc >= codim_) && (cc <= dim)) ? static_cast<void> (0) : __assert_fail ("(cc >= codim_) && (cc <= dim)", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh", 380, __PRETTY_FUNCTION__));
      return numbering_[ cc ].size();
    }

    int number ( int ii, int cc ) const
    {
      (((cc >= codim_) && (cc <= dim)) ? static_cast<void> (0) : __assert_fail ("(cc >= codim_) && (cc <= dim)", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh", 386, __PRETTY_FUNCTION__));
      return numbering_[ cc ][ ii ];
    }

    const FieldVector< ctype, dim > &position () const
    {
      return baryCenter_;
    }

    const GeometryType &type () const
    {
      return type_;
    }

    unsigned int topologyId () const __attribute__((deprecated))
    {
      return type_.id();
    }

    template< class Topology, unsigned int codim, unsigned int i >
    void initialize ()
    {
      typedef Initialize< Topology, codim > Init;
      typedef GenericGeometry::ReferenceDomain< Topology > RefDomain;

      codim_ = codim;

      const unsigned int iVariable = i;
      Dune::ForLoop< Init::template SubCodim, 0, dim-codim >::apply( iVariable, numbering_ );

      baryCenter_ = ctype( 0 );
      static const unsigned int numCorners = size( dim );
      for( unsigned int j = 0; j < numCorners; ++j )
      {
        FieldVector< ctype, dim > corner;
        RefDomain::corner( number( j, dim ), corner );
        baryCenter_ += corner;
      }
      baryCenter_ *= ctype( 1 ) / ctype( numCorners );

      typedef typename GenericGeometry::SubTopology< Topology, codim, i >::type SubTopology;
      type_ = GeometryType( SubTopology::id, SubTopology::dimension );

    }
  };


  template< class ctype, int dim >
  template< class Topology >
  class GenericReferenceElement< ctype, dim >::CornerStorage
  {
    typedef GenericGeometry::ReferenceDomain< Topology > RefDomain;

  public:
    static const unsigned int size = Topology::numCorners;

    template< class SubTopology >
    struct SubStorage
    {
      typedef CornerStorage< SubTopology > type;
    };

    explicit CornerStorage ( const integral_constant< int, 0 > & )
    {
      for( unsigned int i = 0; i < size; ++i )
        RefDomain::corner( i, coords_[ i ] );
    }

    template< class Mapping, unsigned int codim >
    explicit
    CornerStorage ( const GenericGeometry::SubMappingCoords< Mapping, codim > &coords )
    {
      for( unsigned int i = 0; i < size; ++i )
        coords_[ i ] = coords[ i ];
    }

    const FieldVector< ctype, dim > &operator[] ( unsigned int i ) const
    {
      return coords_[ i ];
    }

  private:
    FieldVector< ctype, dim > coords_[ size ];
  };


  template< class ctype, int dim >
  template< class Topology, int codim >
  template< int subcodim >
  struct GenericReferenceElement< ctype, dim >::SubEntityInfo::Initialize< Topology, codim >::SubCodim
  {
    typedef GenericGeometry::SubTopologySize< Topology, codim, subcodim > SubSize;
    typedef GenericGeometry::GenericSubTopologyNumbering< Topology, codim, subcodim > SubNumbering;

    static void apply ( unsigned int i, std::vector< int > (&numbering)[ dim+1 ] )
    {
      const unsigned int size = SubSize::size( i );
      numbering[ codim+subcodim ].resize( size );
      for( unsigned int j = 0; j < size; ++j )
        numbering[ codim+subcodim ][ j ] = SubNumbering::number( i, j );
    }
  };


  template< class ctype, int dim >
  template< class Topology >
  struct GenericReferenceElement< ctype, dim >::Initialize
  {
    typedef Dune::GenericReferenceElement< ctype, dim > GenericReferenceElement;

    typedef typename GenericReferenceElement::template Codim< 0 >::Mapping ReferenceMapping;

    template< int codim >
    struct Codim
    {
      template< int i >
      struct SubTopology
      {
        static void apply ( std::vector< SubEntityInfo > &info )
        {
          info[ i ].template initialize< Topology, codim, i >();
        }
      };

      static void
      apply ( std::vector< SubEntityInfo > (&info)[ dim+1 ],
              MappingsTable &mappings )
      {
        const unsigned int size = GenericGeometry::Size< Topology, codim >::value;
        info[ codim ].resize( size );
        Dune::ForLoop< SubTopology, 0, size-1 >::apply( info[ codim ] );

        if( codim > 0 )
        {
          integral_constant< int, 0 > codim0Variable;
          const ReferenceMapping &refMapping = *(mappings[ codim0Variable ][ 0 ]);

          typedef typename GenericGeometry::MappingProvider< ReferenceMapping, codim > MappingProvider;

          integral_constant< int, codim > codimVariable;
          mappings[ codimVariable ].resize( size );
          for( unsigned int i = 0; i < size; ++i ) {
              char* storage = new char[MappingProvider::maxMappingSize];
            mappings[ codimVariable ][ i ] = refMapping.template trace< codim >( i, storage );
          }
        }
      }
    };
  };



  template< class ctype, int dim >
  template< int codim >
  struct GenericReferenceElement< ctype, dim >::Destroy
  {
    static void apply ( MappingsTable &mappings )
    {
      if (codim > 0 )
      {
        integral_constant< int, codim > codimVariable;
        for( size_t i = 0; i < mappings[ codimVariable ].size(); ++i ) {
           typedef typename Codim<codim>::Mapping Mapping;
           mappings[ codimVariable ][ i ]->~Mapping();
           char* storage = (char*)mappings[ codimVariable ][ i ];
           delete[](storage);
        }
      }
    }
  };






  template< class ctype, int dim >
  class GenericReferenceElementContainer
  {
    static const unsigned int numTopologies = (1u << dim);

  public:
    typedef GenericReferenceElement< ctype, dim > value_type;

    const value_type &operator() ( const unsigned int topologyId ) const __attribute__((deprecated))
    {
      return values_[ topologyId ];
    }

    const value_type &operator() ( const GeometryType &type ) const
    {
      ((type.dim() == dim) ? static_cast<void> (0) : __assert_fail ("type.dim() == dim", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh", 577, __PRETTY_FUNCTION__));
      return values_[ type.id() ];
    }

    const value_type &simplex () const
    {
      return values_[ GenericGeometry::SimplexTopology< dim >::type::id ];
    }

    const value_type &cube () const
    {
      return values_[ GenericGeometry::CubeTopology< dim >::type::id ];
    }

    const value_type &pyramid () const
    {
      return values_[ GenericGeometry::PyramidTopology< dim >::type::id ];
    }

    const value_type &prism () const
    {
      return values_[ GenericGeometry::PrismTopology< dim >::type::id ];
    }

    static const GenericReferenceElementContainer &instance ()
    {
      static GenericReferenceElementContainer inst;
      return inst;
    }

  private:
    template< int topologyId >
    struct Builder
    {
      static void apply ( value_type (&values)[ numTopologies ] )
      {
        typedef typename GenericGeometry::Topology< topologyId, dim >::type Topology;
        values[ topologyId ].template initializeTopology< Topology >();
      }
    };

    GenericReferenceElementContainer ()
    {
      ForLoop< Builder, 0, numTopologies-1 >::apply( values_ );
    }

    value_type values_[ numTopologies ];
  };
# 638 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/genericreferenceelements.hh"
  template< class ctype, int dim >
  struct GenericReferenceElements
  {

    static const GenericReferenceElement< ctype, dim > &
    general ( const GeometryType &type )
    {
      return GenericReferenceElementContainer< ctype, dim >::instance()( type );
    }


    static const GenericReferenceElement< ctype, dim > &simplex ()
    {
      return GenericReferenceElementContainer< ctype, dim >::instance().simplex();
    }


    static const GenericReferenceElement< ctype, dim > &cube ()
    {
      return GenericReferenceElementContainer< ctype, dim >::instance().cube();
    }
  };

}
# 14 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/geometry.hh" 2


namespace Dune
{




template< int dim, int dimworld, class ct, class GridFamily >
class GridDefaultImplementation;
# 66 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/geometry.hh"
template<int mydim, int cdim, class GridImp, template<int,int,class> class GeometryImp>
class Geometry {

protected:
  GeometryImp<mydim,cdim,GridImp> realGeometry;


  typedef GeometryImp<mydim,cdim,GridImp> ImplementationType;
public:

  enum { dimension=GridImp::dimension };

  enum { mydimension=mydim };

  enum { coorddimension=cdim };


  enum { dimensionworld=GridImp::dimensionworld };

  typedef typename GridImp::ctype ctype;


  typedef FieldVector<ctype, mydim> LocalCoordinate;


  typedef FieldVector< ctype, cdim > GlobalCoordinate;


  typedef FieldMatrix<ctype,cdim,mydim> Jacobian;


  typedef FieldMatrix< ctype, mydim, cdim > JacobianTransposed;




  GeometryType type () const { return realGeometry.type(); }


  bool affine() const { return realGeometry.affine(); }







  int corners () const { return realGeometry.corners(); }
# 127 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/geometry.hh"
  GlobalCoordinate corner ( int i ) const
  {
    return realGeometry.corner(i);
  }





  GlobalCoordinate global (const LocalCoordinate& local) const
    {
      return realGeometry.global(local);
    }





  LocalCoordinate local (const GlobalCoordinate& global) const
    {
      return realGeometry.local(global);
    }
# 173 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/geometry.hh"
  ctype integrationElement (const LocalCoordinate& local) const
  {
    return realGeometry.integrationElement(local);
  }


  ctype volume () const
  {
    return realGeometry.volume();
  }
# 194 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/geometry.hh"
  GlobalCoordinate center () const
  {
    return realGeometry.center();
  }
# 208 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/geometry.hh"
  const JacobianTransposed &
  jacobianTransposed ( const LocalCoordinate& local ) const
  {
    return realGeometry.jacobianTransposed( local );
  }
# 233 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/geometry.hh"
  const Jacobian& jacobianInverseTransposed (const LocalCoordinate& local) const
  {
    return realGeometry.jacobianInverseTransposed(local);
  }

public:

  explicit Geometry(const GeometryImp<mydim,cdim,GridImp> & e) : realGeometry(e) {};

protected:

  friend class GridDefaultImplementation<
            GridImp::dimension, GridImp::dimensionworld,
            typename GridImp::ctype,
            typename GridImp::GridFamily> ;


  GeometryImp<mydim,cdim,GridImp> & getRealImp() { return realGeometry; }

  const GeometryImp<mydim,cdim,GridImp> & getRealImp() const { return realGeometry; }

protected:

  Geometry(const Geometry& rhs) : realGeometry(rhs.realGeometry) {};

  Geometry & operator = (const Geometry& rhs) {
    realGeometry = rhs.realGeometry;
    return *this;
  };
};
# 272 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/geometry.hh"
template<int mydim, int cdim, class GridImp, template<int,int,class> class GeometryImp>
class GeometryDefaultImplementation
{
public:

  typedef typename GridImp::ctype ctype;


  ctype volume () const
  {
    GeometryType type = asImp().type();


    const GenericReferenceElement< ctype , mydim > & refElement =
      GenericReferenceElements< ctype, mydim >::general(type);

    FieldVector<ctype,mydim> localBaryCenter (0.0);

    const int corners = refElement.size(0,0,mydim);
    for(int i=0; i<corners; ++i) localBaryCenter += refElement.position(i,mydim);
    localBaryCenter *= (ctype) (1.0/corners);


    return refElement.volume() * asImp().integrationElement(localBaryCenter);
  }


  FieldVector<ctype, cdim> center () const
  {
    GeometryType type = asImp().type();


    const GenericReferenceElement< ctype , mydim > & refElement =
      GenericReferenceElements< ctype, mydim >::general(type);



    return asImp().global(refElement.position(0,0));
  }

private:

  GeometryImp<mydim,cdim,GridImp>& asImp () {return static_cast<GeometryImp<mydim,cdim,GridImp>&>(*this);}
  const GeometryImp<mydim,cdim,GridImp>& asImp () const {return static_cast<const GeometryImp<mydim,cdim,GridImp>&>(*this);}
};

template<int cdim, class GridImp, template<int,int,class> class GeometryImp>
class GeometryDefaultImplementation<0,cdim,GridImp,GeometryImp>
{

  enum { mydim = 0 };
public:

  typedef typename GridImp::ctype ctype;


  FieldVector<ctype, cdim> global (const FieldVector<ctype, mydim>& local) const
  {
      return asImp().corner(0);
  }


  FieldVector<ctype, mydim> local (const FieldVector<ctype, cdim>& ) const
  {
    return FieldVector<ctype, mydim>();
  }


  bool checkInside (const FieldVector<ctype, mydim>& ) const
  {
    return true;
  }


  ctype volume () const
  {
    return 1.0;
  }


  FieldVector<ctype, cdim> center () const
  {
      return asImp().corner(0);
  }

private:

  GeometryImp<mydim,cdim,GridImp>& asImp () {return static_cast<GeometryImp<mydim,cdim,GridImp>&>(*this);}
  const GeometryImp<mydim,cdim,GridImp>& asImp () const {return static_cast<const GeometryImp<mydim,cdim,GridImp>&>(*this);}
};

}
# 11 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/geometry.hh" 2





namespace Dune
{

  namespace GenericGeometry
  {
# 250 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/geometry.hh"
    template< int mydim, class Traits >
    class BasicGeometry
    {
      typedef typename Traits :: CoordTraits CoordTraits;

      static const int dimGrid = Traits :: dimGrid;


      template< int, class > friend class BasicGeometry;

    public:


      static const int mydimension = mydim;


      static const int coorddimension = Traits :: dimWorld;


      typedef typename CoordTraits :: ctype ctype;


      typedef FieldVector< ctype, mydimension > LocalCoordinate;


      typedef FieldVector< ctype, coorddimension > GlobalCoordinate;

    private:
      typedef static_assert_test< sizeof(static_assert_failure< (bool)( (0 <= mydimension) && (mydimension <= dimGrid) )>) > dune_static_assert_typedef_279;


      static const int codimension = dimGrid - mydimension;

      template< bool >
      struct Hybrid
      {
        typedef HybridMapping< dimGrid, Traits > Mapping;
      };

      template< bool >
      struct NonHybrid
      {
        typedef typename GenericGeometry::Topology< Traits::topologyId, dimGrid >::type Topology;
        typedef GenericGeometry::CachedMapping< Topology, Traits > Mapping;
      };

      typedef typename SelectType< Traits::hybrid, Hybrid< true >, NonHybrid< false > >::Type::Mapping
        ElementMapping;
      typedef GenericGeometry::MappingProvider< ElementMapping, codimension > MappingProvider;

    protected:
      typedef typename MappingProvider::Mapping Mapping;

    public:





      typedef typename Mapping::JacobianTransposed JacobianTransposed;





      typedef typename Mapping::JacobianInverseTransposed JacobianInverseTransposed;

    public:


      BasicGeometry ()
      : mapping_(nullptr)
      {}






      template< class CoordVector >
      __attribute__((deprecated)) BasicGeometry ( const unsigned int topologyId, const CoordVector &coords )
      {
        mapping_ = MappingProvider::construct( topologyId, coords, mappingStorage_ );
      }
# 344 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/geometry.hh"
      template< class CoordVector >
      __attribute__((deprecated)) BasicGeometry ( const unsigned int topologyId, const CoordVector &coords, const bool affine )
      {
        mapping_ = MappingProvider::construct( topologyId, coords, affine, mappingStorage_ );
      }


      template< class CoordVector >
      BasicGeometry ( const GeometryType &type, const CoordVector &coords )
      {
        mapping_ = MappingProvider::construct( type.id(), coords, mappingStorage_ );
      }
# 370 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/geometry.hh"
      template< int fatherdim >
      BasicGeometry ( const BasicGeometry< fatherdim, Traits > &father, int i )
      {
        const unsigned int codim = fatherdim - mydim;
        mapping_ = father.mapping_->template trace< codim >( i, mappingStorage_ );
      }


      BasicGeometry ( const BasicGeometry &other )
      {
          mapping_ = (other.mapping_) ? other.mapping_->clone( mappingStorage_ ) : nullptr;
      }


      ~BasicGeometry ()
      {
        if (mapping_)
          mapping_->~Mapping();
      }


      BasicGeometry &operator= ( const BasicGeometry &other )
      {
        if (mapping_)
          mapping_->~Mapping();
        mapping_ = (other.mapping_) ? other.mapping_->clone( mappingStorage_ ) : nullptr;
        return *this;
      }




      bool operator! () const
      {
        return (mapping_ == 0);
      }


      GeometryType type () const
      {
        return GeometryType( mapping_->topologyId(), mydimension );
      }


      int corners () const
      {
        return mapping_->numCorners();
      }


      const GlobalCoordinate &operator[] ( int i ) const
      {
        return mapping_->corner( i );
      }


      GlobalCoordinate corner ( const int i ) const
      {
        return mapping_->corner( i );
      }


      GlobalCoordinate global ( const LocalCoordinate &local ) const
      {
        return mapping_->global( local );
      }


      LocalCoordinate local ( const GlobalCoordinate &global ) const
      {
        return mapping_->local( global );
      }


      GlobalCoordinate center () const
      {
        return mapping_->center();
      }


      bool affine () const
      {
        return mapping_->affine();
      }


      ctype integrationElement ( const LocalCoordinate &local ) const
      {
        return mapping_->integrationElement( local );
      }


      ctype volume () const
      {
        return mapping_->volume();
      }





      const JacobianTransposed &jacobianTransposed ( const LocalCoordinate &local ) const
      {
        return mapping_->jacobianTransposed( local );
      }



      const JacobianInverseTransposed &jacobianInverseTransposed ( const LocalCoordinate &local ) const
      {
        return mapping_->jacobianInverseTransposed( local );
      }
# 493 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/geometry.hh"
      GlobalCoordinate normal ( int face, const LocalCoordinate &local ) const __attribute__((deprecated))
      {
        const GenericReferenceElement< ctype, mydimension > &refElement
          = GenericReferenceElements< ctype, mydimension>::general( type() );
        ((face < refElement.size( 1 )) ? static_cast<void> (0) : __assert_fail ("face < refElement.size( 1 )", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/geometry.hh", 497, __PRETTY_FUNCTION__));

        const JacobianInverseTransposed &jit = jacobianInverseTransposed( local );
        const LocalCoordinate &refNormal = refElement.volumeOuterNormal( face );

        GlobalCoordinate normal;
        jit.mv( refNormal, normal );
        normal *= integrationElement( local );
        return normal;
      }

    private:


      Mapping* mapping_;






      char mappingStorage_[ MappingProvider::maxMappingSize ];
    };
# 538 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/geometry.hh"
    template< int mydim, int cdim, class Grid >
    class Geometry
    : public BasicGeometry< mydim, GlobalGeometryTraits< Grid > >
    {
      typedef BasicGeometry< mydim, GlobalGeometryTraits< Grid > > Base;

    protected:
      typedef typename Base::Mapping Mapping;

    public:

      Geometry ()
      {}

      template< class CoordVector >
      __attribute__((deprecated)) Geometry ( const unsigned int topologyId, const CoordVector &coords )
      : Base( topologyId, coords )
      {}

      template< class CoordVector >
      __attribute__((deprecated)) Geometry ( const unsigned int topologyId, const CoordVector &coords, const bool affine )
      : Base( topologyId, coords, affine )
      {}


      template< class Geo >
      explicit Geometry ( const Geo &geo )
      : Base( geo.type(), geo, geo.affine() )
      {}


      template< class CoordVector >
      Geometry ( const GeometryType &type, const CoordVector &coords )
      : Base( type, coords )
      {}


      template< int fatherdim >
      Geometry ( const Geometry< fatherdim, cdim, Grid > &father, int i )
      : Base( father, i )
      {}
    };
# 598 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/genericgeometry/geometry.hh"
    template< int mydim, int cdim, class Grid >
    class LocalGeometry
    : public BasicGeometry< mydim, LocalGeometryTraits< Grid > >
    {
      typedef BasicGeometry< mydim, LocalGeometryTraits< Grid > > Base;

    protected:
      typedef typename Base::Mapping Mapping;

    public:
      template< class CoordVector >
      __attribute__((deprecated)) LocalGeometry ( const unsigned int topologyId, const CoordVector &coords )
      : Base( topologyId, coords )
      {}

      template< class CoordVector >
      __attribute__((deprecated)) LocalGeometry ( const unsigned int topologyId, const CoordVector &coords, const bool affine )
      : Base( topologyId, coords, affine )
      {}


      template< class Geo >
      explicit LocalGeometry ( const Geo &geo )
      : Base( geo.type(), geo, geo.affine() )
      {}


      template< class CoordVector >
      LocalGeometry ( const GeometryType &type, const CoordVector &coords )
      : Base( type, coords )
      {}


      template< int fatherdim >
      LocalGeometry ( const Geometry< fatherdim, cdim, Grid > &father, int i )
      : Base( father, i )
      {}
    };

  }

}
# 13 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/utility/mockgeometry.hh" 2


namespace Dune {
# 32 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/utility/mockgeometry.hh"
  template<class ctype, std::size_t mydim, std::size_t coorddim>
  class MockGeometry :
    public GenericGeometry::BasicGeometry<
      mydim, GenericGeometry::DefaultGeometryTraits<ctype, coorddim, coorddim>
      >
  {
    typedef GenericGeometry::DefaultGeometryTraits<ctype, coorddim, coorddim>
      Traits;
    typedef GenericGeometry::BasicGeometry<mydim, Traits> Base;


    using typename Base::JacobianInverseTransposed;
    using typename Base::operator[];
    using typename Base::normal;

  public:

    typedef FieldMatrix<ctype, coorddim, mydim> Jacobian;

    typedef FieldMatrix<ctype, mydim, coorddim> JacobianTransposed;


    MockGeometry() {}

    template<class CoordVector>
    MockGeometry(const GeometryType &type, const CoordVector &coords) :
      Base(type, coords)
    { }

    template<int fatherdim>
    MockGeometry(const MockGeometry<ctype, fatherdim, coorddim> &father,
                 int i) :
      Base(static_cast<const GenericGeometry::BasicGeometry<
             fatherdim,
             GenericGeometry::DefaultGeometryTraits<ctype, coorddim, coorddim>
             > &>(father),
           i)
    { }


    JacobianTransposed jacobianTransposed
    (const typename Base::LocalCoordinate &local) const
    { return Base::jacobianTransposed(local); }

    Jacobian jacobianInverseTransposed
    (const typename Base::LocalCoordinate &local) const
    { return Base::jacobianInverseTransposed(local); }
  };

}
# 18 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/test/test-edges0.5.cc" 2
# 1 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/utility/vertexorder.hh" 1







# 1 "/usr/include/c++/4.4/cassert" 1 3
# 43 "/usr/include/c++/4.4/cassert" 3
# 43 "/usr/include/c++/4.4/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 45 "/usr/include/c++/4.4/cassert" 2 3
# 9 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/utility/vertexorder.hh" 2
# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 10 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/utility/vertexorder.hh" 2
# 1 "/usr/include/c++/4.4/functional" 1 3
# 47 "/usr/include/c++/4.4/functional" 3
# 47 "/usr/include/c++/4.4/functional" 3
# 11 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/utility/vertexorder.hh" 2








namespace Dune {
# 37 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/utility/vertexorder.hh"
  template<class InIterator, class OutIterator>
  void reduceOrder(const InIterator& inBegin, const InIterator& inEnd,
                   OutIterator outIt)
  {
    typedef std::less<
      typename std::iterator_traits<InIterator>::value_type
      > less_t;
    static const less_t less = less_t();

    for(InIterator inIt = inBegin; inIt != inEnd; ++inIt, ++outIt)
      *outIt = std::count_if(inBegin, inEnd, std::bind2nd(less, *inIt));
  }
# 66 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/utility/vertexorder.hh"
  template<std::size_t dim, class Index_ = std::size_t>
  class GeneralVertexOrder {
    typedef GenericReferenceElement<double, dim> RefElem;
    typedef GenericReferenceElements<double, dim> RefElems;

    const RefElem& refelem;
    GeometryType gt;
    std::vector<Index_> vertexOrder;

  public:

    typedef Index_ Index;


    class iterator;


    static const std::size_t dimension = dim;

    const GeometryType &type() const { return gt; }
# 96 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/utility/vertexorder.hh"
    template<class InIterator>
    GeneralVertexOrder(const GeometryType& gt_, const InIterator &inBegin,
                       const InIterator &inEnd) :
      refelem(RefElems::general(gt_)), gt(gt_),
      vertexOrder(refelem.size(dim))
    { reduceOrder(inBegin, inEnd, vertexOrder.begin()); }






    iterator begin(std::size_t codim, std::size_t subEntity) const
    { return iterator(*this, codim, subEntity); }





    iterator end(std::size_t codim, std::size_t subEntity) const {
      return iterator(*this, codim, subEntity,
                      refelem.size(subEntity, codim, dim));
    }
# 128 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/utility/vertexorder.hh"
    void getReduced(std::size_t codim, std::size_t subEntity,
                    std::vector<Index>& order) const
    {
      order.resize(refelem.size(subEntity, codim, dim));
      reduceOrder(begin(codim, subEntity), end(codim, subEntity),
                  order.begin());
    }
  };





  template<std::size_t dim, class Index_>
  class GeneralVertexOrder<dim, Index_>::iterator :
    public Dune::RandomAccessIteratorFacade<iterator, const Index_>
  {
    const GeneralVertexOrder *order;
    std::size_t codim;
    std::size_t subEntity;
    std::size_t vertex;

    iterator(const GeneralVertexOrder &order_, std::size_t codim_,
             std::size_t subEntity_, std::size_t vertex_ = 0) :
      order(&order_), codim(codim_), subEntity(subEntity_), vertex(vertex_)
    { }

  public:
    const Index &dereference() const {
      return order->vertexOrder[order->refelem.subEntity(subEntity, codim,
                                                         vertex, dim)];
    }
    const Index &elementAt(std::ptrdiff_t n) const {
      return order->vertexOrder[order->refelem.subEntity(subEntity, codim,
                                                         vertex+n, dim)];
    }
    bool equals(const iterator &other) const {
      return order == other.order && codim == other.codim &&
        subEntity == other.subEntity && vertex == other.vertex;
    }
    void increment() { ++vertex; }
    void decrement() { --vertex; }
    void advance(std::ptrdiff_t n) { vertex += n; }
    std::ptrdiff_t distanceTo(const iterator &other) const {

      ((order == other.order && codim == other.codim && subEntity == other.subEntity) ? static_cast<void> (0) : __assert_fail ("order == other.order && codim == other.codim && subEntity == other.subEntity", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/utility/vertexorder.hh", 174, __PRETTY_FUNCTION__));

      if(vertex < other.vertex) return other.vertex - vertex;
      else return -static_cast<std::ptrdiff_t>(vertex - other.vertex);
    }

    friend class GeneralVertexOrder<dim, Index>;







    iterator() { }
  };
# 202 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/utility/vertexorder.hh"
  template<class IdSet, class Index = std::size_t>
  class VertexOrderByIdFactory {
    const IdSet& idset;

  public:

    template<std::size_t dim>
    struct VertexOrder {

      typedef GeneralVertexOrder<dim, Index> type;
    };
# 224 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/utility/vertexorder.hh"
    VertexOrderByIdFactory(const IdSet &idset_) : idset(idset_) { }
# 233 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/utility/vertexorder.hh"
    template<typename Element>
    typename VertexOrder<Element::mydimension>::type
    make(const Element &e) const {
      typedef GenericReferenceElements<
        typename Element::ctype,
        Element::mydimension
        > RefElems;
      std::size_t size =
        RefElems::general(e.type()).size(Element::mydimension);

      std::vector<typename IdSet::IdType> ids(size);
      for(std::size_t i = 0; i < size; ++i)
        ids[i] = idset.subId(e, i, Element::mydimension);
      return GeneralVertexOrder<Element::mydimension, Index>
        (e.type(), ids.begin(), ids.end());
    }
  };

}
# 19 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/test/test-edges0.5.cc" 2

# 1 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/whitney/edges0.5.hh" 1
# 19 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/whitney/edges0.5.hh"
# 1 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/whitney/edges0.5/basis.hh" 1






# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 8 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/whitney/edges0.5/basis.hh" 2
# 17 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/whitney/edges0.5/basis.hh"
# 1 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/common/localtoglobaladaptors.hh" 1






# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 8 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/common/localtoglobaladaptors.hh" 2








namespace Dune {
# 27 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/common/localtoglobaladaptors.hh"
  template<class LocalBasisTraits, std::size_t dimDomainGlobal_>
  struct LocalToGlobalBasisAdaptorTraits {
    typedef typename LocalBasisTraits::DomainFieldType DomainField;
    static const std::size_t dimDomainLocal = LocalBasisTraits::dimDomain;
    static const std::size_t dimDomainGlobal = dimDomainGlobal_;
    typedef typename LocalBasisTraits::DomainType DomainLocal;
    typedef FieldVector<DomainField, dimDomainGlobal> DomainGlobal;

    typedef typename LocalBasisTraits::RangeFieldType RangeField;
    static const std::size_t dimRange = LocalBasisTraits::dimRange;
    typedef typename LocalBasisTraits::RangeType Range;

    typedef FieldMatrix<RangeField, dimRange, dimDomainGlobal> Jacobian;

    static const std::size_t diffOrder = LocalBasisTraits::diffOrder;
  };
# 64 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/common/localtoglobaladaptors.hh"
  template<class LocalBasis, class Geometry>
  class ScalarLocalToGlobalBasisAdaptor {
    typedef static_assert_test< sizeof(static_assert_failure< (bool)( LocalBasis::Traits::dimRange == 1 )>) > dune_static_assert_typedef_68;


    typedef static_assert_test< sizeof(static_assert_failure< (bool)( (is_same<typename LocalBasis::Traits::DomainFieldType, typename Geometry::ctype>::value) )>) > dune_static_assert_typedef_72;



    typedef static_assert_test< sizeof(static_assert_failure< (bool)( static_cast<std::size_t>(LocalBasis::Traits::dimDomain) == static_cast<std::size_t>(Geometry::mydimension) )>) > dune_static_assert_typedef_77;





    const LocalBasis& localBasis;
    const Geometry& geometry;

  public:
    typedef LocalToGlobalBasisAdaptorTraits<typename LocalBasis::Traits,
                                            Geometry::coorddimension> Traits;
# 96 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/common/localtoglobaladaptors.hh"
    ScalarLocalToGlobalBasisAdaptor(const LocalBasis& localBasis_,
                                    const Geometry& geometry_) :
      localBasis(localBasis_), geometry(geometry_)
    { }

    std::size_t size() const { return localBasis.size(); }
# 110 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/common/localtoglobaladaptors.hh"
    std::size_t order() const {
      if(geometry.affine())

        return localBasis.order();
      else

        return localBasis.order() + Traits::dimDomainGlobal - 1;
    }

    void evaluateFunction(const typename Traits::DomainLocal& in,
                          std::vector<typename Traits::Range>& out) const
    {
      localBasis.evaluateFunction(in, out);
    }

    void evaluateJacobian(const typename Traits::DomainLocal& in,
                          std::vector<typename Traits::Jacobian>& out) const
    {
      std::vector<typename LocalBasis::Traits::JacobianType>
        localJacobian(size());
      localBasis.evaluateJacobian(in, localJacobian);

      const typename Geometry::Jacobian &geoJacobian =
        geometry.jacobianInverseTransposed(in);

      out.resize(size());
      for(std::size_t i = 0; i < size(); ++i)
        geoJacobian.mv(localJacobian[i][0], out[i][0]);
    }
  };
# 148 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/common/localtoglobaladaptors.hh"
  template<class LocalInterpolation, class Traits_>
  class LocalToGlobalInterpolationAdaptor {
    const LocalInterpolation& localInterpolation;

  public:
    typedef Traits_ Traits;
# 164 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/common/localtoglobaladaptors.hh"
    LocalToGlobalInterpolationAdaptor
    ( const LocalInterpolation& localInterpolation_) :
      localInterpolation(localInterpolation_)
    { }

    template<class Function, class Coeff>
    void interpolate(const Function& function, std::vector<Coeff>& out) const
    { localInterpolation.interpolate(function, out); }
  };
# 186 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/common/localtoglobaladaptors.hh"
  template<class LocalFiniteElement, class Geometry>
  struct ScalarLocalToGlobalFiniteElementAdaptor {



    struct Traits {
      typedef ScalarLocalToGlobalBasisAdaptor<typename LocalFiniteElement::
              Traits::LocalBasisType, Geometry> Basis;
      typedef LocalToGlobalInterpolationAdaptor<typename LocalFiniteElement::
              Traits::LocalInterpolationType, typename Basis::Traits>
              Interpolation;
      typedef typename LocalFiniteElement::Traits::LocalCoefficientsType
              Coefficients;
    };

  private:
    const LocalFiniteElement &localFE;
    typename Traits::Basis basis_;
    typename Traits::Interpolation interpolation_;

  public:
# 217 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/common/localtoglobaladaptors.hh"
    ScalarLocalToGlobalFiniteElementAdaptor
    ( const LocalFiniteElement& localFE_, const Geometry &geometry) :
      localFE(localFE_),
      basis_(localFE.localBasis(), geometry),
      interpolation_(localFE.localInterpolation())
    { }

    const typename Traits::Basis& basis() const { return basis_; }
    const typename Traits::Interpolation& interpolation() const
    { return interpolation_; }
    const typename Traits::Coefficients& coefficients() const
    { return localFE.localCoefficients(); }
    GeometryType type() const { return localFE.type(); }
  };
# 243 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/common/localtoglobaladaptors.hh"
  template<class LocalFiniteElement, class Geometry>
  class ScalarLocalToGlobalFiniteElementAdaptorFactory {
    const LocalFiniteElement& localFE;

  public:
    typedef ScalarLocalToGlobalFiniteElementAdaptor<LocalFiniteElement,
                                                    Geometry> FiniteElement;
# 260 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/common/localtoglobaladaptors.hh"
    ScalarLocalToGlobalFiniteElementAdaptorFactory
    (const LocalFiniteElement &localFE_) : localFE(localFE_) {}
# 274 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/common/localtoglobaladaptors.hh"
    const FiniteElement make(const Geometry& geometry) {
      return FiniteElement(localFE, geometry);
    }
  };

}
# 18 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/whitney/edges0.5/basis.hh" 2
# 1 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/lagrange/p1/p1localbasis.hh" 1






# 1 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/common/localbasis.hh" 1
# 13 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/common/localbasis.hh"
namespace Dune
{
# 38 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/common/localbasis.hh"
  template<class DF, int n, class D, class RF, int m, class R, class J, int dorder=0>
  struct LocalBasisTraits
  {

 typedef DF DomainFieldType;


 enum {

   dimDomain = n
 };


 typedef D DomainType;


 typedef RF RangeFieldType;


 enum {

   dimRange = m
 };


 typedef R RangeType;







 typedef J JacobianType;


 enum {

   diffOrder=dorder
 };
  };
# 101 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/common/localbasis.hh"
  template<class DF, int n, class D, class RF, int m, class R>
  struct C0LocalBasisTraits
  {

 typedef DF DomainFieldType;


 enum {

   dimDomain = n
 };


 typedef D DomainType;


 typedef RF RangeFieldType;


 enum {

   dimRange = m
 };


 typedef R RangeType;


 enum {

   diffOrder=0
 };
  };
# 152 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/common/localbasis.hh"
  template<class DF, int n, class D, class RF, int m, class R, class J>
  struct C1LocalBasisTraits : public C0LocalBasisTraits<DF,n,D,RF,m,R>
  {






 typedef J JacobianType;


 enum {

   diffOrder=1
 };
  };

  template<class DF, int n, class D, class RF, int m, class R, class J, int dorder>
  struct CkLocalBasisTraits : public C1LocalBasisTraits<DF,n,D,RF,m,R,J>
  {

 enum {

   diffOrder=dorder
 };
  };

}
# 8 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/lagrange/p1/p1localbasis.hh" 2

namespace Dune
{
# 22 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/lagrange/p1/p1localbasis.hh"
    template<class D, class R, int dim>
  class P1LocalBasis
  {
  public:

    typedef LocalBasisTraits<D,dim,Dune::FieldVector<D,dim>,R,1,Dune::FieldVector<R,1>,
          Dune::FieldMatrix<R,1,dim>, 2> Traits;


    unsigned int size () const
    {
      return dim+1;
    }


    inline void evaluateFunction (const typename Traits::DomainType& in,
                                  std::vector<typename Traits::RangeType>& out) const
    {
        out.resize(size());
        out[0] = 1.0;
        for (size_t i=0; i<dim; i++) {
            out[0] -= in[i];
            out[i+1] = in[i];
        }
    }


    inline void
    evaluateJacobian (const typename Traits::DomainType& in,
                      std::vector<typename Traits::JacobianType>& out) const
    {
        out.resize(size());

        for (int i=0; i<dim; i++)
            out[0][0][i] = -1;

        for (int i=0; i<dim; i++)
            for (int j=0; j<dim; j++)
                out[i+1][0][j] = (i==j);

    }


    template<unsigned int k>
    inline void evaluate (const typename Dune::array<int,k>& directions,
                                  const typename Traits::DomainType& in,
                                  std::vector<typename Traits::RangeType>& out) const
    {
        if (k==0)
            evaluateFunction(in, out);
        else if (k==1)
        {
            out.resize(size());

            out[0] = -1;
            for (int i=0; i<dim; i++)
                out[i+1] = (i==directions[0]);
        }
        else if (k==2)
        {
            out.resize(size());

            for (int i=0; i<dim+1; i++)
                out[i] = 0;
        }
    }


    unsigned int order () const
    {
      return 1;
    }
  };
}
# 19 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/whitney/edges0.5/basis.hh" 2
# 1 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/whitney/edges0.5/common.hh" 1






# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 8 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/whitney/edges0.5/common.hh" 2



namespace Dune {


  template<std::size_t dim, class DF = double>
  struct EdgeS0_5Common {

    static const GenericReferenceElement<DF, dim>& refelem;





    static const std::size_t s;
  };

  template<std::size_t dim, class DF>
  const GenericReferenceElement<DF, dim>& EdgeS0_5Common<dim,DF>::
  refelem(GenericReferenceElements<DF, dim>::simplex());

  template<std::size_t dim, typename DF>
  const std::size_t EdgeS0_5Common<dim,DF>::s(refelem.size(dim-1));

}
# 20 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/whitney/edges0.5/basis.hh" 2

namespace Dune {
# 37 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/whitney/edges0.5/basis.hh"
  template<class Geometry, class RF>
  class EdgeS0_5Basis :
    private EdgeS0_5Common<Geometry::mydimension, typename Geometry::ctype>
  {
  public:

    struct Traits {
      typedef typename Geometry::ctype DomainField;
      static const std::size_t dimDomainLocal = Geometry::mydimension;
      static const std::size_t dimDomainGlobal = Geometry::coorddimension;
      typedef FieldVector<DomainField, dimDomainLocal> DomainLocal;
      typedef FieldVector<DomainField, dimDomainGlobal> DomainGlobal;

      typedef RF RangeField;
      static const std::size_t dimRange = dimDomainLocal;
      typedef FieldVector<RangeField, dimRange> Range;

      typedef FieldMatrix<RangeField, dimRange, dimDomainGlobal> Jacobian;

      static const std::size_t diffOrder = 1;
    };

  private:
    typedef Dune::P1LocalBasis<typename Traits::DomainField,
                               typename Traits::RangeField,
                               Traits::dimDomainLocal
                               > P1LocalBasis;
    typedef ScalarLocalToGlobalBasisAdaptor<P1LocalBasis, Geometry> P1Basis;

    static const P1LocalBasis& p1LocalBasis;
    static const std::size_t dim = Traits::dimDomainLocal;

    typedef EdgeS0_5Common<dim, typename Geometry::ctype> Base;
    using Base::refelem;
    using Base::s;


    std::vector<typename P1Basis::Traits::Jacobian> p1j;

    std::vector<typename Traits::DomainField> edgel;

  public:







    template<typename VertexOrder>
    EdgeS0_5Basis(const Geometry& geo, const VertexOrder& vertexOrder) :
      p1j(s, typename P1Basis::Traits::Jacobian(0)), edgel(s)
    {

      static const typename Traits::DomainLocal xl(0);


      P1Basis(p1LocalBasis, geo).evaluateJacobian(xl, p1j);


      for(std::size_t i = 0; i < s; ++i) {
        edgel[i] = (geo.corner(refelem.subEntity(i,dim-1,0,dim))-
                    geo.corner(refelem.subEntity(i,dim-1,1,dim))
                    ).two_norm();
        const typename VertexOrder::iterator& edgeVertexOrder =
          vertexOrder.begin(dim-1, i);
        if(edgeVertexOrder[0] > edgeVertexOrder[1])
          edgel[i] *= -1;
      }
    }


    std::size_t size () const { return s; }


    void evaluateFunction(const typename Traits::DomainLocal& xl,
                          std::vector<typename Traits::Range>& out) const
    {
      out.assign(s, typename Traits::Range(0));



      std::vector<typename P1LocalBasis::Traits::RangeType> p1v;
      p1LocalBasis.evaluateFunction(xl, p1v);

      for(std::size_t i = 0; i < s; i++) {
        const std::size_t i0 = refelem.subEntity(i,dim-1,0,dim);
        const std::size_t i1 = refelem.subEntity(i,dim-1,1,dim);
        out[i].axpy( p1v[i0], p1j[i1][0]);
        out[i].axpy(-p1v[i1], p1j[i0][0]);
        out[i] *= edgel[i];
      }
    }


    void evaluateJacobian(const typename Traits::DomainLocal&,
                          std::vector<typename Traits::Jacobian>& out) const
    {
      out.resize(s);

      for(std::size_t i = 0; i < s; i++) {
        const std::size_t i0 = refelem.subEntity(i,dim-1,0,dim);
        const std::size_t i1 = refelem.subEntity(i,dim-1,1,dim);
        for(std::size_t j = 0; j < dim; j++)
          for(std::size_t k = 0; k < dim; k++)
            out[i][j][k] = edgel[i] *
              (p1j[i0][0][k]*p1j[i1][0][j]-p1j[i1][0][k]*p1j[i0][0][j]);
      }
    }


    std::size_t order () const { return 1; }
  };

  template<class Geometry, class RF>
  const typename EdgeS0_5Basis<Geometry, RF>::P1LocalBasis&
  EdgeS0_5Basis<Geometry, RF>::p1LocalBasis = P1LocalBasis();

}
# 20 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/whitney/edges0.5.hh" 2
# 1 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/whitney/edges0.5/coefficients.hh" 1






# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 8 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/whitney/edges0.5/coefficients.hh" 2


# 1 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/common/localkey.hh" 1




# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 6 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/common/localkey.hh" 2



namespace Dune
{
# 19 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/common/localkey.hh"
  class LocalKey
  {
  public:


      enum {
# 33 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/common/localkey.hh"
          intersectionCodim=666
      };


 LocalKey ()
 {}






 LocalKey (unsigned int s, unsigned int c, unsigned int i)
 {
        values_[0] = s;
        values_[1] = c;
        values_[2] = i;
    }


 inline unsigned int subEntity () const
 {
   return values_[0];
 }


 inline unsigned int codim () const
 {
   return values_[1];
 }


 inline unsigned int index () const
 {
   return values_[2];
 }


 void index (unsigned int i)
 {
   values_[2] = i;
 }


      bool operator< (const LocalKey& other) const
      {
          return values_ < other.values_;
      }


      friend std::ostream& operator<< (std::ostream& s, const LocalKey& localKey)
      {
          return s << "[ subEntity: " << localKey.subEntity()
                   << ", codim: " << localKey.codim()
                   << ", index: " << localKey.index() << " ]";
      }

  private:


      Dune::array<unsigned int,3> values_;

  };

}
# 11 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/whitney/edges0.5/coefficients.hh" 2


namespace Dune {
# 27 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/whitney/edges0.5/coefficients.hh"
  template<std::size_t dim>
  class EdgeS0_5Coefficients : private EdgeS0_5Common<dim> {
    using EdgeS0_5Common<dim>::s;

    std::vector<LocalKey> li;

  public:

    EdgeS0_5Coefficients() : li(s) {
      for(std::size_t i = 0; i < s; i++)
        li[i] = LocalKey(i, dim-1, 0);
    }


    std::size_t size () const { return s; }


    const LocalKey& localKey(std::size_t i) const { return li[i]; }
  };

}
# 21 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/whitney/edges0.5.hh" 2
# 1 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/whitney/edges0.5/interpolation.hh" 1






# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 8 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/whitney/edges0.5/interpolation.hh" 2




namespace Dune {
# 26 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/whitney/edges0.5/interpolation.hh"
  template<class Geometry, class Traits_>
  class EdgeS0_5Interpolation :
    private EdgeS0_5Common<Traits_::dimDomainLocal,
                           typename Traits_::DomainField>
  {
  public:
    typedef Traits_ Traits;

  private:
    static const std::size_t dim = Traits::dimDomainLocal;
    typedef EdgeS0_5Common<dim, typename Traits::DomainField> Base;
    using Base::refelem;
    using Base::s;

    std::vector<typename Traits::DomainGlobal> edgev;

  public:







    template<typename VertexOrder>
    EdgeS0_5Interpolation(const Geometry& geo,
                          const VertexOrder& vertexOrder) :
      edgev(s)
    {
      for(std::size_t i = 0; i < s; ++i) {
        const std::size_t i0 = refelem.subEntity(i,dim-1,0,dim);
        const std::size_t i1 = refelem.subEntity(i,dim-1,1,dim);

        edgev[i] = geo.corner(i1);
        edgev[i] -= geo.corner(i0);
        edgev[i] /= edgev[i].two_norm();

        const typename VertexOrder::iterator& edgeVertexOrder =
          vertexOrder.begin(dim-1, i);
        if(edgeVertexOrder[0] > edgeVertexOrder[1])
          edgev[i] *= -1;
      }
    }


    template<typename F, typename C>
    void interpolate(const F& f, std::vector<C>& out) const {
      typename Traits::Range y;

      out.resize(s);

      for(std::size_t i = 0; i < s; ++i) {
        f.evaluate(refelem.position(i,dim-1), y);

        out[i] = y * edgev[i];
      }
    }
  };

}
# 22 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/whitney/edges0.5.hh" 2

namespace Dune {
# 47 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/whitney/edges0.5.hh"
  template<class Geometry, class RF>
  class EdgeS0_5FiniteElement {
  public:



    struct Traits {
      typedef EdgeS0_5Basis<Geometry, RF> Basis;
      typedef EdgeS0_5Interpolation<Geometry,
                                    typename Basis::Traits> Interpolation;
      typedef EdgeS0_5Coefficients<Geometry::mydimension> Coefficients;
    };

  private:
    typename Traits::Basis basis_;
    typename Traits::Interpolation interpolation_;
    static const typename Traits::Coefficients& coefficients_;
    static const GeometryType gt;

  public:





    template<class VertexOrder>
    EdgeS0_5FiniteElement(const Geometry& geo,
                          const VertexOrder& vertexOrder) :
      basis_(geo, vertexOrder), interpolation_(geo, vertexOrder)
    { }


    const typename Traits::Basis& basis() const { return basis_; }

    const typename Traits::Interpolation& interpolation() const
    { return interpolation_; }

    const typename Traits::Coefficients& coefficients() const
    { return coefficients_; }

    const GeometryType& type() const { return gt; }
  };

  template<class Geometry, class RF>
  const typename EdgeS0_5FiniteElement<Geometry, RF>::Traits::Coefficients&
  EdgeS0_5FiniteElement<Geometry, RF>::coefficients_ =
    typename Traits::Coefficients();

  template<class Geometry, class RF>
  const GeometryType
  EdgeS0_5FiniteElement<Geometry, RF>::gt(GeometryType::simplex,
                                          Geometry::mydimension);
# 115 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/whitney/edges0.5.hh"
  template<class Geometry, class RF>
  struct EdgeS0_5FiniteElementFactory {
    typedef EdgeS0_5FiniteElement<Geometry, RF> FiniteElement;
# 134 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/whitney/edges0.5.hh"
    template<class VertexOrder>
    const FiniteElement make(const Geometry& geometry,
                             const VertexOrder& vertexOrder)
    { return FiniteElement(geometry, vertexOrder); }
  };

}
# 21 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/test/test-edges0.5.cc" 2

# 1 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/test/geometries.hh" 1






# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 8 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/test/geometries.hh" 2








template<class ctype, std::size_t dim>
class TestGeometries;

template<class ctype>
class TestGeometries<ctype, 0> :
  public std::vector<Dune::MockGeometry<ctype, 0, 0> >
{
  static const std::size_t dim = 0;

public:
  typedef Dune::MockGeometry<ctype, dim, dim> Geometry;

  TestGeometries() {
    Dune::GeometryType gt;
    std::vector<Dune::FieldVector<ctype, dim> > coords;

    gt.makeVertex();
    coords.resize(1);
    push_back(Geometry(gt, coords));
  }

  const Geometry &get(const Dune::GeometryType &gt) const {
    for(std::size_t i = 0; i < this->size(); ++i)
      if((*this)[i].type() == gt) return (*this)[i];
    do { Dune::NotImplemented th__ex; std::ostringstream th__out; th__out << "Dune::NotImplemented" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/test/geometries.hh" << ":" << 41 << "]: " << "No predefined test-geometry in " "dimension " << dim << " for GeometryType " << gt; th__ex.message(th__out.str()); throw th__ex; } while (0);

  }
};

template<class ctype>
class TestGeometries<ctype, 1> :
  public std::vector<Dune::MockGeometry<ctype, 1, 1> >
{
  static const std::size_t dim = 1;

public:
  typedef Dune::MockGeometry<ctype, dim, dim> Geometry;

  TestGeometries() {
    Dune::GeometryType gt;
    std::vector<Dune::FieldVector<ctype, dim> > coords;

    gt.makeLine();
    coords.resize(2);
    coords[0][0] = -.3;
    coords[1][0] = .7;
    push_back(Geometry(gt, coords));
  }

  const Geometry &get(const Dune::GeometryType &gt) const {
    for(std::size_t i = 0; i < this->size(); ++i)
      if((*this)[i].type() == gt) return (*this)[i];
    do { Dune::NotImplemented th__ex; std::ostringstream th__out; th__out << "Dune::NotImplemented" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/test/geometries.hh" << ":" << 69 << "]: " << "No predefined test-geometry in " "dimension " << dim << " for GeometryType " << gt; th__ex.message(th__out.str()); throw th__ex; } while (0);

  }
};

template<class ctype>
class TestGeometries<ctype, 2> :
  public std::vector<Dune::MockGeometry<ctype, 2, 2> >
{
  static const std::size_t dim = 2;

public:
  typedef Dune::MockGeometry<ctype, dim, dim> Geometry;

  TestGeometries() {
    Dune::GeometryType gt;
    std::vector<Dune::FieldVector<ctype, dim> > coords;

    gt.makeTriangle();
    coords.resize(3);
    coords[0][0] = -.5; coords[0][1] = -.5;
    coords[1][0] = .5; coords[1][1] = -.5;
    coords[2][0] = 0 ; coords[2][1] = .5;
    push_back(Geometry(gt, coords));

    gt.makeQuadrilateral();
    coords.resize(4);
    coords[0][0] = -.5; coords[0][1] = 0;
    coords[1][0] = 0 ; coords[1][1] = -.5;
    coords[2][0] = .5; coords[2][1] = 0;
    coords[3][0] = 0 ; coords[3][1] = .5;
    push_back(Geometry(gt, coords));
  }

  const Geometry &get(const Dune::GeometryType &gt) const {
    for(std::size_t i = 0; i < this->size(); ++i)
      if((*this)[i].type() == gt) return (*this)[i];
    do { Dune::NotImplemented th__ex; std::ostringstream th__out; th__out << "Dune::NotImplemented" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/test/geometries.hh" << ":" << 106 << "]: " << "No predefined test-geometry in " "dimension " << dim << " for GeometryType " << gt; th__ex.message(th__out.str()); throw th__ex; } while (0);

  }
};

template<class ctype>
class TestGeometries<ctype, 3> :
  public std::vector<Dune::MockGeometry<ctype, 3, 3> >
{
  static const std::size_t dim = 3;

public:
  typedef Dune::MockGeometry<ctype, dim, dim> Geometry;

  TestGeometries() {
    Dune::GeometryType gt;
    std::vector<Dune::FieldVector<ctype, dim> > coords;

    gt.makeTetrahedron();
    coords.resize(4);
    coords[0][0] = -.5; coords[0][1] = -.5; coords[0][2] = -.5;
    coords[1][0] = .5; coords[1][1] = -.5; coords[1][2] = -.5;
    coords[2][0] = 0 ; coords[2][1] = .5; coords[2][2] = -.5;
    coords[3][0] = 0 ; coords[3][1] = 0 ; coords[3][2] = .5;
    push_back(Geometry(gt, coords));

    gt.makePyramid();
    coords.resize(5);
    coords[0][0] = -.5; coords[0][1] = 0; coords[0][2] = -.5;
    coords[1][0] = 0 ; coords[1][1] = -.5; coords[1][2] = -.5;
    coords[2][0] = .5; coords[2][1] = 0; coords[2][2] = -.5;
    coords[3][0] = 0 ; coords[3][1] = .5; coords[3][2] = -.5;
    coords[4][0] = .1; coords[4][1] = .1; coords[4][2] = .1;
    push_back(Geometry(gt, coords));

    gt.makePrism();
    coords.resize(6);
    coords[0][0] = -.6; coords[0][1] = -.5; coords[0][2] = -.4;
    coords[1][0] = .5; coords[1][1] = -.6; coords[1][2] = -.5;
    coords[2][0] = .1; coords[2][1] = .5; coords[2][2] = -.6;
    coords[3][0] = -.5; coords[3][1] = -.4; coords[3][2] = .5;
    coords[4][0] = .4; coords[4][1] = -.5; coords[4][2] = .6;
    coords[5][0] = 0 ; coords[5][1] = .4; coords[5][2] = .5;
    push_back(Geometry(gt, coords));

    gt.makeHexahedron();
    coords.resize(8);
    coords[0][0] = -.7; coords[0][1] = -.6; coords[0][2] = -.5;
    coords[1][0] = .4; coords[1][1] = -.3; coords[1][2] = -.7;
    coords[2][0] = -.6; coords[2][1] = .5; coords[2][2] = -.4;
    coords[3][0] = .3; coords[3][1] = .7; coords[3][2] = -.6;
    coords[4][0] = -.5; coords[4][1] = -.4; coords[4][2] = .3;
    coords[5][0] = .7; coords[5][1] = -.6; coords[5][2] = .5;
    coords[6][0] = -.4; coords[6][1] = .3; coords[6][2] = .7;
    coords[7][0] = .6; coords[7][1] = .5; coords[7][2] = .4;
    push_back(Geometry(gt, coords));
  }

  const Geometry &get(const Dune::GeometryType &gt) const {
    for(std::size_t i = 0; i < this->size(); ++i)
      if((*this)[i].type() == gt) return (*this)[i];
    do { Dune::NotImplemented th__ex; std::ostringstream th__out; th__out << "Dune::NotImplemented" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/test/geometries.hh" << ":" << 167 << "]: " << "No predefined test-geometry in " "dimension " << dim << " for GeometryType " << gt; th__ex.message(th__out.str()); throw th__ex; } while (0);

  }
};
# 23 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/test/test-edges0.5.cc" 2
# 1 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/test/test-fe.hh" 1







# 1 "/usr/include/c++/4.4/cmath" 1 3
# 41 "/usr/include/c++/4.4/cmath" 3
# 41 "/usr/include/c++/4.4/cmath" 3
# 9 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/test/test-fe.hh" 2
# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 10 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/test/test-fe.hh" 2
# 1 "/usr/include/c++/4.4/cstdlib" 1 3
# 41 "/usr/include/c++/4.4/cstdlib" 3
# 41 "/usr/include/c++/4.4/cstdlib" 3


# 1 "/usr/include/c++/4.4/cstddef" 1 3
# 41 "/usr/include/c++/4.4/cstddef" 3
# 41 "/usr/include/c++/4.4/cstddef" 3


# 1 "/home/cocktail/pipping/.local/clang/bin/../lib/clang/3.0/include/stddef.h" 1 3 4
# 44 "/usr/include/c++/4.4/cstddef" 2 3
# 44 "/usr/include/c++/4.4/cstdlib" 2 3
# 11 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/test/test-fe.hh" 2








# 1 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules.hh" 1
# 10 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules.hh"
# 1 "/usr/include/c++/4.4/map" 1 3
# 58 "/usr/include/c++/4.4/map" 3
# 58 "/usr/include/c++/4.4/map" 3

# 1 "/usr/include/c++/4.4/bits/stl_tree.h" 1 3
# 67 "/usr/include/c++/4.4/bits/stl_tree.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 85 "/usr/include/c++/4.4/bits/stl_tree.h" 3
  enum _Rb_tree_color { _S_red = false, _S_black = true };

  struct _Rb_tree_node_base
  {
    typedef _Rb_tree_node_base* _Base_ptr;
    typedef const _Rb_tree_node_base* _Const_Base_ptr;

    _Rb_tree_color _M_color;
    _Base_ptr _M_parent;
    _Base_ptr _M_left;
    _Base_ptr _M_right;

    static _Base_ptr
    _S_minimum(_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Const_Base_ptr
    _S_minimum(_Const_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Base_ptr
    _S_maximum(_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }

    static _Const_Base_ptr
    _S_maximum(_Const_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }
  };

  template<typename _Val>
    struct _Rb_tree_node : public _Rb_tree_node_base
    {
      typedef _Rb_tree_node<_Val>* _Link_type;
      _Val _M_value_field;







    };

  _Rb_tree_node_base*
  _Rb_tree_increment(_Rb_tree_node_base* __x);

  const _Rb_tree_node_base*
  _Rb_tree_increment(const _Rb_tree_node_base* __x);

  _Rb_tree_node_base*
  _Rb_tree_decrement(_Rb_tree_node_base* __x);

  const _Rb_tree_node_base*
  _Rb_tree_decrement(const _Rb_tree_node_base* __x);

  template<typename _Tp>
    struct _Rb_tree_iterator
    {
      typedef _Tp value_type;
      typedef _Tp& reference;
      typedef _Tp* pointer;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
      typedef _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_iterator()
      : _M_node() { }

      explicit
      _Rb_tree_iterator(_Link_type __x)
      : _M_node(__x) { }

      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }

      pointer
      operator->() const
      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }

      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
  };

  template<typename _Tp>
    struct _Rb_tree_const_iterator
    {
      typedef _Tp value_type;
      typedef const _Tp& reference;
      typedef const _Tp* pointer;

      typedef _Rb_tree_iterator<_Tp> iterator;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_const_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
      typedef const _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_const_iterator()
      : _M_node() { }

      explicit
      _Rb_tree_const_iterator(_Link_type __x)
      : _M_node(__x) { }

      _Rb_tree_const_iterator(const iterator& __it)
      : _M_node(__it._M_node) { }

      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }

      pointer
      operator->() const
      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }

      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }

      _Base_ptr _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }

  void
  _Rb_tree_insert_and_rebalance(const bool __insert_left,
                                _Rb_tree_node_base* __x,
                                _Rb_tree_node_base* __p,
                                _Rb_tree_node_base& __header);

  _Rb_tree_node_base*
  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
          _Rb_tree_node_base& __header);


  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc = allocator<_Val> >
    class _Rb_tree
    {
      typedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other
              _Node_allocator;

    protected:
      typedef _Rb_tree_node_base* _Base_ptr;
      typedef const _Rb_tree_node_base* _Const_Base_ptr;

    public:
      typedef _Key key_type;
      typedef _Val value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef _Rb_tree_node<_Val>* _Link_type;
      typedef const _Rb_tree_node<_Val>* _Const_Link_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

      _Node_allocator&
      _M_get_Node_allocator()
      { return *static_cast<_Node_allocator*>(&this->_M_impl); }

      const _Node_allocator&
      _M_get_Node_allocator() const
      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Node_allocator()); }

    protected:
      _Link_type
      _M_get_node()
      { return _M_impl._Node_allocator::allocate(1); }

      void
      _M_put_node(_Link_type __p)
      { _M_impl._Node_allocator::deallocate(__p, 1); }


      _Link_type
      _M_create_node(const value_type& __x)
      {
 _Link_type __tmp = _M_get_node();
 try
   { get_allocator().construct(&__tmp->_M_value_field, __x); }
 catch(...)
   {
     _M_put_node(__tmp);
     throw;
   }
 return __tmp;
      }

      void
      _M_destroy_node(_Link_type __p)
      {
 get_allocator().destroy(&__p->_M_value_field);
 _M_put_node(__p);
      }
# 413 "/usr/include/c++/4.4/bits/stl_tree.h" 3
      _Link_type
      _M_clone_node(_Const_Link_type __x)
      {
 _Link_type __tmp = _M_create_node(__x->_M_value_field);
 __tmp->_M_color = __x->_M_color;
 __tmp->_M_left = 0;
 __tmp->_M_right = 0;
 return __tmp;
      }

    protected:
      template<typename _Key_compare,
        bool _Is_pod_comparator = __is_pod(_Key_compare)>
        struct _Rb_tree_impl : public _Node_allocator
        {
   _Key_compare _M_key_compare;
   _Rb_tree_node_base _M_header;
   size_type _M_node_count;

   _Rb_tree_impl()
   : _Node_allocator(), _M_key_compare(), _M_header(),
     _M_node_count(0)
   { _M_initialize(); }

   _Rb_tree_impl(const _Key_compare& __comp, const _Node_allocator& __a)
   : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),
     _M_node_count(0)
   { _M_initialize(); }

 private:
   void
   _M_initialize()
   {
     this->_M_header._M_color = _S_red;
     this->_M_header._M_parent = 0;
     this->_M_header._M_left = &this->_M_header;
     this->_M_header._M_right = &this->_M_header;
   }
 };

      _Rb_tree_impl<_Compare> _M_impl;

    protected:
      _Base_ptr&
      _M_root()
      { return this->_M_impl._M_header._M_parent; }

      _Const_Base_ptr
      _M_root() const
      { return this->_M_impl._M_header._M_parent; }

      _Base_ptr&
      _M_leftmost()
      { return this->_M_impl._M_header._M_left; }

      _Const_Base_ptr
      _M_leftmost() const
      { return this->_M_impl._M_header._M_left; }

      _Base_ptr&
      _M_rightmost()
      { return this->_M_impl._M_header._M_right; }

      _Const_Base_ptr
      _M_rightmost() const
      { return this->_M_impl._M_header._M_right; }

      _Link_type
      _M_begin()
      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }

      _Const_Link_type
      _M_begin() const
      {
 return static_cast<_Const_Link_type>
   (this->_M_impl._M_header._M_parent);
      }

      _Link_type
      _M_end()
      { return static_cast<_Link_type>(&this->_M_impl._M_header); }

      _Const_Link_type
      _M_end() const
      { return static_cast<_Const_Link_type>(&this->_M_impl._M_header); }

      static const_reference
      _S_value(_Const_Link_type __x)
      { return __x->_M_value_field; }

      static const _Key&
      _S_key(_Const_Link_type __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Link_type
      _S_left(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_left); }

      static _Const_Link_type
      _S_left(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_left); }

      static _Link_type
      _S_right(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_right); }

      static _Const_Link_type
      _S_right(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_right); }

      static const_reference
      _S_value(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x)->_M_value_field; }

      static const _Key&
      _S_key(_Const_Base_ptr __x)
      { return _KeyOfValue()(_S_value(__x)); }

      static _Base_ptr
      _S_minimum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Const_Base_ptr
      _S_minimum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Base_ptr
      _S_maximum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }

      static _Const_Base_ptr
      _S_maximum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }

    public:
      typedef _Rb_tree_iterator<value_type> iterator;
      typedef _Rb_tree_const_iterator<value_type> const_iterator;

      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    private:
      iterator
      _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __y,
   const value_type& __v);



      iterator
      _M_insert_lower(_Base_ptr __x, _Base_ptr __y, const value_type& __v);

      iterator
      _M_insert_equal_lower(const value_type& __x);

      _Link_type
      _M_copy(_Const_Link_type __x, _Link_type __p);

      void
      _M_erase(_Link_type __x);

      iterator
      _M_lower_bound(_Link_type __x, _Link_type __y,
       const _Key& __k);

      const_iterator
      _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
       const _Key& __k) const;

      iterator
      _M_upper_bound(_Link_type __x, _Link_type __y,
       const _Key& __k);

      const_iterator
      _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
       const _Key& __k) const;

    public:

      _Rb_tree() { }

      _Rb_tree(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_impl(__comp, __a) { }

      _Rb_tree(const _Rb_tree& __x)
      : _M_impl(__x._M_impl._M_key_compare, __x._M_get_Node_allocator())
      {
 if (__x._M_root() != 0)
   {
     _M_root() = _M_copy(__x._M_begin(), _M_end());
     _M_leftmost() = _S_minimum(_M_root());
     _M_rightmost() = _S_maximum(_M_root());
     _M_impl._M_node_count = __x._M_impl._M_node_count;
   }
      }





      ~_Rb_tree()
      { _M_erase(_M_begin()); }

      _Rb_tree&
      operator=(const _Rb_tree& __x);


      _Compare
      key_comp() const
      { return _M_impl._M_key_compare; }

      iterator
      begin()
      {
 return iterator(static_cast<_Link_type>
   (this->_M_impl._M_header._M_left));
      }

      const_iterator
      begin() const
      {
 return const_iterator(static_cast<_Const_Link_type>
         (this->_M_impl._M_header._M_left));
      }

      iterator
      end()
      { return iterator(static_cast<_Link_type>(&this->_M_impl._M_header)); }

      const_iterator
      end() const
      {
 return const_iterator(static_cast<_Const_Link_type>
         (&this->_M_impl._M_header));
      }

      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }

      bool
      empty() const
      { return _M_impl._M_node_count == 0; }

      size_type
      size() const
      { return _M_impl._M_node_count; }

      size_type
      max_size() const
      { return _M_get_Node_allocator().max_size(); }

      void



      swap(_Rb_tree& __t);



      pair<iterator, bool>
      _M_insert_unique(const value_type& __x);

      iterator
      _M_insert_equal(const value_type& __x);

      iterator
      _M_insert_unique_(const_iterator __position, const value_type& __x);

      iterator
      _M_insert_equal_(const_iterator __position, const value_type& __x);

      template<typename _InputIterator>
        void
        _M_insert_unique(_InputIterator __first, _InputIterator __last);

      template<typename _InputIterator>
        void
        _M_insert_equal(_InputIterator __first, _InputIterator __last);

      void
      erase(iterator __position);

      void
      erase(const_iterator __position);

      size_type
      erase(const key_type& __x);

      void
      erase(iterator __first, iterator __last);

      void
      erase(const_iterator __first, const_iterator __last);

      void
      erase(const key_type* __first, const key_type* __last);

      void
      clear()
      {
        _M_erase(_M_begin());
        _M_leftmost() = _M_end();
        _M_root() = 0;
        _M_rightmost() = _M_end();
        _M_impl._M_node_count = 0;
      }


      iterator
      find(const key_type& __k);

      const_iterator
      find(const key_type& __k) const;

      size_type
      count(const key_type& __k) const;

      iterator
      lower_bound(const key_type& __k)
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      lower_bound(const key_type& __k) const
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      iterator
      upper_bound(const key_type& __k)
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      upper_bound(const key_type& __k) const
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      pair<iterator, iterator>
      equal_range(const key_type& __k);

      pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;


      bool
      __rb_verify() const;
    };

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return __x.size() == __y.size()
      && std::equal(__x.begin(), __x.end(), __y.begin());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x == __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return __y < __x; }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__y < __x); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x < __y); }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { __x.swap(__y); }
# 849 "/usr/include/c++/4.4/bits/stl_tree.h" 3
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)
    {
      if (this != &__x)
 {

   clear();
   _M_impl._M_key_compare = __x._M_impl._M_key_compare;
   if (__x._M_root() != 0)
     {
       _M_root() = _M_copy(__x._M_begin(), _M_end());
       _M_leftmost() = _S_minimum(_M_root());
       _M_rightmost() = _S_maximum(_M_root());
       _M_impl._M_node_count = __x._M_impl._M_node_count;
     }
 }
      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __p, const _Val& __v)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || _M_impl._M_key_compare(_KeyOfValue()(__v),
            _S_key(__p)));

      _Link_type __z = _M_create_node(__v);

      _Rb_tree_insert_and_rebalance(__insert_left, __z,
        const_cast<_Base_ptr>(__p),
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_lower(_Base_ptr __x, _Base_ptr __p, const _Val& __v)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || !_M_impl._M_key_compare(_S_key(__p),
             _KeyOfValue()(__v)));

      _Link_type __z = _M_create_node(__v);

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal_lower(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert_lower(__x, __y, __v);
    }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
    _M_copy(_Const_Link_type __x, _Link_type __p)
    {

      _Link_type __top = _M_clone_node(__x);
      __top->_M_parent = __p;

      try
 {
   if (__x->_M_right)
     __top->_M_right = _M_copy(_S_right(__x), __top);
   __p = __top;
   __x = _S_left(__x);

   while (__x != 0)
     {
       _Link_type __y = _M_clone_node(__x);
       __p->_M_left = __y;
       __y->_M_parent = __p;
       if (__x->_M_right)
  __y->_M_right = _M_copy(_S_right(__x), __y);
       __p = __y;
       __x = _S_left(__x);
     }
 }
      catch(...)
 {
   _M_erase(__top);
   throw;
 }
      return __top;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase(_Link_type __x)
    {

      while (__x != 0)
 {
   _M_erase(_S_right(__x));
   _Link_type __y = _S_left(__x);
   _M_destroy_node(__x);
   __x = __y;
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Link_type __x, _Link_type __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Link_type __xu(__x), __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<iterator,
            iterator>(_M_lower_bound(__x, __y, __k),
        _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<iterator, iterator>(iterator(__y),
          iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Link_type __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Const_Link_type __xu(__x), __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<const_iterator,
            const_iterator>(_M_lower_bound(__x, __y, __k),
       _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<const_iterator, const_iterator>(const_iterator(__y),
        const_iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::



    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t)

    {
      if (_M_root() == 0)
 {
   if (__t._M_root() != 0)
     {
       _M_root() = __t._M_root();
       _M_leftmost() = __t._M_leftmost();
       _M_rightmost() = __t._M_rightmost();
       _M_root()->_M_parent = _M_end();

       __t._M_root() = 0;
       __t._M_leftmost() = __t._M_end();
       __t._M_rightmost() = __t._M_end();
     }
 }
      else if (__t._M_root() == 0)
 {
   __t._M_root() = _M_root();
   __t._M_leftmost() = _M_leftmost();
   __t._M_rightmost() = _M_rightmost();
   __t._M_root()->_M_parent = __t._M_end();

   _M_root() = 0;
   _M_leftmost() = _M_end();
   _M_rightmost() = _M_end();
 }
      else
 {
   std::swap(_M_root(),__t._M_root());
   std::swap(_M_leftmost(),__t._M_leftmost());
   std::swap(_M_rightmost(),__t._M_rightmost());

   _M_root()->_M_parent = _M_end();
   __t._M_root()->_M_parent = __t._M_end();
 }

      std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);



      std::__alloc_swap<_Node_allocator>::
 _S_do_it(_M_get_Node_allocator(), __t._M_get_Node_allocator());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator, bool>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_unique(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      bool __comp = true;
      while (__x != 0)
 {
   __y = __x;
   __comp = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x));
   __x = __comp ? _S_left(__x) : _S_right(__x);
 }
      iterator __j = iterator(__y);
      if (__comp)
 {
   if (__j == begin())
     return pair<iterator, bool>(_M_insert_(__x, __y, __v), true);
   else
     --__j;
 }
      if (_M_impl._M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))
 return pair<iterator, bool>(_M_insert_(__x, __y, __v), true);
      return pair<iterator, bool>(__j, false);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert_(__x, __y, __v);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_unique_(const_iterator __position, const _Val& __v)
    {

      if (__position._M_node == _M_end())
 {
   if (size() > 0
       && _M_impl._M_key_compare(_S_key(_M_rightmost()),
     _KeyOfValue()(__v)))
     return _M_insert_(0, _M_rightmost(), __v);
   else
     return _M_insert_unique(__v).first;
 }
      else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
          _S_key(__position._M_node)))
 {

   const_iterator __before = __position;
   if (__position._M_node == _M_leftmost())
     return _M_insert_(_M_leftmost(), _M_leftmost(), __v);
   else if (_M_impl._M_key_compare(_S_key((--__before)._M_node),
       _KeyOfValue()(__v)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert_(0, __before._M_node, __v);
       else
  return _M_insert_(__position._M_node,
      __position._M_node, __v);
     }
   else
     return _M_insert_unique(__v).first;
 }
      else if (_M_impl._M_key_compare(_S_key(__position._M_node),
          _KeyOfValue()(__v)))
 {

   const_iterator __after = __position;
   if (__position._M_node == _M_rightmost())
     return _M_insert_(0, _M_rightmost(), __v);
   else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
       _S_key((++__after)._M_node)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert_(0, __position._M_node, __v);
       else
  return _M_insert_(__after._M_node, __after._M_node, __v);
     }
   else
     return _M_insert_unique(__v).first;
 }
      else

 return iterator(static_cast<_Link_type>
   (const_cast<_Base_ptr>(__position._M_node)));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal_(const_iterator __position, const _Val& __v)
    {

      if (__position._M_node == _M_end())
 {
   if (size() > 0
       && !_M_impl._M_key_compare(_KeyOfValue()(__v),
      _S_key(_M_rightmost())))
     return _M_insert_(0, _M_rightmost(), __v);
   else
     return _M_insert_equal(__v);
 }
      else if (!_M_impl._M_key_compare(_S_key(__position._M_node),
           _KeyOfValue()(__v)))
 {

   const_iterator __before = __position;
   if (__position._M_node == _M_leftmost())
     return _M_insert_(_M_leftmost(), _M_leftmost(), __v);
   else if (!_M_impl._M_key_compare(_KeyOfValue()(__v),
        _S_key((--__before)._M_node)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert_(0, __before._M_node, __v);
       else
  return _M_insert_(__position._M_node,
      __position._M_node, __v);
     }
   else
     return _M_insert_equal(__v);
 }
      else
 {

   const_iterator __after = __position;
   if (__position._M_node == _M_rightmost())
     return _M_insert_(0, _M_rightmost(), __v);
   else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node),
        _KeyOfValue()(__v)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert_(0, __position._M_node, __v);
       else
  return _M_insert_(__after._M_node, __after._M_node, __v);
     }
   else
     return _M_insert_equal_lower(__v);
 }
    }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_unique(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   _M_insert_unique_(end(), *__first);
      }

  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_equal(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   _M_insert_equal_(end(), *__first);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (__position._M_node,
     this->_M_impl._M_header));
      _M_destroy_node(__y);
      --_M_impl._M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const_iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (const_cast<_Base_ptr>(__position._M_node),
     this->_M_impl._M_header));
      _M_destroy_node(__y);
      --_M_impl._M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key& __x)
    {
      pair<iterator, iterator> __p = equal_range(__x);
      const size_type __old_size = size();
      erase(__p.first, __p.second);
      return __old_size - size();
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   erase(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const_iterator __first, const_iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   erase(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key* __first, const _Key* __last)
    {
      while (__first != __last)
 erase(*__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k)
    {
      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k) const
    {
      const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    count(const _Key& __k) const
    {
      pair<const_iterator, const_iterator> __p = equal_range(__k);
      const size_type __n = std::distance(__p.first, __p.second);
      return __n;
    }

  unsigned int
  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
                       const _Rb_tree_node_base* __root);

  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    bool
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
    {
      if (_M_impl._M_node_count == 0 || begin() == end())
 return _M_impl._M_node_count == 0 && begin() == end()
        && this->_M_impl._M_header._M_left == _M_end()
        && this->_M_impl._M_header._M_right == _M_end();

      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
      for (const_iterator __it = begin(); __it != end(); ++__it)
 {
   _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
   _Const_Link_type __L = _S_left(__x);
   _Const_Link_type __R = _S_right(__x);

   if (__x->_M_color == _S_red)
     if ((__L && __L->_M_color == _S_red)
  || (__R && __R->_M_color == _S_red))
       return false;

   if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
     return false;
   if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
     return false;

   if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
     return false;
 }

      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
 return false;
      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
 return false;
      return true;
    }

}
# 60 "/usr/include/c++/4.4/map" 2 3
# 1 "/usr/include/c++/4.4/bits/stl_map.h" 1 3
# 64 "/usr/include/c++/4.4/bits/stl_map.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 84 "/usr/include/c++/4.4/bits/stl_map.h" 3
  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,
            typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class map
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::value_type _Alloc_value_type;





    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class map<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename _Alloc::template rebind<value_type>::other
        _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;


      _Rep_type _M_t;

    public:


      typedef typename _Pair_alloc_type::pointer pointer;
      typedef typename _Pair_alloc_type::const_pointer const_pointer;
      typedef typename _Pair_alloc_type::reference reference;
      typedef typename _Pair_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;







      map()
      : _M_t() { }






      explicit
      map(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 170 "/usr/include/c++/4.4/bits/stl_map.h" 3
      map(const map& __x)
      : _M_t(__x._M_t) { }
# 211 "/usr/include/c++/4.4/bits/stl_map.h" 3
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_unique(__first, __last); }
# 227 "/usr/include/c++/4.4/bits/stl_map.h" 3
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t._M_insert_unique(__first, __last); }
# 250 "/usr/include/c++/4.4/bits/stl_map.h" 3
      map&
      operator=(const map& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 295 "/usr/include/c++/4.4/bits/stl_map.h" 3
      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }







      iterator
      begin()
      { return _M_t.begin(); }






      const_iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end()
      { return _M_t.end(); }






      const_iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin()
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend()
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const
      { return _M_t.rend(); }
# 414 "/usr/include/c++/4.4/bits/stl_map.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 441 "/usr/include/c++/4.4/bits/stl_map.h" 3
      mapped_type&
      operator[](const key_type& __k)
      {



 iterator __i = lower_bound(__k);

 if (__i == end() || key_comp()(__k, (*__i).first))
          __i = insert(__i, value_type(__k, mapped_type()));
 return (*__i).second;
      }
# 463 "/usr/include/c++/4.4/bits/stl_map.h" 3
      mapped_type&
      at(const key_type& __k)
      {
 iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }

      const mapped_type&
      at(const key_type& __k) const
      {
 const_iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }
# 498 "/usr/include/c++/4.4/bits/stl_map.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_t._M_insert_unique(__x); }
# 538 "/usr/include/c++/4.4/bits/stl_map.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_unique_(__position, __x); }
# 550 "/usr/include/c++/4.4/bits/stl_map.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_unique(__first, __last); }
# 565 "/usr/include/c++/4.4/bits/stl_map.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 580 "/usr/include/c++/4.4/bits/stl_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 595 "/usr/include/c++/4.4/bits/stl_map.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 610 "/usr/include/c++/4.4/bits/stl_map.h" 3
      void



      swap(map& __x)

      { _M_t.swap(__x._M_t); }







      void
      clear()
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 657 "/usr/include/c++/4.4/bits/stl_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 672 "/usr/include/c++/4.4/bits/stl_map.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
# 684 "/usr/include/c++/4.4/bits/stl_map.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
# 699 "/usr/include/c++/4.4/bits/stl_map.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 714 "/usr/include/c++/4.4/bits/stl_map.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }







      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }







      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 753 "/usr/include/c++/4.4/bits/stl_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 772 "/usr/include/c++/4.4/bits/stl_map.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator==(const map<_K1, _T1, _C1, _A1>&,
     const map<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator<(const map<_K1, _T1, _C1, _A1>&,
    const map<_K1, _T1, _C1, _A1>&);
    };
# 797 "/usr/include/c++/4.4/bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 814 "/usr/include/c++/4.4/bits/stl_map.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,
  map<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }
# 869 "/usr/include/c++/4.4/bits/stl_map.h" 3
}
# 61 "/usr/include/c++/4.4/map" 2 3
# 1 "/usr/include/c++/4.4/bits/stl_multimap.h" 1 3
# 63 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 83 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
  template <typename _Key, typename _Tp,
     typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class multimap
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename _Alloc::value_type _Alloc_value_type;





    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class multimap<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;

 value_compare(_Compare __c)
 : comp(__c) { }

      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };

    private:

      typedef typename _Alloc::template rebind<value_type>::other
        _Pair_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;

      _Rep_type _M_t;

    public:


      typedef typename _Pair_alloc_type::pointer pointer;
      typedef typename _Pair_alloc_type::const_pointer const_pointer;
      typedef typename _Pair_alloc_type::reference reference;
      typedef typename _Pair_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;






      multimap()
      : _M_t() { }






      explicit
      multimap(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
# 168 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      multimap(const multimap& __x)
      : _M_t(__x._M_t) { }
# 208 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_equal(__first, __last); }
# 224 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
        : _M_t(__comp, __a)
        { _M_t._M_insert_equal(__first, __last); }
# 247 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      multimap&
      operator=(const multimap& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
# 292 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }







      iterator
      begin()
      { return _M_t.begin(); }






      const_iterator
      begin() const
      { return _M_t.begin(); }






      iterator
      end()
      { return _M_t.end(); }






      const_iterator
      end() const
      { return _M_t.end(); }






      reverse_iterator
      rbegin()
      { return _M_t.rbegin(); }






      const_reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }






      reverse_iterator
      rend()
      { return _M_t.rend(); }






      const_reverse_iterator
      rend() const
      { return _M_t.rend(); }
# 409 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      bool
      empty() const
      { return _M_t.empty(); }


      size_type
      size() const
      { return _M_t.size(); }


      size_type
      max_size() const
      { return _M_t.max_size(); }
# 436 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }
# 460 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_equal_(__position, __x); }
# 473 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }
# 501 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      void
      erase(iterator __position)
      { _M_t.erase(__position); }
# 516 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 531 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      void
      erase(iterator __first, iterator __last)
      { _M_t.erase(__first, __last); }
# 546 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      void



      swap(multimap& __x)

      { _M_t.swap(__x._M_t); }







      void
      clear()
      { _M_t.clear(); }






      key_compare
      key_comp() const
      { return _M_t.key_comp(); }





      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
# 593 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
# 608 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }






      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
# 632 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
# 647 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }







      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }







      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
# 684 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
# 701 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator==(const multimap<_K1, _T1, _C1, _A1>&,
     const multimap<_K1, _T1, _C1, _A1>&);

      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator<(const multimap<_K1, _T1, _C1, _A1>&,
    const multimap<_K1, _T1, _C1, _A1>&);
  };
# 726 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 743 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,
         multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }
# 798 "/usr/include/c++/4.4/bits/stl_multimap.h" 3
}
# 62 "/usr/include/c++/4.4/map" 2 3
# 11 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules.hh" 2



# 1 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/stdstreams.hh" 1
# 12 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/stdstreams.hh"
# 1 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/debugstream.hh" 1






# 1 "/usr/include/c++/4.4/stack" 1 3
# 59 "/usr/include/c++/4.4/stack" 3
# 59 "/usr/include/c++/4.4/stack" 3

# 1 "/usr/include/c++/4.4/deque" 1 3
# 59 "/usr/include/c++/4.4/deque" 3
# 59 "/usr/include/c++/4.4/deque" 3





# 1 "/usr/include/c++/4.4/bits/stl_deque.h" 1 3
# 65 "/usr/include/c++/4.4/bits/stl_deque.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 77 "/usr/include/c++/4.4/bits/stl_deque.h" 3
  inline size_t
  __deque_buf_size(size_t __size)
  { return __size < 512 ? size_t(512 / __size) : size_t(1); }
# 93 "/usr/include/c++/4.4/bits/stl_deque.h" 3
  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator
    {
      typedef _Deque_iterator<_Tp, _Tp&, _Tp*> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;

      static size_t _S_buffer_size()
      { return __deque_buf_size(sizeof(_Tp)); }

      typedef std::random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Ptr pointer;
      typedef _Ref reference;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp** _Map_pointer;
      typedef _Deque_iterator _Self;

      _Tp* _M_cur;
      _Tp* _M_first;
      _Tp* _M_last;
      _Map_pointer _M_node;

      _Deque_iterator(_Tp* __x, _Map_pointer __y)
      : _M_cur(__x), _M_first(*__y),
        _M_last(*__y + _S_buffer_size()), _M_node(__y) { }

      _Deque_iterator()
      : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) { }

      _Deque_iterator(const iterator& __x)
      : _M_cur(__x._M_cur), _M_first(__x._M_first),
        _M_last(__x._M_last), _M_node(__x._M_node) { }

      reference
      operator*() const
      { return *_M_cur; }

      pointer
      operator->() const
      { return _M_cur; }

      _Self&
      operator++()
      {
 ++_M_cur;
 if (_M_cur == _M_last)
   {
     _M_set_node(_M_node + 1);
     _M_cur = _M_first;
   }
 return *this;
      }

      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 ++*this;
 return __tmp;
      }

      _Self&
      operator--()
      {
 if (_M_cur == _M_first)
   {
     _M_set_node(_M_node - 1);
     _M_cur = _M_last;
   }
 --_M_cur;
 return *this;
      }

      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 --*this;
 return __tmp;
      }

      _Self&
      operator+=(difference_type __n)
      {
 const difference_type __offset = __n + (_M_cur - _M_first);
 if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
   _M_cur += __n;
 else
   {
     const difference_type __node_offset =
       __offset > 0 ? __offset / difference_type(_S_buffer_size())
                    : -difference_type((-__offset - 1)
           / _S_buffer_size()) - 1;
     _M_set_node(_M_node + __node_offset);
     _M_cur = _M_first + (__offset - __node_offset
     * difference_type(_S_buffer_size()));
   }
 return *this;
      }

      _Self
      operator+(difference_type __n) const
      {
 _Self __tmp = *this;
 return __tmp += __n;
      }

      _Self&
      operator-=(difference_type __n)
      { return *this += -__n; }

      _Self
      operator-(difference_type __n) const
      {
 _Self __tmp = *this;
 return __tmp -= __n;
      }

      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }






      void
      _M_set_node(_Map_pointer __new_node)
      {
 _M_node = __new_node;
 _M_first = *__new_node;
 _M_last = _M_first + difference_type(_S_buffer_size());
      }
    };




  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__x == __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__x == __y); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                          : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                   : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return __y < __x; }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return __y < __x; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__x < __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__x < __y); }





  template<typename _Tp, typename _Ref, typename _Ptr>
    inline typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
    operator-(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    {
      return typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
 (_Deque_iterator<_Tp, _Ref, _Ptr>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
    operator-(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    {
      return typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
 (_Deque_iterator<_Tp, _RefL, _PtrL>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline _Deque_iterator<_Tp, _Ref, _Ptr>
    operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)
    { return __x + __n; }

  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>& __first,
  const _Deque_iterator<_Tp, _Tp&, _Tp*>& __last, const _Tp& __value);
# 360 "/usr/include/c++/4.4/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    class _Deque_base
    {
    public:
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Tp_allocator()); }

      typedef _Deque_iterator<_Tp, _Tp&, _Tp*> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;

      _Deque_base()
      : _M_impl()
      { _M_initialize_map(0); }

      _Deque_base(const allocator_type& __a, size_t __num_elements)
      : _M_impl(__a)
      { _M_initialize_map(__num_elements); }

      _Deque_base(const allocator_type& __a)
      : _M_impl(__a)
      { }
# 400 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      ~_Deque_base();

    protected:



      typedef typename _Alloc::template rebind<_Tp*>::other _Map_alloc_type;

      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _Deque_impl
      : public _Tp_alloc_type
      {
 _Tp** _M_map;
 size_t _M_map_size;
 iterator _M_start;
 iterator _M_finish;

 _Deque_impl()
 : _Tp_alloc_type(), _M_map(0), _M_map_size(0),
   _M_start(), _M_finish()
 { }

 _Deque_impl(const _Tp_alloc_type& __a)
 : _Tp_alloc_type(__a), _M_map(0), _M_map_size(0),
   _M_start(), _M_finish()
 { }
      };

      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      _Map_alloc_type
      _M_get_map_allocator() const
      { return _Map_alloc_type(_M_get_Tp_allocator()); }

      _Tp*
      _M_allocate_node()
      {
 return _M_impl._Tp_alloc_type::allocate(__deque_buf_size(sizeof(_Tp)));
      }

      void
      _M_deallocate_node(_Tp* __p)
      {
 _M_impl._Tp_alloc_type::deallocate(__p, __deque_buf_size(sizeof(_Tp)));
      }

      _Tp**
      _M_allocate_map(size_t __n)
      { return _M_get_map_allocator().allocate(__n); }

      void
      _M_deallocate_map(_Tp** __p, size_t __n)
      { _M_get_map_allocator().deallocate(__p, __n); }

    protected:
      void _M_initialize_map(size_t);
      void _M_create_nodes(_Tp** __nstart, _Tp** __nfinish);
      void _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish);
      enum { _S_initial_map_size = 8 };

      _Deque_impl _M_impl;
    };

  template<typename _Tp, typename _Alloc>
    _Deque_base<_Tp, _Alloc>::
    ~_Deque_base()
    {
      if (this->_M_impl._M_map)
 {
   _M_destroy_nodes(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
 }
    }
# 490 "/usr/include/c++/4.4/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_initialize_map(size_t __num_elements)
    {
      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
      + 1);

      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
        size_t(__num_nodes + 2));
      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);






      _Tp** __nstart = (this->_M_impl._M_map
   + (this->_M_impl._M_map_size - __num_nodes) / 2);
      _Tp** __nfinish = __nstart + __num_nodes;

      try
 { _M_create_nodes(__nstart, __nfinish); }
      catch(...)
 {
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
   this->_M_impl._M_map = 0;
   this->_M_impl._M_map_size = 0;
   throw;
 }

      this->_M_impl._M_start._M_set_node(__nstart);
      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
     + __num_elements
     % __deque_buf_size(sizeof(_Tp)));
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_create_nodes(_Tp** __nstart, _Tp** __nfinish)
    {
      _Tp** __cur;
      try
 {
   for (__cur = __nstart; __cur < __nfinish; ++__cur)
     *__cur = this->_M_allocate_node();
 }
      catch(...)
 {
   _M_destroy_nodes(__nstart, __cur);
   throw;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)
    {
      for (_Tp** __n = __nstart; __n < __nfinish; ++__n)
 _M_deallocate_node(*__n);
    }
# 637 "/usr/include/c++/4.4/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class deque : protected _Deque_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;



      typedef _Deque_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef typename _Base::iterator iterator;
      typedef typename _Base::const_iterator const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      typedef pointer* _Map_pointer;

      static size_t _S_buffer_size()
      { return __deque_buf_size(sizeof(_Tp)); }


      using _Base::_M_initialize_map;
      using _Base::_M_create_nodes;
      using _Base::_M_destroy_nodes;
      using _Base::_M_allocate_node;
      using _Base::_M_deallocate_node;
      using _Base::_M_allocate_map;
      using _Base::_M_deallocate_map;
      using _Base::_M_get_Tp_allocator;





      using _Base::_M_impl;

    public:





      deque()
      : _Base() { }





      explicit
      deque(const allocator_type& __a)
      : _Base(__a, 0) { }
# 709 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      explicit
      deque(size_type __n, const value_type& __value = value_type(),
     const allocator_type& __a = allocator_type())
      : _Base(__a, __n)
      { _M_fill_initialize(__value); }
# 722 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      deque(const deque& __x)
      : _Base(__x._M_get_Tp_allocator(), __x.size())
      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
        this->_M_impl._M_start,
        _M_get_Tp_allocator()); }
# 774 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      template<typename _InputIterator>
        deque(_InputIterator __first, _InputIterator __last,
       const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }






      ~deque()
      { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }
# 799 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      deque&
      operator=(const deque& __x);
# 848 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 864 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }
# 890 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }






      iterator
      begin()
      { return this->_M_impl._M_start; }





      const_iterator
      begin() const
      { return this->_M_impl._M_start; }






      iterator
      end()
      { return this->_M_impl._M_finish; }






      const_iterator
      end() const
      { return this->_M_impl._M_finish; }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->_M_impl._M_start); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->_M_impl._M_start); }
# 1004 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      size_type
      size() const
      { return this->_M_impl._M_finish - this->_M_impl._M_start; }


      size_type
      max_size() const
      { return _M_get_Tp_allocator().max_size(); }
# 1024 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
 const size_type __len = size();
 if (__new_size < __len)
   _M_erase_at_end(this->_M_impl._M_start + difference_type(__new_size));
 else
   insert(this->_M_impl._M_finish, __new_size - __len, __x);
      }





      bool
      empty() const
      { return this->_M_impl._M_finish == this->_M_impl._M_start; }
# 1054 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      reference
      operator[](size_type __n)
      { return this->_M_impl._M_start[difference_type(__n)]; }
# 1069 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      const_reference
      operator[](size_type __n) const
      { return this->_M_impl._M_start[difference_type(__n)]; }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("deque::_M_range_check"));
      }

    public:
# 1094 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 1112 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
# 1169 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      void
      push_front(const value_type& __x)
      {
 if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
   {
     this->_M_impl.construct(this->_M_impl._M_start._M_cur - 1, __x);
     --this->_M_impl._M_start._M_cur;
   }
 else
   _M_push_front_aux(__x);
      }
# 1200 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_last - 1)
   {
     this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __x);
     ++this->_M_impl._M_finish._M_cur;
   }
 else
   _M_push_back_aux(__x);
      }
# 1231 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      void
      pop_front()
      {
 if (this->_M_impl._M_start._M_cur
     != this->_M_impl._M_start._M_last - 1)
   {
     this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
     ++this->_M_impl._M_start._M_cur;
   }
 else
   _M_pop_front_aux();
      }
# 1252 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      void
      pop_back()
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_first)
   {
     --this->_M_impl._M_finish._M_cur;
     this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
   }
 else
   _M_pop_back_aux();
      }
# 1289 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
# 1329 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
# 1343 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
# 1366 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      iterator
      erase(iterator __position);
# 1385 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      iterator
      erase(iterator __first, iterator __last);
# 1397 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      void



      swap(deque& __x)

      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_map, __x._M_impl._M_map);
 std::swap(this->_M_impl._M_map_size, __x._M_impl._M_map_size);



 std::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
          __x._M_get_Tp_allocator());
      }







      void
      clear()
      { _M_erase_at_end(begin()); }

    protected:






      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        {
   _M_initialize_map(static_cast<size_type>(__n));
   _M_fill_initialize(__x);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }
# 1463 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag);
# 1485 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      void
      _M_fill_initialize(const value_type& __value);
# 1495 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag)
        {
   const size_type __len = std::distance(__first, __last);
   if (__len > size())
     {
       _ForwardIterator __mid = __first;
       std::advance(__mid, size());
       std::copy(__first, __mid, begin());
       insert(end(), __mid, __last);
     }
   else
     _M_erase_at_end(std::copy(__first, __last, begin()));
 }



      void
      _M_fill_assign(size_type __n, const value_type& __val)
      {
 if (__n > size())
   {
     std::fill(begin(), end(), __val);
     insert(end(), __n - size(), __val);
   }
 else
   {
     _M_erase_at_end(begin() + difference_type(__n));
     std::fill(begin(), end(), __val);
   }
      }




      void _M_push_back_aux(const value_type&);

      void _M_push_front_aux(const value_type&);
# 1566 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      void _M_pop_back_aux();

      void _M_pop_front_aux();
# 1578 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos,
      _Integer __n, _Integer __x, __true_type)
        { _M_fill_insert(__pos, __n, __x); }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos,
      _InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
          _M_range_insert_aux(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert_aux(iterator __pos, _InputIterator __first,
       _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert_aux(iterator __pos, _ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag);




      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);



      iterator
      _M_insert_aux(iterator __pos, const value_type& __x);







      void
      _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);


      template<typename _ForwardIterator>
        void
        _M_insert_aux(iterator __pos,
        _ForwardIterator __first, _ForwardIterator __last,
        size_type __n);




      void
      _M_destroy_data_aux(iterator __first, iterator __last);



      template<typename _Alloc1>
        void
        _M_destroy_data(iterator __first, iterator __last, const _Alloc1&)
        { _M_destroy_data_aux(__first, __last); }

      void
      _M_destroy_data(iterator __first, iterator __last,
        const std::allocator<_Tp>&)
      {
 if (!__has_trivial_destructor(value_type))
   _M_destroy_data_aux(__first, __last);
      }


      void
      _M_erase_at_begin(iterator __pos)
      {
 _M_destroy_data(begin(), __pos, _M_get_Tp_allocator());
 _M_destroy_nodes(this->_M_impl._M_start._M_node, __pos._M_node);
 this->_M_impl._M_start = __pos;
      }



      void
      _M_erase_at_end(iterator __pos)
      {
 _M_destroy_data(__pos, end(), _M_get_Tp_allocator());
 _M_destroy_nodes(__pos._M_node + 1,
    this->_M_impl._M_finish._M_node + 1);
 this->_M_impl._M_finish = __pos;
      }



      iterator
      _M_reserve_elements_at_front(size_type __n)
      {
 const size_type __vacancies = this->_M_impl._M_start._M_cur
                               - this->_M_impl._M_start._M_first;
 if (__n > __vacancies)
   _M_new_elements_at_front(__n - __vacancies);
 return this->_M_impl._M_start - difference_type(__n);
      }

      iterator
      _M_reserve_elements_at_back(size_type __n)
      {
 const size_type __vacancies = (this->_M_impl._M_finish._M_last
           - this->_M_impl._M_finish._M_cur) - 1;
 if (__n > __vacancies)
   _M_new_elements_at_back(__n - __vacancies);
 return this->_M_impl._M_finish + difference_type(__n);
      }

      void
      _M_new_elements_at_front(size_type __new_elements);

      void
      _M_new_elements_at_back(size_type __new_elements);
# 1714 "/usr/include/c++/4.4/bits/stl_deque.h" 3
      void
      _M_reserve_map_at_back(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add + 1 > this->_M_impl._M_map_size
     - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, false);
      }

      void
      _M_reserve_map_at_front(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add > size_type(this->_M_impl._M_start._M_node
           - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, true);
      }

      void
      _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);

    };
# 1746 "/usr/include/c++/4.4/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const deque<_Tp, _Alloc>& __x,
                         const deque<_Tp, _Alloc>& __y)
    { return __x.size() == __y.size()
             && std::equal(__x.begin(), __x.end(), __y.begin()); }
# 1764 "/usr/include/c++/4.4/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)
    { __x.swap(__y); }
# 1817 "/usr/include/c++/4.4/bits/stl_deque.h" 3
}
# 65 "/usr/include/c++/4.4/deque" 2 3


# 1 "/usr/include/c++/4.4/bits/deque.tcc" 1 3
# 60 "/usr/include/c++/4.4/bits/deque.tcc" 3
namespace std __attribute__ ((__visibility__ ("default"))) {

  template <typename _Tp, typename _Alloc>
    deque<_Tp, _Alloc>&
    deque<_Tp, _Alloc>::
    operator=(const deque& __x)
    {
      const size_type __len = size();
      if (&__x != this)
 {
   if (__len >= __x.size())
     _M_erase_at_end(std::copy(__x.begin(), __x.end(),
          this->_M_impl._M_start));
   else
     {
       const_iterator __mid = __x.begin() + difference_type(__len);
       std::copy(__x.begin(), __mid, this->_M_impl._M_start);
       insert(this->_M_impl._M_finish, __mid, __x.end());
     }
 }
      return *this;
    }
# 118 "/usr/include/c++/4.4/bits/deque.tcc" 3
  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      if (__position._M_cur == this->_M_impl._M_start._M_cur)
 {
   push_front(__x);
   return this->_M_impl._M_start;
 }
      else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
 {
   push_back(__x);
   iterator __tmp = this->_M_impl._M_finish;
   --__tmp;
   return __tmp;
 }
      else
        return _M_insert_aux(__position, __x);
    }
# 163 "/usr/include/c++/4.4/bits/deque.tcc" 3
  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    erase(iterator __position)
    {
      iterator __next = __position;
      ++__next;
      const difference_type __index = __position - begin();
      if (static_cast<size_type>(__index) < (size() >> 1))
 {
   if (__position != begin())
     std::copy_backward(begin(), __position, __next);
   pop_front();
 }
      else
 {
   if (__next != end())
     std::copy(__next, end(), __position);
   pop_back();
 }
      return begin() + __index;
    }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first == begin() && __last == end())
 {
   clear();
   return end();
 }
      else
 {
   const difference_type __n = __last - __first;
   const difference_type __elems_before = __first - begin();
   if (static_cast<size_type>(__elems_before) <= (size() - __n) / 2)
     {
       if (__first != begin())
  std::copy_backward(begin(), __first, __last);
       _M_erase_at_begin(begin() + __n);
     }
   else
     {
       if (__last != end())
  std::copy(__last, end(), __first);
       _M_erase_at_end(end() - __n);
     }
   return begin() + __elems_before;
 }
    }

  template <typename _Tp, class _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
        iterator __cur = begin();
        for (; __first != __last && __cur != end(); ++__cur, ++__first)
          *__cur = *__first;
        if (__first == __last)
          _M_erase_at_end(__cur);
        else
          insert(end(), __first, __last);
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)
    {
      if (__pos._M_cur == this->_M_impl._M_start._M_cur)
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   try
     {
       std::__uninitialized_fill_a(__new_start, this->_M_impl._M_start,
       __x, _M_get_Tp_allocator());
       this->_M_impl._M_start = __new_start;
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   try
     {
       std::__uninitialized_fill_a(this->_M_impl._M_finish,
       __new_finish, __x,
       _M_get_Tp_allocator());
       this->_M_impl._M_finish = __new_finish;
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
      else
        _M_insert_aux(__pos, __n, __x);
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_initialize(const value_type& __value)
    {
      _Map_pointer __cur;
      try
        {
          for (__cur = this->_M_impl._M_start._M_node;
        __cur < this->_M_impl._M_finish._M_node;
        ++__cur)
            std::__uninitialized_fill_a(*__cur, *__cur + _S_buffer_size(),
     __value, _M_get_Tp_allocator());
          std::__uninitialized_fill_a(this->_M_impl._M_finish._M_first,
          this->_M_impl._M_finish._M_cur,
          __value, _M_get_Tp_allocator());
        }
      catch(...)
        {
          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
   _M_get_Tp_allocator());
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      {
        this->_M_initialize_map(0);
        try
          {
            for (; __first != __last; ++__first)
              push_back(*__first);
          }
        catch(...)
          {
            clear();
            throw;
          }
      }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        this->_M_initialize_map(__n);

        _Map_pointer __cur_node;
        try
          {
            for (__cur_node = this->_M_impl._M_start._M_node;
                 __cur_node < this->_M_impl._M_finish._M_node;
                 ++__cur_node)
       {
  _ForwardIterator __mid = __first;
  std::advance(__mid, _S_buffer_size());
  std::__uninitialized_copy_a(__first, __mid, *__cur_node,
         _M_get_Tp_allocator());
  __first = __mid;
       }
            std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_finish._M_first,
     _M_get_Tp_allocator());
          }
        catch(...)
          {
            std::_Destroy(this->_M_impl._M_start,
     iterator(*__cur_node, __cur_node),
     _M_get_Tp_allocator());
            throw;
          }
      }


  template<typename _Tp, typename _Alloc>






      void
      deque<_Tp, _Alloc>::
      _M_push_back_aux(const value_type& __t)

      {
 _M_reserve_map_at_back();
 *(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();
 try
   {




     this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __t);

     this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node
      + 1);
     this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
   }
 catch(...)
   {
     _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
     throw;
   }
      }


  template<typename _Tp, typename _Alloc>






      void
      deque<_Tp, _Alloc>::
      _M_push_front_aux(const value_type& __t)

      {
 _M_reserve_map_at_front();
 *(this->_M_impl._M_start._M_node - 1) = this->_M_allocate_node();
 try
   {
     this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node
            - 1);
     this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_last - 1;




     this->_M_impl.construct(this->_M_impl._M_start._M_cur, __t);

   }
 catch(...)
   {
     ++this->_M_impl._M_start;
     _M_deallocate_node(*(this->_M_impl._M_start._M_node - 1));
     throw;
   }
      }


  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_back_aux()
    {
      _M_deallocate_node(this->_M_impl._M_finish._M_first);
      this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);
      this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_last - 1;
      this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
    }






  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_front_aux()
    {
      this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
      _M_deallocate_node(this->_M_impl._M_start._M_first);
      this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);
      this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      { std::copy(__first, __last, std::inserter(*this, __pos)); }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        if (__pos._M_cur == this->_M_impl._M_start._M_cur)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last, __new_start,
         _M_get_Tp_allocator());
  this->_M_impl._M_start = __new_start;
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
   {
     iterator __new_finish = _M_reserve_elements_at_back(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last,
         this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  this->_M_impl._M_finish = __new_finish;
       }
     catch(...)
       {
  _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
     __new_finish._M_node + 1);
  throw;
       }
   }
        else
          _M_insert_aux(__pos, __first, __last, __n);
      }

  template<typename _Tp, typename _Alloc>
# 514 "/usr/include/c++/4.4/bits/deque.tcc" 3
    typename deque<_Tp, _Alloc>::iterator
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos, const value_type& __x)
      {
 value_type __x_copy = __x;

 difference_type __index = __pos - this->_M_impl._M_start;
 if (static_cast<size_type>(__index) < size() / 2)
   {
     push_front((front()));
     iterator __front1 = this->_M_impl._M_start;
     ++__front1;
     iterator __front2 = __front1;
     ++__front2;
     __pos = this->_M_impl._M_start + __index;
     iterator __pos1 = __pos;
     ++__pos1;
     std::copy(__front2, __pos1, __front1);
   }
 else
   {
     push_back((back()));
     iterator __back1 = this->_M_impl._M_finish;
     --__back1;
     iterator __back2 = __back1;
     --__back2;
     __pos = this->_M_impl._M_start + __index;
     std::copy_backward(__pos, __back2, __back1);
   }
 *__pos = (__x_copy);
 return __pos;
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)
    {
      const difference_type __elems_before = __pos - this->_M_impl._M_start;
      const size_type __length = this->size();
      value_type __x_copy = __x;
      if (__elems_before < difference_type(__length / 2))
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   iterator __old_start = this->_M_impl._M_start;
   __pos = this->_M_impl._M_start + __elems_before;
   try
     {
       if (__elems_before >= difference_type(__n))
  {
    iterator __start_n = (this->_M_impl._M_start
     + difference_type(__n));
    std::__uninitialized_move_a(this->_M_impl._M_start,
           __start_n, __new_start,
           _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::copy(__start_n, __pos, __old_start);
    std::fill(__pos - difference_type(__n), __pos, __x_copy);
  }
       else
  {
    std::__uninitialized_move_fill(this->_M_impl._M_start,
       __pos, __new_start,
       this->_M_impl._M_start,
       __x_copy,
       _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::fill(__old_start, __pos, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   iterator __old_finish = this->_M_impl._M_finish;
   const difference_type __elems_after =
     difference_type(__length) - __elems_before;
   __pos = this->_M_impl._M_finish - __elems_after;
   try
     {
       if (__elems_after > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_move_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy_backward(__pos, __finish_n, __old_finish);
    std::fill(__pos, __pos + difference_type(__n), __x_copy);
  }
       else
  {
    std::__uninitialized_fill_move(this->_M_impl._M_finish,
       __pos + difference_type(__n),
       __x_copy, __pos,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::fill(__pos, __old_finish, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos,
                    _ForwardIterator __first, _ForwardIterator __last,
                    size_type __n)
      {
        const difference_type __elemsbefore = __pos - this->_M_impl._M_start;
        const size_type __length = size();
        if (static_cast<size_type>(__elemsbefore) < __length / 2)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     iterator __old_start = this->_M_impl._M_start;
     __pos = this->_M_impl._M_start + __elemsbefore;
     try
       {
  if (__elemsbefore >= difference_type(__n))
    {
      iterator __start_n = (this->_M_impl._M_start
       + difference_type(__n));
      std::__uninitialized_move_a(this->_M_impl._M_start,
      __start_n, __new_start,
      _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::copy(__start_n, __pos, __old_start);
      std::copy(__first, __last, __pos - difference_type(__n));
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, difference_type(__n) - __elemsbefore);
      std::__uninitialized_move_copy(this->_M_impl._M_start,
         __pos, __first, __mid,
         __new_start,
         _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::copy(__mid, __last, __old_start);
    }
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else
        {
          iterator __new_finish = _M_reserve_elements_at_back(__n);
          iterator __old_finish = this->_M_impl._M_finish;
          const difference_type __elemsafter =
            difference_type(__length) - __elemsbefore;
          __pos = this->_M_impl._M_finish - __elemsafter;
          try
            {
              if (__elemsafter > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_move_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy_backward(__pos, __finish_n, __old_finish);
    std::copy(__first, __last, __pos);
  }
              else
  {
    _ForwardIterator __mid = __first;
    std::advance(__mid, __elemsafter);
    std::__uninitialized_copy_move(__mid, __last, __pos,
       this->_M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy(__first, __mid, __pos);
  }
            }
          catch(...)
            {
              _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
              throw;
            }
        }
      }

   template<typename _Tp, typename _Alloc>
     void
     deque<_Tp, _Alloc>::
     _M_destroy_data_aux(iterator __first, iterator __last)
     {
       for (_Map_pointer __node = __first._M_node + 1;
     __node < __last._M_node; ++__node)
  std::_Destroy(*__node, *__node + _S_buffer_size(),
         _M_get_Tp_allocator());

       if (__first._M_node != __last._M_node)
  {
    std::_Destroy(__first._M_cur, __first._M_last,
    _M_get_Tp_allocator());
    std::_Destroy(__last._M_first, __last._M_cur,
    _M_get_Tp_allocator());
  }
       else
  std::_Destroy(__first._M_cur, __last._M_cur,
         _M_get_Tp_allocator());
     }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_front(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_front"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_front(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_start._M_node - __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_start._M_node - __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_back(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_back"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_back(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_finish._M_node + __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_finish._M_node + __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
    {
      const size_type __old_num_nodes
 = this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;

      _Map_pointer __new_nstart;
      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
 {
   __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
      - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   if (__new_nstart < this->_M_impl._M_start._M_node)
     std::copy(this->_M_impl._M_start._M_node,
        this->_M_impl._M_finish._M_node + 1,
        __new_nstart);
   else
     std::copy_backward(this->_M_impl._M_start._M_node,
          this->_M_impl._M_finish._M_node + 1,
          __new_nstart + __old_num_nodes);
 }
      else
 {
   size_type __new_map_size = this->_M_impl._M_map_size
                              + std::max(this->_M_impl._M_map_size,
      __nodes_to_add) + 2;

   _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
   __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   std::copy(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1,
      __new_nstart);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);

   this->_M_impl._M_map = __new_map;
   this->_M_impl._M_map_size = __new_map_size;
 }

      this->_M_impl._M_start._M_set_node(__new_nstart);
      this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
    }



  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>& __first,
  const _Deque_iterator<_Tp, _Tp&, _Tp*>& __last, const _Tp& __value)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;

      for (typename _Self::_Map_pointer __node = __first._M_node + 1;
           __node < __last._M_node; ++__node)
 std::fill(*__node, *__node + _Self::_S_buffer_size(), __value);

      if (__first._M_node != __last._M_node)
 {
   std::fill(__first._M_cur, __first._M_last, __value);
   std::fill(__last._M_first, __last._M_cur, __value);
 }
      else
 std::fill(__first._M_cur, __last._M_cur, __value);
    }

}
# 68 "/usr/include/c++/4.4/deque" 2 3
# 61 "/usr/include/c++/4.4/stack" 2 3
# 1 "/usr/include/c++/4.4/bits/stl_stack.h" 1 3
# 63 "/usr/include/c++/4.4/bits/stl_stack.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {
# 91 "/usr/include/c++/4.4/bits/stl_stack.h" 3
  template<typename _Tp, typename _Sequence = deque<_Tp> >
    class stack
    {

      typedef typename _Sequence::value_type _Sequence_value_type;




      template<typename _Tp1, typename _Seq1>
        friend bool
        operator==(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);

      template<typename _Tp1, typename _Seq1>
        friend bool
        operator<(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);

    public:
      typedef typename _Sequence::value_type value_type;
      typedef typename _Sequence::reference reference;
      typedef typename _Sequence::const_reference const_reference;
      typedef typename _Sequence::size_type size_type;
      typedef _Sequence container_type;

    protected:

      _Sequence c;

    public:





      explicit
      stack(const _Sequence& __c = _Sequence())
      : c(__c) { }
# 141 "/usr/include/c++/4.4/bits/stl_stack.h" 3
      bool
      empty() const
      { return c.empty(); }


      size_type
      size() const
      { return c.size(); }





      reference
      top()
      {
                              ;
 return c.back();
      }





      const_reference
      top() const
      {
                              ;
 return c.back();
      }
# 181 "/usr/include/c++/4.4/bits/stl_stack.h" 3
      void
      push(const value_type& __x)
      { c.push_back(__x); }
# 207 "/usr/include/c++/4.4/bits/stl_stack.h" 3
      void
      pop()
      {
                              ;
 c.pop_back();
      }






    };
# 233 "/usr/include/c++/4.4/bits/stl_stack.h" 3
  template<typename _Tp, typename _Seq>
    inline bool
    operator==(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return __x.c == __y.c; }
# 251 "/usr/include/c++/4.4/bits/stl_stack.h" 3
  template<typename _Tp, typename _Seq>
    inline bool
    operator<(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return __x.c < __y.c; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator!=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator<=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
    { return !(__x < __y); }
# 297 "/usr/include/c++/4.4/bits/stl_stack.h" 3
}
# 62 "/usr/include/c++/4.4/stack" 2 3
# 8 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/debugstream.hh" 2



namespace Dune {
# 111 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/debugstream.hh"
  typedef unsigned int DebugLevel;
# 122 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/debugstream.hh"
  template <DebugLevel current, DebugLevel threshold>
  struct greater_or_equal {
    static const bool value = (current >= threshold);
  };
# 134 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/debugstream.hh"
  template <DebugLevel current, DebugLevel mask>
  struct common_bits {
    enum {value = ((current & mask)!=0) };
  };



  class DebugStreamError : public IOError {};

  class StreamWrap {
  public:
    StreamWrap(std::ostream& _out) : out(_out) { };
    std::ostream& out;
    StreamWrap *next;
  };


  class DebugStreamState {

  public:

    StreamWrap* current;


    bool _active;


    bool _tied;


    unsigned int _tied_streams;
  };
# 181 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/debugstream.hh"
  template <DebugLevel thislevel = 1,
            DebugLevel dlevel = 1,
            DebugLevel alevel = 1,
            template<DebugLevel, DebugLevel> class activator = greater_or_equal>
  class DebugStream : public DebugStreamState {
  public:





    DebugStream(std::ostream& out = std::cerr) {

      current = new StreamWrap(out);
      current->next = 0;


      _active = activator<thislevel,alevel>::value;


      _tied = false;


      _tied_streams = 0;
    };






    DebugStream (DebugStreamState& master,
                std::ostream& fallback = std::cerr)
    {

      current = new StreamWrap(fallback);
      current->next = 0;


      _active = activator<thislevel,alevel>::value;
      _tied_streams = 0;


      _tied = true;
      tiedstate = &master;
      tiedstate->_tied_streams++;
    };







    ~DebugStream() {

      if (_tied)
        tiedstate->_tied_streams--;
      else {

        if (_tied_streams != 0)
          do { DebugStreamError th__ex; std::ostringstream th__out; th__out << "DebugStreamError" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/debugstream.hh" << ":" << 243 << "]: " << "There are streams still tied to this stream!"; th__ex.message(th__out.str()); throw th__ex; } while (0);

      };


      while (current != 0) {
        StreamWrap *s = current;
        current = current->next;
        delete s;
      };
    };


    template <class T>
    DebugStream& operator<<(const T data) {

      if (activator<thislevel, dlevel>::value) {
        if (! _tied) {
          if (_active)
            current->out << data;
        } else {
          if (_active && tiedstate->_active)
            tiedstate->current->out << data;
        };
      };

      return *this;
    }
# 278 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/debugstream.hh"
    DebugStream& operator<<(const int data) {

      if (activator<thislevel, dlevel>::value) {
        if (! _tied) {
          if (_active)
            current->out << data;
        } else {
          if (_active && tiedstate->_active)
            tiedstate->current->out << data;
        };
      };

      return *this;
    }


    DebugStream& operator<<(std::ostream& (*f)(std::ostream&)) {
      if (activator<thislevel, dlevel>::value) {
        if (! _tied) {
          if (_active)
            f(current->out);
        } else {
          if (_active && tiedstate->_active)
            f(tiedstate->current->out);
        };
      }

      return *this;
    };


    DebugStream& flush() {
      if (activator<thislevel, dlevel>::value) {
        if (! _tied) {
          if (_active)
            current->out.flush();
        } else {
          if (_active && tiedstate->_active)
            tiedstate->current->out.flush();
        };
      }

      return *this;
    };


    void push(bool b) {

      if (activator<thislevel,alevel>::value) {
        _actstack.push(_active);
        _active = b;
      } else {

        _actstack.push(false);
      };
    };


    void pop() throw(DebugStreamError) {
      if (_actstack.empty())
        do { DebugStreamError th__ex; std::ostringstream th__out; th__out << "DebugStreamError" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/debugstream.hh" << ":" << 338 << "]: " << "No previous activation setting!"; th__ex.message(th__out.str()); throw th__ex; } while (0);

      _active = _actstack.top();
      _actstack.pop();
    };







    bool active() const {
      return activator<thislevel, dlevel>::value && _active;
    };





    void attach(std::ostream& stream) {
      if (_tied)
        do { DebugStreamError th__ex; std::ostringstream th__out; th__out << "DebugStreamError" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/debugstream.hh" << ":" << 360 << "]: " << "Cannot attach to a tied stream!"; th__ex.message(th__out.str()); throw th__ex; } while (0);

      StreamWrap* newcurr = new StreamWrap(stream);
      newcurr->next = current;
      current = newcurr;
    };


    void detach() throw(DebugStreamError) {
      if (current->next == 0)
        do { DebugStreamError th__ex; std::ostringstream th__out; th__out << "DebugStreamError" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/debugstream.hh" << ":" << 370 << "]: " << "Cannot detach initial stream!"; th__ex.message(th__out.str()); throw th__ex; } while (0);
      if (_tied)
        do { DebugStreamError th__ex; std::ostringstream th__out; th__out << "DebugStreamError" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/debugstream.hh" << ":" << 372 << "]: " << "Cannot detach a tied stream!"; th__ex.message(th__out.str()); throw th__ex; } while (0);

      StreamWrap* old = current;
      current = current->next;
      delete old;
    };


    void tie(DebugStreamState& to) throw(DebugStreamError) {
      if (to._tied)
        do { DebugStreamError th__ex; std::ostringstream th__out; th__out << "DebugStreamError" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/debugstream.hh" << ":" << 382 << "]: " << "Cannot tie to an already tied stream!"; th__ex.message(th__out.str()); throw th__ex; } while (0);
      if (_tied)
        do { DebugStreamError th__ex; std::ostringstream th__out; th__out << "DebugStreamError" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/debugstream.hh" << ":" << 384 << "]: " << "Stream already tied: untie first!"; th__ex.message(th__out.str()); throw th__ex; } while (0);

      _tied = true;
      tiedstate = &to;


      tiedstate->_tied_streams++;
    };


    void untie() throw(DebugStreamError) {
      if(! _tied)
        do { DebugStreamError th__ex; std::ostringstream th__out; th__out << "DebugStreamError" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/debugstream.hh" << ":" << 396 << "]: " << "Cannot untie, stream is not tied!"; th__ex.message(th__out.str()); throw th__ex; } while (0);

      tiedstate->_tied_streams--;
      _tied = false;
      tiedstate = 0;
    };

  private:

    DebugStreamState* tiedstate;





    std::stack<bool> _actstack;
  };


}
# 13 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/stdstreams.hh" 2

namespace Dune {
# 69 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/stdstreams.hh"
  static const DebugLevel MINIMAL_DEBUG_LEVEL = 2;





  static const DebugLevel VERY_VERBOSE_DEBUG_LEVEL = 1;





  typedef DebugStream<VERY_VERBOSE_DEBUG_LEVEL, MINIMAL_DEBUG_LEVEL> DVVerbType;
# 95 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/stdstreams.hh"
  extern DVVerbType dvverb;





  static const DebugLevel VERBOSE_DEBUG_LEVEL = 2;





  typedef DebugStream<VERBOSE_DEBUG_LEVEL, MINIMAL_DEBUG_LEVEL> DVerbType;
# 116 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/stdstreams.hh"
  extern DVerbType dverb;





  static const DebugLevel INFO_DEBUG_LEVEL = 3;





  typedef DebugStream<INFO_DEBUG_LEVEL, MINIMAL_DEBUG_LEVEL> DInfoType;
# 140 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/stdstreams.hh"
  extern DInfoType dinfo;





  static const DebugLevel WARN_DEBUG_LEVEL = 4;





  typedef DebugStream<WARN_DEBUG_LEVEL, MINIMAL_DEBUG_LEVEL> DWarnType;
# 161 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/stdstreams.hh"
  extern DWarnType dwarn;





  static const DebugLevel GRAVE_DEBUG_LEVEL = 5;


  typedef DebugStream<GRAVE_DEBUG_LEVEL, MINIMAL_DEBUG_LEVEL> DGraveType;
# 179 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/stdstreams.hh"
  extern DGraveType dgrave;


  typedef DebugStream<1> DErrType;
# 195 "/home/cocktail/pipping/dune-git-svn/dune-common/dune/common/stdstreams.hh"
  extern DErrType derr;


}
# 15 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules.hh" 2







namespace Dune {





  class QuadratureOrderOutOfRange : public NotImplemented {};




  template<typename ct, int dim>
  class QuadraturePoint {
  public:

 enum { d=dim };
 typedef ct CoordType;

    static const unsigned int dimension = d;
    typedef ct Field;
    typedef Dune::FieldVector<ct,dim> Vector;


 QuadraturePoint (const Vector& x, ct w) : local(x)
      {
        wght = w;
      }


 const Vector& position () const
      {
        return local;
      }


 const ct &weight () const
      {
        return wght;
      }

  protected:
 FieldVector<ct, dim> local;
 ct wght;
  };




  namespace QuadratureType {
    enum Enum {
      Gauss = 0,

      Jacobian_1_0 = 1,
      Jacobian_2_0 = 2,

      Simpson = 3,
      Trap = 4,
      Grid = 5,

      Clough = 21,

      Invalid_Rule = 127
    };
  }




  template<typename ct, int dim>
  class QuadratureRule : public std::vector<QuadraturePoint<ct,dim> >
  {
  public:


    QuadratureRule() : delivered_order(-1) {}


    QuadratureRule(GeometryType t) : geometry_type(t), delivered_order(-1) {}


    QuadratureRule(GeometryType t, int order) : geometry_type(t), delivered_order(order) {}


 enum { d=dim };


 typedef ct CoordType;


 virtual int order () const { return delivered_order; }


 virtual GeometryType type () const { return geometry_type; }
    virtual ~QuadratureRule(){}



    typedef typename std::vector<QuadraturePoint<ct,dim> >::const_iterator iterator;

  protected:
    GeometryType geometry_type;
 int delivered_order;

    void tensor_product (const QuadratureRule<ct,1> & q1d)
      {

        int m = q1d.size();
        int n = power(m,dim);
        for (int i=0; i<n; i++)
  {

    int x[dim];
    int z = i;
    for (int k=0; k<dim; ++k)
          {
            x[k] = z%m;
            z = z/m;
          }


    double weight = 1.0;
    FieldVector<ct, dim> local;
    for (int k=0; k<dim; k++)
          {
            local[k] = q1d[x[k]].position()[0];
            weight *= q1d[x[k]].weight();
          }


    this->push_back(QuadraturePoint<ct,dim>(local,weight));
  }
      }

 int power (int y, int d)
      {
        int m=1;
        for (int i=0; i<d; i++) m *= y;
        return m;
      }
  };



  template<typename ctype, int dim> class QuadratureRuleFactory;




  template<typename ctype, int dim>
  class QuadratureRules {


    typedef std::pair<GeometryType,int> QuadratureRuleKey;


    typedef Dune::QuadratureRule<ctype, dim> QuadratureRule;


    const QuadratureRule& _rule(const GeometryType& t, int p, QuadratureType::Enum qt=QuadratureType::Gauss)
      {
        static std::map<QuadratureRuleKey, QuadratureRule> _quadratureMap;
        QuadratureRuleKey key(t,p);
        if (_quadratureMap.find(key) == _quadratureMap.end()) {





          QuadratureRule rule =
            QuadratureRuleFactory<ctype,dim>::rule(t,p,qt);
          _quadratureMap[key] = rule;
        }
        return _quadratureMap[key];
      }

    static QuadratureRules& instance()
      {
        static QuadratureRules instance;
        return instance;
      }

    QuadratureRules () {};
  public:

    static const QuadratureRule& rule(const GeometryType& t, int p, QuadratureType::Enum qt=QuadratureType::Gauss)
      {
        return instance()._rule(t,p,qt);
      }

    static const QuadratureRule& rule(const GeometryType::BasicType t, int p, QuadratureType::Enum qt=QuadratureType::Gauss)
      {
        GeometryType gt(t,dim);
        return instance()._rule(gt,p,qt);
      }
  };






  template<typename ct, int dim>
  class CubeQuadratureRule :
    public QuadratureRule<ct,dim>
  {
  public:

 enum { d=dim };


 enum { highest_order=CubeQuadratureRule<ct,1>::highest_order };


 typedef ct CoordType;


 typedef CubeQuadratureRule value_type;

    ~CubeQuadratureRule(){}
  private:
    friend class QuadratureRuleFactory<ct,dim>;

 CubeQuadratureRule (int p) : QuadratureRule<ct,dim>(GeometryType(GeometryType::cube, d))
      {
        QuadratureRule<ct,1> q1D = QuadratureRules<ct,1>::rule(GeometryType::cube, p);
        this->tensor_product( q1D );
        this->delivered_order = q1D.order();
      }

  };



  template<typename ct>
  class CubeQuadratureRule<ct,0> :
    public QuadratureRule<ct,0>
  {
  public:

 enum { d=0 };
 enum { dim=0 };
 enum { highest_order=61 };
 typedef ct CoordType;
 typedef CubeQuadratureRule value_type;

    ~CubeQuadratureRule(){}
  private:
    friend class QuadratureRuleFactory<ct,dim>;
    CubeQuadratureRule (int p):
      QuadratureRule<ct,0>(GeometryType(GeometryType::cube, 0))
    {
      FieldVector<ct, dim> point(0.0);

      if (p > highest_order)
        do { QuadratureOrderOutOfRange th__ex; std::ostringstream th__out; th__out << "QuadratureOrderOutOfRange" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules.hh" << ":" << 276 << "]: " << "Quadrature rule " << p << " not supported!"; th__ex.message(th__out.str()); throw th__ex; } while (0);

      this->delivered_order = highest_order;
      this->push_back(QuadraturePoint<ct,dim>(point, 1.0));
    }
  };


  template<typename ct,
           bool fundamental = std::numeric_limits<ct>::is_specialized>
  struct CubeQuadratureInitHelper;
  template<typename ct>
  struct CubeQuadratureInitHelper<ct, true> {
    static void init(int p,
                     std::vector< FieldVector<ct, 1> > & _points,
                     std::vector< ct > & _weight,
                     int & delivered_order);
  };
  template<typename ct>
  struct CubeQuadratureInitHelper<ct, false> {
    static void init(int p,
                     std::vector< FieldVector<ct, 1> > & _points,
                     std::vector< ct > & _weight,
                     int & delivered_order);
  };



  template<typename ct>
  class CubeQuadratureRule<ct,1> :
    public QuadratureRule<ct,1>
  {
  public:

 enum { d=1 };
 enum { dim=1 };
 enum { highest_order=61 };
 typedef ct CoordType;
 typedef CubeQuadratureRule value_type;

    ~CubeQuadratureRule(){}
  private:
    friend class QuadratureRuleFactory<ct,dim>;
    CubeQuadratureRule (int p)
      : QuadratureRule<ct,1>(GeometryType(GeometryType::cube, 1))
    {

      std::vector< FieldVector<ct, dim> > _points;
      std::vector< ct > _weight;

      CubeQuadratureInitHelper<ct>::init
        (p, _points, _weight, this->delivered_order);

      ((_points.size() == _weight.size()) ? static_cast<void> (0) : __assert_fail ("_points.size() == _weight.size()", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules.hh", 329, __PRETTY_FUNCTION__));
      for (size_t i = 0; i < _points.size(); i++)
        this->push_back(QuadraturePoint<ct,dim>(_points[i], _weight[i]));
    }
  };

  extern template CubeQuadratureRule<float, 1>::CubeQuadratureRule(int);
  extern template CubeQuadratureRule<double, 1>::CubeQuadratureRule(int);

}



# 1 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules/cube_imp.hh" 1
# 11 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules/cube_imp.hh"
namespace Dune {


  template<typename ct>
  void CubeQuadratureInitHelper<ct,true>::init(int p,
         std::vector< FieldVector<ct, 1> > & _points,
         std::vector< ct > & _weight,
         int & delivered_order)
  {
    switch(p)
    {

    case 0:
    case 1:
      delivered_order = 1;
      _points.resize(1);
      _weight.resize(1);
      _points[0] = .5;
      _weight[0] = 1.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
      break;


    case 2:
    case 3:
      delivered_order = 3;
      _points.resize(2);
      _weight.resize(2);
      _points[0] = .2113248654051871177454256097490212721761991243649365619906988367580111638485333271531423022071252374;
      _weight[0] = .5000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
      _points[1] = .7886751345948128822545743902509787278238008756350634380093011632419888361514666728468576977928747626;
      _weight[1] = .5000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
      break;


    case 4:
    case 5:
      delivered_order = 5;
      _points.resize(3);
      _weight.resize(3);
      _points[0] = .1127016653792583114820734600217600389167078294708409173412426233886516908063020966480712623141326482;
      _weight[0] = .2777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777768;
      _points[1] = .5;
      _weight[1] = .4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444;
      _points[2] = .8872983346207416885179265399782399610832921705291590826587573766113483091936979033519287376858673518;
      _weight[2] = .2777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777;
      break;


    case 6:
    case 7:
      delivered_order = 7;
      _points.resize(4);
      _weight.resize(4);
      _points[0] = .694318442029737123880267555535952474521373101851411811921390395467352642524755671479188300577603474e-1;
      _weight[0] = .1739274225687269286865319746109997036176743479169467702462646597593759337329551758609918838661290805;
      _points[1] = .3300094782075718675986671204483776563997120651145428237035230115894899847683814827610623597822225942;
      _weight[1] = .3260725774312730713134680253890002963823256520830532297537353402406240662670448241390081161338709199;
      _points[2] = .6699905217924281324013328795516223436002879348854571762964769884105100152316185172389376402177774058;
      _weight[2] = .3260725774312730713134680253890002963823256520830532297537353402406240662670448241390081161338709201;
      _points[3] = .9305681557970262876119732444464047525478626898148588188078609604532647357475244328520811699422396526;
      _weight[3] = .1739274225687269286865319746109997036176743479169467702462646597593759337329551758609918838661290798;
      break;


    case 8:
    case 9:
      delivered_order = 9;
      _points.resize(5);
      _weight.resize(5);
      _points[0] = .469100770306680036011865608503035174371740446187345685631188567281146025416565765294285052232288690e-1;
      _weight[0] = .1184634425280945437571320203599586813216300011062070077914139441108586442015215492899967152469757221;
      _points[1] = .2307653449471584544818427896498955975163566965472200218988841864702644073161223544820981663747145342;
      _weight[1] = .2393143352496832340206457574178190964561477766715707699863638336669191335762562284877810625308020550;
      _points[2] = .5;
      _weight[2] = .2844444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444445;
      _points[3] = .7692346550528415455181572103501044024836433034527799781011158135297355926838776455179018336252854658;
      _weight[3] = .2393143352496832340206457574178190964561477766715707699863638336669191335762562284877810625308020556;
      _points[4] = .9530899229693319963988134391496964825628259553812654314368811432718853974583434234705714947767711310;
      _weight[4] = .1184634425280945437571320203599586813216300011062070077914139441108586442015215492899967152469757224;
      break;


    case 10:
    case 11:
      delivered_order = 11;
      _points.resize(6);
      _weight.resize(6);
      _points[0] = .337652428984239860938492227530026954326171311438550875637251917366932495778999018618556300390370075e-1;
      _weight[0] = .8566224618958517252014807108636644676341125074202199119931771989947288027117007732396385271319433505e-1;
      _points[1] = .1693953067668677431693002024900473264967757178024149645927366470739082516964284495278567981267692718;
      _weight[1] = .1803807865240693037849167569188580558307609463733727411448696201185700189186308591604811009944096747;
      _points[2] = .3806904069584015456847491391596440322906946849299893249093024177128625328621800788753877863713254342;
      _weight[2] = .2339569672863455236949351719947754974058278028846052676558126599819571008101990635155550462923959909;
      _points[3] = .6193095930415984543152508608403559677093053150700106750906975822871374671378199211246122136286745658;
      _weight[3] = .2339569672863455236949351719947754974058278028846052676558126599819571008101990635155550462923959910;
      _points[4] = .8306046932331322568306997975099526735032242821975850354072633529260917483035715504721432018732307282;
      _weight[4] = .1803807865240693037849167569188580558307609463733727411448696201185700189186308591604811009944096740;
      _points[5] = .9662347571015760139061507772469973045673828688561449124362748082633067504221000981381443699609629925;
      _weight[5] = .8566224618958517252014807108636644676341125074202199119931771989947288027117007732396385271319433505e-1;
      break;


    case 12:
    case 13:
      delivered_order = 13;
      _points.resize(7);
      _weight.resize(7);
      _points[0] = .254460438286207377369051579760743687996145311646911082256154480434683348225799295971346149860371380e-1;
      _weight[0] = .6474248308443484663530571633954100916429370112997333198860431936232761748602115435781270908146042335e-1;
      _points[1] = .1292344072003027800680676133596057964629261764293048699400223240162850626639097431035865838165683764;
      _weight[1] = .1398526957446383339507338857118897912434625326132993822685070163468094052152813384066204714505988094;
      _points[2] = .2970774243113014165466967939615192683263089929503149368064783741026680933869371723358436551361267061;
      _weight[2] = .1909150252525594724751848877444875669391825417669313673755417255153527732170648541743423296720224005;
      _points[3] = .5;
      _weight[3] = .2089795918367346938775510204081632653061224489795918367346938775510204081632653061224489795918367346;
      _points[4] = .7029225756886985834533032060384807316736910070496850631935216258973319066130628276641563448638732939;
      _weight[4] = .1909150252525594724751848877444875669391825417669313673755417255153527732170648541743423296720224007;
      _points[5] = .8707655927996972199319323866403942035370738235706951300599776759837149373360902568964134161834316236;
      _weight[5] = .1398526957446383339507338857118897912434625326132993822685070163468094052152813384066204714505988092;
      _points[6] = .9745539561713792622630948420239256312003854688353088917743845519565316651774200704028653850139628620;
      _weight[6] = .6474248308443484663530571633954100916429370112997333198860431936232761748602115435781270908146042285e-1;
      break;


    case 14:
    case 15:
      delivered_order = 15;
      _points.resize(8);
      _weight.resize(8);
      _points[0] = .198550717512318841582195657152635047858823828492739808641801113137875511282903577802805203683438658e-1;
      _weight[0] = .5061426814518812957626567715498109505769704552584247852950184903237008938173539243014136965202250520e-1;
      _points[1] = .1016667612931866302042230317620847815814141341920175839649148524803913471617634539264240363521370305;
      _weight[1] = .1111905172266872352721779972131204422150654350256247823629546446468084072852245204268265711885989640;
      _points[2] = .2372337950418355070911304754053768254790178784398035711245714503637725896157193637380192999031840090;
      _weight[2] = .1568533229389436436689811009933006566301644995013674688451319725374781359710867484808490381169642782;
      _points[3] = .4082826787521750975302619288199080096666210935435131088414057631503977628892289429419658881444383232;
      _weight[3] = .1813418916891809914825752246385978060970730199471652702624115337833433673619533386621830210424142548;
      _points[4] = .5917173212478249024697380711800919903333789064564868911585942368496022371107710570580341118555616768;
      _weight[4] = .1813418916891809914825752246385978060970730199471652702624115337833433673619533386621830210424142549;
      _points[5] = .7627662049581644929088695245946231745209821215601964288754285496362274103842806362619807000968159910;
      _weight[5] = .1568533229389436436689811009933006566301644995013674688451319725374781359710867484808490381169642781;
      _points[6] = .8983332387068133697957769682379152184185858658079824160350851475196086528382365460735759636478629695;
      _weight[6] = .1111905172266872352721779972131204422150654350256247823629546446468084072852245204268265711885989639;
      _points[7] = .9801449282487681158417804342847364952141176171507260191358198886862124488717096422197194796316561342;
      _weight[7] = .5061426814518812957626567715498109505769704552584247852950184903237008938173539243014136965202250335e-1;
      break;


    case 16:
    case 17:
      delivered_order = 17;
      _points.resize(9);
      _weight.resize(9);
      _points[0] = .159198802461869550822118985481635649752975997540373352249883440754598128016996234690631253865529442e-1;
      _weight[0] = .4063719418078720598594607905526182533783086039120537535555383844034334315422603147278927735147128571e-1;
      _points[1] = .819844463366821028502851059651325617279466409376620019478140101802724965592049405530269014870712298e-1;
      _weight[1] = .9032408034742870202923601562145640475716891086602024224916795323567864527247313488229748865159985275e-1;
      _points[2] = .1933142836497048013456489803292629076071396975297176535635935288593663267544994007083799930482157077;
      _weight[2] = .1303053482014677311593714347093164248859201022186499759699985010598054078344456223238230465475087002;
      _points[3] = .3378732882980955354807309926783316957140218696315134555864762615789067102324378754034506991507512164;
      _weight[3] = .1561735385200014200343152032922218327993774306309523227770055827995719486620096582850609609440031770;
      _points[4] = .5;
      _weight[4] = .1651196775006298815822625346434870244394053917863441672965482489292013101536911060720584530108339632;
      _points[5] = .6621267117019044645192690073216683042859781303684865444135237384210932897675621245965493008492487836;
      _weight[5] = .1561735385200014200343152032922218327993774306309523227770055827995719486620096582850609609440031768;
      _points[6] = .8066857163502951986543510196707370923928603024702823464364064711406336732455005992916200069517842923;
      _weight[6] = .1303053482014677311593714347093164248859201022186499759699985010598054078344456223238230465475087008;
      _points[7] = .9180155536633178971497148940348674382720533590623379980521859898197275034407950594469730985129287702;
      _weight[7] = .9032408034742870202923601562145640475716891086602024224916795323567864527247313488229748865159985195e-1;
      _points[8] = .9840801197538130449177881014518364350247024002459626647750116559245401871983003765309368746134470558;
      _weight[8] = .4063719418078720598594607905526182533783086039120537535555383844034334315422603147278927735147128848e-1;
      break;


    case 18:
    case 19:
      delivered_order = 19;
      _points.resize(10);
      _weight.resize(10);
      _points[0] = .130467357414141399610179939577739732858650266538089403843939666517023983826819201871382175218657218e-1;
      _weight[0] = .3333567215434406879678440494666589642893241716007907256434744080670603204204355088839275484252944050e-1;
      _points[1] = .674683166555077446339516557882534757362284925173347737390201340773126224309722193216046355269771146e-1;
      _weight[1] = .7472567457529029657288816982884866620127831983471368391773863437661932736331500547297363231736597515e-1;
      _points[2] = .1602952158504877968828363174425632121153526440825952661675914055237207123024625376924607132147598102;
      _weight[2] = .1095431812579910219977674671140815962293859352613385449404782718175999553264756406213419965886010958;
      _points[3] = .2833023029353764046003670284171079188999640811718767517486492434281165054611482493874486210249411394;
      _weight[3] = .1346333596549981775456134607847346764298799692304418979002816381210767161595896383821133183546263805;
      _points[4] = .4255628305091843945575869994351400076912175702896541521460053732420481913221657393144111851002681544;
      _weight[4] = .1477621123573764350869464973256691647105233585134268006771540148779979691085761646351782978968771084;
      _points[5] = .5744371694908156054424130005648599923087824297103458478539946267579518086778342606855888148997318456;
      _weight[5] = .1477621123573764350869464973256691647105233585134268006771540148779979691085761646351782978968771085;
      _points[6] = .7166976970646235953996329715828920811000359188281232482513507565718834945388517506125513789750588606;
      _weight[6] = .1346333596549981775456134607847346764298799692304418979002816381210767161595896383821133183546263804;
      _points[7] = .8397047841495122031171636825574367878846473559174047338324085944762792876975374623075392867852401898;
      _weight[7] = .1095431812579910219977674671140815962293859352613385449404782718175999553264756406213419965886010963;
      _points[8] = .9325316833444922553660483442117465242637715074826652262609798659226873775690277806783953644730228854;
      _weight[8] = .7472567457529029657288816982884866620127831983471368391773863437661932736331500547297363231736597595e-1;
      _points[9] = .9869532642585858600389820060422260267141349733461910596156060333482976016173180798128617824781342782;
      _weight[9] = .3333567215434406879678440494666589642893241716007907256434744080670603204204355088839275484252943861e-1;
      break;


    case 20:
    case 21:
      delivered_order = 21;
      _points.resize(11);
      _weight.resize(11);
      _points[0] = .108856709269715035980309994385713046142887955401077922870994670081681003095550058998403009163276150e-1;
      _weight[0] = .2783428355808683324137686022127428936425781284844907417419214283707770364036877194184561103615942288e-1;
      _points[1] = .564687001159523504624211153480363666841621243873428075162944722311943430713136662788547024367013129e-1;
      _weight[1] = .6279018473245231231734714961197005009880789569770175033196700540895728756623563881734382085702726505e-1;
      _points[2] = .1349239972129753379532918739844232709751784689869348440108108301564933774707403852022882945143581500;
      _weight[2] = .9314510546386712571304882071582794584564237402010170589075320208693617400439275123466537925898979300e-1;
      _points[3] = .2404519353965940920371371652706952227598864424400357554895386942566520367744635535872006099477254724;
      _weight[3] = .1165968822959952399592618524215875697158990861584792545136598610609661066094404979770199742191308422;
      _points[4] = .3652284220238275138342340072995692376601890687804738591880371840599714668881526321480892038778663494;
      _weight[4] = .1314022722551233310903444349452545976863823388015722781900276857427564016697726267762084985085133530;
      _points[5] = .5;
      _weight[5] = .1364625433889503153572417641681710945780209849473918737988002057266126530195794265058334322403586472;
      _points[6] = .6347715779761724861657659927004307623398109312195261408119628159400285331118473678519107961221336506;
      _weight[6] = .1314022722551233310903444349452545976863823388015722781900276857427564016697726267762084985085133529;
      _points[7] = .7595480646034059079628628347293047772401135575599642445104613057433479632255364464127993900522745276;
      _weight[7] = .1165968822959952399592618524215875697158990861584792545136598610609661066094404979770199742191308422;
      _points[8] = .8650760027870246620467081260155767290248215310130651559891891698435066225292596147977117054856418500;
      _weight[8] = .9314510546386712571304882071582794584564237402010170589075320208693617400439275123466537925898979305e-1;
      _points[9] = .9435312998840476495375788846519636333158378756126571924837055277688056569286863337211452975632986871;
      _weight[9] = .6279018473245231231734714961197005009880789569770175033196700540895728756623563881734382085702726505e-1;
      _points[10] = .9891143290730284964019690005614286953857112044598922077129005329918318996904449941001596990836723850;
      _weight[10] = .2783428355808683324137686022127428936425781284844907417419214283707770364036877194184561103615942288e-1;
      break;


    case 22:
    case 23:
      delivered_order = 23;
      _points.resize(12);
      _weight.resize(12);
      _points[0] = .92196828766403746547254549253595885199224000931342447686589390961033778408730088873713660547738821e-2;
      _weight[0] = .2358766819325591359730798074250853015851453699742354478025267350190486057601935533541295353770726794e-1;
      _points[1] = .479413718147625716607670669404519037312016453933512267229621196593826021353821047565152860881333661e-1;
      _weight[1] = .5346966299765921548012735909699811210728508673516244000256302105140949681374878827026865904815822880e-1;
      _points[2] = .1150486629028476564815530833935909620075371249905341811677904678754417284457643879917875003882890447;
      _weight[2] = .8003916427167311316732626477167953593600586524543208895494977207897711258664557534082827631852886530e-1;
      _points[3] = .2063410228566912763516487905297328598154507429759737592448645601663296503120523687821446175056258990;
      _weight[3] = .1015837133615329608745322279048991882532590736372950731992972828988228162552364218975721975323026162;
      _points[4] = .3160842505009099031236542316781412193718199293322951893441000602479550352416060630606327857497267114;
      _weight[4] = .1167462682691774043804249494624390281297049860998774373652617489107460000397058376403395132542818452;
      _points[5] = .4373832957442655422637793152680734350083015418472778633935391226257689718793051556285658507652543202;
      _weight[5] = .1245735229067013925002812180214756054152304512848094156976755015581397137286440215155784003090211766;
      _points[6] = .5626167042557344577362206847319265649916984581527221366064608773742310281206948443714341492347456798;
      _weight[6] = .1245735229067013925002812180214756054152304512848094156976755015581397137286440215155784003090211766;
      _points[7] = .6839157494990900968763457683218587806281800706677048106558999397520449647583939369393672142502732886;
      _weight[7] = .1167462682691774043804249494624390281297049860998774373652617489107460000397058376403395132542818452;
      _points[8] = .7936589771433087236483512094702671401845492570240262407551354398336703496879476312178553824943741010;
      _weight[8] = .1015837133615329608745322279048991882532590736372950731992972828988228162552364218975721975323026162;
      _points[9] = .8849513370971523435184469166064090379924628750094658188322095321245582715542356120082124996117109553;
      _weight[9] = .8003916427167311316732626477167953593600586524543208895494977207897711258664557534082827631852886530e-1;
      _points[10] = .9520586281852374283392329330595480962687983546066487732770378803406173978646178952434847139118666339;
      _weight[10] = .5346966299765921548012735909699811210728508673516244000256302105140949681374878827026865904815822885e-1;
      _points[11] = .9907803171233596253452745450746404114800775999068657552313410609038966221591269911126286339452261179;
      _weight[11] = .2358766819325591359730798074250853015851453699742354478025267350190486057601935533541295353770726794e-1;
      break;


    case 24:
    case 25:
      delivered_order = 25;
      _points.resize(13);
      _weight.resize(13);
      _points[0] = .79084726407059252635852755964451944675047190370625456529963397857023810621865790697153563692907058e-2;
      _weight[0] = .2024200238265793976001079610049303002099327287249443406752330375249723025639635524721040621652658088e-1;
      _points[1] = .412008003885110173967260817496402438047626049441583520523573271701703957051950428582573048297085378e-1;
      _weight[1] = .4606074991886422395721088797689856046184199993111841954419577366979686486381646314594890787786598622e-1;
      _points[2] = .992109546333450436028967552085700548471921376047499850513076430703889418866799389849850629073414698e-1;
      _weight[2] = .6943675510989361923180088843443573381093135913164911382317750825288626076744476786259077142730281280e-1;
      _points[3] = .1788253302798298896780076965022421749641513008692115713054287960406782234275032125428058499429042224;
      _weight[3] = .8907299038097286914002334599804899775640632533050825149339722014457253474937436174735847561115635070e-1;
      _points[4] = .2757536244817765735610435739361800660990391662791210605208585262708779539668914281774808957226334950;
      _weight[4] = .1039080237684442511562616096530263816932913045997517746095555599582692717825422161302977640233059632;
      _points[5] = .3847708420224326029672359394510055823942288120582344182653692510814189581557090245935985276176599354;
      _weight[5] = .1131415901314486192060450930198883092173788688077785099324842743857878315602499855209131593331569648;
      _points[6] = .5;
      _weight[6] = .1162757766154369550972947576344179740783137386533989930593327196723800120403517006913610310213706817;
      _points[7] = .6152291579775673970327640605489944176057711879417655817346307489185810418442909754064014723823400646;
      _weight[7] = .1131415901314486192060450930198883092173788688077785099324842743857878315602499855209131593331569648;
      _points[8] = .7242463755182234264389564260638199339009608337208789394791414737291220460331085718225191042773665050;
      _weight[8] = .1039080237684442511562616096530263816932913045997517746095555599582692717825422161302977640233059632;
      _points[9] = .8211746697201701103219923034977578250358486991307884286945712039593217765724967874571941500570957776;
      _weight[9] = .8907299038097286914002334599804899775640632533050825149339722014457253474937436174735847561115635070e-1;
      _points[10] = .9007890453666549563971032447914299451528078623952500149486923569296110581133200610150149370926585302;
      _weight[10] = .6943675510989361923180088843443573381093135913164911382317750825288626076744476786259077142730281280e-1;
      _points[11] = .9587991996114889826032739182503597561952373950558416479476426728298296042948049571417426951702914622;
      _weight[11] = .4606074991886422395721088797689856046184199993111841954419577366979686486381646314594890787786598626e-1;
      _points[12] = .9920915273592940747364147244035548055324952809629374543470036602142976189378134209302846436307092942;
      _weight[12] = .2024200238265793976001079610049303002099327287249443406752330375249723025639635524721040621652658088e-1;
      break;


    case 26:
    case 27:
      delivered_order = 27;
      _points.resize(14);
      _weight.resize(14);
      _points[0] = .68580956515938305792013666479735991619542963803870591779645941111252229337541810446768801674241236e-2;
      _weight[0] = .1755973016587593151591643806909589030985280463856363829074994509820816141890413526883839849932323143e-1;
      _points[1] = .357825581682132413318044303110628677614803947950811906410187762589344532278200734442930471581712412e-1;
      _weight[1] = .4007904357988010490281663853142715479184889269729738260069953274478573722864358493176809540956887818e-1;
      _points[2] = .863993424651175034051026286748025194801494492624594092196454728792600845949855632147868049310552273e-1;
      _weight[2] = .6075928534395159234470740453623831297833467284503733614553769627157987194626324615940995313518750360e-1;
      _points[3] = .1563535475941572649259900984903329312307993936264146621903667556859075519084333715263134647473940808;
      _weight[3] = .7860158357909676728480096931192107830283401866866168748465852193738408818480414925697904668120903810e-1;
      _points[4] = .2423756818209229540173546407244056688455573587153469815242476154536075240839721697739639898246135538;
      _weight[4] = .9276919873896890687085829506257851812446130146866582951001746253454917513176272221277636557335611145e-1;
      _points[5] = .3404438155360551197821640879157622665828693982330780217016749063713332797436036084175331472893267934;
      _weight[5] = .1025992318606478019829620328306090278551695306547097258584486451416835724126248601697159199959454478;
      _points[6] = .4459725256463281689668776748900826261940241972628812214795894693459932354941349964349496559116553164;
      _weight[6] = .1076319267315788950979382216581300176374987790270644001098881962718093936769973020005122207054097892;
      _points[7] = .5540274743536718310331223251099173738059758027371187785204105306540067645058650035650503440883446836;
      _weight[7] = .1076319267315788950979382216581300176374987790270644001098881962718093936769973020005122207054097891;
      _points[8] = .6595561844639448802178359120842377334171306017669219782983250936286667202563963915824668527106732066;
      _weight[8] = .1025992318606478019829620328306090278551695306547097258584486451416835724126248601697159199959454478;
      _points[9] = .7576243181790770459826453592755943311544426412846530184757523845463924759160278302260360101753864462;
      _weight[9] = .9276919873896890687085829506257851812446130146866582951001746253454917513176272221277636557335611150e-1;
      _points[10] = .8436464524058427350740099015096670687692006063735853378096332443140924480915666284736865352526059192;
      _weight[10] = .7860158357909676728480096931192107830283401866866168748465852193738408818480414925697904668120903815e-1;
      _points[11] = .9136006575348824965948973713251974805198505507375405907803545271207399154050144367852131950689447727;
      _weight[11] = .6075928534395159234470740453623831297833467284503733614553769627157987194626324615940995313518750360e-1;
      _points[12] = .9642174418317867586681955696889371322385196052049188093589812237410655467721799265557069528418287588;
      _weight[12] = .4007904357988010490281663853142715479184889269729738260069953274478573722864358493176809540956887818e-1;
      _points[13] = .9931419043484061694207986333520264008380457036196129408220354058888747770662458189553231198325758764;
      _weight[13] = .1755973016587593151591643806909589030985280463856363829074994509820816141890413526883839849932323144e-1;
      break;


    case 28:
    case 29:
      delivered_order = 29;
      _points.resize(15);
      _weight.resize(15);
      _points[0] = .60037409897572857552171407066937094265135914381192550000012422063057813154902876436389748158404275e-2;
      _weight[0] = .1537662099805863417731419678860220886087407241671703713211414275211859473355858401951938536619970174e-1;
      _points[1] = .313633037996470478461205261448952643780018632423477710493184618248985131014772360247262069128659567e-1;
      _weight[1] = .3518302374405406235463370822533366923335401637716535991295364645719352775643711852242022603334696957e-1;
      _points[2] = .758967082947863918996758396128915743168719126315036829521362206196624624129272574011961401245892596e-1;
      _weight[2] = .5357961023358596750593477334293465170777185787905099034351119456093899742615789986284292856880431190e-1;
      _points[3] = .1377911343199149762919069726930309951845503527079487182242882896479381091610373905019494511984328368;
      _weight[3] = .6978533896307715722390239725551416126042513765775562160119556431554422227095390584038412868178566675e-1;
      _points[4] = .2145139136957305762313866313730446793808068018586251975733672914729023100651207102582926857150869276;
      _weight[4] = .8313460290849696677660043024060440556545009004920645366093259528177678160613925885535258714620776805e-1;
      _points[5] = .3029243264612183150513963145094772658186236119206508724844173280241955211065192910122514429191701190;
      _weight[5] = .9308050000778110551340028093321141225311300613896420140774786365500662775134958030947488444304966175e-1;
      _points[6] = .3994029530012827388496858483027018960935817727686811601920251376950258804984899061990818709662394704;
      _weight[6] = .9921574266355578822805916322191966240934627997877099674236896396456239876671713406665749958240891160e-1;
      _points[7] = .5;
      _weight[7] = .1012891209627806364403100999837596574193310790047386783983520580257176993773730370466967203563940160;
      _points[8] = .6005970469987172611503141516972981039064182272313188398079748623049741195015100938009181290337605296;
      _weight[8] = .9921574266355578822805916322191966240934627997877099674236896396456239876671713406665749958240891160e-1;
      _points[9] = .6970756735387816849486036854905227341813763880793491275155826719758044788934807089877485570808298810;
      _weight[9] = .9308050000778110551340028093321141225311300613896420140774786365500662775134958030947488444304966185e-1;
      _points[10] = .7854860863042694237686133686269553206191931981413748024266327085270976899348792897417073142849130724;
      _weight[10] = .8313460290849696677660043024060440556545009004920645366093259528177678160613925885535258714620776810e-1;
      _points[11] = .8622088656800850237080930273069690048154496472920512817757117103520618908389626094980505488015671632;
      _weight[11] = .6978533896307715722390239725551416126042513765775562160119556431554422227095390584038412868178566675e-1;
      _points[12] = .9241032917052136081003241603871084256831280873684963170478637793803375375870727425988038598754107404;
      _weight[12] = .5357961023358596750593477334293465170777185787905099034351119456093899742615789986284292856880431190e-1;
      _points[13] = .9686366962003529521538794738551047356219981367576522289506815381751014868985227639752737930871340433;
      _weight[13] = .3518302374405406235463370822533366923335401637716535991295364645719352775643711852242022603334696957e-1;
      _points[14] = .9939962590102427142447828592933062905734864085618807449999987577936942186845097123563610251841595725;
      _weight[14] = .1537662099805863417731419678860220886087407241671703713211414275211859473355858401951938536619970174e-1;
      break;


    case 30:
    case 31:
      delivered_order = 31;
      _points.resize(16);
      _weight.resize(16);
      _points[0] = .52995325041750337019229132748336862868629641711774349743880476343379313920873015307317840466009095e-2;
      _weight[0] = .1357622970587704742589028622800905175613368778338039899530515953690205683210808662466288961451544060e-1;
      _points[1] = .277124884633837119610057922326958274544303637044636995372231739666951055486588478902171356309208405e-1;
      _weight[1] = .3112676196932394643142191849718884713749325417645342895065175790976786944352190953060585476842586700e-1;
      _points[2] = .671843988060841280597660511438034338063323075762366459482442872161198011437547208714337528176138229e-1;
      _weight[2] = .4757925584124639240496255380112311317763175159185632907841114361481587978884097972351247866040249325e-1;
      _points[3] = .1222977958224984830524494025762788658230931717712484951091214115388515694843641611396889715403752783;
      _weight[3] = .6231448562776693602623814109600821007244342961110133997237529521470548196073267679898459500882784225e-1;
      _points[4] = .1910618777986781257766641179756044905040588911171711029481013222291333411225942877715444847860207484;
      _weight[4] = .7479799440828836604075086527373927448524553410391823340271098109368020201020899122588931920152962910e-1;
      _points[5] = .2709916111713863068287902785082112132299841934822382545494226245261204128548531961322822360320059534;
      _weight[5] = .8457825969750126909465603951517998110581973670801414087254146784040183210496526546607766127103911410e-1;
      _points[6] = .3591982246103705433847697492697519467569652546147000997255826330220374102504346147792798854239799204;
      _weight[6] = .9130170752246179443338183398460996969177811182732464120924757218971523247505558748020021255849263760e-1;
      _points[7] = .4524937450811812799073403322875209684348234721554672716513900913874373508777039335076206535121083240;
      _weight[7] = .9472530522753424814269836160414155257345449419795148751875662260001144538456650315006698891676697610e-1;
      _points[8] = .5475062549188187200926596677124790315651765278445327283486099086125626491222960664923793464878916760;
      _weight[8] = .9472530522753424814269836160414155257345449419795148751875662260001144538456650315006698891676697615e-1;
      _points[9] = .6408017753896294566152302507302480532430347453852999002744173669779625897495653852207201145760200796;
      _weight[9] = .9130170752246179443338183398460996969177811182732464120924757218971523247505558748020021255849263765e-1;
      _points[10] = .7290083888286136931712097214917887867700158065177617454505773754738795871451468038677177639679940466;
      _weight[10] = .8457825969750126909465603951517998110581973670801414087254146784040183210496526546607766127103911410e-1;
      _points[11] = .8089381222013218742233358820243955094959411088828288970518986777708666588774057122284555152139792516;
      _weight[11] = .7479799440828836604075086527373927448524553410391823340271098109368020201020899122588931920152962905e-1;
      _points[12] = .8777022041775015169475505974237211341769068282287515048908785884611484305156358388603110284596247217;
      _weight[12] = .6231448562776693602623814109600821007244342961110133997237529521470548196073267679898459500882784225e-1;
      _points[13] = .9328156011939158719402339488561965661936676924237633540517557127838801988562452791285662471823861771;
      _weight[13] = .4757925584124639240496255380112311317763175159185632907841114361481587978884097972351247866040249330e-1;
      _points[14] = .9722875115366162880389942077673041725455696362955363004627768260333048944513411521097828643690791595;
      _weight[14] = .3112676196932394643142191849718884713749325417645342895065175790976786944352190953060585476842586700e-1;
      _points[15] = .9947004674958249662980770867251663137131370358288225650256119523656620686079126984692682159533990905;
      _weight[15] = .1357622970587704742589028622800905175613368778338039899530515953690205683210808662466288961451544060e-1;
      break;


    case 32:
    case 33:
      delivered_order = 33;
      _points.resize(17);
      _weight.resize(17);
      _points[0] = .47122623427913321622829900296673617461050747702178486080456066288280712646889831443207796751290108e-2;
      _weight[0] = .1207415143427396598005501314378266234584865797251263915559257441510919835275524317979262073377249585e-1;
      _points[1] = .246622391156161193886415210520984892783074767204456461650153937939423168639007026249815486242658212e-1;
      _weight[1] = .2772976468699360056472008267912233025642312597661442349686203935512871300166731918663789437241095073e-1;
      _points[2] = .598804231365070489385221527559221536882915910327860498240449203379864347477943942408464030657204052e-1;
      _weight[2] = .4251807415858959044176768509553103692524569460925273788320518036939199639374132387349380214678649986e-1;
      _points[3] = .1092429980515992965373849722397619748880137636297157437433427322437111919202434619133097495665191906;
      _weight[3] = .5594192359670198554739419281317796336792171213153852500924324122454783982180491780761085226388315475e-1;
      _points[4] = .1711644203916546170748488916784988324260970542620133780973841522463378512126512091235044063472449351;
      _weight[4] = .6756818423426273664315999085117509868606292661724451018899730534443362149496927204875472415679216140e-1;
      _points[5] = .2436547314567615160568767156852240627085381387944135470436342505178575375286072598590097938097411992;
      _weight[5] = .7702288053840514404071579740097930597024152923550896719263235567572337092983822554580872467672545440e-1;
      _points[6] = .3243841182730618423514072414523269974797301242121624883404194902261028691766252135512084276982454476;
      _weight[6] = .8400205107822502225498533189416157751059906448253700713497792567016155325001229328060192486945988585e-1;
      _points[7] = .4107579092520760720746612531729672212622903336542371782185240928646512247603497119148555388951824977;
      _weight[7] = .8828135268349632316263549505659861957546220900037405902157220345660451810364134022616734534204332795e-1;
      _points[8] = .5;
      _weight[8] = .8972323517810326272913282213094281072439015994883426183383434897779837730314012970226422287625213875e-1;
      _points[9] = .5892420907479239279253387468270327787377096663457628217814759071353487752396502880851444611048175023;
      _weight[9] = .8828135268349632316263549505659861957546220900037405902157220345660451810364134022616734534204332795e-1;
      _points[10] = .6756158817269381576485927585476730025202698757878375116595805097738971308233747864487915723017545524;
      _weight[10] = .8400205107822502225498533189416157751059906448253700713497792567016155325001229328060192486945988585e-1;
      _points[11] = .7563452685432384839431232843147759372914618612055864529563657494821424624713927401409902061902588008;
      _weight[11] = .7702288053840514404071579740097930597024152923550896719263235567572337092983822554580872467672545440e-1;
      _points[12] = .8288355796083453829251511083215011675739029457379866219026158477536621487873487908764955936527550649;
      _weight[12] = .6756818423426273664315999085117509868606292661724451018899730534443362149496927204875472415679216140e-1;
      _points[13] = .8907570019484007034626150277602380251119862363702842562566572677562888080797565380866902504334808094;
      _weight[13] = .5594192359670198554739419281317796336792171213153852500924324122454783982180491780761085226388315475e-1;
      _points[14] = .9401195768634929510614778472440778463117084089672139501759550796620135652522056057591535969342795948;
      _weight[14] = .4251807415858959044176768509553103692524569460925273788320518036939199639374132387349380214678649990e-1;
      _points[15] = .9753377608843838806113584789479015107216925232795543538349846062060576831360992973750184513757341788;
      _weight[15] = .2772976468699360056472008267912233025642312597661442349686203935512871300166731918663789437241095073e-1;
      _points[16] = .9952877376572086678377170099703326382538949252297821513919543933711719287353110168556792203248709892;
      _weight[16] = .1207415143427396598005501314378266234584865797251263915559257441510919835275524317979262073377249586e-1;
      break;


    case 34:
    case 35:
      delivered_order = 35;
      _points.resize(18);
      _weight.resize(18);
      _points[0] = .42174157895345266349919976469246148737105315772801535401621848800714532041101951241182651936993864e-2;
      _weight[0] = .1080800676324165515667135513322623469384261573779497273103799507067654511867256095162565153493559774e-1;
      _points[1] = .220880252143011224094020535351118450135779325943467605773061851545509643976133880210588035201830378e-1;
      _weight[1] = .2485727444748489822666747310131932084043312306445510112315215393278617164790170814752068547468776830e-1;
      _points[2] = .536987667512221303969697044364272422960523643238508929062668425463797087816075320846662064596984218e-1;
      _weight[2] = .3821286512744452826456483880831826280265895310417914372476068961720500364589648967088255133919807780e-1;
      _points[3] = .981475205137384421587912724927046014483505391940387591247859679023059472855278563858565172787941202e-1;
      _weight[3] = .5047102205314358278140699246241730353140056944383945080518726832782539869024926167622531935567022570e-1;
      _points[4] = .1541564784698233960625544593555758052738647135912461205489186715814013155481853744330945959274336848;
      _weight[4] = .6127760335573923009225956340010077761408194866671954858362675682702871979970184091909860996252050735e-1;
      _points[5] = .2201145844630262326960642257373354315361867571146452916800065279689077358967397401704589758199778157;
      _weight[5] = .7032145733532532560236565187597361404775120516548627994172809763023279346387494851533138451345666080e-1;
      _points[6] = .2941244192685786769820341030834741814605051589399872443594255661048051634497872951128265748031744856;
      _weight[6] = .7734233756313262246270900191818738609660919813367708633332095736389143461532186515617346192611184055e-1;
      _points[7] = .3740568871542472452055135725610443849185691171701797709898644841316077532221378890964612289453068764;
      _weight[7] = .8213824187291636149302688823296379520616947699867647662224848545582421092260400387768187887353024455e-1;
      _points[8] = .4576124934791323493788690735321080941333413065469550399783177411872501046733599991810977246362801938;
      _weight[8] = .8457119148157179592032823506749330516705290968517194013493759577452972209577732108546045701988907675e-1;
      _points[9] = .5423875065208676506211309264678919058666586934530449600216822588127498953266400008189022753637198062;
      _weight[9] = .8457119148157179592032823506749330516705290968517194013493759577452972209577732108546045701988907675e-1;
      _points[10] = .6259431128457527547944864274389556150814308828298202290101355158683922467778621109035387710546931236;
      _weight[10] = .8213824187291636149302688823296379520616947699867647662224848545582421092260400387768187887353024455e-1;
      _points[11] = .7058755807314213230179658969165258185394948410600127556405744338951948365502127048871734251968255144;
      _weight[11] = .7734233756313262246270900191818738609660919813367708633332095736389143461532186515617346192611184055e-1;
      _points[12] = .7798854155369737673039357742626645684638132428853547083199934720310922641032602598295410241800221843;
      _weight[12] = .7032145733532532560236565187597361404775120516548627994172809763023279346387494851533138451345666080e-1;
      _points[13] = .8458435215301766039374455406444241947261352864087538794510813284185986844518146255669054040725663152;
      _weight[13] = .6127760335573923009225956340010077761408194866671954858362675682702871979970184091909860996252050735e-1;
      _points[14] = .9018524794862615578412087275072953985516494608059612408752140320976940527144721436141434827212058798;
      _weight[14] = .5047102205314358278140699246241730353140056944383945080518726832782539869024926167622531935567022565e-1;
      _points[15] = .9463012332487778696030302955635727577039476356761491070937331574536202912183924679153337935403015782;
      _weight[15] = .3821286512744452826456483880831826280265895310417914372476068961720500364589648967088255133919807780e-1;
      _points[16] = .9779119747856988775905979464648881549864220674056532394226938148454490356023866119789411964798169622;
      _weight[16] = .2485727444748489822666747310131932084043312306445510112315215393278617164790170814752068547468776829e-1;
      _points[17] = .9957825842104654733650080023530753851262894684227198464598378151199285467958898048758817348063006136;
      _weight[17] = .1080800676324165515667135513322623469384261573779497273103799507067654511867256095162565153493559774e-1;
      break;


    case 36:
    case 37:
      delivered_order = 37;
      _points.resize(19);
      _weight.resize(19);
      _points[0] = .37965780782077984054911648733697532053417992983946066601602804543840485207385580981625395632905994e-2;
      _weight[0] = .9730894114863238518156020732219217876453304534643320396340236230800718784052774105426044022633746010e-2;
      _points[1] = .198959239325849845736105796561742366924542483629309470410918327838996250312557433896282192542293412e-1;
      _weight[1] = .2240711338284980016641907870099710597587711373392880104292726338382149569213972882233451785512799686e-1;
      _points[2] = .484220481925910491786695357338437560953030329713220911524837876191820977049478905212398858153514772e-1;
      _weight[2] = .3452227136882061329035412900300652248092401584380656556145021384801748745321951075883154773166748644e-1;
      _points[3] = .886426717314285875105387566436430491127307568965849793150680556972498285481570839865668884453697002e-1;
      _weight[3] = .4574501081122499973223104706191982633045582564829939233249467245103111052189863080287385752094447824e-1;
      _points[4] = .1395169113323853106914520695881091851714290835456666125307047643066927204260069735782833086643367127;
      _weight[4] = .5578332277366699735801195084088299874066592691994688776073057143822948805282323530050214247629615270e-1;
      _points[5] = .1997273476691594882651809175268803600658389586338537162067066371658075456515645797876221023342729993;
      _weight[5] = .6437698126966811383775789242843855852791978854673151727355219231115180202831583996571650116707603665e-1;
      _points[6] = .2677146293120195271413664259479488160118571426879317015078455612121579394432872966567752271396340276;
      _weight[6] = .7130335108680330588787305472095148623783417241223693046328582795322912423645162550747003591862506850e-1;
      _points[7] = .3417179500181850840049413355750775410538573904335563774221355066010535570897118010015805539567598244;
      _weight[7] = .7638302103292983338942770044883149923050413361821431176155077653740552182553160682740492351539353415e-1;
      _points[8] = .4198206771798873120659519421296282252475632497645623105626782741968396956598044631716302132502595436;
      _weight[8] = .7948442169697717382497821973252360083939007909756304787558745766237048929169252987130523836300323930e-1;
      _points[9] = .5;
      _weight[9] = .8052722492439184798958181266045836751995127928925845106416157636788552422774903607627038285846452350e-1;
      _points[10] = .5801793228201126879340480578703717747524367502354376894373217258031603043401955368283697867497404564;
      _weight[10] = .7948442169697717382497821973252360083939007909756304787558745766237048929169252987130523836300323930e-1;
      _points[11] = .6582820499818149159950586644249224589461426095664436225778644933989464429102881989984194460432401756;
      _weight[11] = .7638302103292983338942770044883149923050413361821431176155077653740552182553160682740492351539353415e-1;
      _points[12] = .7322853706879804728586335740520511839881428573120682984921544387878420605567127033432247728603659724;
      _weight[12] = .7130335108680330588787305472095148623783417241223693046328582795322912423645162550747003591862506845e-1;
      _points[13] = .8002726523308405117348190824731196399341610413661462837932933628341924543484354202123778976657270007;
      _weight[13] = .6437698126966811383775789242843855852791978854673151727355219231115180202831583996571650116707603665e-1;
      _points[14] = .8604830886676146893085479304118908148285709164543333874692952356933072795739930264217166913356632873;
      _weight[14] = .5578332277366699735801195084088299874066592691994688776073057143822948805282323530050214247629615270e-1;
      _points[15] = .9113573282685714124894612433563569508872692431034150206849319443027501714518429160134331115546302998;
      _weight[15] = .4574501081122499973223104706191982633045582564829939233249467245103111052189863080287385752094447821e-1;
      _points[16] = .9515779518074089508213304642661562439046969670286779088475162123808179022950521094787601141846485228;
      _weight[16] = .3452227136882061329035412900300652248092401584380656556145021384801748745321951075883154773166748644e-1;
      _points[17] = .9801040760674150154263894203438257633075457516370690529589081672161003749687442566103717807457706588;
      _weight[17] = .2240711338284980016641907870099710597587711373392880104292726338382149569213972882233451785512799687e-1;
      _points[18] = .9962034219217922015945088351266302467946582007016053933398397195456159514792614419018374604367094006;
      _weight[18] = .9730894114863238518156020732219217876453304534643320396340236230800718784052774105426044022633746010e-2;
      break;


    case 38:
    case 39:
      delivered_order = 39;
      _points.resize(20);
      _weight.resize(20);
      _points[0] = .34357004074525376069388057643398608886764345491720519259079343910076411861231095802752987517138954e-2;
      _weight[0] = .8807003569576059155930981175926408181071552771668366262174663338674209629810923908701552771073048480e-2;
      _points[1] = .180140363610431043661669344013613890439698360969055719682312030539792096078084715099909373720176422e-1;
      _weight[1] = .2030071490019347066551997613746605493954531999497576840880342728091614837549366414776946031152219270e-1;
      _points[2] = .438827858743370470661237793983509434754076012881541126020588904209645543956404605317776369035393063e-1;
      _weight[2] = .3133602416705453178475326759352080317580053828921818204979217271898740551683283932228188302841610166e-1;
      _points[3] = .804415140888905883027354691492396573351853174671813133737536372335694530003375950403853297170211754e-1;
      _weight[3] = .4163837078835237436237907161102310305008891429158164537244103039284654144703970973568759542189541972e-1;
      _points[4] = .1268340467699246036928474648221792048446346602154117779302270469657323224809224676594479431896762397;
      _weight[4] = .5096505990862021751837506774017493808334582801169627813098580809842616101269717323767465788473992915e-1;
      _points[5] = .1819731596367424872735816518868570316283054416003157680302766887267293687072849337206484022521193467;
      _weight[5] = .5909726598075920865618868885569114350252060977448438772344497601008737417525575815286434391290950870e-1;
      _points[6] = .2445664990245864509978179745223745007872543353987865832638256900526325148046171359279841584745661104;
      _weight[6] = .6584431922458831344924724987408156745805525557349176349821824685442717821474046657177898759198631460e-1;
      _points[7] = .3131469556422902196637259114875363813021268391471586440860256932421771178134702360520521581827333106;
      _weight[7] = .7104805465919102566464916253358246651725770669601015166868354149191404374896718380847461214160029135e-1;
      _points[8] = .3861070744291774609597519023157126876284555311585362638426821303964143290682220861025239374045156460;
      _weight[8] = .7458649323630187339391436850098471834633995204068415824810560890492221129779339034698066301760524055e-1;
      _points[9] = .4617367394332513331226797953005808944976018665932512495976023778078718289758315108792274429092218922;
      _weight[9] = .7637669356536292534904216597754879674597432255618929863735052490879872658136889076778624391825195300e-1;
      _points[10] = .5382632605667486668773202046994191055023981334067487504023976221921281710241684891207725570907781078;
      _weight[10] = .7637669356536292534904216597754879674597432255618929863735052490879872658136889076778624391825195295e-1;
      _points[11] = .6138929255708225390402480976842873123715444688414637361573178696035856709317779138974760625954843540;
      _weight[11] = .7458649323630187339391436850098471834633995204068415824810560890492221129779339034698066301760524055e-1;
      _points[12] = .6868530443577097803362740885124636186978731608528413559139743067578228821865297639479478418172666894;
      _weight[12] = .7104805465919102566464916253358246651725770669601015166868354149191404374896718380847461214160029135e-1;
      _points[13] = .7554335009754135490021820254776254992127456646012134167361743099473674851953828640720158415254338896;
      _weight[13] = .6584431922458831344924724987408156745805525557349176349821824685442717821474046657177898759198631465e-1;
      _points[14] = .8180268403632575127264183481131429683716945583996842319697233112732706312927150662793515977478806533;
      _weight[14] = .5909726598075920865618868885569114350252060977448438772344497601008737417525575815286434391290950870e-1;
      _points[15] = .8731659532300753963071525351778207951553653397845882220697729530342676775190775323405520568103237603;
      _weight[15] = .5096505990862021751837506774017493808334582801169627813098580809842616101269717323767465788473992915e-1;
      _points[16] = .9195584859111094116972645308507603426648146825328186866262463627664305469996624049596146702829788246;
      _weight[16] = .4163837078835237436237907161102310305008891429158164537244103039284654144703970973568759542189541972e-1;
      _points[17] = .9561172141256629529338762206016490565245923987118458873979411095790354456043595394682223630964606937;
      _weight[17] = .3133602416705453178475326759352080317580053828921818204979217271898740551683283932228188302841610168e-1;
      _points[18] = .9819859636389568956338330655986386109560301639030944280317687969460207903921915284900090626279823578;
      _weight[18] = .2030071490019347066551997613746605493954531999497576840880342728091614837549366414776946031152219268e-1;
      _points[19] = .9965642995925474623930611942356601391113235654508279480740920656089923588138768904197247012482861046;
      _weight[19] = .8807003569576059155930981175926408181071552771668366262174663338674209629810923908701552771073048480e-2;
      break;


    case 40:
    case 41:
      delivered_order = 41;
      _points.resize(21);
      _weight.resize(21);
      _points[0] = .31239146898052498698789820310295354033307726088354072095630726434519454885035965009356264323804612e-2;
      _weight[0] = .8008614128887166662112308429235507632945211058951241274088955056779383680659431157453353047572838170e-2;
      _points[1] = .163865807168468528416888925461524192876531563350765750235144359574395199974598560140812990680379736e-1;
      _weight[1] = .1847689488542624689997533414966483309447215407436491871358459093939287557878370422926172143848016472e-1;
      _points[2] = .399503329247995856049064331425155529204261951758891514119322564545092184652960855041340243139658653e-1;
      _weight[2] = .2856721271342860414181791323622397874564379841312802072125366171352452769982600404414322428351082334e-1;
      _points[3] = .733183177083413581763746807062161648619470984103280146285041853028785468580824265138551814041519428e-1;
      _weight[3] = .3805005681418965100852582665009158961307717621198301426073424290822675829330037499656830940632376613e-1;
      _points[4] = .1157800182621610456920610743468859825895116471143152245656366674849906287301494102064641704530678064;
      _weight[4] = .4672221172801693077664487055696604424176332368079642243334763581628894888685619367593429428339537842e-1;
      _points[5] = .1664305979012938403470166650048304187014853283442985787622664588264029034421518523502447557186043700;
      _weight[5] = .5439864958357418883173728903505282101684979789692816527639104358448682188313469419058838121539598570e-1;
      _points[6] = .2241905820563900964704906016378433566889698878846601674978470802501976091441579814715095060504845204;
      _weight[6] = .6091570802686426709768358856286679917816881278076872512149190392137945061467548197097422700255402720e-1;
      _points[7] = .2878289398962806082131655557281059739517773840801827078878708820517565581605992215000639535430861812;
      _weight[7] = .6613446931666873089052628724838780216450577007157841160917516157589129928261519951184529780764439120e-1;
      _points[8] = .3559893415987994516996037419676998400454908681769833856228592376253775285290786160733304858198915867;
      _weight[8] = .6994369739553657736106671193379155544639658047745980218686566316212163123260307830816081080108004990e-1;
      _points[9] = .4272190729195524545314845088306568349418369877810311212892558050072263595583401011547420107808957735;
      _weight[9] = .7226220199498502953191358327687627180497498109854991737623649444304865467169593493263483293242601165e-1;
      _points[10] = .5;
      _weight[10] = .7304056682484521359599257384168559412240478847098272205366129375771929635169980596487109556323312785e-1;
      _points[11] = .5727809270804475454685154911693431650581630122189688787107441949927736404416598988452579892191042265;
      _weight[11] = .7226220199498502953191358327687627180497498109854991737623649444304865467169593493263483293242601170e-1;
      _points[12] = .6440106584012005483003962580323001599545091318230166143771407623746224714709213839266695141801084133;
      _weight[12] = .6994369739553657736106671193379155544639658047745980218686566316212163123260307830816081080108004995e-1;
      _points[13] = .7121710601037193917868344442718940260482226159198172921121291179482434418394007784999360464569138188;
      _weight[13] = .6613446931666873089052628724838780216450577007157841160917516157589129928261519951184529780764439115e-1;
      _points[14] = .7758094179436099035295093983621566433110301121153398325021529197498023908558420185284904939495154796;
      _weight[14] = .6091570802686426709768358856286679917816881278076872512149190392137945061467548197097422700255402725e-1;
      _points[15] = .8335694020987061596529833349951695812985146716557014212377335411735970965578481476497552442813956300;
      _weight[15] = .5439864958357418883173728903505282101684979789692816527639104358448682188313469419058838121539598570e-1;
      _points[16] = .8842199817378389543079389256531140174104883528856847754343633325150093712698505897935358295469321936;
      _weight[16] = .4672221172801693077664487055696604424176332368079642243334763581628894888685619367593429428339537845e-1;
      _points[17] = .9266816822916586418236253192937838351380529015896719853714958146971214531419175734861448185958480572;
      _weight[17] = .3805005681418965100852582665009158961307717621198301426073424290822675829330037499656830940632376613e-1;
      _points[18] = .9600496670752004143950935668574844470795738048241108485880677435454907815347039144958659756860341347;
      _weight[18] = .2856721271342860414181791323622397874564379841312802072125366171352452769982600404414322428351082336e-1;
      _points[19] = .9836134192831531471583111074538475807123468436649234249764855640425604800025401439859187009319620264;
      _weight[19] = .1847689488542624689997533414966483309447215407436491871358459093939287557878370422926172143848016470e-1;
      _points[20] = .9968760853101947501301210179689704645966692273911645927904369273565480545114964034990643735676195388;
      _weight[20] = .8008614128887166662112308429235507632945211058951241274088955056779383680659431157453353047572838170e-2;
      break;


    case 42:
    case 43:
      delivered_order = 43;
      _points.resize(22);
      _weight.resize(22);
      _points[0] = .28527072588003539634842894193505098034729008019842325114885375166717511479600440896140371118641978e-2;
      _weight[0] = .7313997649136100342495549023592722595105974562161865462248795710094053266374085571141887053759164140e-2;
      _points[1] = .149697510822856364380245066173656445970155384310985152201308938318128696125787456812293226864828573e-1;
      _weight[1] = .1688745079240707739665112343295645067458465723723733021644159727997575587653074419945747441116359070e-1;
      _points[2] = .365216139064129997396535303704734016823351733139740089777134042364319404442294372481531235762733209e-1;
      _weight[2] = .2614666757634164297015602563660562805607504678461815806135504164883817117996641239098409502489711904e-1;
      _points[3] = .670937111398499317317871814903106354576016222057769219364533153686415525292397825957599218580713774e-1;
      _weight[3] = .3489823421226024404748070946510882869938752647754026369315568588197320174364294701969642039672437436e-1;
      _points[4] = .1060915970103959189978610222958242393059106643342184209391533011444338618736459625499742405203333074;
      _weight[4] = .4297080310853386370722184068635143309457220267453989164328500552412301238656307871601112490735976389e-1;
      _points[5] = .1527563684066586099746550821188716143663288550112824194391331123038570301128534725802029426006948234;
      _weight[5] = .5020707222144048246603941891526814117540554438384981289248045717022654803711188637143031958167977870e-1;
      _points[6] = .2061797982465442035205615361806763255611921982131410801149830893137658110859778198204199473943616987;
      _weight[6] = .5646614804026960919670030371089215955713166606049735213629877312430656546180541682980244071248443370e-1;
      _points[7] = .2653220810066214867968346445167968269523281044346317261019499851532114926571816930628014255887449254;
      _weight[7] = .6162618840525621214278049307740723597972249950248398621421098594256775139958772701589012301721317145e-1;
      _points[8] = .3290320895539578874209262897863101902204133504146563280015688081554932805464265186717208013164783516;
      _weight[8] = .6558675239353118536648249626515372293787094709401532656268985171227230515676448704571705001654012950e-1;
      _points[9] = .3960697866558893572605767330402271328921624454510331751656733478158995793426411678917005879371503930;
      _weight[9] = .6827074917300758567628691561575869829318382649434308405473486746910377908226891669049531646614901690e-1;
      _points[10] = .4651303633401388893930791019406859590888518502598842626466590267441953131836802769617408028147830728;
      _weight[10] = .6962593642781599668770512417090497893696010872871292906309893853651885640938429814937374841202945705e-1;
      _points[11] = .5348696366598611106069208980593140409111481497401157373533409732558046868163197230382591971852169272;
      _weight[11] = .6962593642781599668770512417090497893696010872871292906309893853651885640938429814937374841202945705e-1;
      _points[12] = .6039302133441106427394232669597728671078375545489668248343266521841004206573588321082994120628496070;
      _weight[12] = .6827074917300758567628691561575869829318382649434308405473486746910377908226891669049531646614901690e-1;
      _points[13] = .6709679104460421125790737102136898097795866495853436719984311918445067194535734813282791986835216484;
      _weight[13] = .6558675239353118536648249626515372293787094709401532656268985171227230515676448704571705001654012950e-1;
      _points[14] = .7346779189933785132031653554832031730476718955653682738980500148467885073428183069371985744112550746;
      _weight[14] = .6162618840525621214278049307740723597972249950248398621421098594256775139958772701589012301721317145e-1;
      _points[15] = .7938202017534557964794384638193236744388078017868589198850169106862341889140221801795800526056383013;
      _weight[15] = .5646614804026960919670030371089215955713166606049735213629877312430656546180541682980244071248443370e-1;
      _points[16] = .8472436315933413900253449178811283856336711449887175805608668876961429698871465274197970573993051766;
      _weight[16] = .5020707222144048246603941891526814117540554438384981289248045717022654803711188637143031958167977870e-1;
      _points[17] = .8939084029896040810021389777041757606940893356657815790608466988555661381263540374500257594796666926;
      _weight[17] = .4297080310853386370722184068635143309457220267453989164328500552412301238656307871601112490735976389e-1;
      _points[18] = .9329062888601500682682128185096893645423983777942230780635466846313584474707602174042400781419286226;
      _weight[18] = .3489823421226024404748070946510882869938752647754026369315568588197320174364294701969642039672437440e-1;
      _points[19] = .9634783860935870002603464696295265983176648266860259910222865957635680595557705627518468764237266791;
      _weight[19] = .2614666757634164297015602563660562805607504678461815806135504164883817117996641239098409502489711904e-1;
      _points[20] = .9850302489177143635619754933826343554029844615689014847798691061681871303874212543187706773135171427;
      _weight[20] = .1688745079240707739665112343295645067458465723723733021644159727997575587653074419945747441116359070e-1;
      _points[21] = .9971472927411996460365157105806494901965270991980157674885114624833282488520399559103859628881358022;
      _weight[21] = .7313997649136100342495549023592722595105974562161865462248795710094053266374085571141887053759164145e-2;
      break;


    case 44:
    case 45:
      delivered_order = 45;
      _points.resize(23);
      _weight.resize(23);
      _points[0] = .26153325012239382380371422772128197131863137705647895366030579164629601171073649080054278918099330e-2;
      _weight[0] = .6705929743570886040654746729307532488309167052868616696197941069580443368026029924649517729262032555e-2;
      _points[1] = .137287643909423840219879615896113124091931023230130287543719206321014814127117910662912671280352426e-1;
      _weight[1] = .1549400292848972215534710982094225269188626449996403321744390329930889213143379600112485832998544809e-1;
      _points[2] = .335144565869919488254015054807885108821490899243046146535493726990110855999564600434949640868522473e-1;
      _weight[2] = .2401883586554233428582053581601699828060815415175580566684183343492904343740931457766547088994173192e-1;
      _points[3] = .616238208647791663109215570329271641805354850196746825452994421197241806452420284007172524391514584e-1;
      _weight[3] = .3211621070426292606358480757945549901957913787740341524767334102645877679039064170319608707260665849e-1;
      _points[4] = .975557991905800539244407965016107210292849301348459887072837821641466199154753203924549983090379171e-1;
      _weight[4] = .3964070588835947746144626237102161345685599596920325127781727016602150200687944126797678664420782006e-1;
      _points[5] = .1406693184340249027691877581256905758350351274343536021226093558929744356620371262448563720390262400;
      _weight[5] = .4645788303001757373850930868488232430173003587156494686632975230596864246779408039973782060447362780e-1;
      _points[6] = .1901950621181769218074513441752021733064096705964538521495672071954400967517765817297777471175291148;
      _weight[6] = .5244604573227070503704309250737192742923579159698750275141259616938968817102544494992821898212281070e-1;
      _points[7] = .2452492610769962251551034760665767847275786154075711883864053095893624974476167342466240061359891282;
      _weight[7] = .5749832011120568247082175646698065074570526146479280330453785170139979724187270361906533563747528085e-1;
      _points[8] = .3048494809848545842892555635596972707109745746537482593903973683416436919064837854106762368147562969;
      _weight[8] = .6152454215336476523378920033600482740792640627323528721783516645084523385389260275505301355895106555e-1;
      _points[9] = .3679321595148275347330652308583451985104933749029301975654605614738355732086639877109207356445331132;
      _weight[9] = .6445286109404107498929766969989682662985774859589174622217021585899473237800551787502302994595886845e-1;
      _points[10] = .4333715878507669445341286588791169314947973618733089217445273114064760550621727612127183682018242994;
      _weight[10] = .6623101970234830868582123235165846290251783473711176216125613401924300294133970283679005885397038905e-1;
      _points[11] = .5;
      _weight[11] = .6682728609305308767572855527292216929157640381844165874096798899572049042386144817957960350208853285e-1;
      _points[12] = .5666284121492330554658713411208830685052026381266910782554726885935239449378272387872816317981757006;
      _weight[12] = .6623101970234830868582123235165846290251783473711176216125613401924300294133970283679005885397038905e-1;
      _points[13] = .6320678404851724652669347691416548014895066250970698024345394385261644267913360122890792643554668868;
      _weight[13] = .6445286109404107498929766969989682662985774859589174622217021585899473237800551787502302994595886845e-1;
      _points[14] = .6951505190151454157107444364403027292890254253462517406096026316583563080935162145893237631852437031;
      _weight[14] = .6152454215336476523378920033600482740792640627323528721783516645084523385389260275505301355895106555e-1;
      _points[15] = .7547507389230037748448965239334232152724213845924288116135946904106375025523832657533759938640108718;
      _weight[15] = .5749832011120568247082175646698065074570526146479280330453785170139979724187270361906533563747528085e-1;
      _points[16] = .8098049378818230781925486558247978266935903294035461478504327928045599032482234182702222528824708852;
      _weight[16] = .5244604573227070503704309250737192742923579159698750275141259616938968817102544494992821898212281070e-1;
      _points[17] = .8593306815659750972308122418743094241649648725656463978773906441070255643379628737551436279609737600;
      _weight[17] = .4645788303001757373850930868488232430173003587156494686632975230596864246779408039973782060447362784e-1;
      _points[18] = .9024442008094199460755592034983892789707150698651540112927162178358533800845246796075450016909620829;
      _weight[18] = .3964070588835947746144626237102161345685599596920325127781727016602150200687944126797678664420782006e-1;
      _points[19] = .9383761791352208336890784429670728358194645149803253174547005578802758193547579715992827475608485416;
      _weight[19] = .3211621070426292606358480757945549901957913787740341524767334102645877679039064170319608707260665852e-1;
      _points[20] = .9664855434130080511745984945192114891178509100756953853464506273009889144000435399565050359131477527;
      _weight[20] = .2401883586554233428582053581601699828060815415175580566684183343492904343740931457766547088994173194e-1;
      _points[21] = .9862712356090576159780120384103886875908068976769869712456280793678985185872882089337087328719647574;
      _weight[21] = .1549400292848972215534710982094225269188626449996403321744390329930889213143379600112485832998544808e-1;
      _points[22] = .9973846674987760617619628577227871802868136862294352104633969420835370398828926350919945721081900670;
      _weight[22] = .6705929743570886040654746729307532488309167052868616696197941069580443368026029924649517729262032555e-2;
      break;


    case 46:
    case 47:
      delivered_order = 47;
      _points.resize(24);
      _weight.resize(24);
      _points[0] = .24063900014893199100012951496315940627011537019985612791997274428580839652711310583013553314421456e-2;
      _weight[0] = .6170614899993599773402833535018645787955020445683258408643660470545862758940556895899359335960211630e-2;
      _points[1] = .126357220143452509008040034959154691294084734799106400942032174464094393595098877306812628591422725e-1;
      _weight[1] = .1426569431446683159065390797593914322459889896595405830083240237882200281871457171284271271140493764e-1;
      _points[2] = .308627239986336207381754991456392751725901709612743266824864120452052519737321645200176792320650222e-1;
      _weight[2] = .2213871940870990308430137410566911442965642091692894837069861486051218814113321981719735850777974680e-1;
      _points[3] = .567922364977994828934228290089016224563334783455399798144810416121625828005204139479382490019091494e-1;
      _weight[3] = .2964929245771839037318387925005429227060006328260674551868827564704915158875412078303417780530450481e-1;
      _points[4] = .899990070130485390230250636651273959619367611660722063780094869993085105232227299588697394137081020e-1;
      _weight[4] = .3667324070554015286701680762655825905966825492424973570135124533002069423793546741616257113472227752e-1;
      _points[5] = .1299379042107228178780859484500107872383537564929072715668088158640498306795385337793343219344356028;
      _weight[5] = .4309508076597663795859260149187133359254029411896650279420357193064344223039026563444432814864084862e-1;
      _points[6] = .1759531740315122153737521065446261866651708506905216098505331674877758412157301140359411148171363783;
      _weight[6] = .4880932605205694413494033223212357721395948442684297204165530501147716928879598917401001984535909374e-1;
      _points[7] = .2272892643055802321708121913908138149946080037061909122831928050847175804102145514520825662795968749;
      _weight[7] = .5372213505798281739128867122330311139731434506711001088327082044341093319721855299029336356045761835e-1;
      _points[8] = .2831032461869774307564578840433251437737892445360155959595993576716177964831845429711322847669621916;
      _weight[8] = .5775283402686280067667224195339177993113515568824823529222468004433512677565927497017212882340639775e-1;
      _points[9] = .3424786601519183128066033543400948796067608695875913656228849352350589218293782958280632452223958947;
      _weight[9] = .6083523646390169560223157673813121280351477960190288938873587725631269685885848095887890171538642100e-1;
      _points[10] = .4044405662631918454206800896214651840797974483426233219255407117059570236540641290087544443773951346;
      _weight[10] = .6291872817341414806068769125559184436320166279067270208904575844069693633333129844101908962821057040e-1;
      _points[11] = .4679715535686971869574784586876274807045004022896263032878244591051303582030449460985535619328737455;
      _weight[11] = .6396909767337607848702808261234768592585561977083394121064978818617379577026820120604598878336737115e-1;
      _points[12] = .5320284464313028130425215413123725192954995977103736967121755408948696417969550539014464380671262545;
      _weight[12] = .6396909767337607848702808261234768592585561977083394121064978818617379577026820120604598878336737110e-1;
      _points[13] = .5955594337368081545793199103785348159202025516573766780744592882940429763459358709912455556226048654;
      _weight[13] = .6291872817341414806068769125559184436320166279067270208904575844069693633333129844101908962821057035e-1;
      _points[14] = .6575213398480816871933966456599051203932391304124086343771150647649410781706217041719367547776041053;
      _weight[14] = .6083523646390169560223157673813121280351477960190288938873587725631269685885848095887890171538642095e-1;
      _points[15] = .7168967538130225692435421159566748562262107554639844040404006423283822035168154570288677152330378084;
      _weight[15] = .5775283402686280067667224195339177993113515568824823529222468004433512677565927497017212882340639780e-1;
      _points[16] = .7727107356944197678291878086091861850053919962938090877168071949152824195897854485479174337204031251;
      _weight[16] = .5372213505798281739128867122330311139731434506711001088327082044341093319721855299029336356045761835e-1;
      _points[17] = .8240468259684877846262478934553738133348291493094783901494668325122241587842698859640588851828636217;
      _weight[17] = .4880932605205694413494033223212357721395948442684297204165530501147716928879598917401001984535909372e-1;
      _points[18] = .8700620957892771821219140515499892127616462435070927284331911841359501693204614662206656780655643972;
      _weight[18] = .4309508076597663795859260149187133359254029411896650279420357193064344223039026563444432814864084862e-1;
      _points[19] = .9100009929869514609769749363348726040380632388339277936219905130006914894767772700411302605862918980;
      _weight[19] = .3667324070554015286701680762655825905966825492424973570135124533002069423793546741616257113472227752e-1;
      _points[20] = .9432077635022005171065771709910983775436665216544600201855189583878374171994795860520617509980908506;
      _weight[20] = .2964929245771839037318387925005429227060006328260674551868827564704915158875412078303417780530450481e-1;
      _points[21] = .9691372760013663792618245008543607248274098290387256733175135879547947480262678354799823207679349778;
      _weight[21] = .2213871940870990308430137410566911442965642091692894837069861486051218814113321981719735850777974678e-1;
      _points[22] = .9873642779856547490991959965040845308705915265200893599057967825535905606404901122693187371408577275;
      _weight[22] = .1426569431446683159065390797593914322459889896595405830083240237882200281871457171284271271140493764e-1;
      _points[23] = .9975936099985106800899987048503684059372988462980014387208002725571419160347288689416986446685578544;
      _weight[23] = .6170614899993599773402833535018645787955020445683258408643660470545862758940556895899359335960211630e-2;
      break;


    case 48:
    case 49:
      delivered_order = 49;
      _points.resize(25);
      _weight.resize(25);
      _points[0] = .22215151047509510456075265530491913712186752975959143945975344335332593281360327563559868235264962e-2;
      _weight[0] = .5696899250513143973951482056617386801660263146454848224474030558094945864883371677961838556472516215e-2;
      _points[1] = .116680392702412442508423067602029661273147223427966276645062863419180662320597230517766452584969106e-1;
      _weight[1] = .1317749330751606863095090764764957246798164085166123437768308289193546700443974968576491076408646420e-1;
      _points[2] = .285127143855128302929944151707647340473992146955049290362737514313523387279753693455473909243632584e-1;
      _weight[2] = .2046957835065315632781174385582297683042289168205217325234920744964871644010775638523948552755521192e-1;
      _points[3] = .525040010608623155744789966085975229127225751232080484691491585204142445494002743144069965348041092e-1;
      _weight[3] = .2745234798791759596296844577023666208005499277655567452425424912229688733921825594785596203971672246e-1;
      _points[4] = .832786856195829992894894456532152152695179430882396069895676422691409337614549373733851302612041594e-1;
      _weight[4] = .3401916690617845860359359282835398427735474717731828130753561320500182702585573655332576148474093677e-1;
      _points[5] = .1203703684813211847113585673978195118062389905508329395408051322774906855898687961961816013790738484;
      _weight[5] = .4007035016750050900661747983455565114511286642683794685810073148680641446740064477972868885711265904e-1;
      _points[6] = .1632168157632658177574396833761889120582916359636253414701715191108561315753578942090181571598453390;
      _weight[6] = .4551413099148182490574861035144582669049627947966715548524188448350869233920526345124219907147685948e-1;
      _points[7] = .2111685348793885161381550791936729663021324803542408716772582461194884936236839888616417017671017546;
      _weight[7] = .5026797453352532210110344519634291349423304726407095353493452099970647407952301484097782810186629110e-1;
      _points[8] = .2634986342771425197389089424954039793340911307691863545463845861521983620793569849484215761086031823;
      _weight[8] = .5425981223713182655804697852505830967003879399336100807824715367441964639680422134669884175014827085e-1;
      _points[9] = .3194138470953060811320891349361796662889608264783124651027106110766273088021517256983523424695311930;
      _weight[9] = .5742912957285582416966277293477790432046809583409007479575749501574139833556271128267214949279078135e-1;
      _points[10] = .3780665581395057839774048186012742067971834218370077617894321733748062636070720246601118161183748297;
      _weight[10] = .5972788176789238611408906325645052369508835070686321275979394066759204511009386751221434860487635665e-1;
      _points[11] = .4385676536946448018063200905959815972338973269751081307880532310536455825155707920867805750268344723;
      _weight[11] = .6112122149515502084447975947292575291752962378152952045379004111601948360959005121516770445539453315e-1;
      _points[12] = .5;
      _weight[12] = .6158802686335772560195143653952507121911681375907583269567609865845600397463071064230056258752479190e-1;
      _points[13] = .5614323463053551981936799094040184027661026730248918692119467689463544174844292079132194249731655277;
      _weight[13] = .6112122149515502084447975947292575291752962378152952045379004111601948360959005121516770445539453320e-1;
      _points[14] = .6219334418604942160225951813987257932028165781629922382105678266251937363929279753398881838816251703;
      _weight[14] = .5972788176789238611408906325645052369508835070686321275979394066759204511009386751221434860487635660e-1;
      _points[15] = .6805861529046939188679108650638203337110391735216875348972893889233726911978482743016476575304688070;
      _weight[15] = .5742912957285582416966277293477790432046809583409007479575749501574139833556271128267214949279078130e-1;
      _points[16] = .7365013657228574802610910575045960206659088692308136454536154138478016379206430150515784238913968177;
      _weight[16] = .5425981223713182655804697852505830967003879399336100807824715367441964639680422134669884175014827090e-1;
      _points[17] = .7888314651206114838618449208063270336978675196457591283227417538805115063763160111383582982328982454;
      _weight[17] = .5026797453352532210110344519634291349423304726407095353493452099970647407952301484097782810186629110e-1;
      _points[18] = .8367831842367341822425603166238110879417083640363746585298284808891438684246421057909818428401546610;
      _weight[18] = .4551413099148182490574861035144582669049627947966715548524188448350869233920526345124219907147685948e-1;
      _points[19] = .8796296315186788152886414326021804881937610094491670604591948677225093144101312038038183986209261516;
      _weight[19] = .4007035016750050900661747983455565114511286642683794685810073148680641446740064477972868885711265904e-1;
      _points[20] = .9167213143804170007105105543467847847304820569117603930104323577308590662385450626266148697387958406;
      _weight[20] = .3401916690617845860359359282835398427735474717731828130753561320500182702585573655332576148474093680e-1;
      _points[21] = .9474959989391376844255210033914024770872774248767919515308508414795857554505997256855930034651958908;
      _weight[21] = .2745234798791759596296844577023666208005499277655567452425424912229688733921825594785596203971672244e-1;
      _points[22] = .9714872856144871697070055848292352659526007853044950709637262485686476612720246306544526090756367416;
      _weight[22] = .2046957835065315632781174385582297683042289168205217325234920744964871644010775638523948552755521193e-1;
      _points[23] = .9883319607297587557491576932397970338726852776572033723354937136580819337679402769482233547415030894;
      _weight[23] = .1317749330751606863095090764764957246798164085166123437768308289193546700443974968576491076408646420e-1;
      _points[24] = .9977784848952490489543924734469508086287813247024040856054024655664667406718639672436440131764735038;
      _weight[24] = .5696899250513143973951482056617386801660263146454848224474030558094945864883371677961838556472516210e-2;
      break;


    case 50:
    case 51:
      delivered_order = 51;
      _points.resize(26);
      _weight.resize(26);
      _points[0] = .20571494271915354983915203385469870215710724402201663017360952972168516833610967740467059715813190e-2;
      _weight[0] = .5275686308671503577825593842625988952172868589847307275027713818381611146754875672222351512065323220e-2;
      _points[1] = .108072770217645044497098228440368472765417181263407487572925693417474246274937643305327893794402012e-1;
      _weight[1] = .1220892554631595439480791375989420012024796309863517102602344753784585784943394482691409268167801318e-1;
      _points[2] = .264204666691428749320423582409816227396448311578423649908661101950711777737695961146469011242954620e-1;
      _weight[2] = .1898119164718138197515157062442524734538521087202447883765591232640395020816792394091514299828557512e-1;
      _points[3] = .486810690078464628911672003843948743294379973135473137224171726102671004487270065711695848749312684e-1;
      _weight[3] = .2548791264857390599915995036203668976293965927148596741191884299970865622501582259468230973003046462e-1;
      _points[4] = .772770286057509906012464692660809192139624489543352152849117635441915426643818525249262189103054714e-1;
      _weight[4] = .3163702316478741776972684495352254786111142100634725533304794330399419585613801383092303457974135344e-1;
      _points[5] = .1118070255896605719035163763788580665118908718724025639184157891864835356795866770152894361720059839;
      _weight[5] = .3734207488282987294353789805142416931937358094052034038951542087140981540468873148337652069639443670e-1;
      _points[6] = .1517863697900213675680930431352876510696233411045904241477212730808197265020809856020430775563367220;
      _weight[6] = .4252294715674261960522388253999084829196015838833913809302809070999389600765276409114328884385389266e-1;
      _points[7] = .1966538534911909683840106265415564727823677138670450548106783437400359365548733997670835956949946462;
      _weight[7] = .4710690017795707423183244153365159927458287295710363993165745118401724964172710566666105272447349387e-1;
      _points[8] = .2457796425877471411521484676372154123118466229071245931394497651980363025353216548829887288626245910;
      _weight[8] = .5102958054721271161920703512671539616360440567712100516593690970432633440273700128534590714908431060e-1;
      _points[9] = .2984741224382568467594613114505584481700312951503419087054294332259078914763146734751210244027963392;
      _weight[9] = .5423592026428829532828971336399879114471910171065332226480285430473069963645279198471579576032552260e-1;
      _points[10] = .3539975802570215524285823089610848515576403065185048108938279040481491877109960462088021476536134262;
      _weight[10] = .5668090827315983327472035922129907262297518146250760699414396494374455328228972724632422646792587595e-1;
      _points[11] = .4115705898215549080154711257908276250113081180993678692598261501079773599722919564411924558682029494;
      _weight[11] = .5833022174264829102233125377018110681598244061096210823008134860563283296415986325634816982250102965e-1;
      _points[12] = .4703849532853433964531407124007983196048826323054822089228638541578064819400132898307946865571061161;
      _weight[12] = .5916070763963113825818554285023434232494513541445265904716009968981034737478143412042810703364070915e-1;
      _points[13] = .5296150467146566035468592875992016803951173676945177910771361458421935180599867101692053134428938839;
      _weight[13] = .5916070763963113825818554285023434232494513541445265904716009968981034737478143412042810703364070920e-1;
      _points[14] = .5884294101784450919845288742091723749886918819006321307401738498920226400277080435588075441317970506;
      _weight[14] = .5833022174264829102233125377018110681598244061096210823008134860563283296415986325634816982250102965e-1;
      _points[15] = .6460024197429784475714176910389151484423596934814951891061720959518508122890039537911978523463865738;
      _weight[15] = .5668090827315983327472035922129907262297518146250760699414396494374455328228972724632422646792587590e-1;
      _points[16] = .7015258775617431532405386885494415518299687048496580912945705667740921085236853265248789755972036608;
      _weight[16] = .5423592026428829532828971336399879114471910171065332226480285430473069963645279198471579576032552260e-1;
      _points[17] = .7542203574122528588478515323627845876881533770928754068605502348019636974646783451170112711373754090;
      _weight[17] = .5102958054721271161920703512671539616360440567712100516593690970432633440273700128534590714908431060e-1;
      _points[18] = .8033461465088090316159893734584435272176322861329549451893216562599640634451266002329164043050053538;
      _weight[18] = .4710690017795707423183244153365159927458287295710363993165745118401724964172710566666105272447349384e-1;
      _points[19] = .8482136302099786324319069568647123489303766588954095758522787269191802734979190143979569224436632780;
      _weight[19] = .4252294715674261960522388253999084829196015838833913809302809070999389600765276409114328884385389263e-1;
      _points[20] = .8881929744103394280964836236211419334881091281275974360815842108135164643204133229847105638279940161;
      _weight[20] = .3734207488282987294353789805142416931937358094052034038951542087140981540468873148337652069639443666e-1;
      _points[21] = .9227229713942490093987535307339190807860375510456647847150882364558084573356181474750737810896945286;
      _weight[21] = .3163702316478741776972684495352254786111142100634725533304794330399419585613801383092303457974135346e-1;
      _points[22] = .9513189309921535371088327996156051256705620026864526862775828273897328995512729934288304151250687316;
      _weight[22] = .2548791264857390599915995036203668976293965927148596741191884299970865622501582259468230973003046462e-1;
      _points[23] = .9735795333308571250679576417590183772603551688421576350091338898049288222262304038853530988757045380;
      _weight[23] = .1898119164718138197515157062442524734538521087202447883765591232640395020816792394091514299828557512e-1;
      _points[24] = .9891927229782354955502901771559631527234582818736592512427074306582525753725062356694672106205597988;
      _weight[24] = .1220892554631595439480791375989420012024796309863517102602344753784585784943394482691409268167801318e-1;
      _points[25] = .9979428505728084645016084796614530129784289275597798336982639047027831483166389032259532940284186810;
      _weight[25] = .5275686308671503577825593842625988952172868589847307275027713818381611146754875672222351512065323220e-2;
      break;


    case 52:
    case 53:
      delivered_order = 53;
      _points.resize(27);
      _weight.resize(27);
      _points[0] = .19103685555057165305563958093850048696559722170644061491817516058911272113370939556189766392126889e-2;
      _weight[0] = .4899498025647180130575027545629549049112909467545796084070202282931315208834056077709691101107464872e-2;
      _points[1] = .100382620192493885720633221694764077161788893050246183805700534738087120098905268472915122027480961e-1;
      _weight[1] = .1134311579809031159801710322338074440638386014408317781572106511953791501790501107728496117313161265e-1;
      _points[2] = .245497210926474965740459846780585534537050332577911745330913046063066655950442571041902067017298242e-1;
      _weight[2] = .1764852687870985551128914465235582056806944476147090579111389254745441331417783144223590160180671613e-1;
      _points[3] = .452588396612544478496774908951553725259778322025195204433862237639718668237359887725233973748080687e-1;
      _weight[3] = .2372470626030753135204835505709235911236281008309236425865500633458910592851796202105534688856775970e-1;
      _points[4] = .718960459908527548486313886465786011178565006982470865114051729355983403070955097351216573478990248e-1;
      _weight[4] = .2949176842991679955515041685976581658262029535320608127010760745691056483180227669211726097685475882e-1;
      _points[5] = .1041141804647458864278013279463646335402994671260682437963596939765897575631027349407405614340794446;
      _weight[5] = .3487441188312279649216144417833363806641234662847600018870939081052967940428179133628127024163404922e-1;
      _points[6] = .1414932631302881503525918941788302251246639739507184286743918968321525838419328333124890452720667908;
      _weight[6] = .3980243388652888563153747950492120148807333649350147570670438190137636322061009657571259283000997426e-1;
      _points[7] = .1835460140267524295361326811827556939484619912153316513524440504882996545014591099897366526751979405;
      _weight[7] = .4421157927187847509716140142687455552826837502554955490293556854829634959572854374441795232874487530e-1;
      _points[8] = .2297242177102715525498495292200085895204097755064091548128311249820295516418093872877596583527153648;
      _weight[8] = .4804436368501425378282632327905292958010581476851466721406555676700756739190327262980465269080272892e-1;
      _points[9] = .2794258741249865597070129221553592737761577024184503059273063932983996518602520409574681030394888480;
      _weight[9] = .5125081890887289933562385576633190466220494745735866493489091619149373974629794637200532992832414270e-1;
      _points[10] = .3320030481807455501348404828963577291049899905462029046375066464524953385727201073824309763094718600;
      _weight[10] = .5378914289426659360608149221332870240948304953188233275617945325759724607200991384577327794535431305e-1;
      _points[11] = .3867703172802315705713804463198849144102766335358981616766855014081114331134964348872204676390168474;
      _weight[11] = .5562624417842259633608154802142433741646019004254163354820175484896603913565917187623706977023691845e-1;
      _points[12] = .4430137071952350165335525080650116864133597330109295026171230451168172556057946273018102596801016852;
      _weight[12] = .5673817305448257431018497404604962896026225940523601294820827478851116979698381328179598174896188875e-1;
      _points[13] = .5;
      _weight[13] = .5711043368947849452252286845091762434036072167508266516087385828959706267057662605513742154892559575e-1;
      _points[14] = .5569862928047649834664474919349883135866402669890704973828769548831827443942053726981897403198983148;
      _weight[14] = .5673817305448257431018497404604962896026225940523601294820827478851116979698381328179598174896188870e-1;
      _points[15] = .6132296827197684294286195536801150855897233664641018383233144985918885668865035651127795323609831526;
      _weight[15] = .5562624417842259633608154802142433741646019004254163354820175484896603913565917187623706977023691845e-1;
      _points[16] = .6679969518192544498651595171036422708950100094537970953624933535475046614272798926175690236905281400;
      _weight[16] = .5378914289426659360608149221332870240948304953188233275617945325759724607200991384577327794535431305e-1;
      _points[17] = .7205741258750134402929870778446407262238422975815496940726936067016003481397479590425318969605111520;
      _weight[17] = .5125081890887289933562385576633190466220494745735866493489091619149373974629794637200532992832414270e-1;
      _points[18] = .7702757822897284474501504707799914104795902244935908451871688750179704483581906127122403416472846352;
      _weight[18] = .4804436368501425378282632327905292958010581476851466721406555676700756739190327262980465269080272896e-1;
      _points[19] = .8164539859732475704638673188172443060515380087846683486475559495117003454985408900102633473248020595;
      _weight[19] = .4421157927187847509716140142687455552826837502554955490293556854829634959572854374441795232874487530e-1;
      _points[20] = .8585067368697118496474081058211697748753360260492815713256081031678474161580671666875109547279332092;
      _weight[20] = .3980243388652888563153747950492120148807333649350147570670438190137636322061009657571259283000997426e-1;
      _points[21] = .8958858195352541135721986720536353664597005328739317562036403060234102424368972650592594385659205554;
      _weight[21] = .3487441188312279649216144417833363806641234662847600018870939081052967940428179133628127024163404922e-1;
      _points[22] = .9281039540091472451513686113534213988821434993017529134885948270644016596929044902648783426521009752;
      _weight[22] = .2949176842991679955515041685976581658262029535320608127010760745691056483180227669211726097685475880e-1;
      _points[23] = .9547411603387455521503225091048446274740221677974804795566137762360281331762640112274766026251919313;
      _weight[23] = .2372470626030753135204835505709235911236281008309236425865500633458910592851796202105534688856775968e-1;
      _points[24] = .9754502789073525034259540153219414465462949667422088254669086953936933344049557428958097932982701758;
      _weight[24] = .1764852687870985551128914465235582056806944476147090579111389254745441331417783144223590160180671612e-1;
      _points[25] = .9899617379807506114279366778305235922838211106949753816194299465261912879901094731527084877972519039;
      _weight[25] = .1134311579809031159801710322338074440638386014408317781572106511953791501790501107728496117313161265e-1;
      _points[26] = .9980896314444942834694436041906149951303440277829355938508182483941088727886629060443810233607873111;
      _weight[26] = .4899498025647180130575027545629549049112909467545796084070202282931315208834056077709691101107464872e-2;
      break;


    case 54:
    case 55:
      delivered_order = 55;
      _points.resize(28);
      _weight.resize(28);
      _points[0] = .17787512130227750247818047583445041249347839517870477071638352547578905194656373396422966957998046e-2;
      _weight[0] = .4562141296547258869408076961475853120172245549145499708369845661949729932899064572545815432617494026e-2;
      _points[1] = .93484173145636231527200270960848617779225233734308451619871592706357740391116002490365364722431086e-2;
      _weight[1] = .1056605629638562987575019049663271722568467536164281889883424512553257787678854598207622668980514350e-1;
      _points[2] = .228703596855309013729490801473922054982980629560241622926427756880846797020846005695918472357002312e-1;
      _weight[2] = .1645071389115218998881540958526602299076540871004859392963081030188231834630637036171251530592121066e-1;
      _points[3] = .421834868039339630651552883350364268237516023954392456692498776984959107464796399486009258231709138e-1;
      _weight[3] = .2213646737950211391979393882660369530749705635428342185757353094211208880684996574681622625469913276e-1;
      _points[4] = .670537387128024755288727163101565978290685846078868315112266334916527957174388070387134159576832852e-1;
      _weight[4] = .2755367283785837271574145911347279560952898211283269420344637698647131160967129884326131212831754200e-1;
      _points[5] = .971793145414104142760570222873611706641492925958441658946564191098052283695639826007994828508808920e-1;
      _weight[5] = .3263646198349979789669878338775231817681771558130351316774240907603844736949397023700360993543964608e-1;
      _points[6] = .1321945609931841139859277448537328159919694900034790533857361118320943707653349045332957791687288890;
      _weight[6] = .3732310711728438951196594358651101901081793060316672371966002810748192103268864967435816954497234641e-1;
      _points[7] = .1716744529805675193900509117466285892151991548750350190841482512520748495081871089058221993624929120;
      _weight[7] = .4155670861445060919519824912216623993056720672192566649817783586627122641301714237517145008037053087e-1;
      _points[8] = .2151397640942991403459983583217845334376436571716763860899851611688926236813584997474581943081318948;
      _weight[8] = .4528587219651642047109301566839206491142874272724243618793426692722835773337135218283108971709898088e-1;
      _points[9] = .2620628875224408694827940761662829786863919273106720242954436535283638129005135544364294021883252600;
      _weight[9] = .4846532899896495792524450304772030088251656167823080247843814090718469703877365354821424385351831354e-1;
      _points[10] = .3118742419554606448893213952219565085641530114783885448278236398030841405785217980858613331322624406;
      _weight[10] = .5105648378903038490710831925285606752329000117896027046698772610142319921851682034903030485139628735e-1;
      _points[11] = .3639691861824109611615868219371151325876193516532385237501620367487788298795431516066055368720267690;
      _weight[11] = .5302788296142320895520821849840541439496148134257975841531014814296125636970519336941207124174810065e-1;
      _points[12] = .4177153589333096143592641110544172714271372921994159117528571866523340747621517760908778175101073962;
      _weight[12] = .5435559612914706762678575965183668393763922733302198382856058523865666319156439405412133157517785185e-1;
      _points[13] = .4724603550579828647867417363290600110746020044695831581273307063705527277328462116757936372672850101;
      _weight[13] = .5502350650823759814118813280090880697831276474561581663933405061480620506035357870344563338891741865e-1;
      _points[14] = .5275396449420171352132582636709399889253979955304168418726692936294472722671537883242063627327149899;
      _weight[14] = .5502350650823759814118813280090880697831276474561581663933405061480620506035357870344563338891741865e-1;
      _points[15] = .5822846410666903856407358889455827285728627078005840882471428133476659252378482239091221824898926038;
      _weight[15] = .5435559612914706762678575965183668393763922733302198382856058523865666319156439405412133157517785185e-1;
      _points[16] = .6360308138175890388384131780628848674123806483467614762498379632512211701204568483933944631279732310;
      _weight[16] = .5302788296142320895520821849840541439496148134257975841531014814296125636970519336941207124174810070e-1;
      _points[17] = .6881257580445393551106786047780434914358469885216114551721763601969158594214782019141386668677375594;
      _weight[17] = .5105648378903038490710831925285606752329000117896027046698772610142319921851682034903030485139628740e-1;
      _points[18] = .7379371124775591305172059238337170213136080726893279757045563464716361870994864455635705978116747400;
      _weight[18] = .4846532899896495792524450304772030088251656167823080247843814090718469703877365354821424385351831354e-1;
      _points[19] = .7848602359057008596540016416782154665623563428283236139100148388311073763186415002525418056918681052;
      _weight[19] = .4528587219651642047109301566839206491142874272724243618793426692722835773337135218283108971709898090e-1;
      _points[20] = .8283255470194324806099490882533714107848008451249649809158517487479251504918128910941778006375070880;
      _weight[20] = .4155670861445060919519824912216623993056720672192566649817783586627122641301714237517145008037053087e-1;
      _points[21] = .8678054390068158860140722551462671840080305099965209466142638881679056292346650954667042208312711110;
      _weight[21] = .3732310711728438951196594358651101901081793060316672371966002810748192103268864967435816954497234641e-1;
      _points[22] = .9028206854585895857239429777126388293358507074041558341053435808901947716304360173992005171491191080;
      _weight[22] = .3263646198349979789669878338775231817681771558130351316774240907603844736949397023700360993543964604e-1;
      _points[23] = .9329462612871975244711272836898434021709314153921131684887733665083472042825611929612865840423167148;
      _weight[23] = .2755367283785837271574145911347279560952898211283269420344637698647131160967129884326131212831754200e-1;
      _points[24] = .9578165131960660369348447116649635731762483976045607543307501223015040892535203600513990741768290862;
      _weight[24] = .2213646737950211391979393882660369530749705635428342185757353094211208880684996574681622625469913277e-1;
      _points[25] = .9771296403144690986270509198526077945017019370439758377073572243119153202979153994304081527642997688;
      _weight[25] = .1645071389115218998881540958526602299076540871004859392963081030188231834630637036171251530592121066e-1;
      _points[26] = .9906515826854363768472799729039151382220774766265691548380128407293642259608883997509634635277568914;
      _weight[26] = .1056605629638562987575019049663271722568467536164281889883424512553257787678854598207622668980514349e-1;
      _points[27] = .9982212487869772249752181952416554958750652160482129522928361647452421094805343626603577033042001954;
      _weight[27] = .4562141296547258869408076961475853120172245549145499708369845661949729932899064572545815432617494026e-2;
      break;


    case 56:
    case 57:
      delivered_order = 57;
      _points.resize(29);
      _weight.resize(29);
      _points[0] = .16602788697017069184042337253230571741132733745599989009213381216072070027901278312380182102923982e-2;
      _weight[0] = .4258451939373204827131906651124901501199444899259243026215047279732645793902882418850928550713034328e-2;
      _points[1] = .87272473692934125645369921068115219466090255467842204874399542766637071421848082239136826419265386e-2;
      _weight[1] = .9866042528061352991929900820197815574803284095180793828026922337672178169430556453082169853899485850e-2;
      _points[2] = .213572021109561371008959815095882181312202230229514647182351819233291979228379010689973520716676478e-1;
      _weight[2] = .1537024610104681132220426268730837487355813048435475516104217968317581621794780835865521052823688846e-1;
      _points[3] = .394098835234706074531232819584467872955803283438532007655042680970249933577748626807424065302799843e-1;
      _weight[3] = .2070103125934141805241500505703846076674539019428719862896243971739621852818551854143233329797395968e-1;
      _points[4] = .626810975399486047911032893717107265446915684404793146363895856426290814568444265805376484795765234e-1;
      _weight[4] = .2579741345124896195629719058977129895981105532307103384093141566365206014644921025462916123127927039e-1;
      _points[5] = .909072561923737775052138927106075121849892190588531144314828638523417373322124463984703711024984970e-1;
      _weight[5] = .3060154532853956927105492401195352246203226988956510415893870605599722203767775549076105389088635540e-1;
      _points[6] = .1237685741327614330436949613939309048937040158855066957940010042376539346411570432556968386143779030;
      _weight[6] = .3505896662752563928479074347443958655119744433738679095740371243000397857149125882037608692385616112e-1;
      _points[7] = .1608927311986567424219074973040070368058685349926774186380950705253167483999159884580950739648638133;
      _weight[7] = .3911916356788189191407244432984016568343953847983485473378759766238027210361614738466157853332551373e-1;
      _points[8] = .2018591014308860898102068944055051099609065948072111807632688033848285830191300507043726507755829126;
      _weight[8] = .4273612868308626377267242464860403569084912830679669766094537169121599627783617681021242338566500340e-1;
      _points[9] = .2462035224378861789486860401862399233243880798077079179074678464508928168186815888404097663546827284;
      _weight[9] = .4586887856962938167398320553855540344911451049097728563791493734934686215774724755050591349437150824e-1;
      _points[10] = .2934235559129956680546467069841915883382807406318430401108076673728583268940136014749802695368964878;
      _weight[10] = .4848191704720430315095003744134437958817813896090178213024773337311643895088929114457563589694678856e-1;
      _points[11] = .3429841810661800325259020384044762758707755904545862593516205345527766512852832787297422662473099227;
      _weight[11] = .5054563687995748306091027345374868182378363942626259956141601165288851018461290279446583271690678440e-1;
      _points[12] = .3943238569169994627468121355485312504716745911439524259807995773389705444459941109507107858977417932;
      _weight[12] = .5203665503886468695666423564256003445532611033773384582184702707394015054274691957461250068566737215e-1;
      _points[13] = .4468608849336603849145088037848115095414022803521964318571123629889173281242076795284977696897172914;
      _weight[13] = .5293807754866047070329566392609394653741565687113901991407767276251131908456972819198550959864424905e-1;
      _points[14] = .5;
      _weight[14] = .5323969085915712212325556345483878416509251580649798987648645053394066246579319242238732282325525215e-1;
      _points[15] = .5531391150663396150854911962151884904585977196478035681428876370110826718757923204715022303102827086;
      _weight[15] = .5293807754866047070329566392609394653741565687113901991407767276251131908456972819198550959864424910e-1;
      _points[16] = .6056761430830005372531878644514687495283254088560475740192004226610294555540058890492892141022582068;
      _weight[16] = .5203665503886468695666423564256003445532611033773384582184702707394015054274691957461250068566737210e-1;
      _points[17] = .6570158189338199674740979615955237241292244095454137406483794654472233487147167212702577337526900773;
      _weight[17] = .5054563687995748306091027345374868182378363942626259956141601165288851018461290279446583271690678440e-1;
      _points[18] = .7065764440870043319453532930158084116617192593681569598891923326271416731059863985250197304631035122;
      _weight[18] = .4848191704720430315095003744134437958817813896090178213024773337311643895088929114457563589694678856e-1;
      _points[19] = .7537964775621138210513139598137600766756119201922920820925321535491071831813184111595902336453172716;
      _weight[19] = .4586887856962938167398320553855540344911451049097728563791493734934686215774724755050591349437150824e-1;
      _points[20] = .7981408985691139101897931055944948900390934051927888192367311966151714169808699492956273492244170874;
      _weight[20] = .4273612868308626377267242464860403569084912830679669766094537169121599627783617681021242338566500340e-1;
      _points[21] = .8391072688013432575780925026959929631941314650073225813619049294746832516000840115419049260351361867;
      _weight[21] = .3911916356788189191407244432984016568343953847983485473378759766238027210361614738466157853332551373e-1;
      _points[22] = .8762314258672385669563050386060690951062959841144933042059989957623460653588429567443031613856220970;
      _weight[22] = .3505896662752563928479074347443958655119744433738679095740371243000397857149125882037608692385616112e-1;
      _points[23] = .9090927438076262224947861072893924878150107809411468855685171361476582626677875536015296288975015030;
      _weight[23] = .3060154532853956927105492401195352246203226988956510415893870605599722203767775549076105389088635542e-1;
      _points[24] = .9373189024600513952088967106282892734553084315595206853636104143573709185431555734194623515204234766;
      _weight[24] = .2579741345124896195629719058977129895981105532307103384093141566365206014644921025462916123127927039e-1;
      _points[25] = .9605901164765293925468767180415532127044196716561467992344957319029750066422251373192575934697200157;
      _weight[25] = .2070103125934141805241500505703846076674539019428719862896243971739621852818551854143233329797395967e-1;
      _points[26] = .9786427978890438628991040184904117818687797769770485352817648180766708020771620989310026479283323522;
      _weight[26] = .1537024610104681132220426268730837487355813048435475516104217968317581621794780835865521052823688846e-1;
      _points[27] = .9912727526307065874354630078931884780533909744532157795125600457233362928578151917760863173580734614;
      _weight[27] = .9866042528061352991929900820197815574803284095180793828026922337672178169430556453082169853899485850e-2;
      _points[28] = .9983397211302982930815957662746769428258867266254400010990786618783927929972098721687619817897076018;
      _weight[28] = .4258451939373204827131906651124901501199444899259243026215047279732645793902882418850928550713034330e-2;
      break;


    case 58:
    case 59:
      delivered_order = 59;
      _points.resize(30);
      _weight.resize(30);
      _points[0] = .15532579626752298641849745406523583295589809411246049459528510988061523949181295920589902209691413e-2;
      _weight[0] = .3984096248083302807732941737336811225240348293575860614742581678460019216450666647076830846143087017e-2;
      _points[1] = .81659383601263950149837091971685990298410726451443182414099949244278523176044781489620141698226432e-2;
      _weight[1] = .9233234155545479571151065956023634548103266984090701685649182757292799760653986827040259514837708805e-2;
      _points[2] = .199890675158462438915644872091011685348203912980383002571691637875300211464657853864052781480999881e-1;
      _weight[2] = .1439235394166168467485958980564602181979444727314374823709006130407299447000696655086510335574208568e-1;
      _points[3] = .368999762853628370603378614597629979567627315873354695444814331602885021744488365916135599247205688e-1;
      _weight[3] = .1939959628481352479840096822317384601660048838319767605386639485297348547638489695952751313951755301e-1;
      _points[4] = .587197321039736592284417687348872049716554264267578839658369734391918686524041721353920808571339476e-1;
      _weight[4] = .2420133641529702645146907021140375890763590459868636817259596839590271283855107639888371978178113158e-1;
      _points[5] = .852171188086158012785509401337490417804656519148291605965235082731717467052091824585237782459299200e-1;
      _weight[5] = .2874657810880953324086084470102806439856033536088156727435789950161607370497718846260599982547506277e-1;
      _points[6] = .1161112839475869025410113295127484341525581913835457733967528063174207149135024774736951987068801579;
      _weight[6] = .3298711494109024756406425755798118061872147682833018948351575802107183623304708968290995695579936872e-1;
      _points[7] = .1510747526033421015338538059866799658088230996730226718101385766300116393784200196523091817799554766;
      _weight[7] = .3687798736885260313412192501109536707688526301852471947063459118729969965731760585520067635831909164e-1;
      _points[8] = .1897369085053785694297612217844053503963176535852359337024744149378323425125554411294237077723360894;
      _weight[8] = .4037794761471010767734746923026486543794640185421964994512929685302559028351317280210620138460890400e-1;
      _points[9] = .2316879259289900503679151033444636029179109965348514472736282585439925456905108106844294199514050487;
      _weight[9] = .4344989360054148990119376535756285128837666437177267200611106494107679112713074712397751675481955268e-1;
      _points[10] = .2764831152309554116096950498385729999187962030692877951227613091361923241357078964979965556393790508;
      _weight[10] = .4606126111889306435881635354380938359845661720911705376383752350098652353504708414923202645840595361e-1;
      _points[11] = .3236476372345609432644813964553130696731844959892871867029077655498652918834044606678198016239432353;
      _weight[11] = .4818436858732212981973431317590493254820323071508012295649713786641876737100156186247562390905209770e-1;
      _points[12] = .3726815369160550767800974350910974460586053483487407869178570124555182342154605985468168593078818987;
      _weight[12] = .4979671029339763353139014105178473826493463183335213861068257309197333019495440450904614964466209236e-1;
      _points[13] = .4230650431957082265181026636283720397907240143778307691405185085421064257445919493015384467446296072;
      _weight[13] = .5088119487420275229821447608427702231635314474356342043213047270982125680265883747273799890989195600e-1;
      _points[14] = .4742640787223411520834873934166387131254292731667152178724195780060176223947864454720649546463572571;
      _weight[14] = .5142632644677942017064281835270752193418777853246411129315949333800811932830471469631442316094435460e-1;
      _points[15] = .5257359212776588479165126065833612868745707268332847821275804219939823776052135545279350453536427429;
      _weight[15] = .5142632644677942017064281835270752193418777853246411129315949333800811932830471469631442316094435455e-1;
      _points[16] = .5769349568042917734818973363716279602092759856221692308594814914578935742554080506984615532553703928;
      _weight[16] = .5088119487420275229821447608427702231635314474356342043213047270982125680265883747273799890989195595e-1;
      _points[17] = .6273184630839449232199025649089025539413946516512592130821429875444817657845394014531831406921181013;
      _weight[17] = .4979671029339763353139014105178473826493463183335213861068257309197333019495440450904614964466209234e-1;
      _points[18] = .6763523627654390567355186035446869303268155040107128132970922344501347081165955393321801983760567647;
      _weight[18] = .4818436858732212981973431317590493254820323071508012295649713786641876737100156186247562390905209773e-1;
      _points[19] = .7235168847690445883903049501614270000812037969307122048772386908638076758642921035020034443606209492;
      _weight[19] = .4606126111889306435881635354380938359845661720911705376383752350098652353504708414923202645840595361e-1;
      _points[20] = .7683120740710099496320848966555363970820890034651485527263717414560074543094891893155705800485949513;
      _weight[20] = .4344989360054148990119376535756285128837666437177267200611106494107679112713074712397751675481955268e-1;
      _points[21] = .8102630914946214305702387782155946496036823464147640662975255850621676574874445588705762922276639106;
      _weight[21] = .4037794761471010767734746923026486543794640185421964994512929685302559028351317280210620138460890400e-1;
      _points[22] = .8489252473966578984661461940133200341911769003269773281898614233699883606215799803476908182200445234;
      _weight[22] = .3687798736885260313412192501109536707688526301852471947063459118729969965731760585520067635831909161e-1;
      _points[23] = .8838887160524130974589886704872515658474418086164542266032471936825792850864975225263048012931198421;
      _weight[23] = .3298711494109024756406425755798118061872147682833018948351575802107183623304708968290995695579936874e-1;
      _points[24] = .9147828811913841987214490598662509582195343480851708394034764917268282532947908175414762217540700800;
      _weight[24] = .2874657810880953324086084470102806439856033536088156727435789950161607370497718846260599982547506280e-1;
      _points[25] = .9412802678960263407715582312651127950283445735732421160341630265608081313475958278646079191428660524;
      _weight[25] = .2420133641529702645146907021140375890763590459868636817259596839590271283855107639888371978178113158e-1;
      _points[26] = .9631000237146371629396621385402370020432372684126645304555185668397114978255511634083864400752794312;
      _weight[26] = .1939959628481352479840096822317384601660048838319767605386639485297348547638489695952751313951755302e-1;
      _points[27] = .9800109324841537561084355127908988314651796087019616997428308362124699788535342146135947218519000119;
      _weight[27] = .1439235394166168467485958980564602181979444727314374823709006130407299447000696655086510335574208568e-1;
      _points[28] = .9918340616398736049850162908028314009701589273548556817585900050755721476823955218510379858301773568;
      _weight[28] = .9233234155545479571151065956023634548103266984090701685649182757292799760653986827040259514837708805e-2;
      _points[29] = .9984467420373247701358150254593476416704410190588753950540471489011938476050818704079410097790308587;
      _weight[29] = .3984096248083302807732941737336811225240348293575860614742581678460019216450666647076830846143087017e-2;
      break;


    case 60:
    case 61:
      delivered_order = 61;
      _points.resize(31);
      _weight.resize(31);
      _points[0] = .14562590902614629721867228884487458742773329414651846039381405366717276395697834888283143973765270e-2;
      _weight[0] = .3735415789624387929348437516106203511075426242024019849635485164339136550087160840977924201147052352e-2;
      _points[1] = .76570451674237579987674166326576445307408652426781645271356703022700230557276362559562770200009599e-2;
      _weight[1] = .8659310395155291231578998043410570683136431383997888316377591894405077207572921151022554876722329345e-2;
      _points[2] = .187480374535251691054737979470708490513902574237208116133243214850140100347019417235178165287494856e-1;
      _weight[2] = .1350450959248971090030435404596607807117832300105832292843737492363504441243640117830615119921849170e-1;
      _points[3] = .346215010516759175215271201353682435933011563709589817723318124046585290788184828767824618335974315e-1;
      _weight[3] = .1821613695619273201219600523390172116357266602383384295070951969816670398426204523777386391732458538e-1;
      _points[4] = .551199850258644783129039955089203692282012940674045251184339720369144990319574675014354411561841338e-1;
      _weight[4] = .2274685376360055145115792894731483863177635965501448244675831806076219499563510511006105624936030451e-1;
      _points[5] = .800398399268663299565477320299108219726313494626252385843196930525265858673214444671505722012976430e-1;
      _weight[5] = .2705154121245842685583312954331002136019473129810590384700391052564995152903238580171815827117962399e-1;
      _points[6] = .1091334257916875297968199899026577544522948139933005599675624686482212483980791531009348949655771446;
      _weight[6] = .3108739328051421345517177184334833357936439968232565764075375266574554731138425888095956270391603274e-1;
      _points[7] = .1421116077065733580470145673167570220549032619152057836859458771974568631244629034775778924290842141;
      _weight[7] = .3481429161770518308387806312756285525754285369867169685553635851837134563893470805505726330781329886e-1;
      _points[8] = .1786466385378698269077908983837492730041546583318966217453477017619332973797433691655777512192605948;
      _weight[8] = .3819519329938830821317883745066532246287845684710432704609504082320412596697428296745140103467632755e-1;
      _points[9] = .2183754192964253686395275382024192860256988634165564845071156081562723096081775797374572902948132262;
      _weight[9] = .4119649588079463195191168371598088530788413327832313890519196212531543332326682020762560449528861664e-1;
      _points[10] = .2609031089775487597797029803217571257802383142512884375809194745004315606814533610283708215805617268;
      _weight[10] = .4378837030423893806309903484766654611462907988560212575177060598456271225204984948183410921973182529e-1;
      _points[11] = .3058070491958835284693242693562399490074468660532279821210935607641609639146006582516778301944403820;
      _weight[11] = .4594505694682073910768143580357506274865541268957890208924280825212435217371207403383186527264464579e-1;
      _points[12] = .3526409650091491916910480511641478306235724073608207215318520588819652150614509044215928373785823163;
      _weight[12] = .4764512145615975640360209874379834227066236912347951135572473296423440281824639506062046299784141870e-1;
      _points[13] = .4009394003322146856137935019835830311126025939192225600065988728719973969976976775656044900235067797;
      _weight[13] = .4887166769316436254673700548949835191786439433804755725475732225072623157354002120950387583890251144e-1;
      _points[14] = .4502223439238292398374126049405296330805023206112363469698864545113650622352019669672111409842678964;
      _weight[14] = .4961250561333615393743775721430750700877160997778153489060157125773453723517885216715386205370758320e-1;
      _points[15] = .5;
      _weight[15] = .4986027239671322571376691686717471982162670575010217574280728978204640605537343723220456872105070444e-1;
      _points[16] = .5497776560761707601625873950594703669194976793887636530301135454886349377647980330327888590157321036;
      _weight[16] = .4961250561333615393743775721430750700877160997778153489060157125773453723517885216715386205370758318e-1;
      _points[17] = .5990605996677853143862064980164169688873974060807774399934011271280026030023023224343955099764932203;
      _weight[17] = .4887166769316436254673700548949835191786439433804755725475732225072623157354002120950387583890251144e-1;
      _points[18] = .6473590349908508083089519488358521693764275926391792784681479411180347849385490955784071626214176837;
      _weight[18] = .4764512145615975640360209874379834227066236912347951135572473296423440281824639506062046299784141872e-1;
      _points[19] = .6941929508041164715306757306437600509925531339467720178789064392358390360853993417483221698055596180;
      _weight[19] = .4594505694682073910768143580357506274865541268957890208924280825212435217371207403383186527264464579e-1;
      _points[20] = .7390968910224512402202970196782428742197616857487115624190805254995684393185466389716291784194382732;
      _weight[20] = .4378837030423893806309903484766654611462907988560212575177060598456271225204984948183410921973182529e-1;
      _points[21] = .7816245807035746313604724617975807139743011365834435154928843918437276903918224202625427097051867738;
      _weight[21] = .4119649588079463195191168371598088530788413327832313890519196212531543332326682020762560449528861664e-1;
      _points[22] = .8213533614621301730922091016162507269958453416681033782546522982380667026202566308344222487807394052;
      _weight[22] = .3819519329938830821317883745066532246287845684710432704609504082320412596697428296745140103467632758e-1;
      _points[23] = .8578883922934266419529854326832429779450967380847942163140541228025431368755370965224221075709157859;
      _weight[23] = .3481429161770518308387806312756285525754285369867169685553635851837134563893470805505726330781329888e-1;
      _points[24] = .8908665742083124702031800100973422455477051860066994400324375313517787516019208468990651050344228554;
      _weight[24] = .3108739328051421345517177184334833357936439968232565764075375266574554731138425888095956270391603274e-1;
      _points[25] = .9199601600731336700434522679700891780273686505373747614156803069474734141326785555328494277987023570;
      _weight[25] = .2705154121245842685583312954331002136019473129810590384700391052564995152903238580171815827117962399e-1;
      _points[26] = .9448800149741355216870960044910796307717987059325954748815660279630855009680425324985645588438158662;
      _weight[26] = .2274685376360055145115792894731483863177635965501448244675831806076219499563510511006105624936030451e-1;
      _points[27] = .9653784989483240824784728798646317564066988436290410182276681875953414709211815171232175381664025685;
      _weight[27] = .1821613695619273201219600523390172116357266602383384295070951969816670398426204523777386391732458538e-1;
      _points[28] = .9812519625464748308945262020529291509486097425762791883866756785149859899652980582764821834712505144;
      _weight[28] = .1350450959248971090030435404596607807117832300105832292843737492363504441243640117830615119921849170e-1;
      _points[29] = .9923429548325762420012325833673423554692591347573218354728643296977299769442723637440437229799990401;
      _weight[29] = .8659310395155291231578998043410570683136431383997888316377591894405077207572921151022554876722329345e-2;
      _points[30] = .9985437409097385370278132771115512541257226670585348153960618594633282723604302165111716856026234730;
      _weight[30] = .3735415789624387929348437516106203511075426242024019849635485164339136550087160840977924201147052353e-2;
      break;

    default:
      do { QuadratureOrderOutOfRange th__ex; std::ostringstream th__out; th__out << "QuadratureOrderOutOfRange" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules/cube_imp.hh" << ":" << 1263 << "]: " << "Quadrature rule " << p << " not supported!"; th__ex.message(th__out.str()); throw th__ex; } while (0);
    }
  }


  template<typename ct>
  void CubeQuadratureInitHelper<ct,false>::init(int p,
         std::vector< FieldVector<ct, 1> > & _points,
         std::vector< ct > & _weight,
         int & delivered_order)
  {
    switch(p)
    {

    case 0:
    case 1:
      delivered_order = 1;
      _points.resize(1);
      _weight.resize(1);
      _points[0] = ".5";
      _weight[0] = "1.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
      break;


    case 2:
    case 3:
      delivered_order = 3;
      _points.resize(2);
      _weight.resize(2);
      _points[0] = ".2113248654051871177454256097490212721761991243649365619906988367580111638485333271531423022071252374";
      _weight[0] = ".5000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
      _points[1] = ".7886751345948128822545743902509787278238008756350634380093011632419888361514666728468576977928747626";
      _weight[1] = ".5000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
      break;


    case 4:
    case 5:
      delivered_order = 5;
      _points.resize(3);
      _weight.resize(3);
      _points[0] = ".1127016653792583114820734600217600389167078294708409173412426233886516908063020966480712623141326482";
      _weight[0] = ".2777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777768";
      _points[1] = ".5";
      _weight[1] = ".4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444";
      _points[2] = ".8872983346207416885179265399782399610832921705291590826587573766113483091936979033519287376858673518";
      _weight[2] = ".2777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777";
      break;


    case 6:
    case 7:
      delivered_order = 7;
      _points.resize(4);
      _weight.resize(4);
      _points[0] = ".694318442029737123880267555535952474521373101851411811921390395467352642524755671479188300577603474e-1";
      _weight[0] = ".1739274225687269286865319746109997036176743479169467702462646597593759337329551758609918838661290805";
      _points[1] = ".3300094782075718675986671204483776563997120651145428237035230115894899847683814827610623597822225942";
      _weight[1] = ".3260725774312730713134680253890002963823256520830532297537353402406240662670448241390081161338709199";
      _points[2] = ".6699905217924281324013328795516223436002879348854571762964769884105100152316185172389376402177774058";
      _weight[2] = ".3260725774312730713134680253890002963823256520830532297537353402406240662670448241390081161338709201";
      _points[3] = ".9305681557970262876119732444464047525478626898148588188078609604532647357475244328520811699422396526";
      _weight[3] = ".1739274225687269286865319746109997036176743479169467702462646597593759337329551758609918838661290798";
      break;


    case 8:
    case 9:
      delivered_order = 9;
      _points.resize(5);
      _weight.resize(5);
      _points[0] = ".469100770306680036011865608503035174371740446187345685631188567281146025416565765294285052232288690e-1";
      _weight[0] = ".1184634425280945437571320203599586813216300011062070077914139441108586442015215492899967152469757221";
      _points[1] = ".2307653449471584544818427896498955975163566965472200218988841864702644073161223544820981663747145342";
      _weight[1] = ".2393143352496832340206457574178190964561477766715707699863638336669191335762562284877810625308020550";
      _points[2] = ".5";
      _weight[2] = ".2844444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444445";
      _points[3] = ".7692346550528415455181572103501044024836433034527799781011158135297355926838776455179018336252854658";
      _weight[3] = ".2393143352496832340206457574178190964561477766715707699863638336669191335762562284877810625308020556";
      _points[4] = ".9530899229693319963988134391496964825628259553812654314368811432718853974583434234705714947767711310";
      _weight[4] = ".1184634425280945437571320203599586813216300011062070077914139441108586442015215492899967152469757224";
      break;


    case 10:
    case 11:
      delivered_order = 11;
      _points.resize(6);
      _weight.resize(6);
      _points[0] = ".337652428984239860938492227530026954326171311438550875637251917366932495778999018618556300390370075e-1";
      _weight[0] = ".8566224618958517252014807108636644676341125074202199119931771989947288027117007732396385271319433505e-1";
      _points[1] = ".1693953067668677431693002024900473264967757178024149645927366470739082516964284495278567981267692718";
      _weight[1] = ".1803807865240693037849167569188580558307609463733727411448696201185700189186308591604811009944096747";
      _points[2] = ".3806904069584015456847491391596440322906946849299893249093024177128625328621800788753877863713254342";
      _weight[2] = ".2339569672863455236949351719947754974058278028846052676558126599819571008101990635155550462923959909";
      _points[3] = ".6193095930415984543152508608403559677093053150700106750906975822871374671378199211246122136286745658";
      _weight[3] = ".2339569672863455236949351719947754974058278028846052676558126599819571008101990635155550462923959910";
      _points[4] = ".8306046932331322568306997975099526735032242821975850354072633529260917483035715504721432018732307282";
      _weight[4] = ".1803807865240693037849167569188580558307609463733727411448696201185700189186308591604811009944096740";
      _points[5] = ".9662347571015760139061507772469973045673828688561449124362748082633067504221000981381443699609629925";
      _weight[5] = ".8566224618958517252014807108636644676341125074202199119931771989947288027117007732396385271319433505e-1";
      break;


    case 12:
    case 13:
      delivered_order = 13;
      _points.resize(7);
      _weight.resize(7);
      _points[0] = ".254460438286207377369051579760743687996145311646911082256154480434683348225799295971346149860371380e-1";
      _weight[0] = ".6474248308443484663530571633954100916429370112997333198860431936232761748602115435781270908146042335e-1";
      _points[1] = ".1292344072003027800680676133596057964629261764293048699400223240162850626639097431035865838165683764";
      _weight[1] = ".1398526957446383339507338857118897912434625326132993822685070163468094052152813384066204714505988094";
      _points[2] = ".2970774243113014165466967939615192683263089929503149368064783741026680933869371723358436551361267061";
      _weight[2] = ".1909150252525594724751848877444875669391825417669313673755417255153527732170648541743423296720224005";
      _points[3] = ".5";
      _weight[3] = ".2089795918367346938775510204081632653061224489795918367346938775510204081632653061224489795918367346";
      _points[4] = ".7029225756886985834533032060384807316736910070496850631935216258973319066130628276641563448638732939";
      _weight[4] = ".1909150252525594724751848877444875669391825417669313673755417255153527732170648541743423296720224007";
      _points[5] = ".8707655927996972199319323866403942035370738235706951300599776759837149373360902568964134161834316236";
      _weight[5] = ".1398526957446383339507338857118897912434625326132993822685070163468094052152813384066204714505988092";
      _points[6] = ".9745539561713792622630948420239256312003854688353088917743845519565316651774200704028653850139628620";
      _weight[6] = ".6474248308443484663530571633954100916429370112997333198860431936232761748602115435781270908146042285e-1";
      break;


    case 14:
    case 15:
      delivered_order = 15;
      _points.resize(8);
      _weight.resize(8);
      _points[0] = ".198550717512318841582195657152635047858823828492739808641801113137875511282903577802805203683438658e-1";
      _weight[0] = ".5061426814518812957626567715498109505769704552584247852950184903237008938173539243014136965202250520e-1";
      _points[1] = ".1016667612931866302042230317620847815814141341920175839649148524803913471617634539264240363521370305";
      _weight[1] = ".1111905172266872352721779972131204422150654350256247823629546446468084072852245204268265711885989640";
      _points[2] = ".2372337950418355070911304754053768254790178784398035711245714503637725896157193637380192999031840090";
      _weight[2] = ".1568533229389436436689811009933006566301644995013674688451319725374781359710867484808490381169642782";
      _points[3] = ".4082826787521750975302619288199080096666210935435131088414057631503977628892289429419658881444383232";
      _weight[3] = ".1813418916891809914825752246385978060970730199471652702624115337833433673619533386621830210424142548";
      _points[4] = ".5917173212478249024697380711800919903333789064564868911585942368496022371107710570580341118555616768";
      _weight[4] = ".1813418916891809914825752246385978060970730199471652702624115337833433673619533386621830210424142549";
      _points[5] = ".7627662049581644929088695245946231745209821215601964288754285496362274103842806362619807000968159910";
      _weight[5] = ".1568533229389436436689811009933006566301644995013674688451319725374781359710867484808490381169642781";
      _points[6] = ".8983332387068133697957769682379152184185858658079824160350851475196086528382365460735759636478629695";
      _weight[6] = ".1111905172266872352721779972131204422150654350256247823629546446468084072852245204268265711885989639";
      _points[7] = ".9801449282487681158417804342847364952141176171507260191358198886862124488717096422197194796316561342";
      _weight[7] = ".5061426814518812957626567715498109505769704552584247852950184903237008938173539243014136965202250335e-1";
      break;


    case 16:
    case 17:
      delivered_order = 17;
      _points.resize(9);
      _weight.resize(9);
      _points[0] = ".159198802461869550822118985481635649752975997540373352249883440754598128016996234690631253865529442e-1";
      _weight[0] = ".4063719418078720598594607905526182533783086039120537535555383844034334315422603147278927735147128571e-1";
      _points[1] = ".819844463366821028502851059651325617279466409376620019478140101802724965592049405530269014870712298e-1";
      _weight[1] = ".9032408034742870202923601562145640475716891086602024224916795323567864527247313488229748865159985275e-1";
      _points[2] = ".1933142836497048013456489803292629076071396975297176535635935288593663267544994007083799930482157077";
      _weight[2] = ".1303053482014677311593714347093164248859201022186499759699985010598054078344456223238230465475087002";
      _points[3] = ".3378732882980955354807309926783316957140218696315134555864762615789067102324378754034506991507512164";
      _weight[3] = ".1561735385200014200343152032922218327993774306309523227770055827995719486620096582850609609440031770";
      _points[4] = ".5";
      _weight[4] = ".1651196775006298815822625346434870244394053917863441672965482489292013101536911060720584530108339632";
      _points[5] = ".6621267117019044645192690073216683042859781303684865444135237384210932897675621245965493008492487836";
      _weight[5] = ".1561735385200014200343152032922218327993774306309523227770055827995719486620096582850609609440031768";
      _points[6] = ".8066857163502951986543510196707370923928603024702823464364064711406336732455005992916200069517842923";
      _weight[6] = ".1303053482014677311593714347093164248859201022186499759699985010598054078344456223238230465475087008";
      _points[7] = ".9180155536633178971497148940348674382720533590623379980521859898197275034407950594469730985129287702";
      _weight[7] = ".9032408034742870202923601562145640475716891086602024224916795323567864527247313488229748865159985195e-1";
      _points[8] = ".9840801197538130449177881014518364350247024002459626647750116559245401871983003765309368746134470558";
      _weight[8] = ".4063719418078720598594607905526182533783086039120537535555383844034334315422603147278927735147128848e-1";
      break;


    case 18:
    case 19:
      delivered_order = 19;
      _points.resize(10);
      _weight.resize(10);
      _points[0] = ".130467357414141399610179939577739732858650266538089403843939666517023983826819201871382175218657218e-1";
      _weight[0] = ".3333567215434406879678440494666589642893241716007907256434744080670603204204355088839275484252944050e-1";
      _points[1] = ".674683166555077446339516557882534757362284925173347737390201340773126224309722193216046355269771146e-1";
      _weight[1] = ".7472567457529029657288816982884866620127831983471368391773863437661932736331500547297363231736597515e-1";
      _points[2] = ".1602952158504877968828363174425632121153526440825952661675914055237207123024625376924607132147598102";
      _weight[2] = ".1095431812579910219977674671140815962293859352613385449404782718175999553264756406213419965886010958";
      _points[3] = ".2833023029353764046003670284171079188999640811718767517486492434281165054611482493874486210249411394";
      _weight[3] = ".1346333596549981775456134607847346764298799692304418979002816381210767161595896383821133183546263805";
      _points[4] = ".4255628305091843945575869994351400076912175702896541521460053732420481913221657393144111851002681544";
      _weight[4] = ".1477621123573764350869464973256691647105233585134268006771540148779979691085761646351782978968771084";
      _points[5] = ".5744371694908156054424130005648599923087824297103458478539946267579518086778342606855888148997318456";
      _weight[5] = ".1477621123573764350869464973256691647105233585134268006771540148779979691085761646351782978968771085";
      _points[6] = ".7166976970646235953996329715828920811000359188281232482513507565718834945388517506125513789750588606";
      _weight[6] = ".1346333596549981775456134607847346764298799692304418979002816381210767161595896383821133183546263804";
      _points[7] = ".8397047841495122031171636825574367878846473559174047338324085944762792876975374623075392867852401898";
      _weight[7] = ".1095431812579910219977674671140815962293859352613385449404782718175999553264756406213419965886010963";
      _points[8] = ".9325316833444922553660483442117465242637715074826652262609798659226873775690277806783953644730228854";
      _weight[8] = ".7472567457529029657288816982884866620127831983471368391773863437661932736331500547297363231736597595e-1";
      _points[9] = ".9869532642585858600389820060422260267141349733461910596156060333482976016173180798128617824781342782";
      _weight[9] = ".3333567215434406879678440494666589642893241716007907256434744080670603204204355088839275484252943861e-1";
      break;


    case 20:
    case 21:
      delivered_order = 21;
      _points.resize(11);
      _weight.resize(11);
      _points[0] = ".108856709269715035980309994385713046142887955401077922870994670081681003095550058998403009163276150e-1";
      _weight[0] = ".2783428355808683324137686022127428936425781284844907417419214283707770364036877194184561103615942288e-1";
      _points[1] = ".564687001159523504624211153480363666841621243873428075162944722311943430713136662788547024367013129e-1";
      _weight[1] = ".6279018473245231231734714961197005009880789569770175033196700540895728756623563881734382085702726505e-1";
      _points[2] = ".1349239972129753379532918739844232709751784689869348440108108301564933774707403852022882945143581500";
      _weight[2] = ".9314510546386712571304882071582794584564237402010170589075320208693617400439275123466537925898979300e-1";
      _points[3] = ".2404519353965940920371371652706952227598864424400357554895386942566520367744635535872006099477254724";
      _weight[3] = ".1165968822959952399592618524215875697158990861584792545136598610609661066094404979770199742191308422";
      _points[4] = ".3652284220238275138342340072995692376601890687804738591880371840599714668881526321480892038778663494";
      _weight[4] = ".1314022722551233310903444349452545976863823388015722781900276857427564016697726267762084985085133530";
      _points[5] = ".5";
      _weight[5] = ".1364625433889503153572417641681710945780209849473918737988002057266126530195794265058334322403586472";
      _points[6] = ".6347715779761724861657659927004307623398109312195261408119628159400285331118473678519107961221336506";
      _weight[6] = ".1314022722551233310903444349452545976863823388015722781900276857427564016697726267762084985085133529";
      _points[7] = ".7595480646034059079628628347293047772401135575599642445104613057433479632255364464127993900522745276";
      _weight[7] = ".1165968822959952399592618524215875697158990861584792545136598610609661066094404979770199742191308422";
      _points[8] = ".8650760027870246620467081260155767290248215310130651559891891698435066225292596147977117054856418500";
      _weight[8] = ".9314510546386712571304882071582794584564237402010170589075320208693617400439275123466537925898979305e-1";
      _points[9] = ".9435312998840476495375788846519636333158378756126571924837055277688056569286863337211452975632986871";
      _weight[9] = ".6279018473245231231734714961197005009880789569770175033196700540895728756623563881734382085702726505e-1";
      _points[10] = ".9891143290730284964019690005614286953857112044598922077129005329918318996904449941001596990836723850";
      _weight[10] = ".2783428355808683324137686022127428936425781284844907417419214283707770364036877194184561103615942288e-1";
      break;


    case 22:
    case 23:
      delivered_order = 23;
      _points.resize(12);
      _weight.resize(12);
      _points[0] = ".92196828766403746547254549253595885199224000931342447686589390961033778408730088873713660547738821e-2";
      _weight[0] = ".2358766819325591359730798074250853015851453699742354478025267350190486057601935533541295353770726794e-1";
      _points[1] = ".479413718147625716607670669404519037312016453933512267229621196593826021353821047565152860881333661e-1";
      _weight[1] = ".5346966299765921548012735909699811210728508673516244000256302105140949681374878827026865904815822880e-1";
      _points[2] = ".1150486629028476564815530833935909620075371249905341811677904678754417284457643879917875003882890447";
      _weight[2] = ".8003916427167311316732626477167953593600586524543208895494977207897711258664557534082827631852886530e-1";
      _points[3] = ".2063410228566912763516487905297328598154507429759737592448645601663296503120523687821446175056258990";
      _weight[3] = ".1015837133615329608745322279048991882532590736372950731992972828988228162552364218975721975323026162";
      _points[4] = ".3160842505009099031236542316781412193718199293322951893441000602479550352416060630606327857497267114";
      _weight[4] = ".1167462682691774043804249494624390281297049860998774373652617489107460000397058376403395132542818452";
      _points[5] = ".4373832957442655422637793152680734350083015418472778633935391226257689718793051556285658507652543202";
      _weight[5] = ".1245735229067013925002812180214756054152304512848094156976755015581397137286440215155784003090211766";
      _points[6] = ".5626167042557344577362206847319265649916984581527221366064608773742310281206948443714341492347456798";
      _weight[6] = ".1245735229067013925002812180214756054152304512848094156976755015581397137286440215155784003090211766";
      _points[7] = ".6839157494990900968763457683218587806281800706677048106558999397520449647583939369393672142502732886";
      _weight[7] = ".1167462682691774043804249494624390281297049860998774373652617489107460000397058376403395132542818452";
      _points[8] = ".7936589771433087236483512094702671401845492570240262407551354398336703496879476312178553824943741010";
      _weight[8] = ".1015837133615329608745322279048991882532590736372950731992972828988228162552364218975721975323026162";
      _points[9] = ".8849513370971523435184469166064090379924628750094658188322095321245582715542356120082124996117109553";
      _weight[9] = ".8003916427167311316732626477167953593600586524543208895494977207897711258664557534082827631852886530e-1";
      _points[10] = ".9520586281852374283392329330595480962687983546066487732770378803406173978646178952434847139118666339";
      _weight[10] = ".5346966299765921548012735909699811210728508673516244000256302105140949681374878827026865904815822885e-1";
      _points[11] = ".9907803171233596253452745450746404114800775999068657552313410609038966221591269911126286339452261179";
      _weight[11] = ".2358766819325591359730798074250853015851453699742354478025267350190486057601935533541295353770726794e-1";
      break;


    case 24:
    case 25:
      delivered_order = 25;
      _points.resize(13);
      _weight.resize(13);
      _points[0] = ".79084726407059252635852755964451944675047190370625456529963397857023810621865790697153563692907058e-2";
      _weight[0] = ".2024200238265793976001079610049303002099327287249443406752330375249723025639635524721040621652658088e-1";
      _points[1] = ".412008003885110173967260817496402438047626049441583520523573271701703957051950428582573048297085378e-1";
      _weight[1] = ".4606074991886422395721088797689856046184199993111841954419577366979686486381646314594890787786598622e-1";
      _points[2] = ".992109546333450436028967552085700548471921376047499850513076430703889418866799389849850629073414698e-1";
      _weight[2] = ".6943675510989361923180088843443573381093135913164911382317750825288626076744476786259077142730281280e-1";
      _points[3] = ".1788253302798298896780076965022421749641513008692115713054287960406782234275032125428058499429042224";
      _weight[3] = ".8907299038097286914002334599804899775640632533050825149339722014457253474937436174735847561115635070e-1";
      _points[4] = ".2757536244817765735610435739361800660990391662791210605208585262708779539668914281774808957226334950";
      _weight[4] = ".1039080237684442511562616096530263816932913045997517746095555599582692717825422161302977640233059632";
      _points[5] = ".3847708420224326029672359394510055823942288120582344182653692510814189581557090245935985276176599354";
      _weight[5] = ".1131415901314486192060450930198883092173788688077785099324842743857878315602499855209131593331569648";
      _points[6] = ".5";
      _weight[6] = ".1162757766154369550972947576344179740783137386533989930593327196723800120403517006913610310213706817";
      _points[7] = ".6152291579775673970327640605489944176057711879417655817346307489185810418442909754064014723823400646";
      _weight[7] = ".1131415901314486192060450930198883092173788688077785099324842743857878315602499855209131593331569648";
      _points[8] = ".7242463755182234264389564260638199339009608337208789394791414737291220460331085718225191042773665050";
      _weight[8] = ".1039080237684442511562616096530263816932913045997517746095555599582692717825422161302977640233059632";
      _points[9] = ".8211746697201701103219923034977578250358486991307884286945712039593217765724967874571941500570957776";
      _weight[9] = ".8907299038097286914002334599804899775640632533050825149339722014457253474937436174735847561115635070e-1";
      _points[10] = ".9007890453666549563971032447914299451528078623952500149486923569296110581133200610150149370926585302";
      _weight[10] = ".6943675510989361923180088843443573381093135913164911382317750825288626076744476786259077142730281280e-1";
      _points[11] = ".9587991996114889826032739182503597561952373950558416479476426728298296042948049571417426951702914622";
      _weight[11] = ".4606074991886422395721088797689856046184199993111841954419577366979686486381646314594890787786598626e-1";
      _points[12] = ".9920915273592940747364147244035548055324952809629374543470036602142976189378134209302846436307092942";
      _weight[12] = ".2024200238265793976001079610049303002099327287249443406752330375249723025639635524721040621652658088e-1";
      break;


    case 26:
    case 27:
      delivered_order = 27;
      _points.resize(14);
      _weight.resize(14);
      _points[0] = ".68580956515938305792013666479735991619542963803870591779645941111252229337541810446768801674241236e-2";
      _weight[0] = ".1755973016587593151591643806909589030985280463856363829074994509820816141890413526883839849932323143e-1";
      _points[1] = ".357825581682132413318044303110628677614803947950811906410187762589344532278200734442930471581712412e-1";
      _weight[1] = ".4007904357988010490281663853142715479184889269729738260069953274478573722864358493176809540956887818e-1";
      _points[2] = ".863993424651175034051026286748025194801494492624594092196454728792600845949855632147868049310552273e-1";
      _weight[2] = ".6075928534395159234470740453623831297833467284503733614553769627157987194626324615940995313518750360e-1";
      _points[3] = ".1563535475941572649259900984903329312307993936264146621903667556859075519084333715263134647473940808";
      _weight[3] = ".7860158357909676728480096931192107830283401866866168748465852193738408818480414925697904668120903810e-1";
      _points[4] = ".2423756818209229540173546407244056688455573587153469815242476154536075240839721697739639898246135538";
      _weight[4] = ".9276919873896890687085829506257851812446130146866582951001746253454917513176272221277636557335611145e-1";
      _points[5] = ".3404438155360551197821640879157622665828693982330780217016749063713332797436036084175331472893267934";
      _weight[5] = ".1025992318606478019829620328306090278551695306547097258584486451416835724126248601697159199959454478";
      _points[6] = ".4459725256463281689668776748900826261940241972628812214795894693459932354941349964349496559116553164";
      _weight[6] = ".1076319267315788950979382216581300176374987790270644001098881962718093936769973020005122207054097892";
      _points[7] = ".5540274743536718310331223251099173738059758027371187785204105306540067645058650035650503440883446836";
      _weight[7] = ".1076319267315788950979382216581300176374987790270644001098881962718093936769973020005122207054097891";
      _points[8] = ".6595561844639448802178359120842377334171306017669219782983250936286667202563963915824668527106732066";
      _weight[8] = ".1025992318606478019829620328306090278551695306547097258584486451416835724126248601697159199959454478";
      _points[9] = ".7576243181790770459826453592755943311544426412846530184757523845463924759160278302260360101753864462";
      _weight[9] = ".9276919873896890687085829506257851812446130146866582951001746253454917513176272221277636557335611150e-1";
      _points[10] = ".8436464524058427350740099015096670687692006063735853378096332443140924480915666284736865352526059192";
      _weight[10] = ".7860158357909676728480096931192107830283401866866168748465852193738408818480414925697904668120903815e-1";
      _points[11] = ".9136006575348824965948973713251974805198505507375405907803545271207399154050144367852131950689447727";
      _weight[11] = ".6075928534395159234470740453623831297833467284503733614553769627157987194626324615940995313518750360e-1";
      _points[12] = ".9642174418317867586681955696889371322385196052049188093589812237410655467721799265557069528418287588";
      _weight[12] = ".4007904357988010490281663853142715479184889269729738260069953274478573722864358493176809540956887818e-1";
      _points[13] = ".9931419043484061694207986333520264008380457036196129408220354058888747770662458189553231198325758764";
      _weight[13] = ".1755973016587593151591643806909589030985280463856363829074994509820816141890413526883839849932323144e-1";
      break;


    case 28:
    case 29:
      delivered_order = 29;
      _points.resize(15);
      _weight.resize(15);
      _points[0] = ".60037409897572857552171407066937094265135914381192550000012422063057813154902876436389748158404275e-2";
      _weight[0] = ".1537662099805863417731419678860220886087407241671703713211414275211859473355858401951938536619970174e-1";
      _points[1] = ".313633037996470478461205261448952643780018632423477710493184618248985131014772360247262069128659567e-1";
      _weight[1] = ".3518302374405406235463370822533366923335401637716535991295364645719352775643711852242022603334696957e-1";
      _points[2] = ".758967082947863918996758396128915743168719126315036829521362206196624624129272574011961401245892596e-1";
      _weight[2] = ".5357961023358596750593477334293465170777185787905099034351119456093899742615789986284292856880431190e-1";
      _points[3] = ".1377911343199149762919069726930309951845503527079487182242882896479381091610373905019494511984328368";
      _weight[3] = ".6978533896307715722390239725551416126042513765775562160119556431554422227095390584038412868178566675e-1";
      _points[4] = ".2145139136957305762313866313730446793808068018586251975733672914729023100651207102582926857150869276";
      _weight[4] = ".8313460290849696677660043024060440556545009004920645366093259528177678160613925885535258714620776805e-1";
      _points[5] = ".3029243264612183150513963145094772658186236119206508724844173280241955211065192910122514429191701190";
      _weight[5] = ".9308050000778110551340028093321141225311300613896420140774786365500662775134958030947488444304966175e-1";
      _points[6] = ".3994029530012827388496858483027018960935817727686811601920251376950258804984899061990818709662394704";
      _weight[6] = ".9921574266355578822805916322191966240934627997877099674236896396456239876671713406665749958240891160e-1";
      _points[7] = ".5";
      _weight[7] = ".1012891209627806364403100999837596574193310790047386783983520580257176993773730370466967203563940160";
      _points[8] = ".6005970469987172611503141516972981039064182272313188398079748623049741195015100938009181290337605296";
      _weight[8] = ".9921574266355578822805916322191966240934627997877099674236896396456239876671713406665749958240891160e-1";
      _points[9] = ".6970756735387816849486036854905227341813763880793491275155826719758044788934807089877485570808298810";
      _weight[9] = ".9308050000778110551340028093321141225311300613896420140774786365500662775134958030947488444304966185e-1";
      _points[10] = ".7854860863042694237686133686269553206191931981413748024266327085270976899348792897417073142849130724";
      _weight[10] = ".8313460290849696677660043024060440556545009004920645366093259528177678160613925885535258714620776810e-1";
      _points[11] = ".8622088656800850237080930273069690048154496472920512817757117103520618908389626094980505488015671632";
      _weight[11] = ".6978533896307715722390239725551416126042513765775562160119556431554422227095390584038412868178566675e-1";
      _points[12] = ".9241032917052136081003241603871084256831280873684963170478637793803375375870727425988038598754107404";
      _weight[12] = ".5357961023358596750593477334293465170777185787905099034351119456093899742615789986284292856880431190e-1";
      _points[13] = ".9686366962003529521538794738551047356219981367576522289506815381751014868985227639752737930871340433";
      _weight[13] = ".3518302374405406235463370822533366923335401637716535991295364645719352775643711852242022603334696957e-1";
      _points[14] = ".9939962590102427142447828592933062905734864085618807449999987577936942186845097123563610251841595725";
      _weight[14] = ".1537662099805863417731419678860220886087407241671703713211414275211859473355858401951938536619970174e-1";
      break;


    case 30:
    case 31:
      delivered_order = 31;
      _points.resize(16);
      _weight.resize(16);
      _points[0] = ".52995325041750337019229132748336862868629641711774349743880476343379313920873015307317840466009095e-2";
      _weight[0] = ".1357622970587704742589028622800905175613368778338039899530515953690205683210808662466288961451544060e-1";
      _points[1] = ".277124884633837119610057922326958274544303637044636995372231739666951055486588478902171356309208405e-1";
      _weight[1] = ".3112676196932394643142191849718884713749325417645342895065175790976786944352190953060585476842586700e-1";
      _points[2] = ".671843988060841280597660511438034338063323075762366459482442872161198011437547208714337528176138229e-1";
      _weight[2] = ".4757925584124639240496255380112311317763175159185632907841114361481587978884097972351247866040249325e-1";
      _points[3] = ".1222977958224984830524494025762788658230931717712484951091214115388515694843641611396889715403752783";
      _weight[3] = ".6231448562776693602623814109600821007244342961110133997237529521470548196073267679898459500882784225e-1";
      _points[4] = ".1910618777986781257766641179756044905040588911171711029481013222291333411225942877715444847860207484";
      _weight[4] = ".7479799440828836604075086527373927448524553410391823340271098109368020201020899122588931920152962910e-1";
      _points[5] = ".2709916111713863068287902785082112132299841934822382545494226245261204128548531961322822360320059534";
      _weight[5] = ".8457825969750126909465603951517998110581973670801414087254146784040183210496526546607766127103911410e-1";
      _points[6] = ".3591982246103705433847697492697519467569652546147000997255826330220374102504346147792798854239799204";
      _weight[6] = ".9130170752246179443338183398460996969177811182732464120924757218971523247505558748020021255849263760e-1";
      _points[7] = ".4524937450811812799073403322875209684348234721554672716513900913874373508777039335076206535121083240";
      _weight[7] = ".9472530522753424814269836160414155257345449419795148751875662260001144538456650315006698891676697610e-1";
      _points[8] = ".5475062549188187200926596677124790315651765278445327283486099086125626491222960664923793464878916760";
      _weight[8] = ".9472530522753424814269836160414155257345449419795148751875662260001144538456650315006698891676697615e-1";
      _points[9] = ".6408017753896294566152302507302480532430347453852999002744173669779625897495653852207201145760200796";
      _weight[9] = ".9130170752246179443338183398460996969177811182732464120924757218971523247505558748020021255849263765e-1";
      _points[10] = ".7290083888286136931712097214917887867700158065177617454505773754738795871451468038677177639679940466";
      _weight[10] = ".8457825969750126909465603951517998110581973670801414087254146784040183210496526546607766127103911410e-1";
      _points[11] = ".8089381222013218742233358820243955094959411088828288970518986777708666588774057122284555152139792516";
      _weight[11] = ".7479799440828836604075086527373927448524553410391823340271098109368020201020899122588931920152962905e-1";
      _points[12] = ".8777022041775015169475505974237211341769068282287515048908785884611484305156358388603110284596247217";
      _weight[12] = ".6231448562776693602623814109600821007244342961110133997237529521470548196073267679898459500882784225e-1";
      _points[13] = ".9328156011939158719402339488561965661936676924237633540517557127838801988562452791285662471823861771";
      _weight[13] = ".4757925584124639240496255380112311317763175159185632907841114361481587978884097972351247866040249330e-1";
      _points[14] = ".9722875115366162880389942077673041725455696362955363004627768260333048944513411521097828643690791595";
      _weight[14] = ".3112676196932394643142191849718884713749325417645342895065175790976786944352190953060585476842586700e-1";
      _points[15] = ".9947004674958249662980770867251663137131370358288225650256119523656620686079126984692682159533990905";
      _weight[15] = ".1357622970587704742589028622800905175613368778338039899530515953690205683210808662466288961451544060e-1";
      break;


    case 32:
    case 33:
      delivered_order = 33;
      _points.resize(17);
      _weight.resize(17);
      _points[0] = ".47122623427913321622829900296673617461050747702178486080456066288280712646889831443207796751290108e-2";
      _weight[0] = ".1207415143427396598005501314378266234584865797251263915559257441510919835275524317979262073377249585e-1";
      _points[1] = ".246622391156161193886415210520984892783074767204456461650153937939423168639007026249815486242658212e-1";
      _weight[1] = ".2772976468699360056472008267912233025642312597661442349686203935512871300166731918663789437241095073e-1";
      _points[2] = ".598804231365070489385221527559221536882915910327860498240449203379864347477943942408464030657204052e-1";
      _weight[2] = ".4251807415858959044176768509553103692524569460925273788320518036939199639374132387349380214678649986e-1";
      _points[3] = ".1092429980515992965373849722397619748880137636297157437433427322437111919202434619133097495665191906";
      _weight[3] = ".5594192359670198554739419281317796336792171213153852500924324122454783982180491780761085226388315475e-1";
      _points[4] = ".1711644203916546170748488916784988324260970542620133780973841522463378512126512091235044063472449351";
      _weight[4] = ".6756818423426273664315999085117509868606292661724451018899730534443362149496927204875472415679216140e-1";
      _points[5] = ".2436547314567615160568767156852240627085381387944135470436342505178575375286072598590097938097411992";
      _weight[5] = ".7702288053840514404071579740097930597024152923550896719263235567572337092983822554580872467672545440e-1";
      _points[6] = ".3243841182730618423514072414523269974797301242121624883404194902261028691766252135512084276982454476";
      _weight[6] = ".8400205107822502225498533189416157751059906448253700713497792567016155325001229328060192486945988585e-1";
      _points[7] = ".4107579092520760720746612531729672212622903336542371782185240928646512247603497119148555388951824977";
      _weight[7] = ".8828135268349632316263549505659861957546220900037405902157220345660451810364134022616734534204332795e-1";
      _points[8] = ".5";
      _weight[8] = ".8972323517810326272913282213094281072439015994883426183383434897779837730314012970226422287625213875e-1";
      _points[9] = ".5892420907479239279253387468270327787377096663457628217814759071353487752396502880851444611048175023";
      _weight[9] = ".8828135268349632316263549505659861957546220900037405902157220345660451810364134022616734534204332795e-1";
      _points[10] = ".6756158817269381576485927585476730025202698757878375116595805097738971308233747864487915723017545524";
      _weight[10] = ".8400205107822502225498533189416157751059906448253700713497792567016155325001229328060192486945988585e-1";
      _points[11] = ".7563452685432384839431232843147759372914618612055864529563657494821424624713927401409902061902588008";
      _weight[11] = ".7702288053840514404071579740097930597024152923550896719263235567572337092983822554580872467672545440e-1";
      _points[12] = ".8288355796083453829251511083215011675739029457379866219026158477536621487873487908764955936527550649";
      _weight[12] = ".6756818423426273664315999085117509868606292661724451018899730534443362149496927204875472415679216140e-1";
      _points[13] = ".8907570019484007034626150277602380251119862363702842562566572677562888080797565380866902504334808094";
      _weight[13] = ".5594192359670198554739419281317796336792171213153852500924324122454783982180491780761085226388315475e-1";
      _points[14] = ".9401195768634929510614778472440778463117084089672139501759550796620135652522056057591535969342795948";
      _weight[14] = ".4251807415858959044176768509553103692524569460925273788320518036939199639374132387349380214678649990e-1";
      _points[15] = ".9753377608843838806113584789479015107216925232795543538349846062060576831360992973750184513757341788";
      _weight[15] = ".2772976468699360056472008267912233025642312597661442349686203935512871300166731918663789437241095073e-1";
      _points[16] = ".9952877376572086678377170099703326382538949252297821513919543933711719287353110168556792203248709892";
      _weight[16] = ".1207415143427396598005501314378266234584865797251263915559257441510919835275524317979262073377249586e-1";
      break;


    case 34:
    case 35:
      delivered_order = 35;
      _points.resize(18);
      _weight.resize(18);
      _points[0] = ".42174157895345266349919976469246148737105315772801535401621848800714532041101951241182651936993864e-2";
      _weight[0] = ".1080800676324165515667135513322623469384261573779497273103799507067654511867256095162565153493559774e-1";
      _points[1] = ".220880252143011224094020535351118450135779325943467605773061851545509643976133880210588035201830378e-1";
      _weight[1] = ".2485727444748489822666747310131932084043312306445510112315215393278617164790170814752068547468776830e-1";
      _points[2] = ".536987667512221303969697044364272422960523643238508929062668425463797087816075320846662064596984218e-1";
      _weight[2] = ".3821286512744452826456483880831826280265895310417914372476068961720500364589648967088255133919807780e-1";
      _points[3] = ".981475205137384421587912724927046014483505391940387591247859679023059472855278563858565172787941202e-1";
      _weight[3] = ".5047102205314358278140699246241730353140056944383945080518726832782539869024926167622531935567022570e-1";
      _points[4] = ".1541564784698233960625544593555758052738647135912461205489186715814013155481853744330945959274336848";
      _weight[4] = ".6127760335573923009225956340010077761408194866671954858362675682702871979970184091909860996252050735e-1";
      _points[5] = ".2201145844630262326960642257373354315361867571146452916800065279689077358967397401704589758199778157";
      _weight[5] = ".7032145733532532560236565187597361404775120516548627994172809763023279346387494851533138451345666080e-1";
      _points[6] = ".2941244192685786769820341030834741814605051589399872443594255661048051634497872951128265748031744856";
      _weight[6] = ".7734233756313262246270900191818738609660919813367708633332095736389143461532186515617346192611184055e-1";
      _points[7] = ".3740568871542472452055135725610443849185691171701797709898644841316077532221378890964612289453068764";
      _weight[7] = ".8213824187291636149302688823296379520616947699867647662224848545582421092260400387768187887353024455e-1";
      _points[8] = ".4576124934791323493788690735321080941333413065469550399783177411872501046733599991810977246362801938";
      _weight[8] = ".8457119148157179592032823506749330516705290968517194013493759577452972209577732108546045701988907675e-1";
      _points[9] = ".5423875065208676506211309264678919058666586934530449600216822588127498953266400008189022753637198062";
      _weight[9] = ".8457119148157179592032823506749330516705290968517194013493759577452972209577732108546045701988907675e-1";
      _points[10] = ".6259431128457527547944864274389556150814308828298202290101355158683922467778621109035387710546931236";
      _weight[10] = ".8213824187291636149302688823296379520616947699867647662224848545582421092260400387768187887353024455e-1";
      _points[11] = ".7058755807314213230179658969165258185394948410600127556405744338951948365502127048871734251968255144";
      _weight[11] = ".7734233756313262246270900191818738609660919813367708633332095736389143461532186515617346192611184055e-1";
      _points[12] = ".7798854155369737673039357742626645684638132428853547083199934720310922641032602598295410241800221843";
      _weight[12] = ".7032145733532532560236565187597361404775120516548627994172809763023279346387494851533138451345666080e-1";
      _points[13] = ".8458435215301766039374455406444241947261352864087538794510813284185986844518146255669054040725663152";
      _weight[13] = ".6127760335573923009225956340010077761408194866671954858362675682702871979970184091909860996252050735e-1";
      _points[14] = ".9018524794862615578412087275072953985516494608059612408752140320976940527144721436141434827212058798";
      _weight[14] = ".5047102205314358278140699246241730353140056944383945080518726832782539869024926167622531935567022565e-1";
      _points[15] = ".9463012332487778696030302955635727577039476356761491070937331574536202912183924679153337935403015782";
      _weight[15] = ".3821286512744452826456483880831826280265895310417914372476068961720500364589648967088255133919807780e-1";
      _points[16] = ".9779119747856988775905979464648881549864220674056532394226938148454490356023866119789411964798169622";
      _weight[16] = ".2485727444748489822666747310131932084043312306445510112315215393278617164790170814752068547468776829e-1";
      _points[17] = ".9957825842104654733650080023530753851262894684227198464598378151199285467958898048758817348063006136";
      _weight[17] = ".1080800676324165515667135513322623469384261573779497273103799507067654511867256095162565153493559774e-1";
      break;


    case 36:
    case 37:
      delivered_order = 37;
      _points.resize(19);
      _weight.resize(19);
      _points[0] = ".37965780782077984054911648733697532053417992983946066601602804543840485207385580981625395632905994e-2";
      _weight[0] = ".9730894114863238518156020732219217876453304534643320396340236230800718784052774105426044022633746010e-2";
      _points[1] = ".198959239325849845736105796561742366924542483629309470410918327838996250312557433896282192542293412e-1";
      _weight[1] = ".2240711338284980016641907870099710597587711373392880104292726338382149569213972882233451785512799686e-1";
      _points[2] = ".484220481925910491786695357338437560953030329713220911524837876191820977049478905212398858153514772e-1";
      _weight[2] = ".3452227136882061329035412900300652248092401584380656556145021384801748745321951075883154773166748644e-1";
      _points[3] = ".886426717314285875105387566436430491127307568965849793150680556972498285481570839865668884453697002e-1";
      _weight[3] = ".4574501081122499973223104706191982633045582564829939233249467245103111052189863080287385752094447824e-1";
      _points[4] = ".1395169113323853106914520695881091851714290835456666125307047643066927204260069735782833086643367127";
      _weight[4] = ".5578332277366699735801195084088299874066592691994688776073057143822948805282323530050214247629615270e-1";
      _points[5] = ".1997273476691594882651809175268803600658389586338537162067066371658075456515645797876221023342729993";
      _weight[5] = ".6437698126966811383775789242843855852791978854673151727355219231115180202831583996571650116707603665e-1";
      _points[6] = ".2677146293120195271413664259479488160118571426879317015078455612121579394432872966567752271396340276";
      _weight[6] = ".7130335108680330588787305472095148623783417241223693046328582795322912423645162550747003591862506850e-1";
      _points[7] = ".3417179500181850840049413355750775410538573904335563774221355066010535570897118010015805539567598244";
      _weight[7] = ".7638302103292983338942770044883149923050413361821431176155077653740552182553160682740492351539353415e-1";
      _points[8] = ".4198206771798873120659519421296282252475632497645623105626782741968396956598044631716302132502595436";
      _weight[8] = ".7948442169697717382497821973252360083939007909756304787558745766237048929169252987130523836300323930e-1";
      _points[9] = ".5";
      _weight[9] = ".8052722492439184798958181266045836751995127928925845106416157636788552422774903607627038285846452350e-1";
      _points[10] = ".5801793228201126879340480578703717747524367502354376894373217258031603043401955368283697867497404564";
      _weight[10] = ".7948442169697717382497821973252360083939007909756304787558745766237048929169252987130523836300323930e-1";
      _points[11] = ".6582820499818149159950586644249224589461426095664436225778644933989464429102881989984194460432401756";
      _weight[11] = ".7638302103292983338942770044883149923050413361821431176155077653740552182553160682740492351539353415e-1";
      _points[12] = ".7322853706879804728586335740520511839881428573120682984921544387878420605567127033432247728603659724";
      _weight[12] = ".7130335108680330588787305472095148623783417241223693046328582795322912423645162550747003591862506845e-1";
      _points[13] = ".8002726523308405117348190824731196399341610413661462837932933628341924543484354202123778976657270007";
      _weight[13] = ".6437698126966811383775789242843855852791978854673151727355219231115180202831583996571650116707603665e-1";
      _points[14] = ".8604830886676146893085479304118908148285709164543333874692952356933072795739930264217166913356632873";
      _weight[14] = ".5578332277366699735801195084088299874066592691994688776073057143822948805282323530050214247629615270e-1";
      _points[15] = ".9113573282685714124894612433563569508872692431034150206849319443027501714518429160134331115546302998";
      _weight[15] = ".4574501081122499973223104706191982633045582564829939233249467245103111052189863080287385752094447821e-1";
      _points[16] = ".9515779518074089508213304642661562439046969670286779088475162123808179022950521094787601141846485228";
      _weight[16] = ".3452227136882061329035412900300652248092401584380656556145021384801748745321951075883154773166748644e-1";
      _points[17] = ".9801040760674150154263894203438257633075457516370690529589081672161003749687442566103717807457706588";
      _weight[17] = ".2240711338284980016641907870099710597587711373392880104292726338382149569213972882233451785512799687e-1";
      _points[18] = ".9962034219217922015945088351266302467946582007016053933398397195456159514792614419018374604367094006";
      _weight[18] = ".9730894114863238518156020732219217876453304534643320396340236230800718784052774105426044022633746010e-2";
      break;


    case 38:
    case 39:
      delivered_order = 39;
      _points.resize(20);
      _weight.resize(20);
      _points[0] = ".34357004074525376069388057643398608886764345491720519259079343910076411861231095802752987517138954e-2";
      _weight[0] = ".8807003569576059155930981175926408181071552771668366262174663338674209629810923908701552771073048480e-2";
      _points[1] = ".180140363610431043661669344013613890439698360969055719682312030539792096078084715099909373720176422e-1";
      _weight[1] = ".2030071490019347066551997613746605493954531999497576840880342728091614837549366414776946031152219270e-1";
      _points[2] = ".438827858743370470661237793983509434754076012881541126020588904209645543956404605317776369035393063e-1";
      _weight[2] = ".3133602416705453178475326759352080317580053828921818204979217271898740551683283932228188302841610166e-1";
      _points[3] = ".804415140888905883027354691492396573351853174671813133737536372335694530003375950403853297170211754e-1";
      _weight[3] = ".4163837078835237436237907161102310305008891429158164537244103039284654144703970973568759542189541972e-1";
      _points[4] = ".1268340467699246036928474648221792048446346602154117779302270469657323224809224676594479431896762397";
      _weight[4] = ".5096505990862021751837506774017493808334582801169627813098580809842616101269717323767465788473992915e-1";
      _points[5] = ".1819731596367424872735816518868570316283054416003157680302766887267293687072849337206484022521193467";
      _weight[5] = ".5909726598075920865618868885569114350252060977448438772344497601008737417525575815286434391290950870e-1";
      _points[6] = ".2445664990245864509978179745223745007872543353987865832638256900526325148046171359279841584745661104";
      _weight[6] = ".6584431922458831344924724987408156745805525557349176349821824685442717821474046657177898759198631460e-1";
      _points[7] = ".3131469556422902196637259114875363813021268391471586440860256932421771178134702360520521581827333106";
      _weight[7] = ".7104805465919102566464916253358246651725770669601015166868354149191404374896718380847461214160029135e-1";
      _points[8] = ".3861070744291774609597519023157126876284555311585362638426821303964143290682220861025239374045156460";
      _weight[8] = ".7458649323630187339391436850098471834633995204068415824810560890492221129779339034698066301760524055e-1";
      _points[9] = ".4617367394332513331226797953005808944976018665932512495976023778078718289758315108792274429092218922";
      _weight[9] = ".7637669356536292534904216597754879674597432255618929863735052490879872658136889076778624391825195300e-1";
      _points[10] = ".5382632605667486668773202046994191055023981334067487504023976221921281710241684891207725570907781078";
      _weight[10] = ".7637669356536292534904216597754879674597432255618929863735052490879872658136889076778624391825195295e-1";
      _points[11] = ".6138929255708225390402480976842873123715444688414637361573178696035856709317779138974760625954843540";
      _weight[11] = ".7458649323630187339391436850098471834633995204068415824810560890492221129779339034698066301760524055e-1";
      _points[12] = ".6868530443577097803362740885124636186978731608528413559139743067578228821865297639479478418172666894";
      _weight[12] = ".7104805465919102566464916253358246651725770669601015166868354149191404374896718380847461214160029135e-1";
      _points[13] = ".7554335009754135490021820254776254992127456646012134167361743099473674851953828640720158415254338896";
      _weight[13] = ".6584431922458831344924724987408156745805525557349176349821824685442717821474046657177898759198631465e-1";
      _points[14] = ".8180268403632575127264183481131429683716945583996842319697233112732706312927150662793515977478806533";
      _weight[14] = ".5909726598075920865618868885569114350252060977448438772344497601008737417525575815286434391290950870e-1";
      _points[15] = ".8731659532300753963071525351778207951553653397845882220697729530342676775190775323405520568103237603";
      _weight[15] = ".5096505990862021751837506774017493808334582801169627813098580809842616101269717323767465788473992915e-1";
      _points[16] = ".9195584859111094116972645308507603426648146825328186866262463627664305469996624049596146702829788246";
      _weight[16] = ".4163837078835237436237907161102310305008891429158164537244103039284654144703970973568759542189541972e-1";
      _points[17] = ".9561172141256629529338762206016490565245923987118458873979411095790354456043595394682223630964606937";
      _weight[17] = ".3133602416705453178475326759352080317580053828921818204979217271898740551683283932228188302841610168e-1";
      _points[18] = ".9819859636389568956338330655986386109560301639030944280317687969460207903921915284900090626279823578";
      _weight[18] = ".2030071490019347066551997613746605493954531999497576840880342728091614837549366414776946031152219268e-1";
      _points[19] = ".9965642995925474623930611942356601391113235654508279480740920656089923588138768904197247012482861046";
      _weight[19] = ".8807003569576059155930981175926408181071552771668366262174663338674209629810923908701552771073048480e-2";
      break;


    case 40:
    case 41:
      delivered_order = 41;
      _points.resize(21);
      _weight.resize(21);
      _points[0] = ".31239146898052498698789820310295354033307726088354072095630726434519454885035965009356264323804612e-2";
      _weight[0] = ".8008614128887166662112308429235507632945211058951241274088955056779383680659431157453353047572838170e-2";
      _points[1] = ".163865807168468528416888925461524192876531563350765750235144359574395199974598560140812990680379736e-1";
      _weight[1] = ".1847689488542624689997533414966483309447215407436491871358459093939287557878370422926172143848016472e-1";
      _points[2] = ".399503329247995856049064331425155529204261951758891514119322564545092184652960855041340243139658653e-1";
      _weight[2] = ".2856721271342860414181791323622397874564379841312802072125366171352452769982600404414322428351082334e-1";
      _points[3] = ".733183177083413581763746807062161648619470984103280146285041853028785468580824265138551814041519428e-1";
      _weight[3] = ".3805005681418965100852582665009158961307717621198301426073424290822675829330037499656830940632376613e-1";
      _points[4] = ".1157800182621610456920610743468859825895116471143152245656366674849906287301494102064641704530678064";
      _weight[4] = ".4672221172801693077664487055696604424176332368079642243334763581628894888685619367593429428339537842e-1";
      _points[5] = ".1664305979012938403470166650048304187014853283442985787622664588264029034421518523502447557186043700";
      _weight[5] = ".5439864958357418883173728903505282101684979789692816527639104358448682188313469419058838121539598570e-1";
      _points[6] = ".2241905820563900964704906016378433566889698878846601674978470802501976091441579814715095060504845204";
      _weight[6] = ".6091570802686426709768358856286679917816881278076872512149190392137945061467548197097422700255402720e-1";
      _points[7] = ".2878289398962806082131655557281059739517773840801827078878708820517565581605992215000639535430861812";
      _weight[7] = ".6613446931666873089052628724838780216450577007157841160917516157589129928261519951184529780764439120e-1";
      _points[8] = ".3559893415987994516996037419676998400454908681769833856228592376253775285290786160733304858198915867";
      _weight[8] = ".6994369739553657736106671193379155544639658047745980218686566316212163123260307830816081080108004990e-1";
      _points[9] = ".4272190729195524545314845088306568349418369877810311212892558050072263595583401011547420107808957735";
      _weight[9] = ".7226220199498502953191358327687627180497498109854991737623649444304865467169593493263483293242601165e-1";
      _points[10] = ".5";
      _weight[10] = ".7304056682484521359599257384168559412240478847098272205366129375771929635169980596487109556323312785e-1";
      _points[11] = ".5727809270804475454685154911693431650581630122189688787107441949927736404416598988452579892191042265";
      _weight[11] = ".7226220199498502953191358327687627180497498109854991737623649444304865467169593493263483293242601170e-1";
      _points[12] = ".6440106584012005483003962580323001599545091318230166143771407623746224714709213839266695141801084133";
      _weight[12] = ".6994369739553657736106671193379155544639658047745980218686566316212163123260307830816081080108004995e-1";
      _points[13] = ".7121710601037193917868344442718940260482226159198172921121291179482434418394007784999360464569138188";
      _weight[13] = ".6613446931666873089052628724838780216450577007157841160917516157589129928261519951184529780764439115e-1";
      _points[14] = ".7758094179436099035295093983621566433110301121153398325021529197498023908558420185284904939495154796";
      _weight[14] = ".6091570802686426709768358856286679917816881278076872512149190392137945061467548197097422700255402725e-1";
      _points[15] = ".8335694020987061596529833349951695812985146716557014212377335411735970965578481476497552442813956300";
      _weight[15] = ".5439864958357418883173728903505282101684979789692816527639104358448682188313469419058838121539598570e-1";
      _points[16] = ".8842199817378389543079389256531140174104883528856847754343633325150093712698505897935358295469321936";
      _weight[16] = ".4672221172801693077664487055696604424176332368079642243334763581628894888685619367593429428339537845e-1";
      _points[17] = ".9266816822916586418236253192937838351380529015896719853714958146971214531419175734861448185958480572";
      _weight[17] = ".3805005681418965100852582665009158961307717621198301426073424290822675829330037499656830940632376613e-1";
      _points[18] = ".9600496670752004143950935668574844470795738048241108485880677435454907815347039144958659756860341347";
      _weight[18] = ".2856721271342860414181791323622397874564379841312802072125366171352452769982600404414322428351082336e-1";
      _points[19] = ".9836134192831531471583111074538475807123468436649234249764855640425604800025401439859187009319620264";
      _weight[19] = ".1847689488542624689997533414966483309447215407436491871358459093939287557878370422926172143848016470e-1";
      _points[20] = ".9968760853101947501301210179689704645966692273911645927904369273565480545114964034990643735676195388";
      _weight[20] = ".8008614128887166662112308429235507632945211058951241274088955056779383680659431157453353047572838170e-2";
      break;


    case 42:
    case 43:
      delivered_order = 43;
      _points.resize(22);
      _weight.resize(22);
      _points[0] = ".28527072588003539634842894193505098034729008019842325114885375166717511479600440896140371118641978e-2";
      _weight[0] = ".7313997649136100342495549023592722595105974562161865462248795710094053266374085571141887053759164140e-2";
      _points[1] = ".149697510822856364380245066173656445970155384310985152201308938318128696125787456812293226864828573e-1";
      _weight[1] = ".1688745079240707739665112343295645067458465723723733021644159727997575587653074419945747441116359070e-1";
      _points[2] = ".365216139064129997396535303704734016823351733139740089777134042364319404442294372481531235762733209e-1";
      _weight[2] = ".2614666757634164297015602563660562805607504678461815806135504164883817117996641239098409502489711904e-1";
      _points[3] = ".670937111398499317317871814903106354576016222057769219364533153686415525292397825957599218580713774e-1";
      _weight[3] = ".3489823421226024404748070946510882869938752647754026369315568588197320174364294701969642039672437436e-1";
      _points[4] = ".1060915970103959189978610222958242393059106643342184209391533011444338618736459625499742405203333074";
      _weight[4] = ".4297080310853386370722184068635143309457220267453989164328500552412301238656307871601112490735976389e-1";
      _points[5] = ".1527563684066586099746550821188716143663288550112824194391331123038570301128534725802029426006948234";
      _weight[5] = ".5020707222144048246603941891526814117540554438384981289248045717022654803711188637143031958167977870e-1";
      _points[6] = ".2061797982465442035205615361806763255611921982131410801149830893137658110859778198204199473943616987";
      _weight[6] = ".5646614804026960919670030371089215955713166606049735213629877312430656546180541682980244071248443370e-1";
      _points[7] = ".2653220810066214867968346445167968269523281044346317261019499851532114926571816930628014255887449254";
      _weight[7] = ".6162618840525621214278049307740723597972249950248398621421098594256775139958772701589012301721317145e-1";
      _points[8] = ".3290320895539578874209262897863101902204133504146563280015688081554932805464265186717208013164783516";
      _weight[8] = ".6558675239353118536648249626515372293787094709401532656268985171227230515676448704571705001654012950e-1";
      _points[9] = ".3960697866558893572605767330402271328921624454510331751656733478158995793426411678917005879371503930";
      _weight[9] = ".6827074917300758567628691561575869829318382649434308405473486746910377908226891669049531646614901690e-1";
      _points[10] = ".4651303633401388893930791019406859590888518502598842626466590267441953131836802769617408028147830728";
      _weight[10] = ".6962593642781599668770512417090497893696010872871292906309893853651885640938429814937374841202945705e-1";
      _points[11] = ".5348696366598611106069208980593140409111481497401157373533409732558046868163197230382591971852169272";
      _weight[11] = ".6962593642781599668770512417090497893696010872871292906309893853651885640938429814937374841202945705e-1";
      _points[12] = ".6039302133441106427394232669597728671078375545489668248343266521841004206573588321082994120628496070";
      _weight[12] = ".6827074917300758567628691561575869829318382649434308405473486746910377908226891669049531646614901690e-1";
      _points[13] = ".6709679104460421125790737102136898097795866495853436719984311918445067194535734813282791986835216484";
      _weight[13] = ".6558675239353118536648249626515372293787094709401532656268985171227230515676448704571705001654012950e-1";
      _points[14] = ".7346779189933785132031653554832031730476718955653682738980500148467885073428183069371985744112550746";
      _weight[14] = ".6162618840525621214278049307740723597972249950248398621421098594256775139958772701589012301721317145e-1";
      _points[15] = ".7938202017534557964794384638193236744388078017868589198850169106862341889140221801795800526056383013";
      _weight[15] = ".5646614804026960919670030371089215955713166606049735213629877312430656546180541682980244071248443370e-1";
      _points[16] = ".8472436315933413900253449178811283856336711449887175805608668876961429698871465274197970573993051766";
      _weight[16] = ".5020707222144048246603941891526814117540554438384981289248045717022654803711188637143031958167977870e-1";
      _points[17] = ".8939084029896040810021389777041757606940893356657815790608466988555661381263540374500257594796666926";
      _weight[17] = ".4297080310853386370722184068635143309457220267453989164328500552412301238656307871601112490735976389e-1";
      _points[18] = ".9329062888601500682682128185096893645423983777942230780635466846313584474707602174042400781419286226";
      _weight[18] = ".3489823421226024404748070946510882869938752647754026369315568588197320174364294701969642039672437440e-1";
      _points[19] = ".9634783860935870002603464696295265983176648266860259910222865957635680595557705627518468764237266791";
      _weight[19] = ".2614666757634164297015602563660562805607504678461815806135504164883817117996641239098409502489711904e-1";
      _points[20] = ".9850302489177143635619754933826343554029844615689014847798691061681871303874212543187706773135171427";
      _weight[20] = ".1688745079240707739665112343295645067458465723723733021644159727997575587653074419945747441116359070e-1";
      _points[21] = ".9971472927411996460365157105806494901965270991980157674885114624833282488520399559103859628881358022";
      _weight[21] = ".7313997649136100342495549023592722595105974562161865462248795710094053266374085571141887053759164145e-2";
      break;


    case 44:
    case 45:
      delivered_order = 45;
      _points.resize(23);
      _weight.resize(23);
      _points[0] = ".26153325012239382380371422772128197131863137705647895366030579164629601171073649080054278918099330e-2";
      _weight[0] = ".6705929743570886040654746729307532488309167052868616696197941069580443368026029924649517729262032555e-2";
      _points[1] = ".137287643909423840219879615896113124091931023230130287543719206321014814127117910662912671280352426e-1";
      _weight[1] = ".1549400292848972215534710982094225269188626449996403321744390329930889213143379600112485832998544809e-1";
      _points[2] = ".335144565869919488254015054807885108821490899243046146535493726990110855999564600434949640868522473e-1";
      _weight[2] = ".2401883586554233428582053581601699828060815415175580566684183343492904343740931457766547088994173192e-1";
      _points[3] = ".616238208647791663109215570329271641805354850196746825452994421197241806452420284007172524391514584e-1";
      _weight[3] = ".3211621070426292606358480757945549901957913787740341524767334102645877679039064170319608707260665849e-1";
      _points[4] = ".975557991905800539244407965016107210292849301348459887072837821641466199154753203924549983090379171e-1";
      _weight[4] = ".3964070588835947746144626237102161345685599596920325127781727016602150200687944126797678664420782006e-1";
      _points[5] = ".1406693184340249027691877581256905758350351274343536021226093558929744356620371262448563720390262400";
      _weight[5] = ".4645788303001757373850930868488232430173003587156494686632975230596864246779408039973782060447362780e-1";
      _points[6] = ".1901950621181769218074513441752021733064096705964538521495672071954400967517765817297777471175291148";
      _weight[6] = ".5244604573227070503704309250737192742923579159698750275141259616938968817102544494992821898212281070e-1";
      _points[7] = ".2452492610769962251551034760665767847275786154075711883864053095893624974476167342466240061359891282";
      _weight[7] = ".5749832011120568247082175646698065074570526146479280330453785170139979724187270361906533563747528085e-1";
      _points[8] = ".3048494809848545842892555635596972707109745746537482593903973683416436919064837854106762368147562969";
      _weight[8] = ".6152454215336476523378920033600482740792640627323528721783516645084523385389260275505301355895106555e-1";
      _points[9] = ".3679321595148275347330652308583451985104933749029301975654605614738355732086639877109207356445331132";
      _weight[9] = ".6445286109404107498929766969989682662985774859589174622217021585899473237800551787502302994595886845e-1";
      _points[10] = ".4333715878507669445341286588791169314947973618733089217445273114064760550621727612127183682018242994";
      _weight[10] = ".6623101970234830868582123235165846290251783473711176216125613401924300294133970283679005885397038905e-1";
      _points[11] = ".5";
      _weight[11] = ".6682728609305308767572855527292216929157640381844165874096798899572049042386144817957960350208853285e-1";
      _points[12] = ".5666284121492330554658713411208830685052026381266910782554726885935239449378272387872816317981757006";
      _weight[12] = ".6623101970234830868582123235165846290251783473711176216125613401924300294133970283679005885397038905e-1";
      _points[13] = ".6320678404851724652669347691416548014895066250970698024345394385261644267913360122890792643554668868";
      _weight[13] = ".6445286109404107498929766969989682662985774859589174622217021585899473237800551787502302994595886845e-1";
      _points[14] = ".6951505190151454157107444364403027292890254253462517406096026316583563080935162145893237631852437031";
      _weight[14] = ".6152454215336476523378920033600482740792640627323528721783516645084523385389260275505301355895106555e-1";
      _points[15] = ".7547507389230037748448965239334232152724213845924288116135946904106375025523832657533759938640108718";
      _weight[15] = ".5749832011120568247082175646698065074570526146479280330453785170139979724187270361906533563747528085e-1";
      _points[16] = ".8098049378818230781925486558247978266935903294035461478504327928045599032482234182702222528824708852";
      _weight[16] = ".5244604573227070503704309250737192742923579159698750275141259616938968817102544494992821898212281070e-1";
      _points[17] = ".8593306815659750972308122418743094241649648725656463978773906441070255643379628737551436279609737600";
      _weight[17] = ".4645788303001757373850930868488232430173003587156494686632975230596864246779408039973782060447362784e-1";
      _points[18] = ".9024442008094199460755592034983892789707150698651540112927162178358533800845246796075450016909620829";
      _weight[18] = ".3964070588835947746144626237102161345685599596920325127781727016602150200687944126797678664420782006e-1";
      _points[19] = ".9383761791352208336890784429670728358194645149803253174547005578802758193547579715992827475608485416";
      _weight[19] = ".3211621070426292606358480757945549901957913787740341524767334102645877679039064170319608707260665852e-1";
      _points[20] = ".9664855434130080511745984945192114891178509100756953853464506273009889144000435399565050359131477527";
      _weight[20] = ".2401883586554233428582053581601699828060815415175580566684183343492904343740931457766547088994173194e-1";
      _points[21] = ".9862712356090576159780120384103886875908068976769869712456280793678985185872882089337087328719647574";
      _weight[21] = ".1549400292848972215534710982094225269188626449996403321744390329930889213143379600112485832998544808e-1";
      _points[22] = ".9973846674987760617619628577227871802868136862294352104633969420835370398828926350919945721081900670";
      _weight[22] = ".6705929743570886040654746729307532488309167052868616696197941069580443368026029924649517729262032555e-2";
      break;


    case 46:
    case 47:
      delivered_order = 47;
      _points.resize(24);
      _weight.resize(24);
      _points[0] = ".24063900014893199100012951496315940627011537019985612791997274428580839652711310583013553314421456e-2";
      _weight[0] = ".6170614899993599773402833535018645787955020445683258408643660470545862758940556895899359335960211630e-2";
      _points[1] = ".126357220143452509008040034959154691294084734799106400942032174464094393595098877306812628591422725e-1";
      _weight[1] = ".1426569431446683159065390797593914322459889896595405830083240237882200281871457171284271271140493764e-1";
      _points[2] = ".308627239986336207381754991456392751725901709612743266824864120452052519737321645200176792320650222e-1";
      _weight[2] = ".2213871940870990308430137410566911442965642091692894837069861486051218814113321981719735850777974680e-1";
      _points[3] = ".567922364977994828934228290089016224563334783455399798144810416121625828005204139479382490019091494e-1";
      _weight[3] = ".2964929245771839037318387925005429227060006328260674551868827564704915158875412078303417780530450481e-1";
      _points[4] = ".899990070130485390230250636651273959619367611660722063780094869993085105232227299588697394137081020e-1";
      _weight[4] = ".3667324070554015286701680762655825905966825492424973570135124533002069423793546741616257113472227752e-1";
      _points[5] = ".1299379042107228178780859484500107872383537564929072715668088158640498306795385337793343219344356028";
      _weight[5] = ".4309508076597663795859260149187133359254029411896650279420357193064344223039026563444432814864084862e-1";
      _points[6] = ".1759531740315122153737521065446261866651708506905216098505331674877758412157301140359411148171363783";
      _weight[6] = ".4880932605205694413494033223212357721395948442684297204165530501147716928879598917401001984535909374e-1";
      _points[7] = ".2272892643055802321708121913908138149946080037061909122831928050847175804102145514520825662795968749";
      _weight[7] = ".5372213505798281739128867122330311139731434506711001088327082044341093319721855299029336356045761835e-1";
      _points[8] = ".2831032461869774307564578840433251437737892445360155959595993576716177964831845429711322847669621916";
      _weight[8] = ".5775283402686280067667224195339177993113515568824823529222468004433512677565927497017212882340639775e-1";
      _points[9] = ".3424786601519183128066033543400948796067608695875913656228849352350589218293782958280632452223958947";
      _weight[9] = ".6083523646390169560223157673813121280351477960190288938873587725631269685885848095887890171538642100e-1";
      _points[10] = ".4044405662631918454206800896214651840797974483426233219255407117059570236540641290087544443773951346";
      _weight[10] = ".6291872817341414806068769125559184436320166279067270208904575844069693633333129844101908962821057040e-1";
      _points[11] = ".4679715535686971869574784586876274807045004022896263032878244591051303582030449460985535619328737455";
      _weight[11] = ".6396909767337607848702808261234768592585561977083394121064978818617379577026820120604598878336737115e-1";
      _points[12] = ".5320284464313028130425215413123725192954995977103736967121755408948696417969550539014464380671262545";
      _weight[12] = ".6396909767337607848702808261234768592585561977083394121064978818617379577026820120604598878336737110e-1";
      _points[13] = ".5955594337368081545793199103785348159202025516573766780744592882940429763459358709912455556226048654";
      _weight[13] = ".6291872817341414806068769125559184436320166279067270208904575844069693633333129844101908962821057035e-1";
      _points[14] = ".6575213398480816871933966456599051203932391304124086343771150647649410781706217041719367547776041053";
      _weight[14] = ".6083523646390169560223157673813121280351477960190288938873587725631269685885848095887890171538642095e-1";
      _points[15] = ".7168967538130225692435421159566748562262107554639844040404006423283822035168154570288677152330378084";
      _weight[15] = ".5775283402686280067667224195339177993113515568824823529222468004433512677565927497017212882340639780e-1";
      _points[16] = ".7727107356944197678291878086091861850053919962938090877168071949152824195897854485479174337204031251";
      _weight[16] = ".5372213505798281739128867122330311139731434506711001088327082044341093319721855299029336356045761835e-1";
      _points[17] = ".8240468259684877846262478934553738133348291493094783901494668325122241587842698859640588851828636217";
      _weight[17] = ".4880932605205694413494033223212357721395948442684297204165530501147716928879598917401001984535909372e-1";
      _points[18] = ".8700620957892771821219140515499892127616462435070927284331911841359501693204614662206656780655643972";
      _weight[18] = ".4309508076597663795859260149187133359254029411896650279420357193064344223039026563444432814864084862e-1";
      _points[19] = ".9100009929869514609769749363348726040380632388339277936219905130006914894767772700411302605862918980";
      _weight[19] = ".3667324070554015286701680762655825905966825492424973570135124533002069423793546741616257113472227752e-1";
      _points[20] = ".9432077635022005171065771709910983775436665216544600201855189583878374171994795860520617509980908506";
      _weight[20] = ".2964929245771839037318387925005429227060006328260674551868827564704915158875412078303417780530450481e-1";
      _points[21] = ".9691372760013663792618245008543607248274098290387256733175135879547947480262678354799823207679349778";
      _weight[21] = ".2213871940870990308430137410566911442965642091692894837069861486051218814113321981719735850777974678e-1";
      _points[22] = ".9873642779856547490991959965040845308705915265200893599057967825535905606404901122693187371408577275";
      _weight[22] = ".1426569431446683159065390797593914322459889896595405830083240237882200281871457171284271271140493764e-1";
      _points[23] = ".9975936099985106800899987048503684059372988462980014387208002725571419160347288689416986446685578544";
      _weight[23] = ".6170614899993599773402833535018645787955020445683258408643660470545862758940556895899359335960211630e-2";
      break;


    case 48:
    case 49:
      delivered_order = 49;
      _points.resize(25);
      _weight.resize(25);
      _points[0] = ".22215151047509510456075265530491913712186752975959143945975344335332593281360327563559868235264962e-2";
      _weight[0] = ".5696899250513143973951482056617386801660263146454848224474030558094945864883371677961838556472516215e-2";
      _points[1] = ".116680392702412442508423067602029661273147223427966276645062863419180662320597230517766452584969106e-1";
      _weight[1] = ".1317749330751606863095090764764957246798164085166123437768308289193546700443974968576491076408646420e-1";
      _points[2] = ".285127143855128302929944151707647340473992146955049290362737514313523387279753693455473909243632584e-1";
      _weight[2] = ".2046957835065315632781174385582297683042289168205217325234920744964871644010775638523948552755521192e-1";
      _points[3] = ".525040010608623155744789966085975229127225751232080484691491585204142445494002743144069965348041092e-1";
      _weight[3] = ".2745234798791759596296844577023666208005499277655567452425424912229688733921825594785596203971672246e-1";
      _points[4] = ".832786856195829992894894456532152152695179430882396069895676422691409337614549373733851302612041594e-1";
      _weight[4] = ".3401916690617845860359359282835398427735474717731828130753561320500182702585573655332576148474093677e-1";
      _points[5] = ".1203703684813211847113585673978195118062389905508329395408051322774906855898687961961816013790738484";
      _weight[5] = ".4007035016750050900661747983455565114511286642683794685810073148680641446740064477972868885711265904e-1";
      _points[6] = ".1632168157632658177574396833761889120582916359636253414701715191108561315753578942090181571598453390";
      _weight[6] = ".4551413099148182490574861035144582669049627947966715548524188448350869233920526345124219907147685948e-1";
      _points[7] = ".2111685348793885161381550791936729663021324803542408716772582461194884936236839888616417017671017546";
      _weight[7] = ".5026797453352532210110344519634291349423304726407095353493452099970647407952301484097782810186629110e-1";
      _points[8] = ".2634986342771425197389089424954039793340911307691863545463845861521983620793569849484215761086031823";
      _weight[8] = ".5425981223713182655804697852505830967003879399336100807824715367441964639680422134669884175014827085e-1";
      _points[9] = ".3194138470953060811320891349361796662889608264783124651027106110766273088021517256983523424695311930";
      _weight[9] = ".5742912957285582416966277293477790432046809583409007479575749501574139833556271128267214949279078135e-1";
      _points[10] = ".3780665581395057839774048186012742067971834218370077617894321733748062636070720246601118161183748297";
      _weight[10] = ".5972788176789238611408906325645052369508835070686321275979394066759204511009386751221434860487635665e-1";
      _points[11] = ".4385676536946448018063200905959815972338973269751081307880532310536455825155707920867805750268344723";
      _weight[11] = ".6112122149515502084447975947292575291752962378152952045379004111601948360959005121516770445539453315e-1";
      _points[12] = ".5";
      _weight[12] = ".6158802686335772560195143653952507121911681375907583269567609865845600397463071064230056258752479190e-1";
      _points[13] = ".5614323463053551981936799094040184027661026730248918692119467689463544174844292079132194249731655277";
      _weight[13] = ".6112122149515502084447975947292575291752962378152952045379004111601948360959005121516770445539453320e-1";
      _points[14] = ".6219334418604942160225951813987257932028165781629922382105678266251937363929279753398881838816251703";
      _weight[14] = ".5972788176789238611408906325645052369508835070686321275979394066759204511009386751221434860487635660e-1";
      _points[15] = ".6805861529046939188679108650638203337110391735216875348972893889233726911978482743016476575304688070";
      _weight[15] = ".5742912957285582416966277293477790432046809583409007479575749501574139833556271128267214949279078130e-1";
      _points[16] = ".7365013657228574802610910575045960206659088692308136454536154138478016379206430150515784238913968177";
      _weight[16] = ".5425981223713182655804697852505830967003879399336100807824715367441964639680422134669884175014827090e-1";
      _points[17] = ".7888314651206114838618449208063270336978675196457591283227417538805115063763160111383582982328982454";
      _weight[17] = ".5026797453352532210110344519634291349423304726407095353493452099970647407952301484097782810186629110e-1";
      _points[18] = ".8367831842367341822425603166238110879417083640363746585298284808891438684246421057909818428401546610";
      _weight[18] = ".4551413099148182490574861035144582669049627947966715548524188448350869233920526345124219907147685948e-1";
      _points[19] = ".8796296315186788152886414326021804881937610094491670604591948677225093144101312038038183986209261516";
      _weight[19] = ".4007035016750050900661747983455565114511286642683794685810073148680641446740064477972868885711265904e-1";
      _points[20] = ".9167213143804170007105105543467847847304820569117603930104323577308590662385450626266148697387958406";
      _weight[20] = ".3401916690617845860359359282835398427735474717731828130753561320500182702585573655332576148474093680e-1";
      _points[21] = ".9474959989391376844255210033914024770872774248767919515308508414795857554505997256855930034651958908";
      _weight[21] = ".2745234798791759596296844577023666208005499277655567452425424912229688733921825594785596203971672244e-1";
      _points[22] = ".9714872856144871697070055848292352659526007853044950709637262485686476612720246306544526090756367416";
      _weight[22] = ".2046957835065315632781174385582297683042289168205217325234920744964871644010775638523948552755521193e-1";
      _points[23] = ".9883319607297587557491576932397970338726852776572033723354937136580819337679402769482233547415030894";
      _weight[23] = ".1317749330751606863095090764764957246798164085166123437768308289193546700443974968576491076408646420e-1";
      _points[24] = ".9977784848952490489543924734469508086287813247024040856054024655664667406718639672436440131764735038";
      _weight[24] = ".5696899250513143973951482056617386801660263146454848224474030558094945864883371677961838556472516210e-2";
      break;


    case 50:
    case 51:
      delivered_order = 51;
      _points.resize(26);
      _weight.resize(26);
      _points[0] = ".20571494271915354983915203385469870215710724402201663017360952972168516833610967740467059715813190e-2";
      _weight[0] = ".5275686308671503577825593842625988952172868589847307275027713818381611146754875672222351512065323220e-2";
      _points[1] = ".108072770217645044497098228440368472765417181263407487572925693417474246274937643305327893794402012e-1";
      _weight[1] = ".1220892554631595439480791375989420012024796309863517102602344753784585784943394482691409268167801318e-1";
      _points[2] = ".264204666691428749320423582409816227396448311578423649908661101950711777737695961146469011242954620e-1";
      _weight[2] = ".1898119164718138197515157062442524734538521087202447883765591232640395020816792394091514299828557512e-1";
      _points[3] = ".486810690078464628911672003843948743294379973135473137224171726102671004487270065711695848749312684e-1";
      _weight[3] = ".2548791264857390599915995036203668976293965927148596741191884299970865622501582259468230973003046462e-1";
      _points[4] = ".772770286057509906012464692660809192139624489543352152849117635441915426643818525249262189103054714e-1";
      _weight[4] = ".3163702316478741776972684495352254786111142100634725533304794330399419585613801383092303457974135344e-1";
      _points[5] = ".1118070255896605719035163763788580665118908718724025639184157891864835356795866770152894361720059839";
      _weight[5] = ".3734207488282987294353789805142416931937358094052034038951542087140981540468873148337652069639443670e-1";
      _points[6] = ".1517863697900213675680930431352876510696233411045904241477212730808197265020809856020430775563367220";
      _weight[6] = ".4252294715674261960522388253999084829196015838833913809302809070999389600765276409114328884385389266e-1";
      _points[7] = ".1966538534911909683840106265415564727823677138670450548106783437400359365548733997670835956949946462";
      _weight[7] = ".4710690017795707423183244153365159927458287295710363993165745118401724964172710566666105272447349387e-1";
      _points[8] = ".2457796425877471411521484676372154123118466229071245931394497651980363025353216548829887288626245910";
      _weight[8] = ".5102958054721271161920703512671539616360440567712100516593690970432633440273700128534590714908431060e-1";
      _points[9] = ".2984741224382568467594613114505584481700312951503419087054294332259078914763146734751210244027963392";
      _weight[9] = ".5423592026428829532828971336399879114471910171065332226480285430473069963645279198471579576032552260e-1";
      _points[10] = ".3539975802570215524285823089610848515576403065185048108938279040481491877109960462088021476536134262";
      _weight[10] = ".5668090827315983327472035922129907262297518146250760699414396494374455328228972724632422646792587595e-1";
      _points[11] = ".4115705898215549080154711257908276250113081180993678692598261501079773599722919564411924558682029494";
      _weight[11] = ".5833022174264829102233125377018110681598244061096210823008134860563283296415986325634816982250102965e-1";
      _points[12] = ".4703849532853433964531407124007983196048826323054822089228638541578064819400132898307946865571061161";
      _weight[12] = ".5916070763963113825818554285023434232494513541445265904716009968981034737478143412042810703364070915e-1";
      _points[13] = ".5296150467146566035468592875992016803951173676945177910771361458421935180599867101692053134428938839";
      _weight[13] = ".5916070763963113825818554285023434232494513541445265904716009968981034737478143412042810703364070920e-1";
      _points[14] = ".5884294101784450919845288742091723749886918819006321307401738498920226400277080435588075441317970506";
      _weight[14] = ".5833022174264829102233125377018110681598244061096210823008134860563283296415986325634816982250102965e-1";
      _points[15] = ".6460024197429784475714176910389151484423596934814951891061720959518508122890039537911978523463865738";
      _weight[15] = ".5668090827315983327472035922129907262297518146250760699414396494374455328228972724632422646792587590e-1";
      _points[16] = ".7015258775617431532405386885494415518299687048496580912945705667740921085236853265248789755972036608";
      _weight[16] = ".5423592026428829532828971336399879114471910171065332226480285430473069963645279198471579576032552260e-1";
      _points[17] = ".7542203574122528588478515323627845876881533770928754068605502348019636974646783451170112711373754090";
      _weight[17] = ".5102958054721271161920703512671539616360440567712100516593690970432633440273700128534590714908431060e-1";
      _points[18] = ".8033461465088090316159893734584435272176322861329549451893216562599640634451266002329164043050053538";
      _weight[18] = ".4710690017795707423183244153365159927458287295710363993165745118401724964172710566666105272447349384e-1";
      _points[19] = ".8482136302099786324319069568647123489303766588954095758522787269191802734979190143979569224436632780";
      _weight[19] = ".4252294715674261960522388253999084829196015838833913809302809070999389600765276409114328884385389263e-1";
      _points[20] = ".8881929744103394280964836236211419334881091281275974360815842108135164643204133229847105638279940161";
      _weight[20] = ".3734207488282987294353789805142416931937358094052034038951542087140981540468873148337652069639443666e-1";
      _points[21] = ".9227229713942490093987535307339190807860375510456647847150882364558084573356181474750737810896945286";
      _weight[21] = ".3163702316478741776972684495352254786111142100634725533304794330399419585613801383092303457974135346e-1";
      _points[22] = ".9513189309921535371088327996156051256705620026864526862775828273897328995512729934288304151250687316";
      _weight[22] = ".2548791264857390599915995036203668976293965927148596741191884299970865622501582259468230973003046462e-1";
      _points[23] = ".9735795333308571250679576417590183772603551688421576350091338898049288222262304038853530988757045380";
      _weight[23] = ".1898119164718138197515157062442524734538521087202447883765591232640395020816792394091514299828557512e-1";
      _points[24] = ".9891927229782354955502901771559631527234582818736592512427074306582525753725062356694672106205597988";
      _weight[24] = ".1220892554631595439480791375989420012024796309863517102602344753784585784943394482691409268167801318e-1";
      _points[25] = ".9979428505728084645016084796614530129784289275597798336982639047027831483166389032259532940284186810";
      _weight[25] = ".5275686308671503577825593842625988952172868589847307275027713818381611146754875672222351512065323220e-2";
      break;


    case 52:
    case 53:
      delivered_order = 53;
      _points.resize(27);
      _weight.resize(27);
      _points[0] = ".19103685555057165305563958093850048696559722170644061491817516058911272113370939556189766392126889e-2";
      _weight[0] = ".4899498025647180130575027545629549049112909467545796084070202282931315208834056077709691101107464872e-2";
      _points[1] = ".100382620192493885720633221694764077161788893050246183805700534738087120098905268472915122027480961e-1";
      _weight[1] = ".1134311579809031159801710322338074440638386014408317781572106511953791501790501107728496117313161265e-1";
      _points[2] = ".245497210926474965740459846780585534537050332577911745330913046063066655950442571041902067017298242e-1";
      _weight[2] = ".1764852687870985551128914465235582056806944476147090579111389254745441331417783144223590160180671613e-1";
      _points[3] = ".452588396612544478496774908951553725259778322025195204433862237639718668237359887725233973748080687e-1";
      _weight[3] = ".2372470626030753135204835505709235911236281008309236425865500633458910592851796202105534688856775970e-1";
      _points[4] = ".718960459908527548486313886465786011178565006982470865114051729355983403070955097351216573478990248e-1";
      _weight[4] = ".2949176842991679955515041685976581658262029535320608127010760745691056483180227669211726097685475882e-1";
      _points[5] = ".1041141804647458864278013279463646335402994671260682437963596939765897575631027349407405614340794446";
      _weight[5] = ".3487441188312279649216144417833363806641234662847600018870939081052967940428179133628127024163404922e-1";
      _points[6] = ".1414932631302881503525918941788302251246639739507184286743918968321525838419328333124890452720667908";
      _weight[6] = ".3980243388652888563153747950492120148807333649350147570670438190137636322061009657571259283000997426e-1";
      _points[7] = ".1835460140267524295361326811827556939484619912153316513524440504882996545014591099897366526751979405";
      _weight[7] = ".4421157927187847509716140142687455552826837502554955490293556854829634959572854374441795232874487530e-1";
      _points[8] = ".2297242177102715525498495292200085895204097755064091548128311249820295516418093872877596583527153648";
      _weight[8] = ".4804436368501425378282632327905292958010581476851466721406555676700756739190327262980465269080272892e-1";
      _points[9] = ".2794258741249865597070129221553592737761577024184503059273063932983996518602520409574681030394888480";
      _weight[9] = ".5125081890887289933562385576633190466220494745735866493489091619149373974629794637200532992832414270e-1";
      _points[10] = ".3320030481807455501348404828963577291049899905462029046375066464524953385727201073824309763094718600";
      _weight[10] = ".5378914289426659360608149221332870240948304953188233275617945325759724607200991384577327794535431305e-1";
      _points[11] = ".3867703172802315705713804463198849144102766335358981616766855014081114331134964348872204676390168474";
      _weight[11] = ".5562624417842259633608154802142433741646019004254163354820175484896603913565917187623706977023691845e-1";
      _points[12] = ".4430137071952350165335525080650116864133597330109295026171230451168172556057946273018102596801016852";
      _weight[12] = ".5673817305448257431018497404604962896026225940523601294820827478851116979698381328179598174896188875e-1";
      _points[13] = ".5";
      _weight[13] = ".5711043368947849452252286845091762434036072167508266516087385828959706267057662605513742154892559575e-1";
      _points[14] = ".5569862928047649834664474919349883135866402669890704973828769548831827443942053726981897403198983148";
      _weight[14] = ".5673817305448257431018497404604962896026225940523601294820827478851116979698381328179598174896188870e-1";
      _points[15] = ".6132296827197684294286195536801150855897233664641018383233144985918885668865035651127795323609831526";
      _weight[15] = ".5562624417842259633608154802142433741646019004254163354820175484896603913565917187623706977023691845e-1";
      _points[16] = ".6679969518192544498651595171036422708950100094537970953624933535475046614272798926175690236905281400";
      _weight[16] = ".5378914289426659360608149221332870240948304953188233275617945325759724607200991384577327794535431305e-1";
      _points[17] = ".7205741258750134402929870778446407262238422975815496940726936067016003481397479590425318969605111520";
      _weight[17] = ".5125081890887289933562385576633190466220494745735866493489091619149373974629794637200532992832414270e-1";
      _points[18] = ".7702757822897284474501504707799914104795902244935908451871688750179704483581906127122403416472846352";
      _weight[18] = ".4804436368501425378282632327905292958010581476851466721406555676700756739190327262980465269080272896e-1";
      _points[19] = ".8164539859732475704638673188172443060515380087846683486475559495117003454985408900102633473248020595";
      _weight[19] = ".4421157927187847509716140142687455552826837502554955490293556854829634959572854374441795232874487530e-1";
      _points[20] = ".8585067368697118496474081058211697748753360260492815713256081031678474161580671666875109547279332092";
      _weight[20] = ".3980243388652888563153747950492120148807333649350147570670438190137636322061009657571259283000997426e-1";
      _points[21] = ".8958858195352541135721986720536353664597005328739317562036403060234102424368972650592594385659205554";
      _weight[21] = ".3487441188312279649216144417833363806641234662847600018870939081052967940428179133628127024163404922e-1";
      _points[22] = ".9281039540091472451513686113534213988821434993017529134885948270644016596929044902648783426521009752";
      _weight[22] = ".2949176842991679955515041685976581658262029535320608127010760745691056483180227669211726097685475880e-1";
      _points[23] = ".9547411603387455521503225091048446274740221677974804795566137762360281331762640112274766026251919313";
      _weight[23] = ".2372470626030753135204835505709235911236281008309236425865500633458910592851796202105534688856775968e-1";
      _points[24] = ".9754502789073525034259540153219414465462949667422088254669086953936933344049557428958097932982701758";
      _weight[24] = ".1764852687870985551128914465235582056806944476147090579111389254745441331417783144223590160180671612e-1";
      _points[25] = ".9899617379807506114279366778305235922838211106949753816194299465261912879901094731527084877972519039";
      _weight[25] = ".1134311579809031159801710322338074440638386014408317781572106511953791501790501107728496117313161265e-1";
      _points[26] = ".9980896314444942834694436041906149951303440277829355938508182483941088727886629060443810233607873111";
      _weight[26] = ".4899498025647180130575027545629549049112909467545796084070202282931315208834056077709691101107464872e-2";
      break;


    case 54:
    case 55:
      delivered_order = 55;
      _points.resize(28);
      _weight.resize(28);
      _points[0] = ".17787512130227750247818047583445041249347839517870477071638352547578905194656373396422966957998046e-2";
      _weight[0] = ".4562141296547258869408076961475853120172245549145499708369845661949729932899064572545815432617494026e-2";
      _points[1] = ".93484173145636231527200270960848617779225233734308451619871592706357740391116002490365364722431086e-2";
      _weight[1] = ".1056605629638562987575019049663271722568467536164281889883424512553257787678854598207622668980514350e-1";
      _points[2] = ".228703596855309013729490801473922054982980629560241622926427756880846797020846005695918472357002312e-1";
      _weight[2] = ".1645071389115218998881540958526602299076540871004859392963081030188231834630637036171251530592121066e-1";
      _points[3] = ".421834868039339630651552883350364268237516023954392456692498776984959107464796399486009258231709138e-1";
      _weight[3] = ".2213646737950211391979393882660369530749705635428342185757353094211208880684996574681622625469913276e-1";
      _points[4] = ".670537387128024755288727163101565978290685846078868315112266334916527957174388070387134159576832852e-1";
      _weight[4] = ".2755367283785837271574145911347279560952898211283269420344637698647131160967129884326131212831754200e-1";
      _points[5] = ".971793145414104142760570222873611706641492925958441658946564191098052283695639826007994828508808920e-1";
      _weight[5] = ".3263646198349979789669878338775231817681771558130351316774240907603844736949397023700360993543964608e-1";
      _points[6] = ".1321945609931841139859277448537328159919694900034790533857361118320943707653349045332957791687288890";
      _weight[6] = ".3732310711728438951196594358651101901081793060316672371966002810748192103268864967435816954497234641e-1";
      _points[7] = ".1716744529805675193900509117466285892151991548750350190841482512520748495081871089058221993624929120";
      _weight[7] = ".4155670861445060919519824912216623993056720672192566649817783586627122641301714237517145008037053087e-1";
      _points[8] = ".2151397640942991403459983583217845334376436571716763860899851611688926236813584997474581943081318948";
      _weight[8] = ".4528587219651642047109301566839206491142874272724243618793426692722835773337135218283108971709898088e-1";
      _points[9] = ".2620628875224408694827940761662829786863919273106720242954436535283638129005135544364294021883252600";
      _weight[9] = ".4846532899896495792524450304772030088251656167823080247843814090718469703877365354821424385351831354e-1";
      _points[10] = ".3118742419554606448893213952219565085641530114783885448278236398030841405785217980858613331322624406";
      _weight[10] = ".5105648378903038490710831925285606752329000117896027046698772610142319921851682034903030485139628735e-1";
      _points[11] = ".3639691861824109611615868219371151325876193516532385237501620367487788298795431516066055368720267690";
      _weight[11] = ".5302788296142320895520821849840541439496148134257975841531014814296125636970519336941207124174810065e-1";
      _points[12] = ".4177153589333096143592641110544172714271372921994159117528571866523340747621517760908778175101073962";
      _weight[12] = ".5435559612914706762678575965183668393763922733302198382856058523865666319156439405412133157517785185e-1";
      _points[13] = ".4724603550579828647867417363290600110746020044695831581273307063705527277328462116757936372672850101";
      _weight[13] = ".5502350650823759814118813280090880697831276474561581663933405061480620506035357870344563338891741865e-1";
      _points[14] = ".5275396449420171352132582636709399889253979955304168418726692936294472722671537883242063627327149899";
      _weight[14] = ".5502350650823759814118813280090880697831276474561581663933405061480620506035357870344563338891741865e-1";
      _points[15] = ".5822846410666903856407358889455827285728627078005840882471428133476659252378482239091221824898926038";
      _weight[15] = ".5435559612914706762678575965183668393763922733302198382856058523865666319156439405412133157517785185e-1";
      _points[16] = ".6360308138175890388384131780628848674123806483467614762498379632512211701204568483933944631279732310";
      _weight[16] = ".5302788296142320895520821849840541439496148134257975841531014814296125636970519336941207124174810070e-1";
      _points[17] = ".6881257580445393551106786047780434914358469885216114551721763601969158594214782019141386668677375594";
      _weight[17] = ".5105648378903038490710831925285606752329000117896027046698772610142319921851682034903030485139628740e-1";
      _points[18] = ".7379371124775591305172059238337170213136080726893279757045563464716361870994864455635705978116747400";
      _weight[18] = ".4846532899896495792524450304772030088251656167823080247843814090718469703877365354821424385351831354e-1";
      _points[19] = ".7848602359057008596540016416782154665623563428283236139100148388311073763186415002525418056918681052";
      _weight[19] = ".4528587219651642047109301566839206491142874272724243618793426692722835773337135218283108971709898090e-1";
      _points[20] = ".8283255470194324806099490882533714107848008451249649809158517487479251504918128910941778006375070880";
      _weight[20] = ".4155670861445060919519824912216623993056720672192566649817783586627122641301714237517145008037053087e-1";
      _points[21] = ".8678054390068158860140722551462671840080305099965209466142638881679056292346650954667042208312711110";
      _weight[21] = ".3732310711728438951196594358651101901081793060316672371966002810748192103268864967435816954497234641e-1";
      _points[22] = ".9028206854585895857239429777126388293358507074041558341053435808901947716304360173992005171491191080";
      _weight[22] = ".3263646198349979789669878338775231817681771558130351316774240907603844736949397023700360993543964604e-1";
      _points[23] = ".9329462612871975244711272836898434021709314153921131684887733665083472042825611929612865840423167148";
      _weight[23] = ".2755367283785837271574145911347279560952898211283269420344637698647131160967129884326131212831754200e-1";
      _points[24] = ".9578165131960660369348447116649635731762483976045607543307501223015040892535203600513990741768290862";
      _weight[24] = ".2213646737950211391979393882660369530749705635428342185757353094211208880684996574681622625469913277e-1";
      _points[25] = ".9771296403144690986270509198526077945017019370439758377073572243119153202979153994304081527642997688";
      _weight[25] = ".1645071389115218998881540958526602299076540871004859392963081030188231834630637036171251530592121066e-1";
      _points[26] = ".9906515826854363768472799729039151382220774766265691548380128407293642259608883997509634635277568914";
      _weight[26] = ".1056605629638562987575019049663271722568467536164281889883424512553257787678854598207622668980514349e-1";
      _points[27] = ".9982212487869772249752181952416554958750652160482129522928361647452421094805343626603577033042001954";
      _weight[27] = ".4562141296547258869408076961475853120172245549145499708369845661949729932899064572545815432617494026e-2";
      break;


    case 56:
    case 57:
      delivered_order = 57;
      _points.resize(29);
      _weight.resize(29);
      _points[0] = ".16602788697017069184042337253230571741132733745599989009213381216072070027901278312380182102923982e-2";
      _weight[0] = ".4258451939373204827131906651124901501199444899259243026215047279732645793902882418850928550713034328e-2";
      _points[1] = ".87272473692934125645369921068115219466090255467842204874399542766637071421848082239136826419265386e-2";
      _weight[1] = ".9866042528061352991929900820197815574803284095180793828026922337672178169430556453082169853899485850e-2";
      _points[2] = ".213572021109561371008959815095882181312202230229514647182351819233291979228379010689973520716676478e-1";
      _weight[2] = ".1537024610104681132220426268730837487355813048435475516104217968317581621794780835865521052823688846e-1";
      _points[3] = ".394098835234706074531232819584467872955803283438532007655042680970249933577748626807424065302799843e-1";
      _weight[3] = ".2070103125934141805241500505703846076674539019428719862896243971739621852818551854143233329797395968e-1";
      _points[4] = ".626810975399486047911032893717107265446915684404793146363895856426290814568444265805376484795765234e-1";
      _weight[4] = ".2579741345124896195629719058977129895981105532307103384093141566365206014644921025462916123127927039e-1";
      _points[5] = ".909072561923737775052138927106075121849892190588531144314828638523417373322124463984703711024984970e-1";
      _weight[5] = ".3060154532853956927105492401195352246203226988956510415893870605599722203767775549076105389088635540e-1";
      _points[6] = ".1237685741327614330436949613939309048937040158855066957940010042376539346411570432556968386143779030";
      _weight[6] = ".3505896662752563928479074347443958655119744433738679095740371243000397857149125882037608692385616112e-1";
      _points[7] = ".1608927311986567424219074973040070368058685349926774186380950705253167483999159884580950739648638133";
      _weight[7] = ".3911916356788189191407244432984016568343953847983485473378759766238027210361614738466157853332551373e-1";
      _points[8] = ".2018591014308860898102068944055051099609065948072111807632688033848285830191300507043726507755829126";
      _weight[8] = ".4273612868308626377267242464860403569084912830679669766094537169121599627783617681021242338566500340e-1";
      _points[9] = ".2462035224378861789486860401862399233243880798077079179074678464508928168186815888404097663546827284";
      _weight[9] = ".4586887856962938167398320553855540344911451049097728563791493734934686215774724755050591349437150824e-1";
      _points[10] = ".2934235559129956680546467069841915883382807406318430401108076673728583268940136014749802695368964878";
      _weight[10] = ".4848191704720430315095003744134437958817813896090178213024773337311643895088929114457563589694678856e-1";
      _points[11] = ".3429841810661800325259020384044762758707755904545862593516205345527766512852832787297422662473099227";
      _weight[11] = ".5054563687995748306091027345374868182378363942626259956141601165288851018461290279446583271690678440e-1";
      _points[12] = ".3943238569169994627468121355485312504716745911439524259807995773389705444459941109507107858977417932";
      _weight[12] = ".5203665503886468695666423564256003445532611033773384582184702707394015054274691957461250068566737215e-1";
      _points[13] = ".4468608849336603849145088037848115095414022803521964318571123629889173281242076795284977696897172914";
      _weight[13] = ".5293807754866047070329566392609394653741565687113901991407767276251131908456972819198550959864424905e-1";
      _points[14] = ".5";
      _weight[14] = ".5323969085915712212325556345483878416509251580649798987648645053394066246579319242238732282325525215e-1";
      _points[15] = ".5531391150663396150854911962151884904585977196478035681428876370110826718757923204715022303102827086";
      _weight[15] = ".5293807754866047070329566392609394653741565687113901991407767276251131908456972819198550959864424910e-1";
      _points[16] = ".6056761430830005372531878644514687495283254088560475740192004226610294555540058890492892141022582068";
      _weight[16] = ".5203665503886468695666423564256003445532611033773384582184702707394015054274691957461250068566737210e-1";
      _points[17] = ".6570158189338199674740979615955237241292244095454137406483794654472233487147167212702577337526900773";
      _weight[17] = ".5054563687995748306091027345374868182378363942626259956141601165288851018461290279446583271690678440e-1";
      _points[18] = ".7065764440870043319453532930158084116617192593681569598891923326271416731059863985250197304631035122";
      _weight[18] = ".4848191704720430315095003744134437958817813896090178213024773337311643895088929114457563589694678856e-1";
      _points[19] = ".7537964775621138210513139598137600766756119201922920820925321535491071831813184111595902336453172716";
      _weight[19] = ".4586887856962938167398320553855540344911451049097728563791493734934686215774724755050591349437150824e-1";
      _points[20] = ".7981408985691139101897931055944948900390934051927888192367311966151714169808699492956273492244170874";
      _weight[20] = ".4273612868308626377267242464860403569084912830679669766094537169121599627783617681021242338566500340e-1";
      _points[21] = ".8391072688013432575780925026959929631941314650073225813619049294746832516000840115419049260351361867";
      _weight[21] = ".3911916356788189191407244432984016568343953847983485473378759766238027210361614738466157853332551373e-1";
      _points[22] = ".8762314258672385669563050386060690951062959841144933042059989957623460653588429567443031613856220970";
      _weight[22] = ".3505896662752563928479074347443958655119744433738679095740371243000397857149125882037608692385616112e-1";
      _points[23] = ".9090927438076262224947861072893924878150107809411468855685171361476582626677875536015296288975015030";
      _weight[23] = ".3060154532853956927105492401195352246203226988956510415893870605599722203767775549076105389088635542e-1";
      _points[24] = ".9373189024600513952088967106282892734553084315595206853636104143573709185431555734194623515204234766";
      _weight[24] = ".2579741345124896195629719058977129895981105532307103384093141566365206014644921025462916123127927039e-1";
      _points[25] = ".9605901164765293925468767180415532127044196716561467992344957319029750066422251373192575934697200157";
      _weight[25] = ".2070103125934141805241500505703846076674539019428719862896243971739621852818551854143233329797395967e-1";
      _points[26] = ".9786427978890438628991040184904117818687797769770485352817648180766708020771620989310026479283323522";
      _weight[26] = ".1537024610104681132220426268730837487355813048435475516104217968317581621794780835865521052823688846e-1";
      _points[27] = ".9912727526307065874354630078931884780533909744532157795125600457233362928578151917760863173580734614";
      _weight[27] = ".9866042528061352991929900820197815574803284095180793828026922337672178169430556453082169853899485850e-2";
      _points[28] = ".9983397211302982930815957662746769428258867266254400010990786618783927929972098721687619817897076018";
      _weight[28] = ".4258451939373204827131906651124901501199444899259243026215047279732645793902882418850928550713034330e-2";
      break;


    case 58:
    case 59:
      delivered_order = 59;
      _points.resize(30);
      _weight.resize(30);
      _points[0] = ".15532579626752298641849745406523583295589809411246049459528510988061523949181295920589902209691413e-2";
      _weight[0] = ".3984096248083302807732941737336811225240348293575860614742581678460019216450666647076830846143087017e-2";
      _points[1] = ".81659383601263950149837091971685990298410726451443182414099949244278523176044781489620141698226432e-2";
      _weight[1] = ".9233234155545479571151065956023634548103266984090701685649182757292799760653986827040259514837708805e-2";
      _points[2] = ".199890675158462438915644872091011685348203912980383002571691637875300211464657853864052781480999881e-1";
      _weight[2] = ".1439235394166168467485958980564602181979444727314374823709006130407299447000696655086510335574208568e-1";
      _points[3] = ".368999762853628370603378614597629979567627315873354695444814331602885021744488365916135599247205688e-1";
      _weight[3] = ".1939959628481352479840096822317384601660048838319767605386639485297348547638489695952751313951755301e-1";
      _points[4] = ".587197321039736592284417687348872049716554264267578839658369734391918686524041721353920808571339476e-1";
      _weight[4] = ".2420133641529702645146907021140375890763590459868636817259596839590271283855107639888371978178113158e-1";
      _points[5] = ".852171188086158012785509401337490417804656519148291605965235082731717467052091824585237782459299200e-1";
      _weight[5] = ".2874657810880953324086084470102806439856033536088156727435789950161607370497718846260599982547506277e-1";
      _points[6] = ".1161112839475869025410113295127484341525581913835457733967528063174207149135024774736951987068801579";
      _weight[6] = ".3298711494109024756406425755798118061872147682833018948351575802107183623304708968290995695579936872e-1";
      _points[7] = ".1510747526033421015338538059866799658088230996730226718101385766300116393784200196523091817799554766";
      _weight[7] = ".3687798736885260313412192501109536707688526301852471947063459118729969965731760585520067635831909164e-1";
      _points[8] = ".1897369085053785694297612217844053503963176535852359337024744149378323425125554411294237077723360894";
      _weight[8] = ".4037794761471010767734746923026486543794640185421964994512929685302559028351317280210620138460890400e-1";
      _points[9] = ".2316879259289900503679151033444636029179109965348514472736282585439925456905108106844294199514050487";
      _weight[9] = ".4344989360054148990119376535756285128837666437177267200611106494107679112713074712397751675481955268e-1";
      _points[10] = ".2764831152309554116096950498385729999187962030692877951227613091361923241357078964979965556393790508";
      _weight[10] = ".4606126111889306435881635354380938359845661720911705376383752350098652353504708414923202645840595361e-1";
      _points[11] = ".3236476372345609432644813964553130696731844959892871867029077655498652918834044606678198016239432353";
      _weight[11] = ".4818436858732212981973431317590493254820323071508012295649713786641876737100156186247562390905209770e-1";
      _points[12] = ".3726815369160550767800974350910974460586053483487407869178570124555182342154605985468168593078818987";
      _weight[12] = ".4979671029339763353139014105178473826493463183335213861068257309197333019495440450904614964466209236e-1";
      _points[13] = ".4230650431957082265181026636283720397907240143778307691405185085421064257445919493015384467446296072";
      _weight[13] = ".5088119487420275229821447608427702231635314474356342043213047270982125680265883747273799890989195600e-1";
      _points[14] = ".4742640787223411520834873934166387131254292731667152178724195780060176223947864454720649546463572571";
      _weight[14] = ".5142632644677942017064281835270752193418777853246411129315949333800811932830471469631442316094435460e-1";
      _points[15] = ".5257359212776588479165126065833612868745707268332847821275804219939823776052135545279350453536427429";
      _weight[15] = ".5142632644677942017064281835270752193418777853246411129315949333800811932830471469631442316094435455e-1";
      _points[16] = ".5769349568042917734818973363716279602092759856221692308594814914578935742554080506984615532553703928";
      _weight[16] = ".5088119487420275229821447608427702231635314474356342043213047270982125680265883747273799890989195595e-1";
      _points[17] = ".6273184630839449232199025649089025539413946516512592130821429875444817657845394014531831406921181013";
      _weight[17] = ".4979671029339763353139014105178473826493463183335213861068257309197333019495440450904614964466209234e-1";
      _points[18] = ".6763523627654390567355186035446869303268155040107128132970922344501347081165955393321801983760567647";
      _weight[18] = ".4818436858732212981973431317590493254820323071508012295649713786641876737100156186247562390905209773e-1";
      _points[19] = ".7235168847690445883903049501614270000812037969307122048772386908638076758642921035020034443606209492";
      _weight[19] = ".4606126111889306435881635354380938359845661720911705376383752350098652353504708414923202645840595361e-1";
      _points[20] = ".7683120740710099496320848966555363970820890034651485527263717414560074543094891893155705800485949513";
      _weight[20] = ".4344989360054148990119376535756285128837666437177267200611106494107679112713074712397751675481955268e-1";
      _points[21] = ".8102630914946214305702387782155946496036823464147640662975255850621676574874445588705762922276639106";
      _weight[21] = ".4037794761471010767734746923026486543794640185421964994512929685302559028351317280210620138460890400e-1";
      _points[22] = ".8489252473966578984661461940133200341911769003269773281898614233699883606215799803476908182200445234";
      _weight[22] = ".3687798736885260313412192501109536707688526301852471947063459118729969965731760585520067635831909161e-1";
      _points[23] = ".8838887160524130974589886704872515658474418086164542266032471936825792850864975225263048012931198421";
      _weight[23] = ".3298711494109024756406425755798118061872147682833018948351575802107183623304708968290995695579936874e-1";
      _points[24] = ".9147828811913841987214490598662509582195343480851708394034764917268282532947908175414762217540700800";
      _weight[24] = ".2874657810880953324086084470102806439856033536088156727435789950161607370497718846260599982547506280e-1";
      _points[25] = ".9412802678960263407715582312651127950283445735732421160341630265608081313475958278646079191428660524";
      _weight[25] = ".2420133641529702645146907021140375890763590459868636817259596839590271283855107639888371978178113158e-1";
      _points[26] = ".9631000237146371629396621385402370020432372684126645304555185668397114978255511634083864400752794312";
      _weight[26] = ".1939959628481352479840096822317384601660048838319767605386639485297348547638489695952751313951755302e-1";
      _points[27] = ".9800109324841537561084355127908988314651796087019616997428308362124699788535342146135947218519000119";
      _weight[27] = ".1439235394166168467485958980564602181979444727314374823709006130407299447000696655086510335574208568e-1";
      _points[28] = ".9918340616398736049850162908028314009701589273548556817585900050755721476823955218510379858301773568";
      _weight[28] = ".9233234155545479571151065956023634548103266984090701685649182757292799760653986827040259514837708805e-2";
      _points[29] = ".9984467420373247701358150254593476416704410190588753950540471489011938476050818704079410097790308587";
      _weight[29] = ".3984096248083302807732941737336811225240348293575860614742581678460019216450666647076830846143087017e-2";
      break;


    case 60:
    case 61:
      delivered_order = 61;
      _points.resize(31);
      _weight.resize(31);
      _points[0] = ".14562590902614629721867228884487458742773329414651846039381405366717276395697834888283143973765270e-2";
      _weight[0] = ".3735415789624387929348437516106203511075426242024019849635485164339136550087160840977924201147052352e-2";
      _points[1] = ".76570451674237579987674166326576445307408652426781645271356703022700230557276362559562770200009599e-2";
      _weight[1] = ".8659310395155291231578998043410570683136431383997888316377591894405077207572921151022554876722329345e-2";
      _points[2] = ".187480374535251691054737979470708490513902574237208116133243214850140100347019417235178165287494856e-1";
      _weight[2] = ".1350450959248971090030435404596607807117832300105832292843737492363504441243640117830615119921849170e-1";
      _points[3] = ".346215010516759175215271201353682435933011563709589817723318124046585290788184828767824618335974315e-1";
      _weight[3] = ".1821613695619273201219600523390172116357266602383384295070951969816670398426204523777386391732458538e-1";
      _points[4] = ".551199850258644783129039955089203692282012940674045251184339720369144990319574675014354411561841338e-1";
      _weight[4] = ".2274685376360055145115792894731483863177635965501448244675831806076219499563510511006105624936030451e-1";
      _points[5] = ".800398399268663299565477320299108219726313494626252385843196930525265858673214444671505722012976430e-1";
      _weight[5] = ".2705154121245842685583312954331002136019473129810590384700391052564995152903238580171815827117962399e-1";
      _points[6] = ".1091334257916875297968199899026577544522948139933005599675624686482212483980791531009348949655771446";
      _weight[6] = ".3108739328051421345517177184334833357936439968232565764075375266574554731138425888095956270391603274e-1";
      _points[7] = ".1421116077065733580470145673167570220549032619152057836859458771974568631244629034775778924290842141";
      _weight[7] = ".3481429161770518308387806312756285525754285369867169685553635851837134563893470805505726330781329886e-1";
      _points[8] = ".1786466385378698269077908983837492730041546583318966217453477017619332973797433691655777512192605948";
      _weight[8] = ".3819519329938830821317883745066532246287845684710432704609504082320412596697428296745140103467632755e-1";
      _points[9] = ".2183754192964253686395275382024192860256988634165564845071156081562723096081775797374572902948132262";
      _weight[9] = ".4119649588079463195191168371598088530788413327832313890519196212531543332326682020762560449528861664e-1";
      _points[10] = ".2609031089775487597797029803217571257802383142512884375809194745004315606814533610283708215805617268";
      _weight[10] = ".4378837030423893806309903484766654611462907988560212575177060598456271225204984948183410921973182529e-1";
      _points[11] = ".3058070491958835284693242693562399490074468660532279821210935607641609639146006582516778301944403820";
      _weight[11] = ".4594505694682073910768143580357506274865541268957890208924280825212435217371207403383186527264464579e-1";
      _points[12] = ".3526409650091491916910480511641478306235724073608207215318520588819652150614509044215928373785823163";
      _weight[12] = ".4764512145615975640360209874379834227066236912347951135572473296423440281824639506062046299784141870e-1";
      _points[13] = ".4009394003322146856137935019835830311126025939192225600065988728719973969976976775656044900235067797";
      _weight[13] = ".4887166769316436254673700548949835191786439433804755725475732225072623157354002120950387583890251144e-1";
      _points[14] = ".4502223439238292398374126049405296330805023206112363469698864545113650622352019669672111409842678964";
      _weight[14] = ".4961250561333615393743775721430750700877160997778153489060157125773453723517885216715386205370758320e-1";
      _points[15] = ".5";
      _weight[15] = ".4986027239671322571376691686717471982162670575010217574280728978204640605537343723220456872105070444e-1";
      _points[16] = ".5497776560761707601625873950594703669194976793887636530301135454886349377647980330327888590157321036";
      _weight[16] = ".4961250561333615393743775721430750700877160997778153489060157125773453723517885216715386205370758318e-1";
      _points[17] = ".5990605996677853143862064980164169688873974060807774399934011271280026030023023224343955099764932203";
      _weight[17] = ".4887166769316436254673700548949835191786439433804755725475732225072623157354002120950387583890251144e-1";
      _points[18] = ".6473590349908508083089519488358521693764275926391792784681479411180347849385490955784071626214176837";
      _weight[18] = ".4764512145615975640360209874379834227066236912347951135572473296423440281824639506062046299784141872e-1";
      _points[19] = ".6941929508041164715306757306437600509925531339467720178789064392358390360853993417483221698055596180";
      _weight[19] = ".4594505694682073910768143580357506274865541268957890208924280825212435217371207403383186527264464579e-1";
      _points[20] = ".7390968910224512402202970196782428742197616857487115624190805254995684393185466389716291784194382732";
      _weight[20] = ".4378837030423893806309903484766654611462907988560212575177060598456271225204984948183410921973182529e-1";
      _points[21] = ".7816245807035746313604724617975807139743011365834435154928843918437276903918224202625427097051867738";
      _weight[21] = ".4119649588079463195191168371598088530788413327832313890519196212531543332326682020762560449528861664e-1";
      _points[22] = ".8213533614621301730922091016162507269958453416681033782546522982380667026202566308344222487807394052";
      _weight[22] = ".3819519329938830821317883745066532246287845684710432704609504082320412596697428296745140103467632758e-1";
      _points[23] = ".8578883922934266419529854326832429779450967380847942163140541228025431368755370965224221075709157859";
      _weight[23] = ".3481429161770518308387806312756285525754285369867169685553635851837134563893470805505726330781329888e-1";
      _points[24] = ".8908665742083124702031800100973422455477051860066994400324375313517787516019208468990651050344228554";
      _weight[24] = ".3108739328051421345517177184334833357936439968232565764075375266574554731138425888095956270391603274e-1";
      _points[25] = ".9199601600731336700434522679700891780273686505373747614156803069474734141326785555328494277987023570";
      _weight[25] = ".2705154121245842685583312954331002136019473129810590384700391052564995152903238580171815827117962399e-1";
      _points[26] = ".9448800149741355216870960044910796307717987059325954748815660279630855009680425324985645588438158662";
      _weight[26] = ".2274685376360055145115792894731483863177635965501448244675831806076219499563510511006105624936030451e-1";
      _points[27] = ".9653784989483240824784728798646317564066988436290410182276681875953414709211815171232175381664025685";
      _weight[27] = ".1821613695619273201219600523390172116357266602383384295070951969816670398426204523777386391732458538e-1";
      _points[28] = ".9812519625464748308945262020529291509486097425762791883866756785149859899652980582764821834712505144";
      _weight[28] = ".1350450959248971090030435404596607807117832300105832292843737492363504441243640117830615119921849170e-1";
      _points[29] = ".9923429548325762420012325833673423554692591347573218354728643296977299769442723637440437229799990401";
      _weight[29] = ".8659310395155291231578998043410570683136431383997888316377591894405077207572921151022554876722329345e-2";
      _points[30] = ".9985437409097385370278132771115512541257226670585348153960618594633282723604302165111716856026234730";
      _weight[30] = ".3735415789624387929348437516106203511075426242024019849635485164339136550087160840977924201147052353e-2";
      break;

    default:
      do { QuadratureOrderOutOfRange th__ex; std::ostringstream th__out; th__out << "QuadratureOrderOutOfRange" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules/cube_imp.hh" << ":" << 2517 << "]: " << "Quadrature rule " << p << " not supported!"; th__ex.message(th__out.str()); throw th__ex; } while (0);
    }
  }

}
# 342 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules.hh" 2

namespace Dune {




  template<typename ct, int dim>
  class Jacobi1QuadratureRule;


  template<typename ct,
           bool fundamental = std::numeric_limits<ct>::is_specialized>
  struct Jacobi1QuadratureInitHelper;
  template<typename ct>
  struct Jacobi1QuadratureInitHelper<ct, true> {
    static void init(int p,
                     std::vector< FieldVector<ct, 1> > & _points,
                     std::vector< ct > & _weight,
                     int & delivered_order);
  };
  template<typename ct>
  struct Jacobi1QuadratureInitHelper<ct, false> {
    static void init(int p,
                     std::vector< FieldVector<ct, 1> > & _points,
                     std::vector< ct > & _weight,
                     int & delivered_order);
  };




  template<typename ct>
  class Jacobi1QuadratureRule<ct,1> :
    public QuadratureRule<ct,1>
  {
  public:

 enum { d=1 };


 enum { dim=1 };


 enum { highest_order=61 };


 typedef ct CoordType;


 typedef Jacobi1QuadratureRule value_type;

    ~Jacobi1QuadratureRule(){}
  private:
    friend class QuadratureRuleFactory<ct,dim>;
    Jacobi1QuadratureRule (int p)
      : QuadratureRule<ct,1>(GeometryType(GeometryType::cube, 1))
    {

      std::vector< FieldVector<ct, dim> > _points;
      std::vector< ct > _weight;

      int delivered_order;

      Jacobi1QuadratureInitHelper<ct>::init
        (p, _points, _weight, delivered_order);
      this->delivered_order = delivered_order;
      ((_points.size() == _weight.size()) ? static_cast<void> (0) : __assert_fail ("_points.size() == _weight.size()", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules.hh", 408, __PRETTY_FUNCTION__));
      for (size_t i = 0; i < _points.size(); i++)
        this->push_back(QuadraturePoint<ct,dim>(_points[i], _weight[i]));
    }
  };


  extern template Jacobi1QuadratureRule<float, 1>::Jacobi1QuadratureRule(int);
  extern template Jacobi1QuadratureRule<double, 1>::Jacobi1QuadratureRule(int);


}



# 1 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules/jacobi_1_0_imp.hh" 1
# 11 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules/jacobi_1_0_imp.hh"
namespace Dune {


  template<typename ct>
  void Jacobi1QuadratureInitHelper<ct,true>::init(int p,
         std::vector< FieldVector<ct, 1> > & _points,
         std::vector< ct > & _weight,
         int & delivered_order)
  {
    switch(p)
    {

    case 0:
    case 1:
      delivered_order = 1;
      _points.resize(1);
      _weight.resize(1);
      _points[0] = .3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333334;
      _weight[0] = 1.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
      break;


    case 2:
    case 3:
      delivered_order = 3;
      _points.resize(2);
      _weight.resize(2);
      _points[0] = .1550510257216821901802715925294108608034052519343329871567307432749039622542684973460140566895359765;
      _weight[0] = .6360827634879543387887380041503272995536637489253705626907051426250533543031841681411033018391466800;
      _points[1] = .6449489742783178098197284074705891391965947480656670128432692567250960377457315026539859433104640235;
      _weight[1] = .3639172365120456612112619958496727004463362510746294373092948573749466456968158318588966981608533202;
      break;


    case 4:
    case 5:
      delivered_order = 5;
      _points.resize(3);
      _weight.resize(3);
      _points[0] = .885879595127039473955461437694561968857293319227495654311636951699764874268100967252193076161015786e-1;
      _weight[0] = .4018638274779192615443962665291996972772826161899046690923842878330733109101018240536312300474029061;
      _points[1] = .4094668644407347108649262520688298940519048952805623079690981414050785099670788198530803511765293624;
      _weight[1] = .4584822127191724933878411891126464928974948079824701329081908673733877785564897155383123086864879296;
      _points[2] = .7876594617608470560252418898759996233480800585109738408854524491392307168918253691359860554930833448;
      _weight[2] = .1396539598029082450677625443581538098252225758276251979994248447935389105334084604080564612661091632;
      break;


    case 6:
    case 7:
      delivered_order = 7;
      _points.resize(4);
      _weight.resize(4);
      _points[0] = .571041961145176821931211925541156212350779455987501643278082929309346782020731645861138168198427368e-1;
      _weight[0] = .2710138268629762324165283481558817992920669850614066882947002084270279998974049555934063155149987742;
      _points[1] = .2768430136381238276800459976856251411108891696950304683494420488311213396837080367725415285640511309;
      _weight[1] = .4069291360205427215828089518717095502110395549825805276980709607103205445318613532915751311604436137;
      _points[2] = .5835904323689168200566976686629172486934326398967716401762938418317475019618310120056322774674562994;
      _weight[2] = .2596950952164648816529124057792580292271059432720818009310478738715197515684797549856501468079414158;
      _points[3] = .8602401356562194478479129188751197667383780225872255049242335941839742579301655644134901549264276107;
      _weight[3] = .6236194190001616434775029419315062126978751668393098307618095699113170400225393612936840651661619870e-1;
      break;


    case 8:
    case 9:
      delivered_order = 9;
      _points.resize(5);
      _weight.resize(5);
      _points[0] = .398098570514687423408066900933331677042626542283851619464077482049647456261743068545022590831845672e-1;
      _weight[0] = .1935631804533033585487219432723014706300773723042959314554533779929073487933655762166538198748335132;
      _points[1] = .1980134178736081725357921367952962360381863588337888792083291768272087117286465026597729214141553943;
      _weight[1] = .3343492761887391309833512461953976371678718933478805952489779597608734587033500754020638058499268806;
      _points[2] = .4379748102473861440050125200052288525167902742147401264690572735060053301210965344528972647247758256;
      _weight[2] = .2927739741693396173960757387119177719719819871066279796088146708892391099142328799058439924278608750;
      _points[3] = .6954642733536360945146148237211671613940015549986483590851972611325288138368238668739250465460035524;
      _weight[3] = .1478177401452333407012664386834071576470881233025680816089650170466871663995867881310135629944366961;
      _points[4] = .9014649142011735738765011021122473096194864304517102005637358130565651259599860618861752355046079332;
      _weight[4] = .3149582904338455237058463313697596258298062393862741207778897431029291618946468034442481885294203156e-1;
      break;


    case 10:
    case 11:
      delivered_order = 11;
      _points.resize(6);
      _weight.resize(6);
      _points[0] = .293164271597848919720502769131649103737303925637149277869106839449360382416657787486309483651843695e-1;
      _weight[0] = .1446206614510173673109086522496639352868157617754660467953566358954592311021538274525319681276946612;
      _points[1] = .1480785996684842918499768524959792122302487748085944614125946418015983860908783218063693976617475760;
      _weight[1] = .2710849944630372336813807932761008554153744603412901289757132736303442652218840953547976196174453524;
      _points[2] = .3369846902811542990970529720807757051975687500284733471225629680736913505127840608524091411736544826;
      _weight[2] = .2815851075763978562381536781418577016545899054471519224997707881147672346819326236756438426595071102;
      _points[3] = .5586715187715501320813933418055219400743682889654078255557472261173501228974210783238200520122825820;
      _weight[3] = .1973223017813105282411690210967195758979330860171400109013608542168691368036765872249948825320820935;
      _points[4] = .7692338620300545009168833601156454518371421433222954161669481696365481305739532856852002115427743676;
      _weight[4] = .8791033110101795101635324861086019025599267125557955276461742797557562193809890394074140334644478685e-1;
      _points[5] = .9269456713197411148518739658196820110561724195422832527244670796566452024525282438143394800135873916;
      _weight[5] = .1747660362721906351203460662479774148929411516337233806318102016698451025225396235129028371682599564e-1;
      break;


    case 12:
    case 13:
      delivered_order = 13;
      _points.resize(7);
      _weight.resize(7);
      _points[0] = .224793864387124981088254995708450599221739072356003898592842760587585757581218801438065593769986904e-1;
      _weight[0] = .1119347268469821023031242268598512673581543443021245729793031713310010121026578504175518039330847150;
      _points[1] = .1146790531609042319096402370675146270777298245319719453889897349515683398313771981082383887487264664;
      _weight[1] = .2210185163817492048422414727392155493566865844622243094323892435572153405312368586320220078424677186;
      _points[2] = .2657898227845894684767893916933899974369968814056098940206796867530550186172425454664726006420981076;
      _weight[2] = .2547817945991766538374689715499232826990128023727599305281889688182403715832304891581911828678072314;
      _points[3] = .4528463736694446169985514423476511453596140721008524586919906545143298698851397040631574340782308227;
      _weight[3] = .2142501313917473399818245059997114645430845154022713345106969229642921740907764451829036761934830748;
      _points[4] = .6473752828868303626260922298287587971919781169427252176007906613661670650910811632587999055012469012;
      _weight[4] = .1327693929309829399672959775272798268160367658936009632652402776516685774949256903432965593140492997;
      _points[5] = .8197593082631076350124200571908182154579393791945298446773744447201820118320424789742899570523187170;
      _weight[5] = .5481671344374695088866209671645257295417296286400596170705830992550156540265177605400520195059885005e-1;
      _points[6] = .9437374394630778535343478089676888242202344852553769164275572083026057856516616966519018212670469614;
      _weight[6] = .1042872440561480817938274860756603627285202470301292757712310575208095879452089021202956789850911330e-1;
      break;


    case 14:
    case 15:
      delivered_order = 15;
      _points.resize(8);
      _weight.resize(8);
      _points[0] = .177799151473634518132051010376790612664883982385004336656078316787592475757830065972642767503224390e-1;
      _weight[0] = .8910160872311186265243123906792652143579327591629599162893070650953490775807421614093597558657520600e-1;
      _points[1] = .913236078997939560037414580745413531070404757445676687668701726347953004791598752353803789213819068e-1;
      _weight[1] = .1822380472727472526914449235657595207038316830973420932240504518535206139038892838023314283723493697;
      _points[2] = .2143084793956307583575412675816703226744297175224765908137326191408580982640893227912904964441607055;
      _weight[2] = .2250115989417747323435441972085622474585313183718632635826722622161065625207531342805328363235010088;
      _points[3] = .3719321645832723024308539604826292446681000633774806778676385412497303508594868127751294857726545930;
      _weight[3] = .2120947188718600214090621928223164323473301836600784587558404501112348205250685256991863152516914684;
      _points[4] = .5451866848034266490322722299532130551329800560537052249374829413005927647507051249095965493813529666;
      _weight[4] = .1583991989846383202408163787197844534389880146907948116529832318421622220548405973903502249576825338;
      _points[5] = .7131752428555694810513137602509073414468837909454265589730704929652137959347225387189767846054023754;
      _weight[5] = .9087863900939779616611084219138819921280234422368229723283559301918617746520672846935872214646562905e-1;
      _points[6] = .8556337429578544285147814797717850302864781605395751604095670933496281754845563783672978210969088188;
      _weight[6] = .3568580531197241678710559440208448516980542367921554701695861934230527222794506401464323963977834131e-1;
      _points[7] = .9553660447100301492668789781416922384764228669900323904483832488568928548867910582521230305572279597;
      _weight[7] = .6590382884497597709484632022178140232917756360727536905728685105949423544222450202661257721956446555e-2;
      break;


    case 16:
    case 17:
      delivered_order = 17;
      _points.resize(9);
      _weight.resize(9);
      _points[0] = .144124096488765486328267408108132394117447310565780860707506791281388758346004489439506930372721012e-1;
      _weight[0] = .7255600704655974291929919588231927759999609533460109803617790164385585111764690194965794919052353280e-1;
      _points[1] = .743873897091960446359181859559985850809769132847351984267996027450199237902342809679124294549830336e-1;
      _weight[1] = .1521485102186163251601586075079285812132106027704451841051048669451110654017776300437392883754252520;
      _points[2] = .1761166561629952818631757460725685864113860479693058739346483371718478923148052033071589166216033503;
      _weight[2] = .1970674843446914103203460407385488509023560656011704825855076061845847487566519614460658661365497237;
      _points[3] = .3096675799276378170596204672294840488163890844971259245735924385417910631238453492458723772259274575;
      _weight[3] = .2006176183867365793083004494651735780405723247720889520792755586297718961156570728203520324197133502;
      _points[4] = .4619704010810109348831431086805643081072330679787275209992998979929435248645151935609445375900637938;
      _weight[4] = .1687166436898406987885000399171749817104627172846977348696669835038285248020424407597603571357401276;
      _points[5] = .6181172346952940246392297516035044802806674046397913475060393055585778777428482116865746364861237204;
      _weight[5] = .1168023905903302211314630458032802960303593103025793617178533568693960614302271220161688241514649211;
      _points[6] = .7628230151850396146826933071467255329235111827037380779911005908346167214808478679770430364298828452;
      _weight[6] = .6360964298210800252338021387173996796508686851938261644837130415206699494945930902374759895630440005e-1;
      _points[7] = .8819210212100012998077148880052647763071205854487038619129766513283089105657085985563097864503385464;
      _weight[7] = .2412000856957075810345430457380053454860935724228865674231168030985443217573930570828234243797814046e-1;
      _points[8] = .9637421871167905390588356992319185479241288771581362138479503914355973155457527404910756919669630462;
      _weight[8] = .4361694171546261745098102240033931989346658172745913415730741761530425250798256232225741196300546707e-2;
      break;


    case 18:
    case 19:
      delivered_order = 19;
      _points.resize(10);
      _weight.resize(10);
      _points[0] = .119176134324155969097455869589859760300278472583748580202759930444135197179395355209349553769888750e-1;
      _weight[0] = .6019901604807404660130951104775872423481025847493586386892954004541908963029659975623116469369848810e-1;
      _points[1] = .617320718771481255226293671942501414528720803619021321847007975030054226778255498860235530897111654e-1;
      _weight[1] = .1285743090181651457496530772577303833702586985336065153964167070111045190343947831187521473702408613;
      _points[2] = .1471114496430702404275994355798195021337713619059297805712867093259790600660861446700545255054338432;
      _weight[2] = .1724226005783520728566667214238285835326209744871433508891823477804675766487885763704506821303023891;
      _points[3] = .2611596760084562402660516580548457231986357161379567253035521310935009972624582003737324443405623492;
      _weight[3] = .1853937873554468316895139838594217245376436126333093188403547348611167640031685342023540925200969458;
      _points[4] = .3946398468857868429619521050776075022149391536489841976946611563878829320916183985232456263028812026;
      _weight[4] = .1691142193816546648612911643310017367123791483004682190032143948519815060462764343108107374876334037;
      _points[5] = .5367387657156606328730951777118890227811982315666478711601841465166401511417696449330275943910494234;
      _weight[5] = .1321061511267007583321490050097555927283068703402401952281986304716746942938517327591629187622353407;
      _points[6] = .6759444616766651073571505089347614715039952762295357455139412301626256578790308622295455518800017058;
      _weight[6] = .8680381281430125184491223517276793341846841416734091479841192293605468475240771493378858474227150545e-1;
      _points[7] = .8009789210368988451379463016172425246730022622599153383117418553952368566445573598703594633591531736;
      _weight[7] = .4554918290652606517297529885212039260089893374717979072674077076892597133564094826507860794028660285e-1;
      _points[8] = .9017109877901467703487989784097679814681176760729360475326567373055975858521386207932416878958506862;
      _weight[8] = .1683863956596637483503273103740214403152870043903156313634792885260503739501482295430271106515098252e-1;
      _points[9] = .9699709678385135029569356423655920593053451564625792084689040051698797214284804451045965026202723376;
      _weight[9] = .2998281204812788056496272008212784833084388876744268112203022420650156860159853329068353288083480899e-2;
      break;


    case 20:
    case 21:
      delivered_order = 21;
      _points.resize(11);
      _weight.resize(11);
      _points[0] = .100182804616804058430247298678047848147919405162162386621691237027768574614451489481147469055721790e-1;
      _weight[0] = .5073468137628285236988931703476675133207796896933092717229277653106864390791321026906916586124492725e-1;
      _points[1] = .520354511271805525835426957729643224471859250583818355555288193433032785128089556252838329676615459e-1;
      _weight[1] = .1098761822657429965174933633313011358561393819756883634817227365336995079659568003680704346417858802;
      _points[2] = .1246192251444430737352995872639092292474441300880058562471871920162296059349519090766521215975420846;
      _weight[2] = .1512400961143739966427541096833209231046779325373189337898872562690835045663875992951588992175314076;
      _points[3] = .2228406070438378555078314534573627644117252503274297081643638173616062308369832016150585853516004854;
      _weight[3] = .1693188457680352424384787771038208637870956062801928026832694675642471331496036035898182671775944241;
      _points[4] = .3400081579146651882336052338970175277313293398208505803470934737382842096120712309333935896431331419;
      _weight[4] = .1637582059761269407791737038869224099299980514119884060206343004445372362390077946424160099852885042;
      _points[5] = .4681376130895840420831103807577535932852717675509161657042498476028053990410676565350775613890232895;
      _weight[5] = .1390637503163660995981017792678681988618489471914846995974738991240924370837736231339537725043865191;
      _points[6] = .5984972797671391832277207136730435902749187521976111511339511314695356530954712310305911412553938959;
      _weight[6] = .1031827213445951603861732834892155856521211990658746337177474052730046190656697225942280520050772121;
      _points[7] = .7222032848909679255633213078046109071372364455125913944559779818780897684066745302575181714890353344;
      _weight[7] = .6528309342766669203590773077952850778791273432908755477991105457383227392156662277547327915069498795e-1;
      _points[8] = .8308248996228185740305665439056567039439893043182143500186679333872078183180614211671796544755957775;
      _weight[8] = .3332724690336138483149424914765120772804900513036485126183239293221332762553574610457746434628573372e-1;
      _points[9] = .9169583865525948532931346270180274177520051095629925713521035439862432832098136415299370694612456098;
      _weight[9] = .1208784192095955158546592435315376798873973678286821945884976723777153926935372997535984241012640657e-1;
      _points[10] = .9747263796024796502466688135383708980845368176554858005326201789921787651358684645855413515511531779;
      _weight[10] = .2127334586489082815067761922450647971339436325800608036378943516449777205231547251874812699983997920e-2;
      break;


    case 22:
    case 23:
      delivered_order = 23;
      _points.resize(12);
      _weight.resize(12);
      _points[0] = .85390549884274193686644608778398028060904145665777464962579273012303645757621667975098429613076291e-2;
      _weight[0] = .4332972177374353464916694415595120758543212996143774483351792036632706037307065931531595605215419108e-1;
      _points[1] = .444464631554077230254667987855527662413093037889971099913964204343602863966164779580398791963530750e-1;
      _weight[1] = .9485570396075494026861836439417384912441834405354373442454022749260726809250625956872612646959123985e-1;
      _points[2] = .1068544908834766576341067704324992625897998143695000275580631125622836143405186814627639697793505873;
      _weight[2] = .1332135012533463962616689707039492301237993045862266872004033332675451141542576651800487628901468218;
      _points[3] = .1921510545298540409910572562286133303827013670215218660373964882963368867384002033277468512639620346;
      _weight[3] = .1537932053600820125624089382247452165048916722672790101081421598961789423490551582621434158001230290;
      _points[4] = .2953808842625802216229168343760149059398907133108521080514580880514097551832904806231230987696368169;
      _weight[4] = .1553926336310620532575312621995209299875566036520209784529663159004552165437224464483364641941562493;
      _points[5] = .4105450812014576824890343505593324118433186951909181754985565958109519682767226149737373217217664215;
      _weight[5] = .1402186799952601889918436100593420114476858105470553510722523423091126135591673604029597265238160539;
      _points[6] = .5309508493128176706289302428968181393245082635016252048349547896722090314354827164359000778197833608;
      _weight[6] = .1132276874273352638874022103122425258241607825709588607721683748382582855487003673371838524124059047;
      _points[7] = .6496006502772549927662917233429805722256531182773037348557195896485644248598662000888560729456533300;
      _weight[7] = .8090330741382723352129284850129132542849080333880815044744208769584595317684194609677391264812915710e-1;
      _points[8] = .7595988895252270537426025740434203419422064350885379264310222786423119973912528922496277727549814325;
      _weight[8] = .4975356081853086402501634458003176107706292549054632675888919684570712369316153894595850288044856446e-1;
      _points[9] = .8545525437649358807902119164056171284859595037395583869615217146999851616473022152580139867380827058;
      _weight[9] = .2487201833284453121496658611334714530755126260542143269983812777030176667500918269938718422593044914e-1;
      _points[10] = .9289421012644110178488101551343152998504932414769823471037599293899243740926428914029706095801991064;
      _weight[10] = .8889615591336924645592291731656523264334512786299205998267553396394713293187392679750568752472744375e-2;
      _points[11] = .9784379368341496390919069169169960383680691296676253661798930654904321350621424594217105164689234998;
      _weight[11] = .1550364441876056714491629023748274324615848140402517231572360221265942541320023063415527150625594874e-2;
      break;


    case 24:
    case 25:
      delivered_order = 25;
      _points.resize(13);
      _weight.resize(13);
      _points[0] = .73646510260893216506914984138223436112057156164460004206894164522697500338945509974163191284452937e-2;
      _weight[0] = .3742946317123035038674881732998767746319565332688557941550995658435906515956362602227579101388780574e-1;
      _points[1] = .383981387396783503768325248641416859178298341363546876124160117982427806914025897403499913466209422e-1;
      _weight[1] = .8264057883967859695322341390524823284515157447829234410387722644326630504728309789009709658120392265e-1;
      _points[2] = .925952246990026352828913754386163558892798586542929263236659323528192107313684954240609003975971810e-1;
      _weight[2] = .1179078759132941650723230065239224885407253391884774647520668533334363292610039623090163568998500540;
      _points[3] = .1672510113915577314955224787593571163747337087390977895834969262324481399932617359780977489832830798;
      _weight[3] = .1394269365642887965028332599008539689313215803996770757259514170749411407585930292996487794819461472;
      _points[4] = .2586235407057625165897907328226910025245301373917701116571591768242959721348720274973743055115115388;
      _weight[4] = .1456993930316364461587680676879467103064777104195675964020137583090170105818763010757692025989814890;
      _points[5] = .3621313972822388004086812982273215588635004488227823666951627890767765685364866146107646481156613178;
      _weight[5] = .1376310589751308344356757788733870175764464444515615290689142927534206737481584776849026461687874130;
      _points[6] = .4725843860041177251750946426785972728715487356847376391370606505456399289933543401366876758017619970;
      _weight[6] = .1182409626281846548385803119060635216477645343671270767817530063264325986532512918418359540320018568;
      _points[7] = .5844439640213404555042208478109107062952661618107888083023659837678484044838564429563713070829009516;
      _weight[7] = .9199156135210478662651956906042682442879113791215881297685885117558806298728604690294432003559148445e-1;
      _points[8] = .6921010017196016568970419516876697301808911008718652877381506074556730863418738419796277914411356902;
      _weight[8] = .6387357432440629768476274231692273392726396567637467815805792742291004917213504197268100373444847690e-1;
      _points[9] = .7901570282734374855528633324993759322704266136136999317134349971780526905331558640579365443870029771;
      _weight[9] = .3842791432943964129179099572748534939545850508452133503000565542463187538463405565894451924872087044e-1;
      _points[10] = .8736948213066894193677145671317438911733815349203347594446961615475144054728685418531116734022398624;
      _weight[10] = .1889784895918550073236017309848252773980721700710176677962226490559734899567257478464677461429063496e-1;
      _points[11] = .9385244591007310123976333867652993517339853062062887126354508873721247374248021832126814047065480952;
      _weight[11] = .6676718501547543613220841284083742579141287031654765750719644999750581810915764860757199651559843235e-2;
      _points[12] = .9813896349890121485602806221597123115526801027908002379955097186555535838880620308147789489545503324;
      _weight[12] = .1156113409872385703193022385189204618455050656599975054649145246648958439626729696480355938730002311e-2;
      break;


    case 26:
    case 27:
      delivered_order = 27;
      _points.resize(14);
      _weight.resize(14);
      _points[0] = .64167607928184568108204640945071788657198399122448843072387699327335456137052391556551219041876968e-2;
      _weight[0] = .3265350864519367963889885870153317340972173478361002456864218835784085024442850788249598470843608060e-1;
      _points[1] = .335014045320131400359639285705724816103907692528423670723219233210066138491594940691258617966863127e-1;
      _weight[1] = .7259215611088738637530423764370492657108112269853959863122175065021865096017202301997584723562877375e-1;
      _points[2] = .809854996819551843924513077399821872276651475866549950782993912779701719653182508178748665537077952e-1;
      _weight[2] = .1048919070038334911821636123253559026309238827100216428801281899821502970289452562493019979731821480;
      _points[3] = .1468048676812137299236601652607991515599694654279756227180485513313137055587256285457460550167373564;
      _weight[3] = .1264260511486584068850582307158644869441896337243628225912745291094341360195650397288853205184768074;
      _points[4] = .2280842706492579915346440986199429719415777248320505178336090146170398503780540680375636284189205414;
      _weight[4] = .1356633192083656742046946796682927954911511002736194344098397958433474422723897998813041094757193617;
      _points[5] = .3212717439889361744023403974130354496573046310098509725155244153528428571119004042632189220394104758;
      _weight[5] = .1327847012521708502656427173025549628480833128549141521111606655971088192656782192878509397656416202;
      _points[6] = .4222946573075702578404089875181026958217938762273438789639540713852576268236287646690911714244228904;
      _weight[6] = .1195711180450631684452281183371739455866965354227942932369779043707771685058862101141744024798095758;
      _points[7] = .5267378613398730320537269448128829953760927123999441876600624391842836631760001928071840738368501546;
      _weight[7] = .9903890904640600916187235867150676110280042407247668375164802867487908835414687742741451294178579330e-1;
      _points[8] = .6300366883704039578844805941314332791605030321087179470245277359365694220786253960307680873297618343;
      _weight[8] = .7488619291797165331187660365377253958575162997750359965853311053036376136149071602224720460759622710e-1;
      _points[9] = .7276764528892646854360267279903316966165601685246486600874809495965456531104679399309294019000621420;
      _weight[9] = .5084693081429752423013979751491821787681438824769049239677309253558218964169264456977882426851556925e-1;
      _points[10] = .8153897394434746419730742186120575147090134055115116514499564217599632405912766985454621567772925720;
      _weight[10] = .3006460748785728700681742950262958234619962060282172680123539669179027622963256575707868303499808856e-1;
      _points[11] = .8893428088195155396908716609464895647037628629053267599145054482375380565684526275834413083786664628;
      _weight[11] = .1459296826642524288681984453495518538081081230683288195407175989264044277989459235431320050562465306e-1;
      _points[12] = .9463027000602753835334059434247240449122575138455164975479188348405641933767500076215855613747667664;
      _weight[12] = .5108202635375307895958999219885338023800341194130592644971481918873169565255964058559811747744224110e-2;
      _points[13] = .9837752340986002382812280091410008568029060918346814026541382401229231239358663224051124039381821714;
      _weight[13] = .8794274174943185095245122078521822019754611306820543635221058449937077708215836466191607368410765415e-3;
      break;


    case 28:
    case 29:
      delivered_order = 29;
      _points.resize(15);
      _weight.resize(15);
      _points[0] = .56406889725117097575064665794442009660841069881311479679783351382181415757363640489156972035896698e-2;
      _weight[0] = .2873413924342504603822660041253805338312894456953019000237612541859506016961128946212643705230668354e-1;
      _points[1] = .294822986479424866316409847180037091870096130316607776016129935209832096965946431513732658899655064e-1;
      _weight[1] = .6423808974993183175709533215289588884744112148800311203074357885220757249757941129839863550850559045e-1;
      _points[2] = .714129531151588400547839017467349191218729023422743567843170138110648900594619504618507323606625814e-1;
      _weight[2] = .9378327988811985135869114109359384457615020825902727102745231221097976938006047088803797585614215020e-1;
      _points[3] = .1298310255535910559712545380942899123177230784713915452688927991403297243171614954096840860975794643;
      _weight[3] = .1147976510138825787492378322328278794932624818571617498887067215859317142102959221744686929404365635;
      _points[4] = .2024927550501040475682199883202304426029145838857816183098197713593869872838287905637745131407654632;
      _weight[4] = .1258362132971938191853306984611028086637728409087228064297723636579546705764893008808467616699197371;
      _points[5] = .2866060862575270599840260454843964124631835183282258747277172597764764143673373926548361027887495961;
      _weight[5] = .1266879103230227850387014761385934876207673172046994042169455568651290983423795896771549684315258373;
      _points[6] = .3789386886469780381065290091427738514254527443330112900124820663975192124536679674713512968590311796;
      _weight[6] = .1183483841194258631300423373291751145087283396220212493347563783564965088196806285369931653722201566;
      _points[7] = .4759423084632348605725889920158496815427420479142534143461931573336140130566014455167924185629638753;
      _weight[7] = .1028247246237729370608003387427179543718483332403108120303957336121729678371306599559686414960307900;
      _points[8] = .5738891609066858806714538552375264393339926267874317142496528265661645824810184689905478175189410147;
      _weight[8] = .8280147036884515645762630104986933848692863219976179565650568989405659185694148889272203873424612485e-1;
      _points[9] = .6690151950299598765386956390531395651245327979857527236420750144055549199665133052913040313820535802;
      _weight[9] = .6121953917293708160858361757949451057101860352459654126809960020356064378300880593208989800744638570e-1;
      _points[10] = .7576647390313427119970742777402853179406886187590936481745381257951925531912300645820920629808513944;
      _weight[10] = .4083261854523967138238199054130899238084842965133790112559698218356527355006904832983602017392238006e-1;
      _points[11] = .8364309606056101239755590856541831966144050516279921337789774230212989904851294862915904006631825436;
      _weight[11] = .2380838071019515768606037392049978041111467814177297555284892510317273317213807457840075998316892906e-1;
      _points[12] = .9022867006793780266312385046620090802654876855849468717160511280017608939616471254566098257665163887;
      _weight[12] = .1143444478944235234324930059485362276155780539908978755489501360681769092103144487510479479672775240e-1;
      _points[13] = .9527004099058333143380442075242620935055589938201492599119746533434704857023258451913238950513425186;
      _weight[13] = .3972469386290076082067610229152060080164258093234183168970372439783118787506178115381153751514450491e-2;
      _points[14] = .9857305452631742252659006330591292421044806623979681396367496904534811104340037194340828859918697398;
      _weight[14] = .6806847682757921219050495213766638432680058407302207119346460095765860960776864024700562258864675455e-3;
      break;


    case 30:
    case 31:
      delivered_order = 31;
      _points.resize(16);
      _weight.resize(16);
      _points[0] = .49972996637719210426511496015206903353343815434163443779705222558749641575587010375026471024396331e-2;
      _weight[0] = .2547862131466836949509969175915548829500688331296582799126402207371385137095959358456182506583938848e-1;
      _points[1] = .261435136813940519785493233805429683954454958525459325896928694344782980835469192641617828190141429e-1;
      _weight[1] = .5722490518028629871511613797483697079230632259783211879752488731784247248602820192649149146115387570e-1;
      _points[2] = .634309455838367454925282227707008598994423272005360632992128633660619650199194169690621454407255802e-1;
      _weight[2] = .8425886231485656951503148108375679459878568927192553127356020255912965879211860283525552207380978935e-1;
      _points[3] = .1155984375798159401789236282473972563726614701242300531764409420939787630288591298296722238684111490;
      _weight[3] = .1044571888079182947270193577860579511982476687312989947927842773279309587346572216043331398328061557;
      _points[4] = .1808705596578836662475733912556982106123115303246260325696821028817277573264066422281984062600090232;
      _weight[4] = .1165084804197116707586035588447860117666087389169987223931858385521171238120053660291409688663307144;
      _points[5] = .2570248078451708599229442395592698543456357763791818065543456950821702866951437507776531490026073372;
      _weight[5] = .1200017097762270141107718840043310847986139968638932139267556119836512373163034295226044021116883990;
      _points[6] = .3414679275478230686258992979386936719113738330035523847360437885913802004557323404561019734950136268;
      _weight[6] = .1154377592185356472353639909359373445130799205578497513133111318249085177414985560302496131357962245;
      _points[7] = .4313243435956253750835922695827402886099831559358862798400496976431495143682652974446555198615522438;
      _weight[7] = .1041282756876131675099467043785466919999001988893057566387403573176304031195728572957688903687759436;
      _points[8] = .5235341160251683205174701650756566635860722410235498499954471423511414451699874777100902273256248828;
      _weight[8] = .8799476437848784634696283460898074168566203452803298141048012151277732409770913018617800056991931685e-1;
      _points[9] = .6149571518764895174896408338190829300761737909570376040266234164320457869812106383069644402943986534;
      _weight[9] = .6929563315857159820616975574746178675946381337997363992181349355292028244090523248488698582693559135e-1;
      _points[10] = .7024801379250410444548069755376171424391608550242998874533600580057788358037540611975107319064165735;
      _weight[10] = .5031846621294008117130791499383570158153393032155337021668257703869079487755627644770701989152687180e-1;
      _points[11] = .7831225539648680838521817825620535305797128397296362805179828091518110236513200121261822163769397744;
      _weight[11] = .3307916871127158700245048416620955670443497800101336034230747234827543543117463085957742175622949140e-1;
      _points[12] = .8541381477752106336651136838193234409326728494243068253734695081123194081450149725457651384431831745;
      _weight[12] = .1906833576933187330993392764154659000664170074848288047274653307098419606424675728205551148860451362e-1;
      _points[13] = .9131083765371412746295855467032689982673591902958463102880070958924077633184989381448279078074159212;
      _weight[13] = .9078464772277270136442222357225691316200205613577463083584857434992460933218018083501741086109300200e-2;
      _points[14] = .9580244176904754545449593445542902781690561530886972767565858987751500797120765811025149504454439509;
      _weight[14] = .3134376947191639406144801392810125165152211379977657619913840594889257190569195251860266967516393470e-2;
      _points[15] = .9873530206260416180311559031679007912251798676684086442026613475062814838402808784348941153083800906;
      _weight[15] = .5349873301110723536352523245214688183617068853187298053447754895460255914769305758271994969580302670e-3;
      break;


    case 32:
    case 33:
      delivered_order = 33;
      _points.resize(17);
      _weight.resize(17);
      _points[0] = .44579935677873917545062291115463999646337601002599705378107254914584942500435984370196648654936660e-2;
      _weight[0] = .2274540622639378829776020880683720609452057522373976015749508324031731694387040746972125362749181489e-1;
      _points[1] = .233400941237742739670215282076831229958606005759941986344997465924823824333975755058549582940548134e-1;
      _weight[1] = .5128485584041035837150041049462227236569515810109611130226859683533715551484088425680168645644920215e-1;
      _points[2] = .567079687690782395327133315565206422583954294330082911813093706572985010525054793316865221556379500e-1;
      _weight[2] = .7605145765148480040294983401333088847853799893124803854611256634704675720143211718355596444822207695e-1;
      _points[3] = .1035554329351970634134912269613124043655029097199118685108784305899757515572621444529640256077589604;
      _weight[3] = .9528373874923688384115041853141755745633038829194399052580502788189156712111849867133924839700215000e-1;
      _points[4] = .1624600034281365499816295439141031838558059790103253735306759523919908694781359490868358657162134128;
      _weight[4] = .1078158633350549603832320404930530506583776814863800678782279266510495293543282695089808637977903962;
      _points[5] = .2316321257771721829467972257383587479080211677883964983117694939499389815368349381911564356963581672;
      _weight[5] = .1131472227649430259739820683657003705456250202081623505248301578043822513167014548107893476058596334;
      _points[6] = .3089701177521959033175242612862631293729470242289113159247135612658365232010381202115837653514093198;
      _weight[6] = .1114698358471210991542580389815065276072464356895427892969110466585885649118705952943517744483556402;
      _points[7] = .3921241347220956580336194633319030935711764025114615789973484145740342676368815150194126405593319517;
      _weight[7] = .1036194838585926665104294095256400693128383841028677293915780879742991691522033818310328703299843336;
      _points[8] = .4785675968530795887837104628593678634648959196490499291294706873670695640275487620721736497706949930;
      _weight[8] = .9095558079828455499487784832842234327421076718008184235832962158876271346851796676218008225388408430e-1;
      _points[9] = .5656739668866343319033069760096456365875201180074841733261734685045356633266844286988014211643520508;
      _weight[9] = .7518465097422447606286399704863748886393605930789172672958010315085190595784826875016684063030466320e-1;
      _points[10] = .6507965584533822647314874073231465774368335045672017460161248195939594014514835415159009295305527973;
      _weight[10] = .5814904817541010112637471093584722632635723649505078175048544545500447542788986279551396785911403605e-1;
      _points[11] = .7313489527340513821330214955629758769642882419335965596457437541501075219052287314086987765714504542;
      _weight[11] = .4160655602059072412002573275154629614396598977699363439275900065216665450117468253795333168827005934e-1;
      _points[12] = .8048835785249664919991777013970255022373475851134620892027287774778381435285669046560052364431526214;
      _weight[12] = .2702739490460156181927791662098239956927108947038280148990998102655235785834616122857118941751075748e-1;
      _points[13] = .8691660595674136192044464980111575364806195339738017470940551470086746289669440820074891382029851424;
      _weight[13] = .1543284442961187739177684553210850040977377913889605049895702539591618751800244624737646088995760080e-1;
      _points[14] = .9222430345922984084871073282303817691602583776161059845144196175091317355129889510768256352598660776;
      _weight[14] = .7294460966842812890068913047567504341965175593956839929686155659396138028717360227340619459024405260e-2;
      _points[15] = .9625011978233500412504607753885055612059058670805919300838487295359170197761774966465922450143861439;
      _weight[15] = .2505366878782441497821305040213450564573948855367154150978343268848357634079495184968727608551616254e-2;
      _points[16] = .9887140406322437514171214022529600950271304358332938882155721604826076932154206388238562326534443352;
      _weight[16] = .4262325784138671616503014825668479867743121463983310760858304095888980890581472393557710822275299578e-3;
      break;


    case 34:
    case 35:
      delivered_order = 35;
      _points.resize(18);
      _weight.resize(18);
      _points[0] = .40014793838673867970427199102708242235411852487858333635545783443198937571148426180584634073488953e-2;
      _weight[0] = .2042867887008126774453513345708525680111295405537645831789221858363235004907653637524376495672032180e-1;
      _points[1] = .209636483937664779951356009865610967568918017653850218271006512363638491846738483155450096276351098e-1;
      _weight[1] = .4621270032675413386257866238629064300957438277868616878558323293289918331132386077257775740214051950e-1;
      _points[2] = .509940415878905539667749212998534275268433517950210225049075762705476416715759097368663577872203266e-1;
      _weight[2] = .6894223784384404993007739031698519886588775153771160210566885018965190752564322224893633438800543855e-1;
      _points[3] = .932803959285449507776090588260657290911042316940360196554551611395487896027129667557276997443350555e-1;
      _weight[3] = .8714781414928617652436330187061168404379158056036702876225120391972824949607113158995664182946364855e-1;
      _points[4] = .1466701036776179571516088297346119926828719790587607976177450052287675453102203350213112764829923396;
      _weight[4] = .9980445383540542778220444771221204607299051846682882828893450936727624068650930424980230859185450610e-1;
      _points[5] = .2097070395888429667218817114520340564344572337129713950314960570502750540556726532998975043202670242;
      _weight[5] = .1063846692636713200524475540357298948042757460509025466150822041706738793410034729395308181693219169;
      _points[6] = .2806717900601716991068192620345454984655482490495543795697683718559155121543067476743790509001396309;
      _weight[6] = .1068905756056280540407231215063610225447807915923361568235083905351292478184997124115608137022036346;
      _points[7] = .3576286499766346293983271429839001635515548234119666315459310143421184553850015752086863654620933560;
      _weight[7] = .1018338577127481863631259923308642099185514417373884497748896700704506385950017111137663314704100215;
      _points[8] = .4384784492241381176518542603874069642668262016685327878789060389076575892412083497577428502906842642;
      _weight[8] = .9216480198048256152417399078564414852612846466652256992046258396446590593706414236053909750896569125e-1;
      _points[9] = .5210158208707761473198147915854717855660664902319620429318729520457293008516289285224828683060695134;
      _weight[9] = .7915832457721575745284593825289506100924953969440499641376678369347764830926340546224343749330271025e-1;
      _points[10] = .6029893605598320721374807041874726334761957597253021332090631742614856848258536813319527445372951366;
      _weight[10] = .6426961225525709848147580633301085880443436756721415851562729065246516504496265169885498286161075810e-1;
      _points[11] = .6821630391136515650188220799815272984812129529984549136808308873845014736266989488992730818190698118;
      _weight[11] = .4897518000258343319573971841628213770242132719001940867089608917054120707937976989292545511549928188e-1;
      _points[12] = .7563771934061506267981673359097779706473518228163447251511697288815637982124887651626427336664155868;
      _weight[12] = .3461660096179857963094037301158265977500547563449518843396957076139936244796763506359293284799220291e-1;
      _points[13] = .8236074297748695658739488546206220397694931892518864127892186510351045655222244744576037075797895550;
      _weight[13] = .2226374019481872490578598695715605901312264527880759493159497248783660222780139439098845774610923860e-1;
      _points[14] = .8820198253620791467312412088622993480054175558087202675489680161512128646692977135156953321849841043;
      _weight[14] = .1261207776476106746655648532508006599729513787362061969061111331011139156523293135970609947071819522e-1;
      _points[15] = .9300208896996932164819585047276942532417932534056115051608547073927014042784861756734769306165350984;
      _weight[15] = .5924886128865675007307012459683759302107922049224705877516978271987271702973648729283156120615280665e-2;
      _points[16] = .9663007519456325424115067464906798893423212721801663890681129055831478702436903498571145506943067400;
      _weight[16] = .2026050358602094250494341820341870894120024561864795036338823580354925264367517227275244577062726796e-2;
      _points[17] = .9898668482025971344167630227759617852272654029332944782218012796457954641639004909483002293295752084;
      _weight[17] = .3437381681963917846247430221834229151499287042287230354055143379188235978579521132163657480039052567e-3;
      break;


    case 36:
    case 37:
      delivered_order = 37;
      _points.resize(19);
      _weight.resize(19);
      _points[0] = .36116428185568930344532101262519834673327535500368291955711340586740834992929520786744161173773638e-2;
      _weight[0] = .1844807545006615338353364973844063664514747348633002796850199039649780838921192974783629157909885336e-1;
      _points[1] = .189318370315882172502645243169492367461404552465872310088109566093838432801783805186034184059745984e-1;
      _weight[1] = .4184930350395978096289045666597507923015930768805746257353242039038709944828752655956749616427151262e-1;
      _points[2] = .460979330484310835739247708354590937590624169342221575240393038979506119620931786171787481316387558e-1;
      _weight[2] = .6275255057146579770871362891521873929256827500121891666402911779624971524361366764385547573429398095e-1;
      _points[3] = .844472227842098205998479004511695475756854756734299647577394837711646475135301153956100567598849586e-1;
      _weight[3] = .7992474009798348388058615288463343146749229939781603917537641412235430355026262140658074962652401900e-1;
      _points[4] = .1330361885580987754240874239752163178462101569942577515312839921107421010353389269684892715246494817;
      _weight[4] = .9246985633715682353076157026438268785806641992726473058335517773221312455376698448719205979627889485e-1;
      _points[5] = .1906685949047633510874746648871937910511869102030339299609855946583176259568932278761873481665619368;
      _weight[5] = .9986827648083875910656821167754631038635897016436543739205281535304647362910941203114996053823459655e-1;
      _points[6] = .2559254034821029602520473972952833166965225034685666607613445549879376542400004376190936134395605994;
      _weight[6] = .1020083732534387925915104591369712164449503353535754486442048495248552091996933451569357987499162327;
      _points[7] = .3271998007638117157284299652756602156954719022978259770161223468001793352880351101154593072887848128;
      _weight[7] = .9918209293741316028263210506706355271369499867043289653925746745730565272014624896429591950124022870e-1;
      _points[8] = .4027367861650770951230470111048776348626646611402175602798726241469139422734752813325599363666955167;
      _weight[8] = .9204397143227682581672576212135660932951865767707678899669727185145202547081949806407328350372842925e-1;
      _points[9] = .4806763935785519026332213524827062607958913951805210382735109679392374943149106385409942481778506352;
      _weight[9] = .8153774174367337114460345968332885877015622313913313374058373868512964935174277352830164497093084720e-1;
      _points[10] = .5590994926490319878469279758790814850485694130830958106631220505575721013709915928328659605930323348;
      _weight[10] = .6879791590381478285911941087185040133275238686516501251070694318774386308432389393107853548035543575e-1;
      _points[11] = .6360750448792708946910910570981647668668019198973285696987761671558681881849944225414546581423684885;
      _weight[11] = .5503611628869595628296228495903234773834971955306329246189976450730557322385402735173501701009562220e-1;
      _points[12] = .7097076516539023988437467831116355144608909392408906399894113065110659853244124588493665962726797403;
      _weight[12] = .4142334512551560975967431967755079490752620840476902467442180073660343747997340115254631834842096820e-1;
      _points[13] = .7781842229767616142092996470420758791283656925578678775853071098643813559091198697527204996713931554;
      _weight[13] = .2897969422421944931400246601007177204686871789749054254495145220324571113131572128329170246403841060e-1;
      _points[14] = .8398186157087110778386362944292882560999767507786887653784723935849407017581430396000219565181239806;
      _weight[14] = .1848218385863319552539537554057223036019964756805820620573212876783093453134742074611622587757857651e-1;
      _points[15] = .8930931349818449707509811545649148473623623153254222496159769165216758357705561673044346695221436232;
      _weight[15] = .1039956265655675937361109308836621689303842061071886601976409524754409444497299628947762427761049612e-1;
      _points[16] = .9366958480743650805439055020819450266811818650579229027664901891451477928206324529848022077423517502;
      _weight[16] = .4860183424086561415136332087732184813912903332909763493482554844577771785083994880850628448767860504e-2;
      _points[17] = .9695526370802208854719287862322660049706018326703098706378843584104484087310020229969934667704093962;
      _weight[17] = .1655761521847964386692006035428965858679000056357516012475017722076239956761833907883794508005261242e-2;
      _points[18] = .9908518052709556853530948352201172311414908971100306236116888056786547010228099804847460306449291276;
      _weight[18] = .2802551883567726748812555744779639105600352061968937989749794735813128057127028672314734206097748682e-3;
      break;


    case 38:
    case 39:
      delivered_order = 39;
      _points.resize(20);
      _weight.resize(20);
      _points[0] = .32761066690500989752646761128711432920101684970296447672954700638314121615841947436103279640525158e-2;
      _weight[0] = .1674168835254511394846955946921133039592001158401097571996247349677350244330260113202342105341285984e-1;
      _points[1] = .171812181452557137382477046315820521714231065092193269938930182717301029969462923980692971400938767e-1;
      _weight[1] = .3806993892740333390463550463872740520842342009670349282847748189119210800461319599436676876862678490e-1;
      _points[2] = .418714311177651952442346341437085111495490230789848869138686347068204907034413700625150699605358272e-1;
      _weight[2] = .5733647475826119260703896626884620663676526982142598197751665152278167937952506465377762304743114550e-1;
      _points[3] = .768008370896219704818705230199473676157366322019186469079395037633694071264219274279012023218664533e-1;
      _weight[3] = .7350047967329571176034002983707970547786941802561395491718754226714603265744811012378159096660733655e-1;
      _points[4] = .1211898673236760656176861522945444470235806268943235898707887850377131524410713389898296198872402903;
      _weight[4] = .8578059167595640842829204758039989126835431719768784417396580841619485004243385901000626954200996215e-1;
      _points[5] = .1740471126355421652241579341996569921877681033069868901852878459116461179764358286536618532558350354;
      _weight[5] = .9368338372511565569498576493650134822004762846570875646531322483816870359335260839464910457905418140e-1;
      _points[6] = .2341918863135921908944557128323043352373021481231570747714734150082081622077654966849128615343105164;
      _weight[6] = .9703221011970818162036374853733578584979674884812765964709076549398887310760714319754736126681214735e-1;
      _points[7] = .3002806768359501643662584187171734631746719686192409655675227716570747312020196669966322653788992472;
      _weight[7] = .9597092321988782503051231642150166590478722336093452405759351080479348502148876405591865563178068395e-1;
      _points[8] = .3708371805843968964453220795377124336991024955666204869798357877359442742262916746260159928230296160;
      _weight[8] = .9094117788270695025052175053988521021573682596634589761784828202602528063874365566272648430490295200e-1;
      _points[9] = .4442852869630111621288239178359750500363597749061959401405017960314177377456681603304441676000055320;
      _weight[9] = .8263541363333147565166589034452447111897790526008740772996796592380070257693533775950888460291073920e-1;
      _points[10] = .5189842887035737296184117608302417580161348370994725645140664538072682185064509019793474604143752166;
      _weight[10] = .7192983830772549570812637571959705220454253379516249592845826823872807811447074214345608253045060850e-1;
      _points[11] = .5932655334835064879673930865443734208473977411399654892597462260744716869678127565393306479732092832;
      _weight[11] = .5980348368525802609816497837917858372547486798828513804350498569402473230677222080215249105521630065e-1;
      _points[12] = .6654696989055136479537295881338505673772460184966543033851700597919629976818155341141170411631585472;
      _weight[12] = .4725059234709778562613272088316633264786049061137085249821716995453687692356004132430763173471374028e-1;
      _points[13] = .7339838582356594497320271932958407316824886943041261173702937687882678060193520684331489222685668046;
      _weight[13] = .3519413375841203253537225731014733812107557483384302032295579824046286874151937628916098565550845026e-1;
      _points[14] = .7972775083365946877021888513752729067366395533700328215630061593076170870677993680779536516217368254;
      _weight[14] = .2440809225336020855759740649158179130555848135630839155224086550001630535743462622984150349858697256e-1;
      _points[15] = .8539367530358904570890043916180165250991367585634254004379927018011944789694603521437745068010804059;
      _weight[15] = .1545533586010292574715613428317953854964217039480755935175135440483625462586097291289321958613827229e-1;
      _points[16] = .9026958717934536922763469416996700772864999425096913605427629927201564197787843225600147491273022002;
      _weight[16] = .8646438225380306267478104148579112377200533623295159410282371065482011056328697434527181912481069745e-2;
      _points[17] = .9424655423631863386908918774276637741176541559385663981945954132521152784422837129268702079654087890;
      _weight[17] = .4022915227928156013814278936824336762072286332632338071325792455668677727129064099489345807391595775e-2;
      _points[18] = .9723569466474369111847018716646485313955816199047026627731927463182820924001386973341816730256378616;
      _weight[18] = .1366124552171843969035439751076010937012975665488565633903154123928917136910100459323476015520863856e-2;
      _points[19] = .9916999557929327307665436596947020094146922407257829898363762060484693209882124325386440915297527167;
      _weight[19] = .2307638143513705802967255226568830728813167721599840524365336414500605445638183205419184404433322438e-3;
      break;


    case 40:
    case 41:
      delivered_order = 41;
      _points.resize(21);
      _weight.resize(21);
      _points[0] = .29852372832130627418887840757498333480458971901820214266471114480518367455909531621871365537087194e-2;
      _weight[0] = .1526121181304637819034183537343181870586287942279387814026920795825460055220015001230072135456557602e-1;
      _points[1] = .156622805575735473328956106556783014972010128293037905774069098289880974645570072495734916113720055e-1;
      _weight[1] = .3477585215239002509062018516237075909270082225585556133119177596182468385879490593869463891914189065e-1;
      _points[2] = .381982882450735533448328193956577878032208188203725328447813769230183945227281635160195550912167396e-1;
      _weight[2] = .5257452016640661293744751166188692897194515113241003199215036965601069114006596457477520534479191075e-1;
      _points[3] = .701396190623257981398426567637581140708182789792715597262705384965631006414560540707747085667187342e-1;
      _weight[3] = .6777358068880635103031781043749696727813442757543512272919269504359828524130368130679643560187425645e-1;
      _points[4] = .1108366733203635022376253075861617420191222518457438320529257958835099421591933038201169995724625575;
      _weight[4] = .7969195514279793288914190000566235267906711260491304675619638962584196774176642443198237281889504350e-1;
      _points[5] = .1594611294440652502638138083655501810579538766130618360388682958278037659580503571599755802371922802;
      _weight[5] = .8787114127030075492971967145810458697850436666177532008944289193939981177542132493146261831484619220e-1;
      _points[6] = .2150231853580202850809121676459173588900222007857657740357006632538302506890640907152055964899157530;
      _weight[6] = .9210054144651500414815597125252491515932996742881640264899141571621140700823572973382363663762699855e-1;
      _points[7] = .2763917790937831724096862097630639456644117270400405937135134283509653312425761670490246263920613134;
      _weight[7] = .9242510522204482532070073767512146817197969239818616413946316147309617242947716994951510527308411215e-1;
      _points[8] = .3423176329587307937234813237124575051663439847813749695996137689085202168611822726580729904499541711;
      _weight[8] = .8913374937230921373396964638398331645759341581488079946582408064396578278281966817037315653266931975e-1;
      _points[9] = .4114586915619051989269753361265125049694148578387329380612416947570578330099506998594987587756143860;
      _weight[9] = .8272952079399523470880740580838362330379464284872694528732063439370860031512300475525677462603061600e-1;
      _points[10] = .4824074446124388805353185218595824144467997109997394967544461672573758804548396608944152015562769533;
      _weight[10] = .7388402529699877110380641152857474527467150780108552765426171096663124369742378311614318387497559480e-1;
      _points[11] = .5537195807282935914003656124348565130222723633112639658363114623393879406517479598116624690714085946;
      _weight[11] = .6337990610025468075352666693255656013349124651231552374816444219192430946831498393294160099075286405e-1;
      _points[12] = .6239433897212819474963058147440920154900191318154389436290443886013853942344250394844038511295753291;
      _weight[12] = .5204609359179111023564632579998986927183950203292324804344689812665144316827079944423657995726457125e-1;
      _points[13] = .6916493150129622572194466789692474731114378954421946863393862533447191774980898542170077714513614260;
      _weight[13] = .4069109877964301658407017730425226266443064057334065145095136833448379998485753079799217710254716886e-1;
      _points[14] = .7554590544496869862658499728148629393663862148485365820478410117499734428055421838878873979671459348;
      _weight[14] = .3003974522638556952704078489267777259843073958271775542411847529124306280115798397937637514899778340e-1;
      _points[15] = .8140736165126974167889441095793418834761159091940745540915800538406752152475818572669301867705564506;
      _weight[15] = .2067841951594062532766545282048113895201409713863530682554154662668730367463374091492579251859917702e-1;
      _points[16] = .8662997589709565970763633043579206958620698193352277530749704236585637715961211057848505289659335869;
      _weight[16] = .1301319484729121067081350259836615564509889406165673029724426861833434880054116162097542563680725932e-1;
      _points[17] = .9110742658026157747796664327661934805098614945934874284421480344586480510586007787502760981037643856;
      _weight[17] = .7244105739489879730472547559442240697420720259915659077551736989091842220673176735262750426044136195e-2;
      _points[18] = .9474855444063973466860989716611313948903221194844454580667087781352119091878179384063695290882735176;
      _weight[18] = .3357512043133831072552673187562964503288479122657296229103793587294405115801504672333876179128347687e-2;
      _points[19] = .9747919756603656530791520912867540805522533015938938496488658734735577229804897977756749790184311510;
      _weight[19] = .1136997053399528357223582471399066105620591183233813017156494435682540599458716110693253306399932688e-2;
      _points[20] = .9924354907256214774937902793889982068789303884718009223638209927180066784787668474833283570905443829;
      _weight[20] = .1917237370594436579591996857304873547811035877252156524166424200636976236585948701383194349572474094e-3;
      break;


    case 42:
    case 43:
      delivered_order = 43;
      _points.resize(22);
      _weight.resize(22);
      _points[0] = .27314460088842296840089704503200014449200918101959305251802699914424705443586062328636487911356529e-2;
      _weight[0] = .1396851222739562730764330994005642798820870305226851204432919119548361416787182679620320754331798072e-1;
      _points[1] = .143359334836997061853080392850525718221273498417199514175668855459687754744077471847082592790774472e-1;
      _weight[1] = .3188810690955699372913185825261865705830584729624107779763818757645318375465544204740945923860488160e-1;
      _points[2] = .349863283512164493872188140710847078954050751341333200887381903194327270144037730981749494305523622e-1;
      _weight[2] = .4836847334378099951774078646756125991897967480632796321673948363274069201822403812450448406477831640e-1;
      _points[3] = .643026411321588825312750713956860648352739646745500827639460760672342712373544920029598919242579590e-1;
      _weight[3] = .6265519399875045578481791711936416627645561286020844389093385854076882602968762518293831335949095095e-1;
      _points[4] = .1017393434521639240125822659379428899539853633989816895418881106050308024257778517338354719506679831;
      _weight[4] = .7415410818640572896643467181854132802159376843867967796198737741804690263271070220679765515149107995e-1;
      _points[5] = .1465992001576654169265658426695235179279442290125604632515204687033228653332772641236747155787630766;
      _weight[5] = .8244480981282290515415823938756621370766471158374133208691690370659610505839603497230175086082115485e-1;
      _points[6] = .1980466041181826148466050402800147983667787135049020201401014006434161174885707857036810715432878876;
      _weight[6] = .8730240757260692599058627618965695877333537373682736038372387813522711622922491115184985620360791810e-1;
      _points[7] = .2551232069716869695768287350762534865017322609522133051615515472916441580767357518665803492792871822;
      _weight[7] = .8870674180083961237725395424888980010638767505799639849446421318828518370656462205089634953215847250e-1;
      _points[8] = .3167657887104472718342111760237885655859172188291768643815974689978323961699472361224441678013379426;
      _weight[8] = .8683750029083565581666905153333353034148761155627255043342898156741359986662248660638659974313738275e-1;
      _points[9] = .3818260692567502030509512762811186856943928877507787697256756013761460030692112995057041549779558298;
      _weight[9] = .8205559156388180327653087723778992847221561856887365139092586395278825727586388000965819474762431935e-1;
      _points[10] = .4490921009868173325138719504239347417475929920954648897808863573672971601962552955877951121911249076;
      _weight[10] = .7487223293386003847932596237778164765909771195087018622881954379418589205789644518583498915989155595e-1;
      _points[11] = .5173108459509911200513628668417419502531014399509647860341897330139076887981516467821142472826215626;
      _weight[11] = .6590811757077106807977571305735299366400317729192485529773531632140783267376844390929590547508218280e-1;
      _points[12] = .5852115179512991297552453346740838766873451701532765634475564569305673634168154853640549882370619951;
      _weight[12] = .5584574164688526249815932491291670258280004563995038841006871240856953599982233845476300338102841800e-1;
      _points[13] = .6515292548958144740358068223118511349859101369629558312595962074831187114090178549434212259989474758;
      _weight[13] = .4537845719632199076042572155228547303759643411880068270661964657070462859342870351180007030550233922e-1;
      _points[14] = .7150286804747624026121578393379999446389645236341253188769096134374679986116977432704020454213976672;
      _weight[14] = .3516003512030458548547005431414484593424269996086323158449180253002667739460805295412856717443265201e-1;
      _points[15] = .7745269160648226353202027384109920682527303908818411141565719030087724957529183987986099954836781138;
      _weight[15] = .2575846056273067939269641009336137254927228722599539141507122547706125044545784147220467239774912148e-1;
      _points[16] = .8289156136217265123540054985427691593398783968413130229560818673737749864709777074205767676513684912;
      _weight[16] = .1761734488022181417634750650161074169827888941368967387824436676905266460390992162845846544121165208e-1;
      _points[17] = .8771815974654200209935832382780264667216854819433063264149961682215358967027150316006842063229547836;
      _weight[17] = .1102775020425528202183274932690576622802929805904276532381154234944322175706675534281853899145454089e-1;
      _points[18] = .9184257249898492632792699442543246960817983206223100233229591659202425806838473116664400173192551525;
      _weight[18] = .6112428226300807468928605022472388819840529336780360990858784903836597627090362080718578613558494340e-2;
      _points[19] = .9518795932297199145233254132304692539088438686423388255790172833977314296065333707540227994344747218;
      _weight[19] = .2823533706278848565916530037911878629982887095586678771104423447725510221470260596622430459254364747e-2;
      _points[20] = .9769196632371288671781665711370362045685576491004758259075059336129642443913384619385342626927520534;
      _weight[20] = .9538558113180135180967949786628451294240092743928687244237285896188821328575349981455725123257991770e-3;
      _points[21] = .9930774850443482149030021066415407683406700298179706308215188462467044126812424398542732069635953078;
      _weight[21] = .1605964338749016320576856292150734027974336746659489676629679245638257528017707162633356434764222922e-3;
      break;


    case 44:
    case 45:
      delivered_order = 45;
      _points.resize(23);
      _weight.resize(23);
      _points[0] = .25086896389827444385828343050849707544655130412157952440372916981066025090909890471445388854540714e-2;
      _weight[0] = .1283316522531259794007885886339914920378556125005332675794854529923962637518005783894453417550545350e-1;
      _points[1] = .131709850003688878183339388300849730423769365649806610639845098755245710145875360535960812816828176e-1;
      _weight[1] = .2934304620092188218926113600741607806739210817537199870266151443933950832690670503976083270668956333e-1;
      _points[2] = .321617276826354932640336756565355053520576656520166453171268662440066582037109860381386933472833722e-1;
      _weight[2] = .4463725220786037308362066413240402086136904820699921434316677932141270933111474705923921172096512584e-1;
      _points[3] = .591602846138907652332220657736201949778825056877930704578476168575747178448446019469938418842188812e-1;
      _weight[3] = .5806819763322011970374782113924425761404511862778324479824299752720919807911566279375389922009886300e-1;
      _points[4] = .937052342256398436693902681070159943129484335537998125508059653663342988274737353712839788132662842e-1;
      _weight[4] = .6911669325016075584493212610566610721140551761560671679530417625630597260007129822813763392845246470e-1;
      _points[5] = .1352056309863808460458454746251433160911708193841602999666708950632019186174750867966318879969585417;
      _weight[5] = .7740045437700328926473449453186946979485005699189929147909285069627000897494280716076551291719096200e-1;
      _points[6] = .1829514347762067378172412190531632831474222483221057392796548221726690126122649180736697770083182074;
      _weight[6] = .8269256057546193715477130820235096515571599625521525349385431798507764427936998623641731528560107055e-1;
      _points[7] = .2361257194699659752033367975673903519867094069780877665480629132753104255091235776405840076486320994;
      _weight[7] = .8493096269792264883907527383068975587810407136558906032073556299546435535076532045263371654911045945e-1;
      _points[8] = .2938186667005872290547424363576361134204043156282958233734911798438694506857100888924860114111920568;
      _weight[8] = .8421756232457493979943437980297802638058106035661088138746759718641313900343550501435144093387029445e-1;
      _points[9] = .3550431384266732981536948763163021427209776085086219647490204456653280019775176349750919633016300716;
      _weight[9] = .8080690215257658597452762845490596703525596328546181279008243628500936409123153800589940372707629465e-1;
      _points[10] = .4187515692045311374092315829147009424821192511291422675616536437335683699790579610322750663361326696;
      _weight[10] = .7508529186083901414100526577407837545431900256520270901278341770173066637555355144434418735382997410e-1;
      _points[11] = .4838538912019967973430622916413376995836676173698294055646030869616179182331776207634155618518804048;
      _weight[11] = .6754184722435728497520002182184314434614082127218346806093570515182043965457234703866461587667979880e-1;
      _points[12] = .5492361859337143986849444709434036999595634258787999588444642290913115681454981608358155754321058537;
      _weight[12] = .5873345966894180966241572944644661616634652469095377698346786561882559594662330923115818784810304390e-1;
      _points[13] = .6137797438222284322478251318001054000017788712275714851022029844218004813706509166663266125837282715;
      _weight[13] = .4924611206265319667827944363701807174968086942310183494453035969494685072370452468029153544157499808e-1;
      _points[14] = .6763802055359521297445541267501844773125729751061369156714561779908754921014857822086096522112308806;
      _weight[14] = .3965518934812491259255210861264327470022577186405535879400719450947738484245734895817049703050119400e-1;
      _points[15] = .7359664575449968693948098166623482992411491974356738064983977465191447748707008794380155771341181074;
      _weight[15] = .3048748451352573060772721176350031611003474117711489554566270549461388710349331159902545415318204602e-1;
      _points[16] = .7915189583921991649995448115618995639698665304943579027528512918922398729387578844199069430995902060;
      _weight[16] = .2218746826207120887276263590638552621253197931251564408631796147019043169238537869081644237856090616e-1;
      _points[17] = .8420871815760147938272551090762841119895322905806887532216879812775912541917310769974367310218997846;
      _weight[17] = .1509008390394755517476464908179904728950585618281600061596910970327096104697896113737910320729447623e-1;
      _points[18] = .8868058750607934334740477882285871206071403541849894413037182530711360933825476533262438961100101040;
      _weight[18] = .9401868666227652995952585963231501422382957680697780965957245463094744102323209704629371165729528365e-2;
      _points[19] = .9249098542075925823337164109969201318994696513183952026689198527018630611553347105313285453711818318;
      _weight[19] = .5191620446910720770096011274932118364042720186345085236614939007955783549782982195562741045147826195e-2;
      _points[20] = .9557470550763801263062809349956559935085465719725784751899715881063639154409472040614620018948967936;
      _weight[20] = .2391164993413535831600994583419511700235568916766570267257880249998309203933376284348100425652683408e-2;
      _points[21] = .9787895175170725588787939186958919174534641597824532080283251852183454120155341188680323899069676110;
      _weight[21] = .8060783183419481302475769328811150712121287430918492847770345087224901752876520422652122466796400245e-3;
      _points[22] = .9936411423413659674234674659492144344825859906238375139346624942288118730536279398452978995101742693;
      _weight[22] = .1355340856302997732120741308975842108365558545642253331618034336109291707704191634410506625033332500e-3;
      break;


    case 46:
    case 47:
      delivered_order = 47;
      _points.resize(24);
      _weight.resize(24);
      _points[0] = .23121076177984915697052766710910895549393840036360101897093883189050514570298921845144940873498066e-2;
      _weight[0] = .1183066055113336862806942240007326328245558099447927275162523552741007390766368641044190307360615082e-1;
      _points[1] = .121423037710748970539161894107291226052275516244601947149938013721604220294834850476248863103407454e-1;
      _weight[1] = .2708890824143026572037962662152288020969476966472863417825282202056481771333289850443734731951459998e-1;
      _points[2] = .296648142140688469429651809241502051764854189590573794305428483666255585319802945970872750545961716e-1;
      _weight[2] = .4131359852028912070813348612469458121266906681977047751086422223751155286109440455542634286396419224e-1;
      _points[3] = .546072632835427812988563452865810999567590785733821281956191007231946426189366729765185738119560742e-1;
      _weight[3] = .5394596868921663524498068262844092364170052310862208007218011372940229373250922674094844211297475960e-1;
      _points[4] = .865767827550265315302788514920136620491530967532293755865061359260821023700663119038016240838011818e-1;
      _weight[4] = .6453135870842410635528940758432413674737559106054908567625814834380452190132723118159379279108454855e-1;
      _points[5] = .1250693120998313816827247034321147372716372812643793892831974422340660561775264779754430133711736113;
      _weight[5] = .7272392358209171859073020012272423331634752635725114961740036064699127019826765310647654099763657770e-1;
      _points[6] = .1694778408374137992122551210880916091724440900194513583551692099521297695569503211773284187174575248;
      _weight[6] = .7830217864471200784132989838038854530001015874197726701210669511616739254100083028981782541128242990e-1;
      _points[7] = .2191020363269966008052502214870027886228146700884203403626969975224363594600835115547810175625647494;
      _weight[7] = .8117812499761111793897603388086616924056250529426903044903261905158249863418553775020821285565607940e-1;
      _points[8] = .2731593030949704981198326346716482638665286879359816866038841088473610512662532110402010110389662081;
      _weight[8] = .8139860229396257985108057536193088271685230951096375019039633824613643145339319826460674182484131945e-1;
      _points[9] = .3307971297342992989465449797634122839351353239458986043016484038687065359502901031392280699179553764;
      _weight[9] = .7913874651520938929265736761457077631574365663020054012563532141424833258155611098929166716363561785e-1;
      _points[10] = .3911065354271857628058029229759407587117961441488460253702401794353555304627992294123975242415039216;
      _weight[10] = .7468800138191237704937459456995169435294967932534591746282115187766476994517745985562126268100280395e-1;
      _points[11] = .4531364059378609233872602564908296475944846220926500743387614702917419726601357431551427286510223686;
      _weight[11] = .6842960472039024618212495432963431108894080844633652827051493472714512862008051584998227091418043710e-1;
      _points[12] = .5159084936202979568506211844229575689363706436725780992080644753405181129907634992160172026059024785;
      _weight[12] = .6081487403303229439557250461246857543106709458728555540542244478846987123597889141506562545922541260e-1;
      _points[13] = .5784328451129381173040996319869945856313733674576909278189693731645225384582334961614709864014439182;
      _weight[13] = .5233393229745876141906451197180871793300976215540282985419030015323189126408906128503865664752988075e-1;
      _points[14] = .6397234134973043576554117727135736996646600113714081000045059910790721633790546552645982027501322789;
      _weight[14] = .4348472766572340728540928114789743818624545599387243885741710511492122452733704265550252406972614456e-1;
      _points[15] = .6988136087122555462016606377145350834461598850036410982928344624206350632284010299704447755398053858;
      _weight[15] = .3474229649484084003930890647846262727505108642173711331754141432035930539668108322663152396873325551e-1;
      _points[16] = .7547715409190971048511486978937648589061186652744929259781655167672301711625351688732468834021431376;
      _weight[16] = .2653019230140020249207268704743023175850973695203784071226564499171372408835572203998397885360695694e-1;
      _points[17] = .8067147162308662079759883230462271215511214289418775696507626148867661530416063674514532295042284498;
      _weight[17] = .1919585570453531090274182547445749150555233627807191180519025749427489117067745137550248265840894570e-1;
      _points[18] = .8538239525472523950102126950475975286633013398103204851603925633645574373545504247981078805449910134;
      _weight[18] = .1299144166781244007855380199287793161149080700512316783535285734348566786945346584013675225762067370e-1;
      _points[19] = .8953562946217610669903735651020598427994962565161247360082353603807290907387866393285046179471647462;
      _weight[19] = .8061266812448580930088891626091521017798326749095430281313277537958062872952727474091698452797851500e-2;
      _points[20] = .9306567200768073264940897342948113540892147989736239490329954181172965522690414938590459685654113660;
      _weight[20] = .4436613641500169169439699970626442930590561207013584324589174385384877629658784768911207363910107724e-2;
      _points[21] = .9591684333956145359195940133146757910921505457443845505930704566821066595074815881415270673833559457;
      _weight[21] = .2038157139126920074596463477698362039463527132653415267345710996681106052705444231857296200602801544e-2;
      _points[22] = .9804414867720773047861990092929623254654564518007672132576640373798768725183629974386659808406819024;
      _weight[22] = .6857923806901939716180130215329527076359172887024981713091355795707735117444618081210374293793006285e-3;
      _points[23] = .9941387002099847972174529494354186447065590111257385945879012558028220919933208547206036697068679643;
      _weight[23] = .1151730150479458384071635595253101782832122745104808509747143553195202907771103803048666290791529852e-3;
      break;


    case 48:
    case 49:
      delivered_order = 49;
      _points.resize(25);
      _weight.resize(25);
      _points[0] = .21377548407793250970039960684843411705311339444511237846084287164651283128895545650774241146434717e-2;
      _weight[0] = .1094107579169813189091237608942257612915731472352215860492901940875784817684822085978414229013138839e-1;
      _points[1] = .112294606056524895376596449529584216087860738616504742252478138001634604024868942504955508350561979e-1;
      _weight[1] = .2508327722702107727564330652194328699205195700415177187291626937632732713366479790665309256342352607e-1;
      _points[2] = .274469434643197743434582952393301677966795058332544771415907730879432148015830814776531097817306074e-1;
      _weight[2] = .3834144667483376494444168127629636943855168654307775524429254616965643468194663566288194639730568382e-1;
      _points[3] = .505573803692126256348059340964892863963929190056692616509419415212892573042434210511409457696638549e-1;
      _weight[3] = .5023107977579624293082489939776848612795440206268521504827201101988163471721421863248506065296455375e-1;
      _points[4] = .802242209123347788711806562294006865192884691392240487497176541792428819362495039574470334376345982e-1;
      _weight[4] = .6035303547197594011536946214697428562244105735504644592761780204490024094524008923006620806500516360e-1;
      _points[5] = .1160149645874870172347350473465606669489106230158662308693922678144886136045272672526553037082935272;
      _weight[5] = .6839537544316108834152713171531975770585381497544037444937248176128482598116938100169829409365540970e-1;
      _points[6] = .1574077383886659652193159384891105328541375646502171946705997212341715684439550613338558276683800542;
      _weight[6] = .7414640177550565019867457680187590050097479701658588964064176822972214718382922048913128461068316080e-1;
      _points[7] = .2037989575831378225336879722401727700751661453631751449300676446592974173952675347684620523747703692;
      _weight[7] = .7750307846489530106069001626917005366648185167101180936037628557609221967072401671463450510599048465e-1;
      _points[8] = .2545121408770102731752042678534638511633337808460910662787207479083865625018202584499175428930839522;
      _weight[8] = .7847361442854745129999858918728471494155807095267460162304348042572581006206020856357340736118874090e-1;
      _points[9] = .3088077795622951038979119439836161009663783922166299606375840033527997031278586274863047483670254861;
      _weight[9] = .7717401233298538239701017926660146653703606970898668982214027556915412179838143641951278835213117650e-1;
      _points[10] = .3658941229846370226364064314991338752818897598016621885592227542838233793054347295626319302125106144;
      _weight[10] = .7381880949267258745570611132264679808177411201634040263123836073740074140392720781241131139297758510e-1;
      _points[11] = .4249387248171481696883001024393147385589320252409908017977547745824610905505913984042249884129209462;
      _weight[11] = .6870658133314383697685351362085691413583117735597939494713400804125932270303523200365795429917671430e-1;
      _points[12] = .4850805823554158825739775389860063675732738097640718535822201240883097297180151158721545179097262209;
      _weight[12] = .6220107820158806088435333669253889377963299096493770394973335210519773180746305069290850138698745455e-1;
      _points[13] = .5454426920332588243126070891910049145712573150611219268116870762412938483414356567846858208870956794;
      _weight[13] = .5470911337993017133325658954591537464613243821693582754945733906555848787274909343811964787857264475e-1;
      _points[14] = .6051448381551349081424173890238120465852778156899718864521872811406263759015006314129890759192133066;
      _weight[14] = .4665650137559238100136333265315206043659187299633210330041980122434126791481360689974380076448028813e-1;
      _points[15] = .6633164283801916080438663597093166623213491788613272167696983082588163829549425343365271477378754116;
      _weight[15] = .3846345091061473349290245539794099303708019282297091901740137152519600363961583008523285646670092169e-1;
      _points[16] = .7191091887702756756924733312759952703610235950003264675599094080939261671384587307200102973531914276;
      _weight[16] = .3052084060846490888777912318780060035451395536472057323180285253178882915878800370061906778387305039e-1;
      _points[17] = .7717095332090876532772702662299137017534216024796653237460220724084526447410338907367806228629368562;
      _weight[17] = .2316874597448142681430272573677028827491415078621799535354766932626957753146747980664577809278033180e-1;
      _points[18] = .8203504266385679362480414025046644799692216902498877451708436721193771528836986810945627036059214166;
      _weight[18] = .1667844746417703482858827412105202654768663139416267562768610651187442182435611008344612761759961254e-1;
      _points[19] = .8643225686575712512890930964464128884912645871039346858755335774412004904375538141581885649622597640;
      _weight[19] = .1123893942176472911521814402227084965277093149641017025250777628933241674291632070615825071755884010e-1;
      _points[20] = .9029847330954237846160108102144816242809611079263960417211087101890827959775348038191523331937766486;
      _weight[20] = .6948690769948242505642979580614419393522896096818128396177316145957533715002768998560257404965457315e-2;
      _points[21] = .9357731085313031293882544650031356312195798060607631882567272915711012342389978233465384997918019230;
      _weight[21] = .3813096281420520842348298710895950881889701039955631763288577889908654722745077399685025735478228049e-2;
      _points[22] = .9622094865907311897728633977477110034871315310658131814516887455258441299589536187221820682340020902;
      _weight[22] = .1747720324216249475087491502293789694397139287420886663505338741268344649234561021604621628603846322e-2;
      _points[23] = .9819080873346961325077074435259613225499801670479781693750962994666519993115924159471265473976193223;
      _weight[23] = .5870930138403858080781133946229403539078885793604901154230653455535909040354642990632606770200359905e-3;
      _points[24] = .9945800980399753817559432581349211965154392439071152418926132220402749667878063230382549504120035082;
      _weight[24] = .9849406172470012342729183797120306729289956825438560707512493759046505877196757172280866074569837955e-4;
      break;


    case 50:
    case 51:
      delivered_order = 51;
      _points.resize(26);
      _weight.resize(26);
      _points[0] = .19824023125009919747645087015092031881870923563100705499480362605097972464274428566413643180861874e-2;
      _weight[0] = .1014808420232600024203421407891864326967813611225317519604953710526452069416772253984767498904498430e-1;
      _points[1] = .104157120350925266682191770293101467493547948510681652442318719181039024127684327072170446982718232e-1;
      _weight[1] = .2329114401400434107623960101019748682844868035669047120616072012257778273808340621067386617903738086e-1;
      _points[2] = .254681477504560134429207505854270137501984164362808123733523963858049364643884008986978728652792768e-1;
      _weight[2] = .3567383035949472508322253846200779250258506124560617922629226954076677145218050153666541892375190978e-1;
      _points[3] = .469395479727239002971935211591535637354607622088211954298917406048933258703348237390626319812966856e-1;
      _weight[3] = .4687405429551426087558989633323650022463453467699547900364888632785840215419132950170713312725027756e-1;
      _points[4] = .745399674749774617774821230693383225642736754097029384714471239364010178892953245719096130536987463e-1;
      _weight[4] = .5654047670425408731673641746840444106706145938580495870768149053927784423957084294479367225322386200e-1;
      _points[5] = .1078962587148670518369933864179128680363862543318018393308158240698289232868109968676399249029241419;
      _weight[5] = .6439218521754601961609217515415748254965335209980546776078885523102830281793937574743196400011578520e-1;
      _points[6] = .1465573689781110622454405645211420385843833471460570019307330150135958433471094540487915029769824543;
      _weight[6] = .7022960671117586974426525058832575750953055446936506488322864597988955028307342935889612007552575090e-1;
      _points[7] = .1900004870599828336341439787909794085126181077453390929451879495109536533280805490705145871629265262;
      _weight[7] = .7394209946166916222101129200752939221868094362783113220849632853398411916937608256518092583361741945e-1;
      _points[8] = .2376381259328170562198557150947490838125062796023926838503683108907578655346968932790673406258905671;
      _weight[8] = .7551112719749781844218082919566389510580336585132778769206085830750979488397455548961364119995051485e-1;
      _points[9] = .2888260716927312263060031147583258288008503288275055379968170057607358670390531602234574905707601092;
      _weight[9] = .7500879353237672763699801406961978229108936240432004642829627625630132640321505130936349085986451175e-1;
      _points[10] = .3428720970842849252151378642974238623794694294290994447908012269211766838901167147393952220069469324;
      _weight[10] = .7259183277120186241203571905154515430079599767823860996443231425840059721696847173875847649730612775e-1;
      _points[11] = .3990453234002412501528182579168397671593845939181776667219899610514800606114315767563476820928747503;
      _weight[11] = .6849140575169568012668800722262161522613334377457403128300937582927520679256050458344419628226693550e-1;
      _points[12] = .4565861046963797540479864485503725667356963030172069689574101221860311846558745203443032208709777164;
      _weight[12] = .6299927337564799294914832905905277124462503427963309452997012853782168724233937070149924372893476690e-1;
      _points[13] = .5147163008581420013517072616386541097050830876907721189103577076394249053259770218196995276011959180;
      _weight[13] = .5645111126600675970723965470326951328705426502217116239087105685107128012521637991950905294860651560e-1;
      _points[14] = .5726498006750368846698153034557769759301843942142236134513678722424631571284058108657451973547353036;
      _weight[14] = .4920787783957516399463353490332616402964507354307016190860555769829433495204703242645409835846820768e-1;
      _points[15] = .6296031526463668324400058351864332464058115851881460382768378372804372721501046970140265988107221240;
      _weight[15] = .4163624742448221054690511799845617999254992276850739950519913819788930854925306643839091326449472762e-1;
      _points[16] = .6848061597563768691573930360166283266837702181638087861103877824608012560472566171090269983928681481;
      _weight[16] = .3408916470242993251882218894046125122731292371714041110875776292446406522925454370012819778710549801e-1;
      _points[17] = .7375122949172582536693195662187433097563287951254783157564549381318449761373581277895857265168695457;
      _weight[17] = .2688756442258594394198564943536074963802617244572964250768720667333181166040705692347132345644914920e-1;
      _points[18] = .7870087961593147963280802382092863076360161431424960256226740790350169217338341468378251792332276716;
      _weight[18] = .2030423177222357942405312178653612755525415648826535986135120681968192455152752689740341632709244092e-1;
      _points[19] = .8326263048793096592840319901487043552909483798146004051450267827213551566378150192788626666368145451;
      _weight[19] = .1455065777740560048945432725678785020079291621240239065081833184010255621019635602390937831583437630e-1;
      _points[20] = .8737479163770055563444293398713444395647730795686451952308337238766361425385557764556171897935916430;
      _weight[20] = .9767577246988349844368959326074245339906130164224783443389859320911296477027153023249456138231528250e-2;
      _points[21] = .9098175190772664572577288936685780032938885885639025695186218563884849263622085581336329392731512698;
      _weight[21] = .6019673135257074110480920880712994889898064197316878936261920311358339469987576574531148022946998145e-2;
      _points[22] = .9403473057218671707575661924897942312565963618065724508702617539552909102894060455499272532250318548;
      _weight[22] = .3294701834427150802711378133094103566373633324556116068118172306506898075038472954763112718183132090e-2;
      _points[23] = .9649243392355685769676789331181850486069916808216714189009346206348469238729501303425886192745979016;
      _weight[23] = .1507051270060215245738339727124017471225049056873612094515045979327154650350622172692114155471249897e-2;
      _points[24] = .9832159998661838487495423597867820380401895721015838753714698965929400840517768491779043505066501448;
      _weight[24] = .5055010659316268156697904469713558505999011355121561471933639284915004498018912965832563274464540485e-3;
      _points[25] = .9949734758572125109018548468457757451414034454994678437134746777377314759592836642394933873290997110;
      _weight[25] = .8472664822184481569473276054473261264196596178442728711569057861362351225167742103870822977949366515e-4;
      break;


    case 52:
    case 53:
      delivered_order = 53;
      _points.resize(27);
      _weight.resize(27);
      _points[0] = .18433866615938319677267356672958288739159820828326729613027074230462450661168042815418798697647316e-2;
      _weight[0] = .9438203890880110866596413809031958726344004381082942643778752283009119164009190109396605527980333740e-2;
      _points[1] = .96872310195408052738280815042821311163596594675494452671872254232231135230100024378444976093547779e-2;
      _weight[1] = .2168341697171634922387206163071664777223232067278973251502576675723184728219216643004024085976216632e-1;
      _points[2] = .236953482391501070838249724425648106801376223769131434045048470162374651829847753625290346598185510e-1;
      _weight[2] = .3327121392996553082051253960656141674676698664874091138577924743699340286248666374931987662370317074e-1;
      _points[3] = .436947358045580001376932446429401974901427110547333258428295124237890327258015779998153557350952520e-1;
      _weight[3] = .4383223890274716207783270394301581492732858579499438231354191010417070821260416813700804750678044807e-1;
      _points[4] = .694342787989322199730161870599743899193417310335786837684089594535236674250451492247500562398383284e-1;
      _weight[4] = .5305637157700611567035240177857449090592886836998970530450787053641364840432593332957280086420584840e-1;
      _points[5] = .1005903811326853915190140549903467621805094580706385252308216095694597532629310010567882974572091808;
      _weight[5] = .6069078747570479786231324288739386744739844478687997246810594496612261624138048834338851565688807470e-1;
      _points[6] = .1367712682105524376025683748648899727450342665933354412753916081149549203877273164378926296500355280;
      _weight[6] = .6654908535523464685397561098642480640115961409995553567285259367625967934405564418116194183134176190e-1;
      _points[7] = .1775219573659193028130614393988634183199427689032530418019253526001223410476168743574185750257463319;
      _weight[7] = .7051803275142590627456213690666551450110300183953213724808652522368240015081698904312405803067309600e-1;
      _points[8] = .2223299911830712808191360033542121533705911233623428600494451493718258335612207931646668848912204772;
      _weight[8] = .7256094481011321558801623950042687835571243590410499523542589298533471692607778934127785957673929250e-1;
      _points[9] = .2706318858403828388174545619009036764776417627277516962633080821607300256186263524972127095298013404;
      _weight[9] = .7271747407265305475209795588052125266906429056397565154975795821613017654667180666213671765959094605e-1;
      _points[10] = .3218202187671672377769064975778236252489272904134530562088575656239167866863330675121375687111015966;
      _weight[10] = .7109983236886887427029839467974307139978913310686388388211605126488499602691446213807129528452625830e-1;
      _points[11] = .3752512679997629534933730456435740542694401655843067372579497841123207581560234471930509217275150034;
      _weight[11] = .6788565307649292039687283320238157402058107784817118583358955398507924022035164383119891786003108590e-1;
      _points[12] = .4302531076729567979697915582545114448017590910700067673138678746580049425247712359442692580026425598;
      _weight[12] = .6330786957011047808854565517611624075329395117374875437813393453496000829664673633228191742678929620e-1;
      _points[13] = .4861340580315818421058114797416192564413484426519500339155726695708358463696974111905124066085644960;
      _weight[13] = .5764213229207180802657160281800379487874937184851651202260951686951263830209716610394437458473375140e-1;
      _points[14] = .5421913837761862949497505196736063188110717433003851565440307389535776130912578939384032088911835582;
      _weight[14] = .5119240661403538109314247413068615838127744479416697841527953461192940260522878214085058664786929485e-1;
      _points[15] = .5977201313878155000196942168596513335913650222028782052701089676472197217513431621531390052097054438;
      _weight[15] = .4427548090437451660491025534447562426298347549475397396883089254063283354707283443536997789447245244e-1;
      _points[16] = .6520219943065595128144520218202029835324140443758028088226666444218422243992797923412452670120753290;
      _weight[16] = .3720516474612843252115408793185275353855779065005451754273434428797531460701296701493334494924995782e-1;
      _points[17] = .7044140944718857265433052486560377972151930169197974524635302295609988027848098312397552342521119569;
      _weight[17] = .3027696861193742610784335894757796436342078243942527942081998530055037186894711078030414144039695370e-1;
      _points[18] = .7542375697640191565673740509855886563757234218511268984625872592197338373290508090761113687668744352;
      _weight[18] = .2375402799044424959072051962268325181356197297482915729116896189554605021009758096115809530389816060e-1;
      _points[19] = .8008658592874873234732464957552331150349938591747462274480585030882443351844636275401613601250524438;
      _weight[19] = .1785496844943601640277750879058008805396662109216816766106464135700233982039264716056288066955816288e-1;
      _points[20] = .8437125821466905369938778855425381743397595579708781792466494145717162173438121723567149172814734067;
      _weight[20] = .1274430680310793177156887614511325415420672227449586320518245942290155190667429505525537942126742114e-1;
      _points[21] = .8822389102341396454689826313057027389226267678942236210056160455752391145785184091546650419162954894;
      _weight[21] = .8525852555960638572219657461707102521891573539394917046403114188820346919404426896026959892511361630e-2;
      _points[22] = .9159603411903557702727824364325821830316077077386156250540469597358886472259235994667255020111472679;
      _weight[22] = .5239419741905222510689162974228147278566274534968597513495834319549298869840982032689125086275887030e-2;
      _points[23] = .9444527826987507331425260090411746078705975423460296253295198573755605731026031630850456677387687427;
      _weight[23] = .2860989938171968740611001933779543816374542989923606744174802748622344893560754537564018227295810619e-2;
      _points[24] = .9673578569938134428880421814747010652405853495240880018419563528070170982699121805787035699931610092;
      _weight[24] = .1306291162482041307513273595746611017270220411081977254624897447679861162403842854670567150585465275e-2;
      _points[25] = .9843872802327865221402703305050865376477358992329912305682706127051502754664076249624229033974675143;
      _weight[25] = .4375835695954694319402968526394878093805906978934431788809678901563370832892874754779046854248855268e-3;
      _points[26] = .9953255513271093328270351894495473119057794466212460828361309213612753533892573799919314231415207025;
      _weight[26] = .7328186742973457248973346335268348308990106749721830402804514884874852544364092321384933744865724135e-4;
      break;


    case 54:
    case 55:
      delivered_order = 55;
      _points.resize(28);
      _weight.resize(28);
      _points[0] = .17184952934022466630280207712667916449961819346023566412434986689636099007902625541242275441217367e-2;
      _weight[0] = .8800223579860048483254710294217191577207739024953436339979561240637942739941017303195392091558371120e-2;
      _points[1] = .90325184953100172901826680083097663354607101758299558173017968869500129573134212735539999233447304e-2;
      _weight[1] = .2023576838137988786034698670252521582177125525959502980263720470161220865339795486195886339611684494e-1;
      _points[2] = .221009813577868113726852102188806294415116094659876033179616599969117414037707455473861775983747134e-1;
      _weight[2] = .3110015822865166067702923886015083025462579664580579398440848573178798449726498247220803134991446174e-1;
      _points[3] = .407736110197750309129947437116760770693489816252020484571557572401897832374419035885309251340398314e-1;
      _weight[3] = .4106881180888533341596419244898047338318591795943706620487407038350580428826353390241364012198871710e-1;
      _points[4] = .648318503631075240976192063907666100992612222184161087421690558762267022351845203316493552458384612e-1;
      _weight[4] = .4986722172799528536062300428357175719538303706187497370739264376729336818031041386693861369974652352e-1;
      _points[5] = .939937256853133658414060403798865751400392882474130913839852491309167398208193449175131469558199520e-1;
      _weight[5] = .5726781728496770116342685381854171257294862281728752208595617722281137028532049290924545670569594165e-1;
      _points[6] = .1279173699497222880332522902374298487321410081872785108652567404644903241925006868210433634637058416;
      _weight[6] = .6309759998920903832871619063187736427798328292865043490361484313506251495597716084181167071470161035e-1;
      _points[7] = .1662050715215077754955928759549225525500957899853919033389963748850263839788521736378389887243457290;
      _weight[7] = .6724408184431729629610348227194436576417121590563488018244433962007116416697608344776238973716037990e-1;
      _points[8] = .2084079478245644898876042894881013130324364643445421872994684928640539779603323923616045542186025370;
      _weight[8] = .6965864122232914783245525515766061197702074092320849650604718467156459693423628053637574066344839550e-1;
      _points[9] = .2540312117051822502779332060989567717949333472202278170522577722830524357606964327183922476911471278;
      _weight[9] = .7035708558254015342678361194760470294443631209691896475761189284078684747935547051565534472259177100e-1;
      _points[10] = .3025399737754953580740983330081879191259593540535832168511508630229688726585007098583484121226723719;
      _weight[10] = .6941740067534460029436271363915171072939625027199343826210971389695270282935707154096891907595896330e-1;
      _points[11] = .3533655141226461443509711091964390610724843762952359906320931037906887192044490676408869047345885827;
      _weight[11] = .6697480576198529947544249860329464644901197190434949442692233737598107738389930962131631795027036900e-1;
      _points[12] = .4059119503245874996847819872096119528855570149194244408537244840158077666547928989884755351269759842;
      _weight[12] = .6321436026746541740578527862238867356580627473567945958614016390860714467272442769773655632274854830e-1;
      _points[13] = .4595632237739050247007580803181932916401376476628329857646448103515031096132724631061051072771519328;
      _weight[13] = .5836147977632291693862247694575220416360419006726144133894084241127940580809791871084881643492680210e-1;
      _points[14] = .5136903224747328748359169275644776550261521565143655052175059751887984135439312756239786212853367327;
      _weight[14] = .5267081444046336301346320191574594298873507545356939242387535251298683116224294172328249432628441325e-1;
      _points[15] = .5676586556635289639505490890258515210526632876626349273181250891130814313326060797131782980779631320;
      _weight[15] = .4641401659297863618279998467239187373005512892102633459543014117149358423998773507108652281038679944e-1;
      _points[16] = .6208354938051186180751604988886875212206555915139963242977997641728491315993006032194731774639848880;
      _weight[16] = .3986697332843073130967213398614351494726775297770389920047505285351725313484619757114780423331171052e-1;
      _points[17] = .6725973867373374963190421178579525574571588976574083160637357387177511124421386108602402867292366287;
      _weight[17] = .3329710179283746617377097231688107447881161015071885848544979051240828473437080881621446821160526426e-1;
      _points[18] = .7223374729826939086395173882436445520337460324133837205062443405405843577730351703929806948350872265;
      _weight[18] = .2695129894362714574317820278902739133656214753061143720194269756412480787235284583042023249985489037e-1;
      _points[19] = .7694725945042181706805050432690356903413932244153720708644567415131536687406382160956998961745972852;
      _weight[19] = .2104510391067328185606724574426733926381029950552618742473734044634105412953922386528522419823967898e-1;
      _points[20] = .8134501334282394697267215578375188617234481770369277012202582476084865180325716182203592738059608613;
      _weight[20] = .1575357142381088974813226281442771906887412741280410221144539737971025231278995461878959784777956885e-1;
      _points[21] = .8537544904322088788247775513811542988294457872776482108393252112089107868125245581262654586120796862;
      _weight[21] = .1120427189543885884005076223431923448359865792254287286501113213756952844083798362642394278826530221e-1;
      _points[22] = .8899131284723934956831712532221734523372783412412214239234061344184586027297876948955008948655267540;
      _weight[22] = .7472731568327629262425404229139219420008809551561161327362666088823157856139752051538421851431710815e-2;
      _points[23] = .9215021099473594085155151704718151363517054432469130506984103322769692925488804599027244231343456589;
      _weight[23] = .4580509469313366317241966253684956837737283433524900914903528095852603465920170011164550038495731330e-2;
      _points[24] = .9481510589669756248379883268157639950428963847697689099425419930439997189239613345109477892586771713;
      _weight[24] = .2495982237871979415829687616319526354929321484971594260093162240535500992872031481883964558506331729e-2;
      _points[25] = .9695474769380218769795841255378286564895236407683444524251818691481329207472659134792764782658287506;
      _weight[25] = .1137779145650798692488932755719335389798893714566876011441140007340853951131875109770356496233154940e-2;
      _points[26] = .9854402875829232562843797204417416195238244745167805643345209779564325262374245842623134551400908974;
      _weight[26] = .3806839593599654687052937172487546861406951983143054441628893654176073429097708717517823083271828856e-3;
      _points[27] = .9956419077642228317186491333620060237601315295415473070854638905269220407116028222638890083449407599;
      _weight[27] = .6370515996210101725745472702265633711758913990764554459024871592454748893659112280488484445055915445e-4;
      break;


    case 56:
    case 57:
      delivered_order = 57;
      _points.resize(29);
      _weight.resize(29);
      _points[0] = .16058778525400944766774602673933333757152836168603318045063743822059058587959310719939424595137882e-2;
      _weight[0] = .8224759073026150013337165044732122149231177684820350074016830574690805752082382554858977265593501695e-2;
      _points[1] = .84419488040311726917503051542707513592546426776604266478056341042086966415783126388255787418638402e-2;
      _weight[1] = .1892773329343349779572660522959708923603067512949384638213060568878587305185604045792269427641210014e-1;
      _points[2] = .206619336361591547601435345567561488815223432237067186292537886141820935501139082553158196993727352e-1;
      _weight[2] = .2913224977147369630435371509591788516497127738021211468364733144940634553044053377381143399400345846e-1;
      _points[3] = .381346969971121293156671304127122061908427724432955368922775580973517627701451337438444969461220516e-1;
      _weight[3] = .3855192568110300992731787948569749686052539437629187659190769761585088614005755907628346504680199758e-1;
      _points[4] = .606691420765822698190466170738797306133965588838233851279245200282045773648867331667482082942766667e-1;
      _weight[4] = .4694309426636408371953486849927191064071717332656199572683966811401250472932076965971239929914353803e-1;
      _points[5] = .880184581398872246511325645775070971408746674491546560679176980636058501053978719493810362381101302e-1;
      _weight[5] = .5410079186859844844367088474395607795687457881564928149255949744070610415755416273615970676958635330e-1;
      _points[6] = .1198830276848970432901164194721133615437473706091056747138979253876140849072260495061209040067645784;
      _weight[6] = .5986514983088954149802257556131410370145028546473926100037200780395276628373010490616317656245104990e-1;
      _points[7] = .1559137470843829473370606131417264220555557747384501978986829188400691312404561996585751299552526045;
      _weight[7] = .6412659178073493294015772905883242677694949119956667273898712010326479351329538109259780287852799430e-1;
      _points[8] = .1957158615701235346271845355727618654403065491060100053893129052945034633900434287495630167925547572;
      _weight[8] = .6682903797752355680708798131643143756002374157820628443355072911779172499539671165753846813121174085e-1;
      _points[9] = .2388532936333663745936940565623196065759316483784380767855858606661415400153543649197279531138628579;
      _weight[9] = .6797092298173053445579386649110409707833752628689484884710968363254660466586108170267586063524069825e-1;
      _points[10] = .2848534221035185149516172379240780825714158061355885118736472933422323566101288260175500745175553864;
      _weight[10] = .6760398471965420388414470001461319453931749237342308586790232501846019357132809543458076332164856535e-1;
      _points[11] = .3332122608640143309721523536351177737981679593513508685203846408997852637001956485169227428186550922;
      _weight[11] = .6582988868215478831775667022005763028145817101026190730235325072255936333675761645812854225390013460e-1;
      _points[12] = .3833999809061070668784747580919607726984317643808177613142919854072677369249366817102831666846690370;
      _weight[12] = .6279484606213871827922785530254060818304508070323358845405923153953552222330567398669030144966779060e-1;
      _points[13] = .4348667153860257491398700432703089870432644535249158432053836873358514943003487504468549993874690006;
      _weight[13] = .5868247100441087283841989450493688012026853494073014267958587339102668812083850425895915857506469625e-1;
      _points[14] = .4870485841530376732703106931946815813887093165769280917756070969164567729544177022621628404883829681;
      _weight[14] = .5370519726261224517441839350484898995722099633288349579493820971087947368967875312163865815120067475e-1;
      _points[15] = .5393738717727236992403103247034391839852566119036684134142180869297304990124736025268732863129619822;
      _weight[15] = .4809463546398829869371533562782688895220513580178416037071732542065284736437622845049166880340602578e-1;
      _points[16] = .5912692913707834829478765566234395995724095853348927353348565847908533092030035780849500293024165982;
      _weight[16] = .4209129631860883510580700101232906094913172520881469088463222892379855573154919991407642591976469950e-1;
      _points[17] = .6421662656731861238287974627913649707773183543080836828973314488493767488926898483696649824941938186;
      _weight[17] = .3593413059728592678232574595449670370924216522382692396538501302643477845479560527760392817593801562e-1;
      _points[18] = .6915071564230854286671345510916194350973455194579840038960101517935299316600829866562060441590159540;
      _weight[18] = .2985034246189268703045850444863408825831084746850206015839821802101854257623979915267724844376644792e-1;
      _points[19] = .7387513739119412937894744959680884811212751986011720468957062635753622921833823658529018354675298890;
      _weight[19] = .2404591853972230935791201088077912861061979588079558439714543772093319758864057087945139004205025584e-1;
      _points[20] = .7833812996605872372611127878355374096893314804833155528966749287801062427902846865455568229607413806;
      _weight[20] = .1869728163635560116792048307870749321429571415331115426277003745924714046260312547581256203485234378e-1;
      _points[21] = .8249079573005494156007944812292208906787416791393452824336661869940549234669086353363655173900740340;
      _weight[21] = .1394442666818688026059107376377405494209665104256295061957681177283639436450565135033828690679829565e-1;
      _points[22] = .8628763693862447339655591786902250565115750641387146145738370691343617140203829052848049853419034594;
      _weight[22] = .9885829532976952297502565856123033463512360899385135623303387224673325024682566847647254849170246860e-2;
      _points[23] = .8968705411002962316766114182292236819780119355812354874912319856093777036147736123027412055456321439;
      _weight[23] = .6575340169921764095135252527351854065836319905993192237496403188926387421135809555119478357387455815e-2;
      _points[24] = .9265180152719407691275609266113728355764496137049103876779217996365555765482396657211416405902146952;
      _weight[24] = .4021182485231803386534230962943425794757388828963288314425169192269667107680391493132507691698657376e-2;
      _points[25] = .9514939456164770559729801920265220261323300561844336714391207835992703432662113799732175447072784858;
      _weight[25] = .2187090029371519934764961921673762746149951990276364790288993358680005697151259428843902444398710951e-2;
      _points[26] = .9715246308559920866035488013575234119830975119551380701750238183981258606107602886980920135471663654;
      _weight[26] = .9955114404107457036282987011420741036488422258616618973463593330141214449773470206707239207859137695e-3;
      _points[27] = .9863904025392899117534861248015055941531051693629358191149649118720756782810516399238781644833375211;
      _weight[27] = .3327279866112555094128006597084461188640953367772790824749440720953263498256535625904972137108060054e-3;
      _points[28] = .9959272163607104691288374259807873291852593765446743146044815163863520054377631604148207633158200421;
      _weight[28] = .5564241358714027532095053065803486490740943017680132607960936195006065033342071382271658581783111975e-4;
      break;


    case 58:
    case 59:
      delivered_order = 59;
      _points.resize(30);
      _weight.resize(30);
      _points[0] = .15039773266387740965389410454398192048970508423236391105171932825289338826512487912405340180087496e-2;
      _weight[0] = .7703907526677142332781611057875534544819793506537816162172648136598926396897833211940408561162874845e-2;
      _points[1] = .79074153199620905538749105487067978896409293956241795230817601104555789575540426777252834764971362e-2;
      _weight[1] = .1774200002910266224241589398107510122653617419432137008802265042177278051968609008820032294264102992e-1;
      _points[2] = .193587084890258378485540305028822179759866856896989699866215848543232567345669305022413437043568121e-1;
      _weight[2] = .2734323769023239623194332571355552815906192296906783687662345184113901926590361535172321053250568946e-1;
      _points[3] = .357429253749061436144235550591078777563486234797585638416364433673687575978762738507275181509603963e-1;
      _weight[3] = .3625397463788723790524483974173847020917492065787212600840108277078063463761026446248645645121576882e-1;
      _points[4] = .568922585352551667982100411059980430161137708365607954620066105644648228452766965609689194596307171e-1;
      _weight[4] = .4425731927748618287257948334671876202437120287511051701022472597796561585699259416961088955149035083e-1;
      _points[5] = .825897633189471503761172023531691318939706564661181720464874299239016639710774216307824523473469200e-1;
      _weight[5] = .5116849259793773961536020333387403840090728696787416722400025316316297583997339267500072129783422955e-1;
      _points[6] = .1125717741109366110536945795187410873380276467679610813297435086513707772487952573486592132917409686;
      _weight[6] = .5684018439459308750223091995103184106621949834142646328307502298037684351282882504507874123563162440e-1;
      _points[7] = .1465306454397049070797253669507133675863970812842654082165416081846888928125469797956253712673817912;
      _weight[7] = .6116708587574294585708384600511210723249655869946088776193334346188726348364913454226106690926661155e-1;
      _points[8] = .1841179183174382295159362040481778712255751073163280436744486781128841767238309332184203445772681764;
      _weight[8] = .6408887558478726966987172952929198476290145444949765876320874448844505401660613395137907367862983045e-1;
      _points[9] = .2249478990674261230239659038071794671177427343701348684130225163163224666208835088859070269965698083;
      _weight[9] = .6559148352964400742074101780590288922762063110608826979290732662425384779750749352007853771708288430e-1;
      _points[10] = .2686016183001323810743018232453001490062411850001232918802978956024515050823666262374429233151229026;
      _weight[10] = .6570658184089414272443437205941363884723654449948817438625048156296749249405795825047760365653661330e-1;
      _points[11] = .3146311306484368093477133152707186848865010512147554712673141128875662531347957837834036041944221956;
      _weight[11] = .6450933095755145680015534470844576452895509725364825086687152102043276408899255479082363408978744140e-1;
      _points[12] = .3625641115525919243603237735395555249376544784701360196082102632275515462910475713276721125086440276;
      _weight[12] = .6211448255080993935299302013223286515895217681731822651599307938155060303705561438986736826778759865e-1;
      _points[13] = .4119087040813242226237090428292506153631763321335100527625422039405211351297361868627226093733969792;
      _weight[13] = .5867100684562144938879531538437321203226400947228654914597314289823584855733418457124886247351885885e-1;
      _points[14] = .4621585661189246886540277907231243106393062489018270745431532167413125006992428964361637064261870771;
      _weight[14] = .5435547110670841272312359308648180196145265254699122138675635302555438086361230585239049569790033030e-1;
      _points[15] = .5127980661561916817746887451598282918401125275994180446481874937657033611674660693401318099368063618;
      _weight[15] = .4936444568948249182271354202432237836841853506199668047436650095508669478549848818479903009284566958e-1;
      _points[16] = .5633075743824562981501263532733843048016241869169987473593829812419401409863189611028075333329458588;
      _weight[16] = .4390625227933978568080902602950186417843079234280225955367345367601986305141065089129071180428246396e-1;
      _points[17] = .6131687947901146656740818993889533163504756553625524311289854346046812852781127326882590856590079556;
      _weight[17] = .3819239423170725851575184801695770825061515968304590598855971096584248504449023211886317255778808429e-1;
      _points[18] = .6618700835772073917491354419849632203892530088735732812563719385176190205613534846026225511037711588;
      _weight[18] = .3242902027054050043405269502953432501755780381155927730280438058383449132894536615575943817616646940e-1;
      _points[19] = .7089116992693157344021296505007320277178336913754735555904081981587657489227382458808600070143246053;
      _weight[19] = .2680876976084624127714802836523064146869361267096646765712817819486360367453807577343673562010302150e-1;
      _points[20] = .7538109306754931985292676380937912950273016582300685379467850951928081223373494944028470408186327934;
      _weight[20] = .2150333048441228769833753851508196766124541500331822808509520438345824079506333418293329418556482182e-1;
      _points[21] = .7961070500327450999963466408130769909254065823786988072990704501299103077656532538035315934328433986;
      _weight[21] = .1665700904270025006653225825818748132054069181447553844487836536226341303293367295386177068216496738e-1;
      _points[22] = .8353660404570975782088039706260406779943814651902810216421804120682862030815465101588411782330910866;
      _weight[22] = .1238157096505112882609671713082506468468716145623744445894400365087184337768244738355016184626377184e-1;
      _points[23] = .8711850490619494505257748373786477444812674413535150966051762168128661783132891618825618402190855740;
      _weight[23] = .8752554092761193897920666189535675116315443555815723285447313014922448847745255648781476354256270845e-2;
      _points[24] = .9031965197235615179874486945867351160142948387890865854781167311755796735993819800971467684401213479;
      _weight[24] = .5807197046687551242251792528986641465603517512649975600107358331114246119583995371668699019307564135e-2;
      _points[25] = .9310719621711364212548285011966173256931864130262399049310424572383352311872885421014229760609648340;
      _weight[25] = .3544057111846242578449714083482700968747522670541078730791206739367707904169668505907306667431049800e-2;
      _points[26] = .9545253157432501968912124059098416516641931213305229648187694517128859748836928516071985626286913600;
      _weight[26] = .1924321465636808530397802622670580849344642812967027613847003408847372214971157287338404751460255104e-2;
      _points[27] = .9733158613935448794453820105491724343356720246202466373654937709136522090881131218997332838287318194;
      _weight[27] = .8747452449452054528434345545792328394990878028984125283749635749400441660481138993437894665039685945e-3;
      _points[28] = .9872505879667329157048673415397576071263296242106313401900976035365908604568987115580782377631356638;
      _weight[28] = .2920824818819113533365390766918036968638135004181526130531057784590465269274888973252186602735742119e-3;
      _points[29] = .9961854092532896146028221753356389314404324408686493792874214932610240703762534389970414536662131638;
      _weight[29] = .4881538648506998360388173728839473046687594331829239051542362498444876128405787257339705259631178955e-4;
      break;


    case 60:
    case 61:
      delivered_order = 61;
      _points.resize(31);
      _weight.resize(31);
      _points[0] = .14114759654438001348256513581390393419562984667192779736338384440996519441026714363454611896215485e-2;
      _weight[0] = .7230975650216755624745604235452245279656002216723509408307916172060648702594298932580225621218825020e-2;
      _points[1] = .74220518264556959990299822731493801998436484709522442421562775961521474913238167448406046166512886e-2;
      _weight[1] = .1666384739763897032812241273494349301940479298727467776618499701123988004490992340669678844400083006e-1;
      _points[2] = .181747690952658038437108481803088021902684415825402595413629159809155223324316565262012634726615878e-1;
      _weight[2] = .2571233502559233962916487514592441336832695124269937897406163393750519114984932213585990978514343900e-1;
      _points[3] = .335684886938805776020351183673393300613167940828654962764585541412287201838144499516964047561630636e-1;
      _weight[3] = .3415097128660151411552293359402711465242260074443127121977548875485479873197667931382868950372343074e-1;
      _points[4] = .534552578512626080105203524342513779937693721718500046157950064301891595545140126867720429028677984e-1;
      _weight[4] = .4178617160801825992915658801875977837905592813985782271826046732639763824111240518813120386902268786e-1;
      _points[5] = .776436274924141509512371198122950867042384907445017214161071063022462809243149841328687393582680416e-1;
      _weight[5] = .4845115329628569641400235641488049317751856187046068419552911791551587187988711061932896461090871948e-1;
      _points[6] = .1059006743507898902323150186915157844736889361974601035488644790649877832087183842561556969865587640;
      _weight[6] = .5401042910942297169606643634238107289080557340412569681213873962182967211009544484382516092556354715e-1;
      _points[7] = .1379542774855552447128780719326255863550668361596339433657214819259907437335908860511917486876748687;
      _weight[7] = .5836375229138350624160086990362615338239160080471286336192335984386192265975526908945540909274677080e-1;
      _points[8] = .1734957478467754419324204886538899820795596100969803016910279626820120007603979994054583834072109771;
      _weight[8] = .6144885509138399963208906732313442111944660705453147856358092910024558128442404871634775095734054840e-1;
      _points[9] = .2121828040888040191351780039348599803712580510768313825900253541385619933886307214449555348905000950;
      _weight[9] = .6324282395146252460962228399357097064629451333929175881113071479705576514084592429465799878090867965e-1;
      _points[10] = .2536428700864666432082452431813143747831005223909369486026040434260267599265945644212698451850907894;
      _weight[10] = .6376205679777034433887185779904126910661659948041441706014396168363015437816563331764831689201831860e-1;
      _points[11] = .2974766635554075645053147462633574325365810656072451302443779042064099713369581234883434685332374988;
      _weight[11] = .6306081016811023815063366225055830973064193329943389248977312015799791678018878924264416822274962415e-1;
      _points[12] = .3432620416022793630998090225239495403051757556793224800045295652949384229369749325747176898568972376;
      _weight[12] = .6122839910606623016083516397607929712359889718041574971984734730807128531033074166688103903282159795e-1;
      _points[13] = .3905580663160595481669443532255889640119739535291665391197508692095761083793683382818158071394605710;
      _weight[13] = .5838516403304980397938236524245392855998127762199298477601893806562625801132740459692252467239117685e-1;
      _points[14] = .4389092513075168270421572355375920326554093292760278491838960877415263051727169311927625190648144359;
      _weight[14] = .5467736526761173539523204053682411291515305478198601616271701663699064504367567004571196515961782495e-1;
      _points[15] = .4878499483276243221234259221844367644251247402658100645076118919224730288083968168335729128892347285;
      _weight[15] = .5027120597876520794900410958133807051720717588961402097129758603339362629583444196959462479095184530e-1;
      _points[16] = .5369088317321095914497342490074296657907384825367613041415625936691425061246625821704741521455568662;
      _weight[16] = .4534621667933985881749779656727066820681662775058860556728564399850914215218638600268285241138664088e-1;
      _points[17] = .5856134376099925987278912540897165142616026682924333001806921183223956634540653543769719960785603366;
      _weight[17] = .4008825767952754596264770738045083066907786976512135760856103031172796742597777430196433932228157118e-1;
      _points[18] = .6334947138634949003275653909484439122889862153213787389931455390854347121392448677482017219298371185;
      _weight[18] = .3468240935401616737828159765451323084923611155594248045105379003407352239380156383657820936225702828e-1;
      _points[19] = .6800915374180712367044778297145377145120919846691833890205513428062919469560369571372697106424002856;
      _weight[19] = .2930602312747382029070259723856409204900613580780841178372978455996881359391922812877220700618340040e-1;
      _points[20] = .7249551550540660529091850992378788810843305525615528425468509817074607906933810574574799861320868234;
      _weight[20] = .2412219864885692984554027268004476514570713341285851510911245483753078318480466778189683872369767099e-1;
      _points[21] = .7676535050807021900513946022822988218884222022947288784940173065942976001602180565188762480511492416;
      _weight[21] = .1927393500347561210274414657736369528739716154850885294306403397770541527835430503292412088596873442e-1;
      _points[22] = .8077753782079414862781562853347802220882808558955060482906917367586304344645833319010154104094769936;
      _weight[22] = .1487917669239610535935110809974107459177779203087820996598630854524461789174475235354270434541465544e-1;
      _points[23] = .8449343774921062514064287344919565431900271420193003901458878575147974746179949038330386644409301552;
      _weight[23] = .1102693954563673028627773823029815539275663335605092754584488542792032540755019077327673485480934167e-1;
      _points[24] = .8787726390975521425669806413071461215080266752415391212208380529932518479277636784487635052984358835;
      _weight[24] = .7774659106840380970358554163391920818229953794719842320238464165175390233650550923962976330020688400e-2;
      _points[25] = .9089642777365259832428053473898178551206481174446911746120405937208542772309144429777671577363068498;
      _weight[25] = .5146855981905776970511696158170320994675246401119572219172360040145011608975207596432949688805111505e-2;
      _points[26] = .9352185227478344903005635619837840093875008866261301248284230002913241844856789158446614001933175108;
      _weight[26] = .3135161039546822021790675745981601732773492778297033598408165845484191268636204404439790130023958754e-2;
      _points[27] = .9572825118149126493832813913549764982221829460675596349535989927608206332156385580989282616894079588;
      _weight[27] = .1699690182723932182540417652805511332197053633010356770823917463334720543387838323616785541913733903e-2;
      _points[28] = .9749437042544240163360031479159922744282696526039622177198702095339328818125350799450505594514084376;
      _weight[28] = .7717057396996697641517258768670426827188915944192573597223229681262995542318343939522690797685893250e-3;
      _points[29] = .9880318304951722914880530368106836749146235982824393858168425335568924461010604907917735038483867468;
      _weight[29] = .2574514681284442266230751751507317607746199866536766321397160733033418132062271464159105252778453157e-3;
      _points[30] = .9964198154713465863814005035441978010799044283122436703650320561453919687873406872890135672697937513;
      _weight[30] = .4300369105210562692826370639121461833320652605667711416578738547360188460016161942657143106316551968e-4;
      break;

    default:
      do { QuadratureOrderOutOfRange th__ex; std::ostringstream th__out; th__out << "QuadratureOrderOutOfRange" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules/jacobi_1_0_imp.hh" << ":" << 1263 << "]: " << "Quadrature rule " << p << " not supported!"; th__ex.message(th__out.str()); throw th__ex; } while (0);
    }
  }


  template<typename ct>
  void Jacobi1QuadratureInitHelper<ct,false>::init(int p,
         std::vector< FieldVector<ct, 1> > & _points,
         std::vector< ct > & _weight,
         int & delivered_order)
  {
    switch(p)
    {

    case 0:
    case 1:
      delivered_order = 1;
      _points.resize(1);
      _weight.resize(1);
      _points[0] = ".3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333334";
      _weight[0] = "1.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
      break;


    case 2:
    case 3:
      delivered_order = 3;
      _points.resize(2);
      _weight.resize(2);
      _points[0] = ".1550510257216821901802715925294108608034052519343329871567307432749039622542684973460140566895359765";
      _weight[0] = ".6360827634879543387887380041503272995536637489253705626907051426250533543031841681411033018391466800";
      _points[1] = ".6449489742783178098197284074705891391965947480656670128432692567250960377457315026539859433104640235";
      _weight[1] = ".3639172365120456612112619958496727004463362510746294373092948573749466456968158318588966981608533202";
      break;


    case 4:
    case 5:
      delivered_order = 5;
      _points.resize(3);
      _weight.resize(3);
      _points[0] = ".885879595127039473955461437694561968857293319227495654311636951699764874268100967252193076161015786e-1";
      _weight[0] = ".4018638274779192615443962665291996972772826161899046690923842878330733109101018240536312300474029061";
      _points[1] = ".4094668644407347108649262520688298940519048952805623079690981414050785099670788198530803511765293624";
      _weight[1] = ".4584822127191724933878411891126464928974948079824701329081908673733877785564897155383123086864879296";
      _points[2] = ".7876594617608470560252418898759996233480800585109738408854524491392307168918253691359860554930833448";
      _weight[2] = ".1396539598029082450677625443581538098252225758276251979994248447935389105334084604080564612661091632";
      break;


    case 6:
    case 7:
      delivered_order = 7;
      _points.resize(4);
      _weight.resize(4);
      _points[0] = ".571041961145176821931211925541156212350779455987501643278082929309346782020731645861138168198427368e-1";
      _weight[0] = ".2710138268629762324165283481558817992920669850614066882947002084270279998974049555934063155149987742";
      _points[1] = ".2768430136381238276800459976856251411108891696950304683494420488311213396837080367725415285640511309";
      _weight[1] = ".4069291360205427215828089518717095502110395549825805276980709607103205445318613532915751311604436137";
      _points[2] = ".5835904323689168200566976686629172486934326398967716401762938418317475019618310120056322774674562994";
      _weight[2] = ".2596950952164648816529124057792580292271059432720818009310478738715197515684797549856501468079414158";
      _points[3] = ".8602401356562194478479129188751197667383780225872255049242335941839742579301655644134901549264276107";
      _weight[3] = ".6236194190001616434775029419315062126978751668393098307618095699113170400225393612936840651661619870e-1";
      break;


    case 8:
    case 9:
      delivered_order = 9;
      _points.resize(5);
      _weight.resize(5);
      _points[0] = ".398098570514687423408066900933331677042626542283851619464077482049647456261743068545022590831845672e-1";
      _weight[0] = ".1935631804533033585487219432723014706300773723042959314554533779929073487933655762166538198748335132";
      _points[1] = ".1980134178736081725357921367952962360381863588337888792083291768272087117286465026597729214141553943";
      _weight[1] = ".3343492761887391309833512461953976371678718933478805952489779597608734587033500754020638058499268806";
      _points[2] = ".4379748102473861440050125200052288525167902742147401264690572735060053301210965344528972647247758256";
      _weight[2] = ".2927739741693396173960757387119177719719819871066279796088146708892391099142328799058439924278608750";
      _points[3] = ".6954642733536360945146148237211671613940015549986483590851972611325288138368238668739250465460035524";
      _weight[3] = ".1478177401452333407012664386834071576470881233025680816089650170466871663995867881310135629944366961";
      _points[4] = ".9014649142011735738765011021122473096194864304517102005637358130565651259599860618861752355046079332";
      _weight[4] = ".3149582904338455237058463313697596258298062393862741207778897431029291618946468034442481885294203156e-1";
      break;


    case 10:
    case 11:
      delivered_order = 11;
      _points.resize(6);
      _weight.resize(6);
      _points[0] = ".293164271597848919720502769131649103737303925637149277869106839449360382416657787486309483651843695e-1";
      _weight[0] = ".1446206614510173673109086522496639352868157617754660467953566358954592311021538274525319681276946612";
      _points[1] = ".1480785996684842918499768524959792122302487748085944614125946418015983860908783218063693976617475760";
      _weight[1] = ".2710849944630372336813807932761008554153744603412901289757132736303442652218840953547976196174453524";
      _points[2] = ".3369846902811542990970529720807757051975687500284733471225629680736913505127840608524091411736544826";
      _weight[2] = ".2815851075763978562381536781418577016545899054471519224997707881147672346819326236756438426595071102";
      _points[3] = ".5586715187715501320813933418055219400743682889654078255557472261173501228974210783238200520122825820";
      _weight[3] = ".1973223017813105282411690210967195758979330860171400109013608542168691368036765872249948825320820935";
      _points[4] = ".7692338620300545009168833601156454518371421433222954161669481696365481305739532856852002115427743676";
      _weight[4] = ".8791033110101795101635324861086019025599267125557955276461742797557562193809890394074140334644478685e-1";
      _points[5] = ".9269456713197411148518739658196820110561724195422832527244670796566452024525282438143394800135873916";
      _weight[5] = ".1747660362721906351203460662479774148929411516337233806318102016698451025225396235129028371682599564e-1";
      break;


    case 12:
    case 13:
      delivered_order = 13;
      _points.resize(7);
      _weight.resize(7);
      _points[0] = ".224793864387124981088254995708450599221739072356003898592842760587585757581218801438065593769986904e-1";
      _weight[0] = ".1119347268469821023031242268598512673581543443021245729793031713310010121026578504175518039330847150";
      _points[1] = ".1146790531609042319096402370675146270777298245319719453889897349515683398313771981082383887487264664";
      _weight[1] = ".2210185163817492048422414727392155493566865844622243094323892435572153405312368586320220078424677186";
      _points[2] = ".2657898227845894684767893916933899974369968814056098940206796867530550186172425454664726006420981076";
      _weight[2] = ".2547817945991766538374689715499232826990128023727599305281889688182403715832304891581911828678072314";
      _points[3] = ".4528463736694446169985514423476511453596140721008524586919906545143298698851397040631574340782308227";
      _weight[3] = ".2142501313917473399818245059997114645430845154022713345106969229642921740907764451829036761934830748";
      _points[4] = ".6473752828868303626260922298287587971919781169427252176007906613661670650910811632587999055012469012";
      _weight[4] = ".1327693929309829399672959775272798268160367658936009632652402776516685774949256903432965593140492997";
      _points[5] = ".8197593082631076350124200571908182154579393791945298446773744447201820118320424789742899570523187170";
      _weight[5] = ".5481671344374695088866209671645257295417296286400596170705830992550156540265177605400520195059885005e-1";
      _points[6] = ".9437374394630778535343478089676888242202344852553769164275572083026057856516616966519018212670469614";
      _weight[6] = ".1042872440561480817938274860756603627285202470301292757712310575208095879452089021202956789850911330e-1";
      break;


    case 14:
    case 15:
      delivered_order = 15;
      _points.resize(8);
      _weight.resize(8);
      _points[0] = ".177799151473634518132051010376790612664883982385004336656078316787592475757830065972642767503224390e-1";
      _weight[0] = ".8910160872311186265243123906792652143579327591629599162893070650953490775807421614093597558657520600e-1";
      _points[1] = ".913236078997939560037414580745413531070404757445676687668701726347953004791598752353803789213819068e-1";
      _weight[1] = ".1822380472727472526914449235657595207038316830973420932240504518535206139038892838023314283723493697";
      _points[2] = ".2143084793956307583575412675816703226744297175224765908137326191408580982640893227912904964441607055";
      _weight[2] = ".2250115989417747323435441972085622474585313183718632635826722622161065625207531342805328363235010088";
      _points[3] = ".3719321645832723024308539604826292446681000633774806778676385412497303508594868127751294857726545930";
      _weight[3] = ".2120947188718600214090621928223164323473301836600784587558404501112348205250685256991863152516914684";
      _points[4] = ".5451866848034266490322722299532130551329800560537052249374829413005927647507051249095965493813529666";
      _weight[4] = ".1583991989846383202408163787197844534389880146907948116529832318421622220548405973903502249576825338";
      _points[5] = ".7131752428555694810513137602509073414468837909454265589730704929652137959347225387189767846054023754";
      _weight[5] = ".9087863900939779616611084219138819921280234422368229723283559301918617746520672846935872214646562905e-1";
      _points[6] = ".8556337429578544285147814797717850302864781605395751604095670933496281754845563783672978210969088188";
      _weight[6] = ".3568580531197241678710559440208448516980542367921554701695861934230527222794506401464323963977834131e-1";
      _points[7] = ".9553660447100301492668789781416922384764228669900323904483832488568928548867910582521230305572279597";
      _weight[7] = ".6590382884497597709484632022178140232917756360727536905728685105949423544222450202661257721956446555e-2";
      break;


    case 16:
    case 17:
      delivered_order = 17;
      _points.resize(9);
      _weight.resize(9);
      _points[0] = ".144124096488765486328267408108132394117447310565780860707506791281388758346004489439506930372721012e-1";
      _weight[0] = ".7255600704655974291929919588231927759999609533460109803617790164385585111764690194965794919052353280e-1";
      _points[1] = ".743873897091960446359181859559985850809769132847351984267996027450199237902342809679124294549830336e-1";
      _weight[1] = ".1521485102186163251601586075079285812132106027704451841051048669451110654017776300437392883754252520";
      _points[2] = ".1761166561629952818631757460725685864113860479693058739346483371718478923148052033071589166216033503";
      _weight[2] = ".1970674843446914103203460407385488509023560656011704825855076061845847487566519614460658661365497237";
      _points[3] = ".3096675799276378170596204672294840488163890844971259245735924385417910631238453492458723772259274575";
      _weight[3] = ".2006176183867365793083004494651735780405723247720889520792755586297718961156570728203520324197133502";
      _points[4] = ".4619704010810109348831431086805643081072330679787275209992998979929435248645151935609445375900637938";
      _weight[4] = ".1687166436898406987885000399171749817104627172846977348696669835038285248020424407597603571357401276";
      _points[5] = ".6181172346952940246392297516035044802806674046397913475060393055585778777428482116865746364861237204";
      _weight[5] = ".1168023905903302211314630458032802960303593103025793617178533568693960614302271220161688241514649211";
      _points[6] = ".7628230151850396146826933071467255329235111827037380779911005908346167214808478679770430364298828452";
      _weight[6] = ".6360964298210800252338021387173996796508686851938261644837130415206699494945930902374759895630440005e-1";
      _points[7] = ".8819210212100012998077148880052647763071205854487038619129766513283089105657085985563097864503385464";
      _weight[7] = ".2412000856957075810345430457380053454860935724228865674231168030985443217573930570828234243797814046e-1";
      _points[8] = ".9637421871167905390588356992319185479241288771581362138479503914355973155457527404910756919669630462";
      _weight[8] = ".4361694171546261745098102240033931989346658172745913415730741761530425250798256232225741196300546707e-2";
      break;


    case 18:
    case 19:
      delivered_order = 19;
      _points.resize(10);
      _weight.resize(10);
      _points[0] = ".119176134324155969097455869589859760300278472583748580202759930444135197179395355209349553769888750e-1";
      _weight[0] = ".6019901604807404660130951104775872423481025847493586386892954004541908963029659975623116469369848810e-1";
      _points[1] = ".617320718771481255226293671942501414528720803619021321847007975030054226778255498860235530897111654e-1";
      _weight[1] = ".1285743090181651457496530772577303833702586985336065153964167070111045190343947831187521473702408613";
      _points[2] = ".1471114496430702404275994355798195021337713619059297805712867093259790600660861446700545255054338432";
      _weight[2] = ".1724226005783520728566667214238285835326209744871433508891823477804675766487885763704506821303023891";
      _points[3] = ".2611596760084562402660516580548457231986357161379567253035521310935009972624582003737324443405623492";
      _weight[3] = ".1853937873554468316895139838594217245376436126333093188403547348611167640031685342023540925200969458";
      _points[4] = ".3946398468857868429619521050776075022149391536489841976946611563878829320916183985232456263028812026";
      _weight[4] = ".1691142193816546648612911643310017367123791483004682190032143948519815060462764343108107374876334037";
      _points[5] = ".5367387657156606328730951777118890227811982315666478711601841465166401511417696449330275943910494234";
      _weight[5] = ".1321061511267007583321490050097555927283068703402401952281986304716746942938517327591629187622353407";
      _points[6] = ".6759444616766651073571505089347614715039952762295357455139412301626256578790308622295455518800017058";
      _weight[6] = ".8680381281430125184491223517276793341846841416734091479841192293605468475240771493378858474227150545e-1";
      _points[7] = ".8009789210368988451379463016172425246730022622599153383117418553952368566445573598703594633591531736";
      _weight[7] = ".4554918290652606517297529885212039260089893374717979072674077076892597133564094826507860794028660285e-1";
      _points[8] = ".9017109877901467703487989784097679814681176760729360475326567373055975858521386207932416878958506862";
      _weight[8] = ".1683863956596637483503273103740214403152870043903156313634792885260503739501482295430271106515098252e-1";
      _points[9] = ".9699709678385135029569356423655920593053451564625792084689040051698797214284804451045965026202723376";
      _weight[9] = ".2998281204812788056496272008212784833084388876744268112203022420650156860159853329068353288083480899e-2";
      break;


    case 20:
    case 21:
      delivered_order = 21;
      _points.resize(11);
      _weight.resize(11);
      _points[0] = ".100182804616804058430247298678047848147919405162162386621691237027768574614451489481147469055721790e-1";
      _weight[0] = ".5073468137628285236988931703476675133207796896933092717229277653106864390791321026906916586124492725e-1";
      _points[1] = ".520354511271805525835426957729643224471859250583818355555288193433032785128089556252838329676615459e-1";
      _weight[1] = ".1098761822657429965174933633313011358561393819756883634817227365336995079659568003680704346417858802";
      _points[2] = ".1246192251444430737352995872639092292474441300880058562471871920162296059349519090766521215975420846";
      _weight[2] = ".1512400961143739966427541096833209231046779325373189337898872562690835045663875992951588992175314076";
      _points[3] = ".2228406070438378555078314534573627644117252503274297081643638173616062308369832016150585853516004854";
      _weight[3] = ".1693188457680352424384787771038208637870956062801928026832694675642471331496036035898182671775944241";
      _points[4] = ".3400081579146651882336052338970175277313293398208505803470934737382842096120712309333935896431331419";
      _weight[4] = ".1637582059761269407791737038869224099299980514119884060206343004445372362390077946424160099852885042";
      _points[5] = ".4681376130895840420831103807577535932852717675509161657042498476028053990410676565350775613890232895";
      _weight[5] = ".1390637503163660995981017792678681988618489471914846995974738991240924370837736231339537725043865191";
      _points[6] = ".5984972797671391832277207136730435902749187521976111511339511314695356530954712310305911412553938959";
      _weight[6] = ".1031827213445951603861732834892155856521211990658746337177474052730046190656697225942280520050772121";
      _points[7] = ".7222032848909679255633213078046109071372364455125913944559779818780897684066745302575181714890353344";
      _weight[7] = ".6528309342766669203590773077952850778791273432908755477991105457383227392156662277547327915069498795e-1";
      _points[8] = ".8308248996228185740305665439056567039439893043182143500186679333872078183180614211671796544755957775";
      _weight[8] = ".3332724690336138483149424914765120772804900513036485126183239293221332762553574610457746434628573372e-1";
      _points[9] = ".9169583865525948532931346270180274177520051095629925713521035439862432832098136415299370694612456098";
      _weight[9] = ".1208784192095955158546592435315376798873973678286821945884976723777153926935372997535984241012640657e-1";
      _points[10] = ".9747263796024796502466688135383708980845368176554858005326201789921787651358684645855413515511531779";
      _weight[10] = ".2127334586489082815067761922450647971339436325800608036378943516449777205231547251874812699983997920e-2";
      break;


    case 22:
    case 23:
      delivered_order = 23;
      _points.resize(12);
      _weight.resize(12);
      _points[0] = ".85390549884274193686644608778398028060904145665777464962579273012303645757621667975098429613076291e-2";
      _weight[0] = ".4332972177374353464916694415595120758543212996143774483351792036632706037307065931531595605215419108e-1";
      _points[1] = ".444464631554077230254667987855527662413093037889971099913964204343602863966164779580398791963530750e-1";
      _weight[1] = ".9485570396075494026861836439417384912441834405354373442454022749260726809250625956872612646959123985e-1";
      _points[2] = ".1068544908834766576341067704324992625897998143695000275580631125622836143405186814627639697793505873";
      _weight[2] = ".1332135012533463962616689707039492301237993045862266872004033332675451141542576651800487628901468218";
      _points[3] = ".1921510545298540409910572562286133303827013670215218660373964882963368867384002033277468512639620346";
      _weight[3] = ".1537932053600820125624089382247452165048916722672790101081421598961789423490551582621434158001230290";
      _points[4] = ".2953808842625802216229168343760149059398907133108521080514580880514097551832904806231230987696368169";
      _weight[4] = ".1553926336310620532575312621995209299875566036520209784529663159004552165437224464483364641941562493";
      _points[5] = ".4105450812014576824890343505593324118433186951909181754985565958109519682767226149737373217217664215";
      _weight[5] = ".1402186799952601889918436100593420114476858105470553510722523423091126135591673604029597265238160539";
      _points[6] = ".5309508493128176706289302428968181393245082635016252048349547896722090314354827164359000778197833608";
      _weight[6] = ".1132276874273352638874022103122425258241607825709588607721683748382582855487003673371838524124059047";
      _points[7] = ".6496006502772549927662917233429805722256531182773037348557195896485644248598662000888560729456533300";
      _weight[7] = ".8090330741382723352129284850129132542849080333880815044744208769584595317684194609677391264812915710e-1";
      _points[8] = ".7595988895252270537426025740434203419422064350885379264310222786423119973912528922496277727549814325";
      _weight[8] = ".4975356081853086402501634458003176107706292549054632675888919684570712369316153894595850288044856446e-1";
      _points[9] = ".8545525437649358807902119164056171284859595037395583869615217146999851616473022152580139867380827058";
      _weight[9] = ".2487201833284453121496658611334714530755126260542143269983812777030176667500918269938718422593044914e-1";
      _points[10] = ".9289421012644110178488101551343152998504932414769823471037599293899243740926428914029706095801991064";
      _weight[10] = ".8889615591336924645592291731656523264334512786299205998267553396394713293187392679750568752472744375e-2";
      _points[11] = ".9784379368341496390919069169169960383680691296676253661798930654904321350621424594217105164689234998";
      _weight[11] = ".1550364441876056714491629023748274324615848140402517231572360221265942541320023063415527150625594874e-2";
      break;


    case 24:
    case 25:
      delivered_order = 25;
      _points.resize(13);
      _weight.resize(13);
      _points[0] = ".73646510260893216506914984138223436112057156164460004206894164522697500338945509974163191284452937e-2";
      _weight[0] = ".3742946317123035038674881732998767746319565332688557941550995658435906515956362602227579101388780574e-1";
      _points[1] = ".383981387396783503768325248641416859178298341363546876124160117982427806914025897403499913466209422e-1";
      _weight[1] = ".8264057883967859695322341390524823284515157447829234410387722644326630504728309789009709658120392265e-1";
      _points[2] = ".925952246990026352828913754386163558892798586542929263236659323528192107313684954240609003975971810e-1";
      _weight[2] = ".1179078759132941650723230065239224885407253391884774647520668533334363292610039623090163568998500540";
      _points[3] = ".1672510113915577314955224787593571163747337087390977895834969262324481399932617359780977489832830798";
      _weight[3] = ".1394269365642887965028332599008539689313215803996770757259514170749411407585930292996487794819461472";
      _points[4] = ".2586235407057625165897907328226910025245301373917701116571591768242959721348720274973743055115115388";
      _weight[4] = ".1456993930316364461587680676879467103064777104195675964020137583090170105818763010757692025989814890";
      _points[5] = ".3621313972822388004086812982273215588635004488227823666951627890767765685364866146107646481156613178";
      _weight[5] = ".1376310589751308344356757788733870175764464444515615290689142927534206737481584776849026461687874130";
      _points[6] = ".4725843860041177251750946426785972728715487356847376391370606505456399289933543401366876758017619970";
      _weight[6] = ".1182409626281846548385803119060635216477645343671270767817530063264325986532512918418359540320018568";
      _points[7] = ".5844439640213404555042208478109107062952661618107888083023659837678484044838564429563713070829009516";
      _weight[7] = ".9199156135210478662651956906042682442879113791215881297685885117558806298728604690294432003559148445e-1";
      _points[8] = ".6921010017196016568970419516876697301808911008718652877381506074556730863418738419796277914411356902";
      _weight[8] = ".6387357432440629768476274231692273392726396567637467815805792742291004917213504197268100373444847690e-1";
      _points[9] = ".7901570282734374855528633324993759322704266136136999317134349971780526905331558640579365443870029771";
      _weight[9] = ".3842791432943964129179099572748534939545850508452133503000565542463187538463405565894451924872087044e-1";
      _points[10] = ".8736948213066894193677145671317438911733815349203347594446961615475144054728685418531116734022398624";
      _weight[10] = ".1889784895918550073236017309848252773980721700710176677962226490559734899567257478464677461429063496e-1";
      _points[11] = ".9385244591007310123976333867652993517339853062062887126354508873721247374248021832126814047065480952";
      _weight[11] = ".6676718501547543613220841284083742579141287031654765750719644999750581810915764860757199651559843235e-2";
      _points[12] = ".9813896349890121485602806221597123115526801027908002379955097186555535838880620308147789489545503324";
      _weight[12] = ".1156113409872385703193022385189204618455050656599975054649145246648958439626729696480355938730002311e-2";
      break;


    case 26:
    case 27:
      delivered_order = 27;
      _points.resize(14);
      _weight.resize(14);
      _points[0] = ".64167607928184568108204640945071788657198399122448843072387699327335456137052391556551219041876968e-2";
      _weight[0] = ".3265350864519367963889885870153317340972173478361002456864218835784085024442850788249598470843608060e-1";
      _points[1] = ".335014045320131400359639285705724816103907692528423670723219233210066138491594940691258617966863127e-1";
      _weight[1] = ".7259215611088738637530423764370492657108112269853959863122175065021865096017202301997584723562877375e-1";
      _points[2] = ".809854996819551843924513077399821872276651475866549950782993912779701719653182508178748665537077952e-1";
      _weight[2] = ".1048919070038334911821636123253559026309238827100216428801281899821502970289452562493019979731821480";
      _points[3] = ".1468048676812137299236601652607991515599694654279756227180485513313137055587256285457460550167373564";
      _weight[3] = ".1264260511486584068850582307158644869441896337243628225912745291094341360195650397288853205184768074";
      _points[4] = ".2280842706492579915346440986199429719415777248320505178336090146170398503780540680375636284189205414";
      _weight[4] = ".1356633192083656742046946796682927954911511002736194344098397958433474422723897998813041094757193617";
      _points[5] = ".3212717439889361744023403974130354496573046310098509725155244153528428571119004042632189220394104758";
      _weight[5] = ".1327847012521708502656427173025549628480833128549141521111606655971088192656782192878509397656416202";
      _points[6] = ".4222946573075702578404089875181026958217938762273438789639540713852576268236287646690911714244228904";
      _weight[6] = ".1195711180450631684452281183371739455866965354227942932369779043707771685058862101141744024798095758";
      _points[7] = ".5267378613398730320537269448128829953760927123999441876600624391842836631760001928071840738368501546";
      _weight[7] = ".9903890904640600916187235867150676110280042407247668375164802867487908835414687742741451294178579330e-1";
      _points[8] = ".6300366883704039578844805941314332791605030321087179470245277359365694220786253960307680873297618343";
      _weight[8] = ".7488619291797165331187660365377253958575162997750359965853311053036376136149071602224720460759622710e-1";
      _points[9] = ".7276764528892646854360267279903316966165601685246486600874809495965456531104679399309294019000621420";
      _weight[9] = ".5084693081429752423013979751491821787681438824769049239677309253558218964169264456977882426851556925e-1";
      _points[10] = ".8153897394434746419730742186120575147090134055115116514499564217599632405912766985454621567772925720";
      _weight[10] = ".3006460748785728700681742950262958234619962060282172680123539669179027622963256575707868303499808856e-1";
      _points[11] = ".8893428088195155396908716609464895647037628629053267599145054482375380565684526275834413083786664628";
      _weight[11] = ".1459296826642524288681984453495518538081081230683288195407175989264044277989459235431320050562465306e-1";
      _points[12] = ".9463027000602753835334059434247240449122575138455164975479188348405641933767500076215855613747667664";
      _weight[12] = ".5108202635375307895958999219885338023800341194130592644971481918873169565255964058559811747744224110e-2";
      _points[13] = ".9837752340986002382812280091410008568029060918346814026541382401229231239358663224051124039381821714";
      _weight[13] = ".8794274174943185095245122078521822019754611306820543635221058449937077708215836466191607368410765415e-3";
      break;


    case 28:
    case 29:
      delivered_order = 29;
      _points.resize(15);
      _weight.resize(15);
      _points[0] = ".56406889725117097575064665794442009660841069881311479679783351382181415757363640489156972035896698e-2";
      _weight[0] = ".2873413924342504603822660041253805338312894456953019000237612541859506016961128946212643705230668354e-1";
      _points[1] = ".294822986479424866316409847180037091870096130316607776016129935209832096965946431513732658899655064e-1";
      _weight[1] = ".6423808974993183175709533215289588884744112148800311203074357885220757249757941129839863550850559045e-1";
      _points[2] = ".714129531151588400547839017467349191218729023422743567843170138110648900594619504618507323606625814e-1";
      _weight[2] = ".9378327988811985135869114109359384457615020825902727102745231221097976938006047088803797585614215020e-1";
      _points[3] = ".1298310255535910559712545380942899123177230784713915452688927991403297243171614954096840860975794643";
      _weight[3] = ".1147976510138825787492378322328278794932624818571617498887067215859317142102959221744686929404365635";
      _points[4] = ".2024927550501040475682199883202304426029145838857816183098197713593869872838287905637745131407654632";
      _weight[4] = ".1258362132971938191853306984611028086637728409087228064297723636579546705764893008808467616699197371";
      _points[5] = ".2866060862575270599840260454843964124631835183282258747277172597764764143673373926548361027887495961";
      _weight[5] = ".1266879103230227850387014761385934876207673172046994042169455568651290983423795896771549684315258373";
      _points[6] = ".3789386886469780381065290091427738514254527443330112900124820663975192124536679674713512968590311796";
      _weight[6] = ".1183483841194258631300423373291751145087283396220212493347563783564965088196806285369931653722201566";
      _points[7] = ".4759423084632348605725889920158496815427420479142534143461931573336140130566014455167924185629638753";
      _weight[7] = ".1028247246237729370608003387427179543718483332403108120303957336121729678371306599559686414960307900";
      _points[8] = ".5738891609066858806714538552375264393339926267874317142496528265661645824810184689905478175189410147";
      _weight[8] = ".8280147036884515645762630104986933848692863219976179565650568989405659185694148889272203873424612485e-1";
      _points[9] = ".6690151950299598765386956390531395651245327979857527236420750144055549199665133052913040313820535802";
      _weight[9] = ".6121953917293708160858361757949451057101860352459654126809960020356064378300880593208989800744638570e-1";
      _points[10] = ".7576647390313427119970742777402853179406886187590936481745381257951925531912300645820920629808513944";
      _weight[10] = ".4083261854523967138238199054130899238084842965133790112559698218356527355006904832983602017392238006e-1";
      _points[11] = ".8364309606056101239755590856541831966144050516279921337789774230212989904851294862915904006631825436";
      _weight[11] = ".2380838071019515768606037392049978041111467814177297555284892510317273317213807457840075998316892906e-1";
      _points[12] = ".9022867006793780266312385046620090802654876855849468717160511280017608939616471254566098257665163887";
      _weight[12] = ".1143444478944235234324930059485362276155780539908978755489501360681769092103144487510479479672775240e-1";
      _points[13] = ".9527004099058333143380442075242620935055589938201492599119746533434704857023258451913238950513425186";
      _weight[13] = ".3972469386290076082067610229152060080164258093234183168970372439783118787506178115381153751514450491e-2";
      _points[14] = ".9857305452631742252659006330591292421044806623979681396367496904534811104340037194340828859918697398";
      _weight[14] = ".6806847682757921219050495213766638432680058407302207119346460095765860960776864024700562258864675455e-3";
      break;


    case 30:
    case 31:
      delivered_order = 31;
      _points.resize(16);
      _weight.resize(16);
      _points[0] = ".49972996637719210426511496015206903353343815434163443779705222558749641575587010375026471024396331e-2";
      _weight[0] = ".2547862131466836949509969175915548829500688331296582799126402207371385137095959358456182506583938848e-1";
      _points[1] = ".261435136813940519785493233805429683954454958525459325896928694344782980835469192641617828190141429e-1";
      _weight[1] = ".5722490518028629871511613797483697079230632259783211879752488731784247248602820192649149146115387570e-1";
      _points[2] = ".634309455838367454925282227707008598994423272005360632992128633660619650199194169690621454407255802e-1";
      _weight[2] = ".8425886231485656951503148108375679459878568927192553127356020255912965879211860283525552207380978935e-1";
      _points[3] = ".1155984375798159401789236282473972563726614701242300531764409420939787630288591298296722238684111490";
      _weight[3] = ".1044571888079182947270193577860579511982476687312989947927842773279309587346572216043331398328061557";
      _points[4] = ".1808705596578836662475733912556982106123115303246260325696821028817277573264066422281984062600090232";
      _weight[4] = ".1165084804197116707586035588447860117666087389169987223931858385521171238120053660291409688663307144";
      _points[5] = ".2570248078451708599229442395592698543456357763791818065543456950821702866951437507776531490026073372";
      _weight[5] = ".1200017097762270141107718840043310847986139968638932139267556119836512373163034295226044021116883990";
      _points[6] = ".3414679275478230686258992979386936719113738330035523847360437885913802004557323404561019734950136268";
      _weight[6] = ".1154377592185356472353639909359373445130799205578497513133111318249085177414985560302496131357962245";
      _points[7] = ".4313243435956253750835922695827402886099831559358862798400496976431495143682652974446555198615522438";
      _weight[7] = ".1041282756876131675099467043785466919999001988893057566387403573176304031195728572957688903687759436";
      _points[8] = ".5235341160251683205174701650756566635860722410235498499954471423511414451699874777100902273256248828";
      _weight[8] = ".8799476437848784634696283460898074168566203452803298141048012151277732409770913018617800056991931685e-1";
      _points[9] = ".6149571518764895174896408338190829300761737909570376040266234164320457869812106383069644402943986534";
      _weight[9] = ".6929563315857159820616975574746178675946381337997363992181349355292028244090523248488698582693559135e-1";
      _points[10] = ".7024801379250410444548069755376171424391608550242998874533600580057788358037540611975107319064165735";
      _weight[10] = ".5031846621294008117130791499383570158153393032155337021668257703869079487755627644770701989152687180e-1";
      _points[11] = ".7831225539648680838521817825620535305797128397296362805179828091518110236513200121261822163769397744";
      _weight[11] = ".3307916871127158700245048416620955670443497800101336034230747234827543543117463085957742175622949140e-1";
      _points[12] = ".8541381477752106336651136838193234409326728494243068253734695081123194081450149725457651384431831745";
      _weight[12] = ".1906833576933187330993392764154659000664170074848288047274653307098419606424675728205551148860451362e-1";
      _points[13] = ".9131083765371412746295855467032689982673591902958463102880070958924077633184989381448279078074159212";
      _weight[13] = ".9078464772277270136442222357225691316200205613577463083584857434992460933218018083501741086109300200e-2";
      _points[14] = ".9580244176904754545449593445542902781690561530886972767565858987751500797120765811025149504454439509";
      _weight[14] = ".3134376947191639406144801392810125165152211379977657619913840594889257190569195251860266967516393470e-2";
      _points[15] = ".9873530206260416180311559031679007912251798676684086442026613475062814838402808784348941153083800906";
      _weight[15] = ".5349873301110723536352523245214688183617068853187298053447754895460255914769305758271994969580302670e-3";
      break;


    case 32:
    case 33:
      delivered_order = 33;
      _points.resize(17);
      _weight.resize(17);
      _points[0] = ".44579935677873917545062291115463999646337601002599705378107254914584942500435984370196648654936660e-2";
      _weight[0] = ".2274540622639378829776020880683720609452057522373976015749508324031731694387040746972125362749181489e-1";
      _points[1] = ".233400941237742739670215282076831229958606005759941986344997465924823824333975755058549582940548134e-1";
      _weight[1] = ".5128485584041035837150041049462227236569515810109611130226859683533715551484088425680168645644920215e-1";
      _points[2] = ".567079687690782395327133315565206422583954294330082911813093706572985010525054793316865221556379500e-1";
      _weight[2] = ".7605145765148480040294983401333088847853799893124803854611256634704675720143211718355596444822207695e-1";
      _points[3] = ".1035554329351970634134912269613124043655029097199118685108784305899757515572621444529640256077589604";
      _weight[3] = ".9528373874923688384115041853141755745633038829194399052580502788189156712111849867133924839700215000e-1";
      _points[4] = ".1624600034281365499816295439141031838558059790103253735306759523919908694781359490868358657162134128";
      _weight[4] = ".1078158633350549603832320404930530506583776814863800678782279266510495293543282695089808637977903962";
      _points[5] = ".2316321257771721829467972257383587479080211677883964983117694939499389815368349381911564356963581672";
      _weight[5] = ".1131472227649430259739820683657003705456250202081623505248301578043822513167014548107893476058596334";
      _points[6] = ".3089701177521959033175242612862631293729470242289113159247135612658365232010381202115837653514093198";
      _weight[6] = ".1114698358471210991542580389815065276072464356895427892969110466585885649118705952943517744483556402";
      _points[7] = ".3921241347220956580336194633319030935711764025114615789973484145740342676368815150194126405593319517";
      _weight[7] = ".1036194838585926665104294095256400693128383841028677293915780879742991691522033818310328703299843336";
      _points[8] = ".4785675968530795887837104628593678634648959196490499291294706873670695640275487620721736497706949930";
      _weight[8] = ".9095558079828455499487784832842234327421076718008184235832962158876271346851796676218008225388408430e-1";
      _points[9] = ".5656739668866343319033069760096456365875201180074841733261734685045356633266844286988014211643520508";
      _weight[9] = ".7518465097422447606286399704863748886393605930789172672958010315085190595784826875016684063030466320e-1";
      _points[10] = ".6507965584533822647314874073231465774368335045672017460161248195939594014514835415159009295305527973";
      _weight[10] = ".5814904817541010112637471093584722632635723649505078175048544545500447542788986279551396785911403605e-1";
      _points[11] = ".7313489527340513821330214955629758769642882419335965596457437541501075219052287314086987765714504542";
      _weight[11] = ".4160655602059072412002573275154629614396598977699363439275900065216665450117468253795333168827005934e-1";
      _points[12] = ".8048835785249664919991777013970255022373475851134620892027287774778381435285669046560052364431526214";
      _weight[12] = ".2702739490460156181927791662098239956927108947038280148990998102655235785834616122857118941751075748e-1";
      _points[13] = ".8691660595674136192044464980111575364806195339738017470940551470086746289669440820074891382029851424";
      _weight[13] = ".1543284442961187739177684553210850040977377913889605049895702539591618751800244624737646088995760080e-1";
      _points[14] = ".9222430345922984084871073282303817691602583776161059845144196175091317355129889510768256352598660776";
      _weight[14] = ".7294460966842812890068913047567504341965175593956839929686155659396138028717360227340619459024405260e-2";
      _points[15] = ".9625011978233500412504607753885055612059058670805919300838487295359170197761774966465922450143861439";
      _weight[15] = ".2505366878782441497821305040213450564573948855367154150978343268848357634079495184968727608551616254e-2";
      _points[16] = ".9887140406322437514171214022529600950271304358332938882155721604826076932154206388238562326534443352";
      _weight[16] = ".4262325784138671616503014825668479867743121463983310760858304095888980890581472393557710822275299578e-3";
      break;


    case 34:
    case 35:
      delivered_order = 35;
      _points.resize(18);
      _weight.resize(18);
      _points[0] = ".40014793838673867970427199102708242235411852487858333635545783443198937571148426180584634073488953e-2";
      _weight[0] = ".2042867887008126774453513345708525680111295405537645831789221858363235004907653637524376495672032180e-1";
      _points[1] = ".209636483937664779951356009865610967568918017653850218271006512363638491846738483155450096276351098e-1";
      _weight[1] = ".4621270032675413386257866238629064300957438277868616878558323293289918331132386077257775740214051950e-1";
      _points[2] = ".509940415878905539667749212998534275268433517950210225049075762705476416715759097368663577872203266e-1";
      _weight[2] = ".6894223784384404993007739031698519886588775153771160210566885018965190752564322224893633438800543855e-1";
      _points[3] = ".932803959285449507776090588260657290911042316940360196554551611395487896027129667557276997443350555e-1";
      _weight[3] = ".8714781414928617652436330187061168404379158056036702876225120391972824949607113158995664182946364855e-1";
      _points[4] = ".1466701036776179571516088297346119926828719790587607976177450052287675453102203350213112764829923396";
      _weight[4] = ".9980445383540542778220444771221204607299051846682882828893450936727624068650930424980230859185450610e-1";
      _points[5] = ".2097070395888429667218817114520340564344572337129713950314960570502750540556726532998975043202670242";
      _weight[5] = ".1063846692636713200524475540357298948042757460509025466150822041706738793410034729395308181693219169";
      _points[6] = ".2806717900601716991068192620345454984655482490495543795697683718559155121543067476743790509001396309";
      _weight[6] = ".1068905756056280540407231215063610225447807915923361568235083905351292478184997124115608137022036346";
      _points[7] = ".3576286499766346293983271429839001635515548234119666315459310143421184553850015752086863654620933560";
      _weight[7] = ".1018338577127481863631259923308642099185514417373884497748896700704506385950017111137663314704100215";
      _points[8] = ".4384784492241381176518542603874069642668262016685327878789060389076575892412083497577428502906842642";
      _weight[8] = ".9216480198048256152417399078564414852612846466652256992046258396446590593706414236053909750896569125e-1";
      _points[9] = ".5210158208707761473198147915854717855660664902319620429318729520457293008516289285224828683060695134";
      _weight[9] = ".7915832457721575745284593825289506100924953969440499641376678369347764830926340546224343749330271025e-1";
      _points[10] = ".6029893605598320721374807041874726334761957597253021332090631742614856848258536813319527445372951366";
      _weight[10] = ".6426961225525709848147580633301085880443436756721415851562729065246516504496265169885498286161075810e-1";
      _points[11] = ".6821630391136515650188220799815272984812129529984549136808308873845014736266989488992730818190698118";
      _weight[11] = ".4897518000258343319573971841628213770242132719001940867089608917054120707937976989292545511549928188e-1";
      _points[12] = ".7563771934061506267981673359097779706473518228163447251511697288815637982124887651626427336664155868";
      _weight[12] = ".3461660096179857963094037301158265977500547563449518843396957076139936244796763506359293284799220291e-1";
      _points[13] = ".8236074297748695658739488546206220397694931892518864127892186510351045655222244744576037075797895550";
      _weight[13] = ".2226374019481872490578598695715605901312264527880759493159497248783660222780139439098845774610923860e-1";
      _points[14] = ".8820198253620791467312412088622993480054175558087202675489680161512128646692977135156953321849841043";
      _weight[14] = ".1261207776476106746655648532508006599729513787362061969061111331011139156523293135970609947071819522e-1";
      _points[15] = ".9300208896996932164819585047276942532417932534056115051608547073927014042784861756734769306165350984";
      _weight[15] = ".5924886128865675007307012459683759302107922049224705877516978271987271702973648729283156120615280665e-2";
      _points[16] = ".9663007519456325424115067464906798893423212721801663890681129055831478702436903498571145506943067400";
      _weight[16] = ".2026050358602094250494341820341870894120024561864795036338823580354925264367517227275244577062726796e-2";
      _points[17] = ".9898668482025971344167630227759617852272654029332944782218012796457954641639004909483002293295752084";
      _weight[17] = ".3437381681963917846247430221834229151499287042287230354055143379188235978579521132163657480039052567e-3";
      break;


    case 36:
    case 37:
      delivered_order = 37;
      _points.resize(19);
      _weight.resize(19);
      _points[0] = ".36116428185568930344532101262519834673327535500368291955711340586740834992929520786744161173773638e-2";
      _weight[0] = ".1844807545006615338353364973844063664514747348633002796850199039649780838921192974783629157909885336e-1";
      _points[1] = ".189318370315882172502645243169492367461404552465872310088109566093838432801783805186034184059745984e-1";
      _weight[1] = ".4184930350395978096289045666597507923015930768805746257353242039038709944828752655956749616427151262e-1";
      _points[2] = ".460979330484310835739247708354590937590624169342221575240393038979506119620931786171787481316387558e-1";
      _weight[2] = ".6275255057146579770871362891521873929256827500121891666402911779624971524361366764385547573429398095e-1";
      _points[3] = ".844472227842098205998479004511695475756854756734299647577394837711646475135301153956100567598849586e-1";
      _weight[3] = ".7992474009798348388058615288463343146749229939781603917537641412235430355026262140658074962652401900e-1";
      _points[4] = ".1330361885580987754240874239752163178462101569942577515312839921107421010353389269684892715246494817";
      _weight[4] = ".9246985633715682353076157026438268785806641992726473058335517773221312455376698448719205979627889485e-1";
      _points[5] = ".1906685949047633510874746648871937910511869102030339299609855946583176259568932278761873481665619368";
      _weight[5] = ".9986827648083875910656821167754631038635897016436543739205281535304647362910941203114996053823459655e-1";
      _points[6] = ".2559254034821029602520473972952833166965225034685666607613445549879376542400004376190936134395605994";
      _weight[6] = ".1020083732534387925915104591369712164449503353535754486442048495248552091996933451569357987499162327";
      _points[7] = ".3271998007638117157284299652756602156954719022978259770161223468001793352880351101154593072887848128";
      _weight[7] = ".9918209293741316028263210506706355271369499867043289653925746745730565272014624896429591950124022870e-1";
      _points[8] = ".4027367861650770951230470111048776348626646611402175602798726241469139422734752813325599363666955167";
      _weight[8] = ".9204397143227682581672576212135660932951865767707678899669727185145202547081949806407328350372842925e-1";
      _points[9] = ".4806763935785519026332213524827062607958913951805210382735109679392374943149106385409942481778506352";
      _weight[9] = ".8153774174367337114460345968332885877015622313913313374058373868512964935174277352830164497093084720e-1";
      _points[10] = ".5590994926490319878469279758790814850485694130830958106631220505575721013709915928328659605930323348";
      _weight[10] = ".6879791590381478285911941087185040133275238686516501251070694318774386308432389393107853548035543575e-1";
      _points[11] = ".6360750448792708946910910570981647668668019198973285696987761671558681881849944225414546581423684885";
      _weight[11] = ".5503611628869595628296228495903234773834971955306329246189976450730557322385402735173501701009562220e-1";
      _points[12] = ".7097076516539023988437467831116355144608909392408906399894113065110659853244124588493665962726797403";
      _weight[12] = ".4142334512551560975967431967755079490752620840476902467442180073660343747997340115254631834842096820e-1";
      _points[13] = ".7781842229767616142092996470420758791283656925578678775853071098643813559091198697527204996713931554";
      _weight[13] = ".2897969422421944931400246601007177204686871789749054254495145220324571113131572128329170246403841060e-1";
      _points[14] = ".8398186157087110778386362944292882560999767507786887653784723935849407017581430396000219565181239806";
      _weight[14] = ".1848218385863319552539537554057223036019964756805820620573212876783093453134742074611622587757857651e-1";
      _points[15] = ".8930931349818449707509811545649148473623623153254222496159769165216758357705561673044346695221436232";
      _weight[15] = ".1039956265655675937361109308836621689303842061071886601976409524754409444497299628947762427761049612e-1";
      _points[16] = ".9366958480743650805439055020819450266811818650579229027664901891451477928206324529848022077423517502";
      _weight[16] = ".4860183424086561415136332087732184813912903332909763493482554844577771785083994880850628448767860504e-2";
      _points[17] = ".9695526370802208854719287862322660049706018326703098706378843584104484087310020229969934667704093962";
      _weight[17] = ".1655761521847964386692006035428965858679000056357516012475017722076239956761833907883794508005261242e-2";
      _points[18] = ".9908518052709556853530948352201172311414908971100306236116888056786547010228099804847460306449291276";
      _weight[18] = ".2802551883567726748812555744779639105600352061968937989749794735813128057127028672314734206097748682e-3";
      break;


    case 38:
    case 39:
      delivered_order = 39;
      _points.resize(20);
      _weight.resize(20);
      _points[0] = ".32761066690500989752646761128711432920101684970296447672954700638314121615841947436103279640525158e-2";
      _weight[0] = ".1674168835254511394846955946921133039592001158401097571996247349677350244330260113202342105341285984e-1";
      _points[1] = ".171812181452557137382477046315820521714231065092193269938930182717301029969462923980692971400938767e-1";
      _weight[1] = ".3806993892740333390463550463872740520842342009670349282847748189119210800461319599436676876862678490e-1";
      _points[2] = ".418714311177651952442346341437085111495490230789848869138686347068204907034413700625150699605358272e-1";
      _weight[2] = ".5733647475826119260703896626884620663676526982142598197751665152278167937952506465377762304743114550e-1";
      _points[3] = ".768008370896219704818705230199473676157366322019186469079395037633694071264219274279012023218664533e-1";
      _weight[3] = ".7350047967329571176034002983707970547786941802561395491718754226714603265744811012378159096660733655e-1";
      _points[4] = ".1211898673236760656176861522945444470235806268943235898707887850377131524410713389898296198872402903";
      _weight[4] = ".8578059167595640842829204758039989126835431719768784417396580841619485004243385901000626954200996215e-1";
      _points[5] = ".1740471126355421652241579341996569921877681033069868901852878459116461179764358286536618532558350354";
      _weight[5] = ".9368338372511565569498576493650134822004762846570875646531322483816870359335260839464910457905418140e-1";
      _points[6] = ".2341918863135921908944557128323043352373021481231570747714734150082081622077654966849128615343105164";
      _weight[6] = ".9703221011970818162036374853733578584979674884812765964709076549398887310760714319754736126681214735e-1";
      _points[7] = ".3002806768359501643662584187171734631746719686192409655675227716570747312020196669966322653788992472";
      _weight[7] = ".9597092321988782503051231642150166590478722336093452405759351080479348502148876405591865563178068395e-1";
      _points[8] = ".3708371805843968964453220795377124336991024955666204869798357877359442742262916746260159928230296160";
      _weight[8] = ".9094117788270695025052175053988521021573682596634589761784828202602528063874365566272648430490295200e-1";
      _points[9] = ".4442852869630111621288239178359750500363597749061959401405017960314177377456681603304441676000055320";
      _weight[9] = ".8263541363333147565166589034452447111897790526008740772996796592380070257693533775950888460291073920e-1";
      _points[10] = ".5189842887035737296184117608302417580161348370994725645140664538072682185064509019793474604143752166";
      _weight[10] = ".7192983830772549570812637571959705220454253379516249592845826823872807811447074214345608253045060850e-1";
      _points[11] = ".5932655334835064879673930865443734208473977411399654892597462260744716869678127565393306479732092832";
      _weight[11] = ".5980348368525802609816497837917858372547486798828513804350498569402473230677222080215249105521630065e-1";
      _points[12] = ".6654696989055136479537295881338505673772460184966543033851700597919629976818155341141170411631585472";
      _weight[12] = ".4725059234709778562613272088316633264786049061137085249821716995453687692356004132430763173471374028e-1";
      _points[13] = ".7339838582356594497320271932958407316824886943041261173702937687882678060193520684331489222685668046";
      _weight[13] = ".3519413375841203253537225731014733812107557483384302032295579824046286874151937628916098565550845026e-1";
      _points[14] = ".7972775083365946877021888513752729067366395533700328215630061593076170870677993680779536516217368254";
      _weight[14] = ".2440809225336020855759740649158179130555848135630839155224086550001630535743462622984150349858697256e-1";
      _points[15] = ".8539367530358904570890043916180165250991367585634254004379927018011944789694603521437745068010804059";
      _weight[15] = ".1545533586010292574715613428317953854964217039480755935175135440483625462586097291289321958613827229e-1";
      _points[16] = ".9026958717934536922763469416996700772864999425096913605427629927201564197787843225600147491273022002";
      _weight[16] = ".8646438225380306267478104148579112377200533623295159410282371065482011056328697434527181912481069745e-2";
      _points[17] = ".9424655423631863386908918774276637741176541559385663981945954132521152784422837129268702079654087890";
      _weight[17] = ".4022915227928156013814278936824336762072286332632338071325792455668677727129064099489345807391595775e-2";
      _points[18] = ".9723569466474369111847018716646485313955816199047026627731927463182820924001386973341816730256378616";
      _weight[18] = ".1366124552171843969035439751076010937012975665488565633903154123928917136910100459323476015520863856e-2";
      _points[19] = ".9916999557929327307665436596947020094146922407257829898363762060484693209882124325386440915297527167";
      _weight[19] = ".2307638143513705802967255226568830728813167721599840524365336414500605445638183205419184404433322438e-3";
      break;


    case 40:
    case 41:
      delivered_order = 41;
      _points.resize(21);
      _weight.resize(21);
      _points[0] = ".29852372832130627418887840757498333480458971901820214266471114480518367455909531621871365537087194e-2";
      _weight[0] = ".1526121181304637819034183537343181870586287942279387814026920795825460055220015001230072135456557602e-1";
      _points[1] = ".156622805575735473328956106556783014972010128293037905774069098289880974645570072495734916113720055e-1";
      _weight[1] = ".3477585215239002509062018516237075909270082225585556133119177596182468385879490593869463891914189065e-1";
      _points[2] = ".381982882450735533448328193956577878032208188203725328447813769230183945227281635160195550912167396e-1";
      _weight[2] = ".5257452016640661293744751166188692897194515113241003199215036965601069114006596457477520534479191075e-1";
      _points[3] = ".701396190623257981398426567637581140708182789792715597262705384965631006414560540707747085667187342e-1";
      _weight[3] = ".6777358068880635103031781043749696727813442757543512272919269504359828524130368130679643560187425645e-1";
      _points[4] = ".1108366733203635022376253075861617420191222518457438320529257958835099421591933038201169995724625575";
      _weight[4] = ".7969195514279793288914190000566235267906711260491304675619638962584196774176642443198237281889504350e-1";
      _points[5] = ".1594611294440652502638138083655501810579538766130618360388682958278037659580503571599755802371922802";
      _weight[5] = ".8787114127030075492971967145810458697850436666177532008944289193939981177542132493146261831484619220e-1";
      _points[6] = ".2150231853580202850809121676459173588900222007857657740357006632538302506890640907152055964899157530";
      _weight[6] = ".9210054144651500414815597125252491515932996742881640264899141571621140700823572973382363663762699855e-1";
      _points[7] = ".2763917790937831724096862097630639456644117270400405937135134283509653312425761670490246263920613134";
      _weight[7] = ".9242510522204482532070073767512146817197969239818616413946316147309617242947716994951510527308411215e-1";
      _points[8] = ".3423176329587307937234813237124575051663439847813749695996137689085202168611822726580729904499541711";
      _weight[8] = ".8913374937230921373396964638398331645759341581488079946582408064396578278281966817037315653266931975e-1";
      _points[9] = ".4114586915619051989269753361265125049694148578387329380612416947570578330099506998594987587756143860";
      _weight[9] = ".8272952079399523470880740580838362330379464284872694528732063439370860031512300475525677462603061600e-1";
      _points[10] = ".4824074446124388805353185218595824144467997109997394967544461672573758804548396608944152015562769533";
      _weight[10] = ".7388402529699877110380641152857474527467150780108552765426171096663124369742378311614318387497559480e-1";
      _points[11] = ".5537195807282935914003656124348565130222723633112639658363114623393879406517479598116624690714085946";
      _weight[11] = ".6337990610025468075352666693255656013349124651231552374816444219192430946831498393294160099075286405e-1";
      _points[12] = ".6239433897212819474963058147440920154900191318154389436290443886013853942344250394844038511295753291";
      _weight[12] = ".5204609359179111023564632579998986927183950203292324804344689812665144316827079944423657995726457125e-1";
      _points[13] = ".6916493150129622572194466789692474731114378954421946863393862533447191774980898542170077714513614260";
      _weight[13] = ".4069109877964301658407017730425226266443064057334065145095136833448379998485753079799217710254716886e-1";
      _points[14] = ".7554590544496869862658499728148629393663862148485365820478410117499734428055421838878873979671459348";
      _weight[14] = ".3003974522638556952704078489267777259843073958271775542411847529124306280115798397937637514899778340e-1";
      _points[15] = ".8140736165126974167889441095793418834761159091940745540915800538406752152475818572669301867705564506";
      _weight[15] = ".2067841951594062532766545282048113895201409713863530682554154662668730367463374091492579251859917702e-1";
      _points[16] = ".8662997589709565970763633043579206958620698193352277530749704236585637715961211057848505289659335869";
      _weight[16] = ".1301319484729121067081350259836615564509889406165673029724426861833434880054116162097542563680725932e-1";
      _points[17] = ".9110742658026157747796664327661934805098614945934874284421480344586480510586007787502760981037643856";
      _weight[17] = ".7244105739489879730472547559442240697420720259915659077551736989091842220673176735262750426044136195e-2";
      _points[18] = ".9474855444063973466860989716611313948903221194844454580667087781352119091878179384063695290882735176";
      _weight[18] = ".3357512043133831072552673187562964503288479122657296229103793587294405115801504672333876179128347687e-2";
      _points[19] = ".9747919756603656530791520912867540805522533015938938496488658734735577229804897977756749790184311510";
      _weight[19] = ".1136997053399528357223582471399066105620591183233813017156494435682540599458716110693253306399932688e-2";
      _points[20] = ".9924354907256214774937902793889982068789303884718009223638209927180066784787668474833283570905443829";
      _weight[20] = ".1917237370594436579591996857304873547811035877252156524166424200636976236585948701383194349572474094e-3";
      break;


    case 42:
    case 43:
      delivered_order = 43;
      _points.resize(22);
      _weight.resize(22);
      _points[0] = ".27314460088842296840089704503200014449200918101959305251802699914424705443586062328636487911356529e-2";
      _weight[0] = ".1396851222739562730764330994005642798820870305226851204432919119548361416787182679620320754331798072e-1";
      _points[1] = ".143359334836997061853080392850525718221273498417199514175668855459687754744077471847082592790774472e-1";
      _weight[1] = ".3188810690955699372913185825261865705830584729624107779763818757645318375465544204740945923860488160e-1";
      _points[2] = ".349863283512164493872188140710847078954050751341333200887381903194327270144037730981749494305523622e-1";
      _weight[2] = ".4836847334378099951774078646756125991897967480632796321673948363274069201822403812450448406477831640e-1";
      _points[3] = ".643026411321588825312750713956860648352739646745500827639460760672342712373544920029598919242579590e-1";
      _weight[3] = ".6265519399875045578481791711936416627645561286020844389093385854076882602968762518293831335949095095e-1";
      _points[4] = ".1017393434521639240125822659379428899539853633989816895418881106050308024257778517338354719506679831";
      _weight[4] = ".7415410818640572896643467181854132802159376843867967796198737741804690263271070220679765515149107995e-1";
      _points[5] = ".1465992001576654169265658426695235179279442290125604632515204687033228653332772641236747155787630766";
      _weight[5] = ".8244480981282290515415823938756621370766471158374133208691690370659610505839603497230175086082115485e-1";
      _points[6] = ".1980466041181826148466050402800147983667787135049020201401014006434161174885707857036810715432878876";
      _weight[6] = ".8730240757260692599058627618965695877333537373682736038372387813522711622922491115184985620360791810e-1";
      _points[7] = ".2551232069716869695768287350762534865017322609522133051615515472916441580767357518665803492792871822";
      _weight[7] = ".8870674180083961237725395424888980010638767505799639849446421318828518370656462205089634953215847250e-1";
      _points[8] = ".3167657887104472718342111760237885655859172188291768643815974689978323961699472361224441678013379426";
      _weight[8] = ".8683750029083565581666905153333353034148761155627255043342898156741359986662248660638659974313738275e-1";
      _points[9] = ".3818260692567502030509512762811186856943928877507787697256756013761460030692112995057041549779558298";
      _weight[9] = ".8205559156388180327653087723778992847221561856887365139092586395278825727586388000965819474762431935e-1";
      _points[10] = ".4490921009868173325138719504239347417475929920954648897808863573672971601962552955877951121911249076";
      _weight[10] = ".7487223293386003847932596237778164765909771195087018622881954379418589205789644518583498915989155595e-1";
      _points[11] = ".5173108459509911200513628668417419502531014399509647860341897330139076887981516467821142472826215626";
      _weight[11] = ".6590811757077106807977571305735299366400317729192485529773531632140783267376844390929590547508218280e-1";
      _points[12] = ".5852115179512991297552453346740838766873451701532765634475564569305673634168154853640549882370619951";
      _weight[12] = ".5584574164688526249815932491291670258280004563995038841006871240856953599982233845476300338102841800e-1";
      _points[13] = ".6515292548958144740358068223118511349859101369629558312595962074831187114090178549434212259989474758";
      _weight[13] = ".4537845719632199076042572155228547303759643411880068270661964657070462859342870351180007030550233922e-1";
      _points[14] = ".7150286804747624026121578393379999446389645236341253188769096134374679986116977432704020454213976672";
      _weight[14] = ".3516003512030458548547005431414484593424269996086323158449180253002667739460805295412856717443265201e-1";
      _points[15] = ".7745269160648226353202027384109920682527303908818411141565719030087724957529183987986099954836781138";
      _weight[15] = ".2575846056273067939269641009336137254927228722599539141507122547706125044545784147220467239774912148e-1";
      _points[16] = ".8289156136217265123540054985427691593398783968413130229560818673737749864709777074205767676513684912";
      _weight[16] = ".1761734488022181417634750650161074169827888941368967387824436676905266460390992162845846544121165208e-1";
      _points[17] = ".8771815974654200209935832382780264667216854819433063264149961682215358967027150316006842063229547836";
      _weight[17] = ".1102775020425528202183274932690576622802929805904276532381154234944322175706675534281853899145454089e-1";
      _points[18] = ".9184257249898492632792699442543246960817983206223100233229591659202425806838473116664400173192551525";
      _weight[18] = ".6112428226300807468928605022472388819840529336780360990858784903836597627090362080718578613558494340e-2";
      _points[19] = ".9518795932297199145233254132304692539088438686423388255790172833977314296065333707540227994344747218";
      _weight[19] = ".2823533706278848565916530037911878629982887095586678771104423447725510221470260596622430459254364747e-2";
      _points[20] = ".9769196632371288671781665711370362045685576491004758259075059336129642443913384619385342626927520534";
      _weight[20] = ".9538558113180135180967949786628451294240092743928687244237285896188821328575349981455725123257991770e-3";
      _points[21] = ".9930774850443482149030021066415407683406700298179706308215188462467044126812424398542732069635953078";
      _weight[21] = ".1605964338749016320576856292150734027974336746659489676629679245638257528017707162633356434764222922e-3";
      break;


    case 44:
    case 45:
      delivered_order = 45;
      _points.resize(23);
      _weight.resize(23);
      _points[0] = ".25086896389827444385828343050849707544655130412157952440372916981066025090909890471445388854540714e-2";
      _weight[0] = ".1283316522531259794007885886339914920378556125005332675794854529923962637518005783894453417550545350e-1";
      _points[1] = ".131709850003688878183339388300849730423769365649806610639845098755245710145875360535960812816828176e-1";
      _weight[1] = ".2934304620092188218926113600741607806739210817537199870266151443933950832690670503976083270668956333e-1";
      _points[2] = ".321617276826354932640336756565355053520576656520166453171268662440066582037109860381386933472833722e-1";
      _weight[2] = ".4463725220786037308362066413240402086136904820699921434316677932141270933111474705923921172096512584e-1";
      _points[3] = ".591602846138907652332220657736201949778825056877930704578476168575747178448446019469938418842188812e-1";
      _weight[3] = ".5806819763322011970374782113924425761404511862778324479824299752720919807911566279375389922009886300e-1";
      _points[4] = ".937052342256398436693902681070159943129484335537998125508059653663342988274737353712839788132662842e-1";
      _weight[4] = ".6911669325016075584493212610566610721140551761560671679530417625630597260007129822813763392845246470e-1";
      _points[5] = ".1352056309863808460458454746251433160911708193841602999666708950632019186174750867966318879969585417";
      _weight[5] = ".7740045437700328926473449453186946979485005699189929147909285069627000897494280716076551291719096200e-1";
      _points[6] = ".1829514347762067378172412190531632831474222483221057392796548221726690126122649180736697770083182074";
      _weight[6] = ".8269256057546193715477130820235096515571599625521525349385431798507764427936998623641731528560107055e-1";
      _points[7] = ".2361257194699659752033367975673903519867094069780877665480629132753104255091235776405840076486320994";
      _weight[7] = ".8493096269792264883907527383068975587810407136558906032073556299546435535076532045263371654911045945e-1";
      _points[8] = ".2938186667005872290547424363576361134204043156282958233734911798438694506857100888924860114111920568";
      _weight[8] = ".8421756232457493979943437980297802638058106035661088138746759718641313900343550501435144093387029445e-1";
      _points[9] = ".3550431384266732981536948763163021427209776085086219647490204456653280019775176349750919633016300716";
      _weight[9] = ".8080690215257658597452762845490596703525596328546181279008243628500936409123153800589940372707629465e-1";
      _points[10] = ".4187515692045311374092315829147009424821192511291422675616536437335683699790579610322750663361326696";
      _weight[10] = ".7508529186083901414100526577407837545431900256520270901278341770173066637555355144434418735382997410e-1";
      _points[11] = ".4838538912019967973430622916413376995836676173698294055646030869616179182331776207634155618518804048";
      _weight[11] = ".6754184722435728497520002182184314434614082127218346806093570515182043965457234703866461587667979880e-1";
      _points[12] = ".5492361859337143986849444709434036999595634258787999588444642290913115681454981608358155754321058537";
      _weight[12] = ".5873345966894180966241572944644661616634652469095377698346786561882559594662330923115818784810304390e-1";
      _points[13] = ".6137797438222284322478251318001054000017788712275714851022029844218004813706509166663266125837282715";
      _weight[13] = ".4924611206265319667827944363701807174968086942310183494453035969494685072370452468029153544157499808e-1";
      _points[14] = ".6763802055359521297445541267501844773125729751061369156714561779908754921014857822086096522112308806";
      _weight[14] = ".3965518934812491259255210861264327470022577186405535879400719450947738484245734895817049703050119400e-1";
      _points[15] = ".7359664575449968693948098166623482992411491974356738064983977465191447748707008794380155771341181074";
      _weight[15] = ".3048748451352573060772721176350031611003474117711489554566270549461388710349331159902545415318204602e-1";
      _points[16] = ".7915189583921991649995448115618995639698665304943579027528512918922398729387578844199069430995902060";
      _weight[16] = ".2218746826207120887276263590638552621253197931251564408631796147019043169238537869081644237856090616e-1";
      _points[17] = ".8420871815760147938272551090762841119895322905806887532216879812775912541917310769974367310218997846";
      _weight[17] = ".1509008390394755517476464908179904728950585618281600061596910970327096104697896113737910320729447623e-1";
      _points[18] = ".8868058750607934334740477882285871206071403541849894413037182530711360933825476533262438961100101040";
      _weight[18] = ".9401868666227652995952585963231501422382957680697780965957245463094744102323209704629371165729528365e-2";
      _points[19] = ".9249098542075925823337164109969201318994696513183952026689198527018630611553347105313285453711818318";
      _weight[19] = ".5191620446910720770096011274932118364042720186345085236614939007955783549782982195562741045147826195e-2";
      _points[20] = ".9557470550763801263062809349956559935085465719725784751899715881063639154409472040614620018948967936";
      _weight[20] = ".2391164993413535831600994583419511700235568916766570267257880249998309203933376284348100425652683408e-2";
      _points[21] = ".9787895175170725588787939186958919174534641597824532080283251852183454120155341188680323899069676110";
      _weight[21] = ".8060783183419481302475769328811150712121287430918492847770345087224901752876520422652122466796400245e-3";
      _points[22] = ".9936411423413659674234674659492144344825859906238375139346624942288118730536279398452978995101742693";
      _weight[22] = ".1355340856302997732120741308975842108365558545642253331618034336109291707704191634410506625033332500e-3";
      break;


    case 46:
    case 47:
      delivered_order = 47;
      _points.resize(24);
      _weight.resize(24);
      _points[0] = ".23121076177984915697052766710910895549393840036360101897093883189050514570298921845144940873498066e-2";
      _weight[0] = ".1183066055113336862806942240007326328245558099447927275162523552741007390766368641044190307360615082e-1";
      _points[1] = ".121423037710748970539161894107291226052275516244601947149938013721604220294834850476248863103407454e-1";
      _weight[1] = ".2708890824143026572037962662152288020969476966472863417825282202056481771333289850443734731951459998e-1";
      _points[2] = ".296648142140688469429651809241502051764854189590573794305428483666255585319802945970872750545961716e-1";
      _weight[2] = ".4131359852028912070813348612469458121266906681977047751086422223751155286109440455542634286396419224e-1";
      _points[3] = ".546072632835427812988563452865810999567590785733821281956191007231946426189366729765185738119560742e-1";
      _weight[3] = ".5394596868921663524498068262844092364170052310862208007218011372940229373250922674094844211297475960e-1";
      _points[4] = ".865767827550265315302788514920136620491530967532293755865061359260821023700663119038016240838011818e-1";
      _weight[4] = ".6453135870842410635528940758432413674737559106054908567625814834380452190132723118159379279108454855e-1";
      _points[5] = ".1250693120998313816827247034321147372716372812643793892831974422340660561775264779754430133711736113";
      _weight[5] = ".7272392358209171859073020012272423331634752635725114961740036064699127019826765310647654099763657770e-1";
      _points[6] = ".1694778408374137992122551210880916091724440900194513583551692099521297695569503211773284187174575248";
      _weight[6] = ".7830217864471200784132989838038854530001015874197726701210669511616739254100083028981782541128242990e-1";
      _points[7] = ".2191020363269966008052502214870027886228146700884203403626969975224363594600835115547810175625647494";
      _weight[7] = ".8117812499761111793897603388086616924056250529426903044903261905158249863418553775020821285565607940e-1";
      _points[8] = ".2731593030949704981198326346716482638665286879359816866038841088473610512662532110402010110389662081";
      _weight[8] = ".8139860229396257985108057536193088271685230951096375019039633824613643145339319826460674182484131945e-1";
      _points[9] = ".3307971297342992989465449797634122839351353239458986043016484038687065359502901031392280699179553764";
      _weight[9] = ".7913874651520938929265736761457077631574365663020054012563532141424833258155611098929166716363561785e-1";
      _points[10] = ".3911065354271857628058029229759407587117961441488460253702401794353555304627992294123975242415039216";
      _weight[10] = ".7468800138191237704937459456995169435294967932534591746282115187766476994517745985562126268100280395e-1";
      _points[11] = ".4531364059378609233872602564908296475944846220926500743387614702917419726601357431551427286510223686";
      _weight[11] = ".6842960472039024618212495432963431108894080844633652827051493472714512862008051584998227091418043710e-1";
      _points[12] = ".5159084936202979568506211844229575689363706436725780992080644753405181129907634992160172026059024785";
      _weight[12] = ".6081487403303229439557250461246857543106709458728555540542244478846987123597889141506562545922541260e-1";
      _points[13] = ".5784328451129381173040996319869945856313733674576909278189693731645225384582334961614709864014439182";
      _weight[13] = ".5233393229745876141906451197180871793300976215540282985419030015323189126408906128503865664752988075e-1";
      _points[14] = ".6397234134973043576554117727135736996646600113714081000045059910790721633790546552645982027501322789";
      _weight[14] = ".4348472766572340728540928114789743818624545599387243885741710511492122452733704265550252406972614456e-1";
      _points[15] = ".6988136087122555462016606377145350834461598850036410982928344624206350632284010299704447755398053858";
      _weight[15] = ".3474229649484084003930890647846262727505108642173711331754141432035930539668108322663152396873325551e-1";
      _points[16] = ".7547715409190971048511486978937648589061186652744929259781655167672301711625351688732468834021431376";
      _weight[16] = ".2653019230140020249207268704743023175850973695203784071226564499171372408835572203998397885360695694e-1";
      _points[17] = ".8067147162308662079759883230462271215511214289418775696507626148867661530416063674514532295042284498";
      _weight[17] = ".1919585570453531090274182547445749150555233627807191180519025749427489117067745137550248265840894570e-1";
      _points[18] = ".8538239525472523950102126950475975286633013398103204851603925633645574373545504247981078805449910134";
      _weight[18] = ".1299144166781244007855380199287793161149080700512316783535285734348566786945346584013675225762067370e-1";
      _points[19] = ".8953562946217610669903735651020598427994962565161247360082353603807290907387866393285046179471647462";
      _weight[19] = ".8061266812448580930088891626091521017798326749095430281313277537958062872952727474091698452797851500e-2";
      _points[20] = ".9306567200768073264940897342948113540892147989736239490329954181172965522690414938590459685654113660";
      _weight[20] = ".4436613641500169169439699970626442930590561207013584324589174385384877629658784768911207363910107724e-2";
      _points[21] = ".9591684333956145359195940133146757910921505457443845505930704566821066595074815881415270673833559457";
      _weight[21] = ".2038157139126920074596463477698362039463527132653415267345710996681106052705444231857296200602801544e-2";
      _points[22] = ".9804414867720773047861990092929623254654564518007672132576640373798768725183629974386659808406819024";
      _weight[22] = ".6857923806901939716180130215329527076359172887024981713091355795707735117444618081210374293793006285e-3";
      _points[23] = ".9941387002099847972174529494354186447065590111257385945879012558028220919933208547206036697068679643";
      _weight[23] = ".1151730150479458384071635595253101782832122745104808509747143553195202907771103803048666290791529852e-3";
      break;


    case 48:
    case 49:
      delivered_order = 49;
      _points.resize(25);
      _weight.resize(25);
      _points[0] = ".21377548407793250970039960684843411705311339444511237846084287164651283128895545650774241146434717e-2";
      _weight[0] = ".1094107579169813189091237608942257612915731472352215860492901940875784817684822085978414229013138839e-1";
      _points[1] = ".112294606056524895376596449529584216087860738616504742252478138001634604024868942504955508350561979e-1";
      _weight[1] = ".2508327722702107727564330652194328699205195700415177187291626937632732713366479790665309256342352607e-1";
      _points[2] = ".274469434643197743434582952393301677966795058332544771415907730879432148015830814776531097817306074e-1";
      _weight[2] = ".3834144667483376494444168127629636943855168654307775524429254616965643468194663566288194639730568382e-1";
      _points[3] = ".505573803692126256348059340964892863963929190056692616509419415212892573042434210511409457696638549e-1";
      _weight[3] = ".5023107977579624293082489939776848612795440206268521504827201101988163471721421863248506065296455375e-1";
      _points[4] = ".802242209123347788711806562294006865192884691392240487497176541792428819362495039574470334376345982e-1";
      _weight[4] = ".6035303547197594011536946214697428562244105735504644592761780204490024094524008923006620806500516360e-1";
      _points[5] = ".1160149645874870172347350473465606669489106230158662308693922678144886136045272672526553037082935272";
      _weight[5] = ".6839537544316108834152713171531975770585381497544037444937248176128482598116938100169829409365540970e-1";
      _points[6] = ".1574077383886659652193159384891105328541375646502171946705997212341715684439550613338558276683800542";
      _weight[6] = ".7414640177550565019867457680187590050097479701658588964064176822972214718382922048913128461068316080e-1";
      _points[7] = ".2037989575831378225336879722401727700751661453631751449300676446592974173952675347684620523747703692";
      _weight[7] = ".7750307846489530106069001626917005366648185167101180936037628557609221967072401671463450510599048465e-1";
      _points[8] = ".2545121408770102731752042678534638511633337808460910662787207479083865625018202584499175428930839522";
      _weight[8] = ".7847361442854745129999858918728471494155807095267460162304348042572581006206020856357340736118874090e-1";
      _points[9] = ".3088077795622951038979119439836161009663783922166299606375840033527997031278586274863047483670254861";
      _weight[9] = ".7717401233298538239701017926660146653703606970898668982214027556915412179838143641951278835213117650e-1";
      _points[10] = ".3658941229846370226364064314991338752818897598016621885592227542838233793054347295626319302125106144";
      _weight[10] = ".7381880949267258745570611132264679808177411201634040263123836073740074140392720781241131139297758510e-1";
      _points[11] = ".4249387248171481696883001024393147385589320252409908017977547745824610905505913984042249884129209462";
      _weight[11] = ".6870658133314383697685351362085691413583117735597939494713400804125932270303523200365795429917671430e-1";
      _points[12] = ".4850805823554158825739775389860063675732738097640718535822201240883097297180151158721545179097262209";
      _weight[12] = ".6220107820158806088435333669253889377963299096493770394973335210519773180746305069290850138698745455e-1";
      _points[13] = ".5454426920332588243126070891910049145712573150611219268116870762412938483414356567846858208870956794";
      _weight[13] = ".5470911337993017133325658954591537464613243821693582754945733906555848787274909343811964787857264475e-1";
      _points[14] = ".6051448381551349081424173890238120465852778156899718864521872811406263759015006314129890759192133066";
      _weight[14] = ".4665650137559238100136333265315206043659187299633210330041980122434126791481360689974380076448028813e-1";
      _points[15] = ".6633164283801916080438663597093166623213491788613272167696983082588163829549425343365271477378754116";
      _weight[15] = ".3846345091061473349290245539794099303708019282297091901740137152519600363961583008523285646670092169e-1";
      _points[16] = ".7191091887702756756924733312759952703610235950003264675599094080939261671384587307200102973531914276";
      _weight[16] = ".3052084060846490888777912318780060035451395536472057323180285253178882915878800370061906778387305039e-1";
      _points[17] = ".7717095332090876532772702662299137017534216024796653237460220724084526447410338907367806228629368562";
      _weight[17] = ".2316874597448142681430272573677028827491415078621799535354766932626957753146747980664577809278033180e-1";
      _points[18] = ".8203504266385679362480414025046644799692216902498877451708436721193771528836986810945627036059214166";
      _weight[18] = ".1667844746417703482858827412105202654768663139416267562768610651187442182435611008344612761759961254e-1";
      _points[19] = ".8643225686575712512890930964464128884912645871039346858755335774412004904375538141581885649622597640";
      _weight[19] = ".1123893942176472911521814402227084965277093149641017025250777628933241674291632070615825071755884010e-1";
      _points[20] = ".9029847330954237846160108102144816242809611079263960417211087101890827959775348038191523331937766486";
      _weight[20] = ".6948690769948242505642979580614419393522896096818128396177316145957533715002768998560257404965457315e-2";
      _points[21] = ".9357731085313031293882544650031356312195798060607631882567272915711012342389978233465384997918019230";
      _weight[21] = ".3813096281420520842348298710895950881889701039955631763288577889908654722745077399685025735478228049e-2";
      _points[22] = ".9622094865907311897728633977477110034871315310658131814516887455258441299589536187221820682340020902";
      _weight[22] = ".1747720324216249475087491502293789694397139287420886663505338741268344649234561021604621628603846322e-2";
      _points[23] = ".9819080873346961325077074435259613225499801670479781693750962994666519993115924159471265473976193223";
      _weight[23] = ".5870930138403858080781133946229403539078885793604901154230653455535909040354642990632606770200359905e-3";
      _points[24] = ".9945800980399753817559432581349211965154392439071152418926132220402749667878063230382549504120035082";
      _weight[24] = ".9849406172470012342729183797120306729289956825438560707512493759046505877196757172280866074569837955e-4";
      break;


    case 50:
    case 51:
      delivered_order = 51;
      _points.resize(26);
      _weight.resize(26);
      _points[0] = ".19824023125009919747645087015092031881870923563100705499480362605097972464274428566413643180861874e-2";
      _weight[0] = ".1014808420232600024203421407891864326967813611225317519604953710526452069416772253984767498904498430e-1";
      _points[1] = ".104157120350925266682191770293101467493547948510681652442318719181039024127684327072170446982718232e-1";
      _weight[1] = ".2329114401400434107623960101019748682844868035669047120616072012257778273808340621067386617903738086e-1";
      _points[2] = ".254681477504560134429207505854270137501984164362808123733523963858049364643884008986978728652792768e-1";
      _weight[2] = ".3567383035949472508322253846200779250258506124560617922629226954076677145218050153666541892375190978e-1";
      _points[3] = ".469395479727239002971935211591535637354607622088211954298917406048933258703348237390626319812966856e-1";
      _weight[3] = ".4687405429551426087558989633323650022463453467699547900364888632785840215419132950170713312725027756e-1";
      _points[4] = ".745399674749774617774821230693383225642736754097029384714471239364010178892953245719096130536987463e-1";
      _weight[4] = ".5654047670425408731673641746840444106706145938580495870768149053927784423957084294479367225322386200e-1";
      _points[5] = ".1078962587148670518369933864179128680363862543318018393308158240698289232868109968676399249029241419";
      _weight[5] = ".6439218521754601961609217515415748254965335209980546776078885523102830281793937574743196400011578520e-1";
      _points[6] = ".1465573689781110622454405645211420385843833471460570019307330150135958433471094540487915029769824543";
      _weight[6] = ".7022960671117586974426525058832575750953055446936506488322864597988955028307342935889612007552575090e-1";
      _points[7] = ".1900004870599828336341439787909794085126181077453390929451879495109536533280805490705145871629265262";
      _weight[7] = ".7394209946166916222101129200752939221868094362783113220849632853398411916937608256518092583361741945e-1";
      _points[8] = ".2376381259328170562198557150947490838125062796023926838503683108907578655346968932790673406258905671";
      _weight[8] = ".7551112719749781844218082919566389510580336585132778769206085830750979488397455548961364119995051485e-1";
      _points[9] = ".2888260716927312263060031147583258288008503288275055379968170057607358670390531602234574905707601092";
      _weight[9] = ".7500879353237672763699801406961978229108936240432004642829627625630132640321505130936349085986451175e-1";
      _points[10] = ".3428720970842849252151378642974238623794694294290994447908012269211766838901167147393952220069469324";
      _weight[10] = ".7259183277120186241203571905154515430079599767823860996443231425840059721696847173875847649730612775e-1";
      _points[11] = ".3990453234002412501528182579168397671593845939181776667219899610514800606114315767563476820928747503";
      _weight[11] = ".6849140575169568012668800722262161522613334377457403128300937582927520679256050458344419628226693550e-1";
      _points[12] = ".4565861046963797540479864485503725667356963030172069689574101221860311846558745203443032208709777164";
      _weight[12] = ".6299927337564799294914832905905277124462503427963309452997012853782168724233937070149924372893476690e-1";
      _points[13] = ".5147163008581420013517072616386541097050830876907721189103577076394249053259770218196995276011959180";
      _weight[13] = ".5645111126600675970723965470326951328705426502217116239087105685107128012521637991950905294860651560e-1";
      _points[14] = ".5726498006750368846698153034557769759301843942142236134513678722424631571284058108657451973547353036";
      _weight[14] = ".4920787783957516399463353490332616402964507354307016190860555769829433495204703242645409835846820768e-1";
      _points[15] = ".6296031526463668324400058351864332464058115851881460382768378372804372721501046970140265988107221240";
      _weight[15] = ".4163624742448221054690511799845617999254992276850739950519913819788930854925306643839091326449472762e-1";
      _points[16] = ".6848061597563768691573930360166283266837702181638087861103877824608012560472566171090269983928681481";
      _weight[16] = ".3408916470242993251882218894046125122731292371714041110875776292446406522925454370012819778710549801e-1";
      _points[17] = ".7375122949172582536693195662187433097563287951254783157564549381318449761373581277895857265168695457";
      _weight[17] = ".2688756442258594394198564943536074963802617244572964250768720667333181166040705692347132345644914920e-1";
      _points[18] = ".7870087961593147963280802382092863076360161431424960256226740790350169217338341468378251792332276716";
      _weight[18] = ".2030423177222357942405312178653612755525415648826535986135120681968192455152752689740341632709244092e-1";
      _points[19] = ".8326263048793096592840319901487043552909483798146004051450267827213551566378150192788626666368145451";
      _weight[19] = ".1455065777740560048945432725678785020079291621240239065081833184010255621019635602390937831583437630e-1";
      _points[20] = ".8737479163770055563444293398713444395647730795686451952308337238766361425385557764556171897935916430";
      _weight[20] = ".9767577246988349844368959326074245339906130164224783443389859320911296477027153023249456138231528250e-2";
      _points[21] = ".9098175190772664572577288936685780032938885885639025695186218563884849263622085581336329392731512698";
      _weight[21] = ".6019673135257074110480920880712994889898064197316878936261920311358339469987576574531148022946998145e-2";
      _points[22] = ".9403473057218671707575661924897942312565963618065724508702617539552909102894060455499272532250318548";
      _weight[22] = ".3294701834427150802711378133094103566373633324556116068118172306506898075038472954763112718183132090e-2";
      _points[23] = ".9649243392355685769676789331181850486069916808216714189009346206348469238729501303425886192745979016";
      _weight[23] = ".1507051270060215245738339727124017471225049056873612094515045979327154650350622172692114155471249897e-2";
      _points[24] = ".9832159998661838487495423597867820380401895721015838753714698965929400840517768491779043505066501448";
      _weight[24] = ".5055010659316268156697904469713558505999011355121561471933639284915004498018912965832563274464540485e-3";
      _points[25] = ".9949734758572125109018548468457757451414034454994678437134746777377314759592836642394933873290997110";
      _weight[25] = ".8472664822184481569473276054473261264196596178442728711569057861362351225167742103870822977949366515e-4";
      break;


    case 52:
    case 53:
      delivered_order = 53;
      _points.resize(27);
      _weight.resize(27);
      _points[0] = ".18433866615938319677267356672958288739159820828326729613027074230462450661168042815418798697647316e-2";
      _weight[0] = ".9438203890880110866596413809031958726344004381082942643778752283009119164009190109396605527980333740e-2";
      _points[1] = ".96872310195408052738280815042821311163596594675494452671872254232231135230100024378444976093547779e-2";
      _weight[1] = ".2168341697171634922387206163071664777223232067278973251502576675723184728219216643004024085976216632e-1";
      _points[2] = ".236953482391501070838249724425648106801376223769131434045048470162374651829847753625290346598185510e-1";
      _weight[2] = ".3327121392996553082051253960656141674676698664874091138577924743699340286248666374931987662370317074e-1";
      _points[3] = ".436947358045580001376932446429401974901427110547333258428295124237890327258015779998153557350952520e-1";
      _weight[3] = ".4383223890274716207783270394301581492732858579499438231354191010417070821260416813700804750678044807e-1";
      _points[4] = ".694342787989322199730161870599743899193417310335786837684089594535236674250451492247500562398383284e-1";
      _weight[4] = ".5305637157700611567035240177857449090592886836998970530450787053641364840432593332957280086420584840e-1";
      _points[5] = ".1005903811326853915190140549903467621805094580706385252308216095694597532629310010567882974572091808";
      _weight[5] = ".6069078747570479786231324288739386744739844478687997246810594496612261624138048834338851565688807470e-1";
      _points[6] = ".1367712682105524376025683748648899727450342665933354412753916081149549203877273164378926296500355280";
      _weight[6] = ".6654908535523464685397561098642480640115961409995553567285259367625967934405564418116194183134176190e-1";
      _points[7] = ".1775219573659193028130614393988634183199427689032530418019253526001223410476168743574185750257463319";
      _weight[7] = ".7051803275142590627456213690666551450110300183953213724808652522368240015081698904312405803067309600e-1";
      _points[8] = ".2223299911830712808191360033542121533705911233623428600494451493718258335612207931646668848912204772";
      _weight[8] = ".7256094481011321558801623950042687835571243590410499523542589298533471692607778934127785957673929250e-1";
      _points[9] = ".2706318858403828388174545619009036764776417627277516962633080821607300256186263524972127095298013404";
      _weight[9] = ".7271747407265305475209795588052125266906429056397565154975795821613017654667180666213671765959094605e-1";
      _points[10] = ".3218202187671672377769064975778236252489272904134530562088575656239167866863330675121375687111015966";
      _weight[10] = ".7109983236886887427029839467974307139978913310686388388211605126488499602691446213807129528452625830e-1";
      _points[11] = ".3752512679997629534933730456435740542694401655843067372579497841123207581560234471930509217275150034";
      _weight[11] = ".6788565307649292039687283320238157402058107784817118583358955398507924022035164383119891786003108590e-1";
      _points[12] = ".4302531076729567979697915582545114448017590910700067673138678746580049425247712359442692580026425598";
      _weight[12] = ".6330786957011047808854565517611624075329395117374875437813393453496000829664673633228191742678929620e-1";
      _points[13] = ".4861340580315818421058114797416192564413484426519500339155726695708358463696974111905124066085644960";
      _weight[13] = ".5764213229207180802657160281800379487874937184851651202260951686951263830209716610394437458473375140e-1";
      _points[14] = ".5421913837761862949497505196736063188110717433003851565440307389535776130912578939384032088911835582";
      _weight[14] = ".5119240661403538109314247413068615838127744479416697841527953461192940260522878214085058664786929485e-1";
      _points[15] = ".5977201313878155000196942168596513335913650222028782052701089676472197217513431621531390052097054438";
      _weight[15] = ".4427548090437451660491025534447562426298347549475397396883089254063283354707283443536997789447245244e-1";
      _points[16] = ".6520219943065595128144520218202029835324140443758028088226666444218422243992797923412452670120753290";
      _weight[16] = ".3720516474612843252115408793185275353855779065005451754273434428797531460701296701493334494924995782e-1";
      _points[17] = ".7044140944718857265433052486560377972151930169197974524635302295609988027848098312397552342521119569";
      _weight[17] = ".3027696861193742610784335894757796436342078243942527942081998530055037186894711078030414144039695370e-1";
      _points[18] = ".7542375697640191565673740509855886563757234218511268984625872592197338373290508090761113687668744352";
      _weight[18] = ".2375402799044424959072051962268325181356197297482915729116896189554605021009758096115809530389816060e-1";
      _points[19] = ".8008658592874873234732464957552331150349938591747462274480585030882443351844636275401613601250524438";
      _weight[19] = ".1785496844943601640277750879058008805396662109216816766106464135700233982039264716056288066955816288e-1";
      _points[20] = ".8437125821466905369938778855425381743397595579708781792466494145717162173438121723567149172814734067";
      _weight[20] = ".1274430680310793177156887614511325415420672227449586320518245942290155190667429505525537942126742114e-1";
      _points[21] = ".8822389102341396454689826313057027389226267678942236210056160455752391145785184091546650419162954894";
      _weight[21] = ".8525852555960638572219657461707102521891573539394917046403114188820346919404426896026959892511361630e-2";
      _points[22] = ".9159603411903557702727824364325821830316077077386156250540469597358886472259235994667255020111472679";
      _weight[22] = ".5239419741905222510689162974228147278566274534968597513495834319549298869840982032689125086275887030e-2";
      _points[23] = ".9444527826987507331425260090411746078705975423460296253295198573755605731026031630850456677387687427";
      _weight[23] = ".2860989938171968740611001933779543816374542989923606744174802748622344893560754537564018227295810619e-2";
      _points[24] = ".9673578569938134428880421814747010652405853495240880018419563528070170982699121805787035699931610092";
      _weight[24] = ".1306291162482041307513273595746611017270220411081977254624897447679861162403842854670567150585465275e-2";
      _points[25] = ".9843872802327865221402703305050865376477358992329912305682706127051502754664076249624229033974675143";
      _weight[25] = ".4375835695954694319402968526394878093805906978934431788809678901563370832892874754779046854248855268e-3";
      _points[26] = ".9953255513271093328270351894495473119057794466212460828361309213612753533892573799919314231415207025";
      _weight[26] = ".7328186742973457248973346335268348308990106749721830402804514884874852544364092321384933744865724135e-4";
      break;


    case 54:
    case 55:
      delivered_order = 55;
      _points.resize(28);
      _weight.resize(28);
      _points[0] = ".17184952934022466630280207712667916449961819346023566412434986689636099007902625541242275441217367e-2";
      _weight[0] = ".8800223579860048483254710294217191577207739024953436339979561240637942739941017303195392091558371120e-2";
      _points[1] = ".90325184953100172901826680083097663354607101758299558173017968869500129573134212735539999233447304e-2";
      _weight[1] = ".2023576838137988786034698670252521582177125525959502980263720470161220865339795486195886339611684494e-1";
      _points[2] = ".221009813577868113726852102188806294415116094659876033179616599969117414037707455473861775983747134e-1";
      _weight[2] = ".3110015822865166067702923886015083025462579664580579398440848573178798449726498247220803134991446174e-1";
      _points[3] = ".407736110197750309129947437116760770693489816252020484571557572401897832374419035885309251340398314e-1";
      _weight[3] = ".4106881180888533341596419244898047338318591795943706620487407038350580428826353390241364012198871710e-1";
      _points[4] = ".648318503631075240976192063907666100992612222184161087421690558762267022351845203316493552458384612e-1";
      _weight[4] = ".4986722172799528536062300428357175719538303706187497370739264376729336818031041386693861369974652352e-1";
      _points[5] = ".939937256853133658414060403798865751400392882474130913839852491309167398208193449175131469558199520e-1";
      _weight[5] = ".5726781728496770116342685381854171257294862281728752208595617722281137028532049290924545670569594165e-1";
      _points[6] = ".1279173699497222880332522902374298487321410081872785108652567404644903241925006868210433634637058416";
      _weight[6] = ".6309759998920903832871619063187736427798328292865043490361484313506251495597716084181167071470161035e-1";
      _points[7] = ".1662050715215077754955928759549225525500957899853919033389963748850263839788521736378389887243457290";
      _weight[7] = ".6724408184431729629610348227194436576417121590563488018244433962007116416697608344776238973716037990e-1";
      _points[8] = ".2084079478245644898876042894881013130324364643445421872994684928640539779603323923616045542186025370";
      _weight[8] = ".6965864122232914783245525515766061197702074092320849650604718467156459693423628053637574066344839550e-1";
      _points[9] = ".2540312117051822502779332060989567717949333472202278170522577722830524357606964327183922476911471278";
      _weight[9] = ".7035708558254015342678361194760470294443631209691896475761189284078684747935547051565534472259177100e-1";
      _points[10] = ".3025399737754953580740983330081879191259593540535832168511508630229688726585007098583484121226723719";
      _weight[10] = ".6941740067534460029436271363915171072939625027199343826210971389695270282935707154096891907595896330e-1";
      _points[11] = ".3533655141226461443509711091964390610724843762952359906320931037906887192044490676408869047345885827";
      _weight[11] = ".6697480576198529947544249860329464644901197190434949442692233737598107738389930962131631795027036900e-1";
      _points[12] = ".4059119503245874996847819872096119528855570149194244408537244840158077666547928989884755351269759842";
      _weight[12] = ".6321436026746541740578527862238867356580627473567945958614016390860714467272442769773655632274854830e-1";
      _points[13] = ".4595632237739050247007580803181932916401376476628329857646448103515031096132724631061051072771519328";
      _weight[13] = ".5836147977632291693862247694575220416360419006726144133894084241127940580809791871084881643492680210e-1";
      _points[14] = ".5136903224747328748359169275644776550261521565143655052175059751887984135439312756239786212853367327";
      _weight[14] = ".5267081444046336301346320191574594298873507545356939242387535251298683116224294172328249432628441325e-1";
      _points[15] = ".5676586556635289639505490890258515210526632876626349273181250891130814313326060797131782980779631320";
      _weight[15] = ".4641401659297863618279998467239187373005512892102633459543014117149358423998773507108652281038679944e-1";
      _points[16] = ".6208354938051186180751604988886875212206555915139963242977997641728491315993006032194731774639848880";
      _weight[16] = ".3986697332843073130967213398614351494726775297770389920047505285351725313484619757114780423331171052e-1";
      _points[17] = ".6725973867373374963190421178579525574571588976574083160637357387177511124421386108602402867292366287";
      _weight[17] = ".3329710179283746617377097231688107447881161015071885848544979051240828473437080881621446821160526426e-1";
      _points[18] = ".7223374729826939086395173882436445520337460324133837205062443405405843577730351703929806948350872265";
      _weight[18] = ".2695129894362714574317820278902739133656214753061143720194269756412480787235284583042023249985489037e-1";
      _points[19] = ".7694725945042181706805050432690356903413932244153720708644567415131536687406382160956998961745972852";
      _weight[19] = ".2104510391067328185606724574426733926381029950552618742473734044634105412953922386528522419823967898e-1";
      _points[20] = ".8134501334282394697267215578375188617234481770369277012202582476084865180325716182203592738059608613";
      _weight[20] = ".1575357142381088974813226281442771906887412741280410221144539737971025231278995461878959784777956885e-1";
      _points[21] = ".8537544904322088788247775513811542988294457872776482108393252112089107868125245581262654586120796862";
      _weight[21] = ".1120427189543885884005076223431923448359865792254287286501113213756952844083798362642394278826530221e-1";
      _points[22] = ".8899131284723934956831712532221734523372783412412214239234061344184586027297876948955008948655267540";
      _weight[22] = ".7472731568327629262425404229139219420008809551561161327362666088823157856139752051538421851431710815e-2";
      _points[23] = ".9215021099473594085155151704718151363517054432469130506984103322769692925488804599027244231343456589";
      _weight[23] = ".4580509469313366317241966253684956837737283433524900914903528095852603465920170011164550038495731330e-2";
      _points[24] = ".9481510589669756248379883268157639950428963847697689099425419930439997189239613345109477892586771713";
      _weight[24] = ".2495982237871979415829687616319526354929321484971594260093162240535500992872031481883964558506331729e-2";
      _points[25] = ".9695474769380218769795841255378286564895236407683444524251818691481329207472659134792764782658287506";
      _weight[25] = ".1137779145650798692488932755719335389798893714566876011441140007340853951131875109770356496233154940e-2";
      _points[26] = ".9854402875829232562843797204417416195238244745167805643345209779564325262374245842623134551400908974";
      _weight[26] = ".3806839593599654687052937172487546861406951983143054441628893654176073429097708717517823083271828856e-3";
      _points[27] = ".9956419077642228317186491333620060237601315295415473070854638905269220407116028222638890083449407599";
      _weight[27] = ".6370515996210101725745472702265633711758913990764554459024871592454748893659112280488484445055915445e-4";
      break;


    case 56:
    case 57:
      delivered_order = 57;
      _points.resize(29);
      _weight.resize(29);
      _points[0] = ".16058778525400944766774602673933333757152836168603318045063743822059058587959310719939424595137882e-2";
      _weight[0] = ".8224759073026150013337165044732122149231177684820350074016830574690805752082382554858977265593501695e-2";
      _points[1] = ".84419488040311726917503051542707513592546426776604266478056341042086966415783126388255787418638402e-2";
      _weight[1] = ".1892773329343349779572660522959708923603067512949384638213060568878587305185604045792269427641210014e-1";
      _points[2] = ".206619336361591547601435345567561488815223432237067186292537886141820935501139082553158196993727352e-1";
      _weight[2] = ".2913224977147369630435371509591788516497127738021211468364733144940634553044053377381143399400345846e-1";
      _points[3] = ".381346969971121293156671304127122061908427724432955368922775580973517627701451337438444969461220516e-1";
      _weight[3] = ".3855192568110300992731787948569749686052539437629187659190769761585088614005755907628346504680199758e-1";
      _points[4] = ".606691420765822698190466170738797306133965588838233851279245200282045773648867331667482082942766667e-1";
      _weight[4] = ".4694309426636408371953486849927191064071717332656199572683966811401250472932076965971239929914353803e-1";
      _points[5] = ".880184581398872246511325645775070971408746674491546560679176980636058501053978719493810362381101302e-1";
      _weight[5] = ".5410079186859844844367088474395607795687457881564928149255949744070610415755416273615970676958635330e-1";
      _points[6] = ".1198830276848970432901164194721133615437473706091056747138979253876140849072260495061209040067645784";
      _weight[6] = ".5986514983088954149802257556131410370145028546473926100037200780395276628373010490616317656245104990e-1";
      _points[7] = ".1559137470843829473370606131417264220555557747384501978986829188400691312404561996585751299552526045";
      _weight[7] = ".6412659178073493294015772905883242677694949119956667273898712010326479351329538109259780287852799430e-1";
      _points[8] = ".1957158615701235346271845355727618654403065491060100053893129052945034633900434287495630167925547572";
      _weight[8] = ".6682903797752355680708798131643143756002374157820628443355072911779172499539671165753846813121174085e-1";
      _points[9] = ".2388532936333663745936940565623196065759316483784380767855858606661415400153543649197279531138628579";
      _weight[9] = ".6797092298173053445579386649110409707833752628689484884710968363254660466586108170267586063524069825e-1";
      _points[10] = ".2848534221035185149516172379240780825714158061355885118736472933422323566101288260175500745175553864";
      _weight[10] = ".6760398471965420388414470001461319453931749237342308586790232501846019357132809543458076332164856535e-1";
      _points[11] = ".3332122608640143309721523536351177737981679593513508685203846408997852637001956485169227428186550922";
      _weight[11] = ".6582988868215478831775667022005763028145817101026190730235325072255936333675761645812854225390013460e-1";
      _points[12] = ".3833999809061070668784747580919607726984317643808177613142919854072677369249366817102831666846690370";
      _weight[12] = ".6279484606213871827922785530254060818304508070323358845405923153953552222330567398669030144966779060e-1";
      _points[13] = ".4348667153860257491398700432703089870432644535249158432053836873358514943003487504468549993874690006";
      _weight[13] = ".5868247100441087283841989450493688012026853494073014267958587339102668812083850425895915857506469625e-1";
      _points[14] = ".4870485841530376732703106931946815813887093165769280917756070969164567729544177022621628404883829681";
      _weight[14] = ".5370519726261224517441839350484898995722099633288349579493820971087947368967875312163865815120067475e-1";
      _points[15] = ".5393738717727236992403103247034391839852566119036684134142180869297304990124736025268732863129619822";
      _weight[15] = ".4809463546398829869371533562782688895220513580178416037071732542065284736437622845049166880340602578e-1";
      _points[16] = ".5912692913707834829478765566234395995724095853348927353348565847908533092030035780849500293024165982";
      _weight[16] = ".4209129631860883510580700101232906094913172520881469088463222892379855573154919991407642591976469950e-1";
      _points[17] = ".6421662656731861238287974627913649707773183543080836828973314488493767488926898483696649824941938186";
      _weight[17] = ".3593413059728592678232574595449670370924216522382692396538501302643477845479560527760392817593801562e-1";
      _points[18] = ".6915071564230854286671345510916194350973455194579840038960101517935299316600829866562060441590159540";
      _weight[18] = ".2985034246189268703045850444863408825831084746850206015839821802101854257623979915267724844376644792e-1";
      _points[19] = ".7387513739119412937894744959680884811212751986011720468957062635753622921833823658529018354675298890";
      _weight[19] = ".2404591853972230935791201088077912861061979588079558439714543772093319758864057087945139004205025584e-1";
      _points[20] = ".7833812996605872372611127878355374096893314804833155528966749287801062427902846865455568229607413806";
      _weight[20] = ".1869728163635560116792048307870749321429571415331115426277003745924714046260312547581256203485234378e-1";
      _points[21] = ".8249079573005494156007944812292208906787416791393452824336661869940549234669086353363655173900740340";
      _weight[21] = ".1394442666818688026059107376377405494209665104256295061957681177283639436450565135033828690679829565e-1";
      _points[22] = ".8628763693862447339655591786902250565115750641387146145738370691343617140203829052848049853419034594";
      _weight[22] = ".9885829532976952297502565856123033463512360899385135623303387224673325024682566847647254849170246860e-2";
      _points[23] = ".8968705411002962316766114182292236819780119355812354874912319856093777036147736123027412055456321439";
      _weight[23] = ".6575340169921764095135252527351854065836319905993192237496403188926387421135809555119478357387455815e-2";
      _points[24] = ".9265180152719407691275609266113728355764496137049103876779217996365555765482396657211416405902146952";
      _weight[24] = ".4021182485231803386534230962943425794757388828963288314425169192269667107680391493132507691698657376e-2";
      _points[25] = ".9514939456164770559729801920265220261323300561844336714391207835992703432662113799732175447072784858";
      _weight[25] = ".2187090029371519934764961921673762746149951990276364790288993358680005697151259428843902444398710951e-2";
      _points[26] = ".9715246308559920866035488013575234119830975119551380701750238183981258606107602886980920135471663654";
      _weight[26] = ".9955114404107457036282987011420741036488422258616618973463593330141214449773470206707239207859137695e-3";
      _points[27] = ".9863904025392899117534861248015055941531051693629358191149649118720756782810516399238781644833375211";
      _weight[27] = ".3327279866112555094128006597084461188640953367772790824749440720953263498256535625904972137108060054e-3";
      _points[28] = ".9959272163607104691288374259807873291852593765446743146044815163863520054377631604148207633158200421";
      _weight[28] = ".5564241358714027532095053065803486490740943017680132607960936195006065033342071382271658581783111975e-4";
      break;


    case 58:
    case 59:
      delivered_order = 59;
      _points.resize(30);
      _weight.resize(30);
      _points[0] = ".15039773266387740965389410454398192048970508423236391105171932825289338826512487912405340180087496e-2";
      _weight[0] = ".7703907526677142332781611057875534544819793506537816162172648136598926396897833211940408561162874845e-2";
      _points[1] = ".79074153199620905538749105487067978896409293956241795230817601104555789575540426777252834764971362e-2";
      _weight[1] = ".1774200002910266224241589398107510122653617419432137008802265042177278051968609008820032294264102992e-1";
      _points[2] = ".193587084890258378485540305028822179759866856896989699866215848543232567345669305022413437043568121e-1";
      _weight[2] = ".2734323769023239623194332571355552815906192296906783687662345184113901926590361535172321053250568946e-1";
      _points[3] = ".357429253749061436144235550591078777563486234797585638416364433673687575978762738507275181509603963e-1";
      _weight[3] = ".3625397463788723790524483974173847020917492065787212600840108277078063463761026446248645645121576882e-1";
      _points[4] = ".568922585352551667982100411059980430161137708365607954620066105644648228452766965609689194596307171e-1";
      _weight[4] = ".4425731927748618287257948334671876202437120287511051701022472597796561585699259416961088955149035083e-1";
      _points[5] = ".825897633189471503761172023531691318939706564661181720464874299239016639710774216307824523473469200e-1";
      _weight[5] = ".5116849259793773961536020333387403840090728696787416722400025316316297583997339267500072129783422955e-1";
      _points[6] = ".1125717741109366110536945795187410873380276467679610813297435086513707772487952573486592132917409686";
      _weight[6] = ".5684018439459308750223091995103184106621949834142646328307502298037684351282882504507874123563162440e-1";
      _points[7] = ".1465306454397049070797253669507133675863970812842654082165416081846888928125469797956253712673817912";
      _weight[7] = ".6116708587574294585708384600511210723249655869946088776193334346188726348364913454226106690926661155e-1";
      _points[8] = ".1841179183174382295159362040481778712255751073163280436744486781128841767238309332184203445772681764";
      _weight[8] = ".6408887558478726966987172952929198476290145444949765876320874448844505401660613395137907367862983045e-1";
      _points[9] = ".2249478990674261230239659038071794671177427343701348684130225163163224666208835088859070269965698083";
      _weight[9] = ".6559148352964400742074101780590288922762063110608826979290732662425384779750749352007853771708288430e-1";
      _points[10] = ".2686016183001323810743018232453001490062411850001232918802978956024515050823666262374429233151229026";
      _weight[10] = ".6570658184089414272443437205941363884723654449948817438625048156296749249405795825047760365653661330e-1";
      _points[11] = ".3146311306484368093477133152707186848865010512147554712673141128875662531347957837834036041944221956";
      _weight[11] = ".6450933095755145680015534470844576452895509725364825086687152102043276408899255479082363408978744140e-1";
      _points[12] = ".3625641115525919243603237735395555249376544784701360196082102632275515462910475713276721125086440276";
      _weight[12] = ".6211448255080993935299302013223286515895217681731822651599307938155060303705561438986736826778759865e-1";
      _points[13] = ".4119087040813242226237090428292506153631763321335100527625422039405211351297361868627226093733969792";
      _weight[13] = ".5867100684562144938879531538437321203226400947228654914597314289823584855733418457124886247351885885e-1";
      _points[14] = ".4621585661189246886540277907231243106393062489018270745431532167413125006992428964361637064261870771";
      _weight[14] = ".5435547110670841272312359308648180196145265254699122138675635302555438086361230585239049569790033030e-1";
      _points[15] = ".5127980661561916817746887451598282918401125275994180446481874937657033611674660693401318099368063618";
      _weight[15] = ".4936444568948249182271354202432237836841853506199668047436650095508669478549848818479903009284566958e-1";
      _points[16] = ".5633075743824562981501263532733843048016241869169987473593829812419401409863189611028075333329458588";
      _weight[16] = ".4390625227933978568080902602950186417843079234280225955367345367601986305141065089129071180428246396e-1";
      _points[17] = ".6131687947901146656740818993889533163504756553625524311289854346046812852781127326882590856590079556";
      _weight[17] = ".3819239423170725851575184801695770825061515968304590598855971096584248504449023211886317255778808429e-1";
      _points[18] = ".6618700835772073917491354419849632203892530088735732812563719385176190205613534846026225511037711588";
      _weight[18] = ".3242902027054050043405269502953432501755780381155927730280438058383449132894536615575943817616646940e-1";
      _points[19] = ".7089116992693157344021296505007320277178336913754735555904081981587657489227382458808600070143246053";
      _weight[19] = ".2680876976084624127714802836523064146869361267096646765712817819486360367453807577343673562010302150e-1";
      _points[20] = ".7538109306754931985292676380937912950273016582300685379467850951928081223373494944028470408186327934";
      _weight[20] = ".2150333048441228769833753851508196766124541500331822808509520438345824079506333418293329418556482182e-1";
      _points[21] = ".7961070500327450999963466408130769909254065823786988072990704501299103077656532538035315934328433986";
      _weight[21] = ".1665700904270025006653225825818748132054069181447553844487836536226341303293367295386177068216496738e-1";
      _points[22] = ".8353660404570975782088039706260406779943814651902810216421804120682862030815465101588411782330910866";
      _weight[22] = ".1238157096505112882609671713082506468468716145623744445894400365087184337768244738355016184626377184e-1";
      _points[23] = ".8711850490619494505257748373786477444812674413535150966051762168128661783132891618825618402190855740";
      _weight[23] = ".8752554092761193897920666189535675116315443555815723285447313014922448847745255648781476354256270845e-2";
      _points[24] = ".9031965197235615179874486945867351160142948387890865854781167311755796735993819800971467684401213479";
      _weight[24] = ".5807197046687551242251792528986641465603517512649975600107358331114246119583995371668699019307564135e-2";
      _points[25] = ".9310719621711364212548285011966173256931864130262399049310424572383352311872885421014229760609648340";
      _weight[25] = ".3544057111846242578449714083482700968747522670541078730791206739367707904169668505907306667431049800e-2";
      _points[26] = ".9545253157432501968912124059098416516641931213305229648187694517128859748836928516071985626286913600";
      _weight[26] = ".1924321465636808530397802622670580849344642812967027613847003408847372214971157287338404751460255104e-2";
      _points[27] = ".9733158613935448794453820105491724343356720246202466373654937709136522090881131218997332838287318194";
      _weight[27] = ".8747452449452054528434345545792328394990878028984125283749635749400441660481138993437894665039685945e-3";
      _points[28] = ".9872505879667329157048673415397576071263296242106313401900976035365908604568987115580782377631356638";
      _weight[28] = ".2920824818819113533365390766918036968638135004181526130531057784590465269274888973252186602735742119e-3";
      _points[29] = ".9961854092532896146028221753356389314404324408686493792874214932610240703762534389970414536662131638";
      _weight[29] = ".4881538648506998360388173728839473046687594331829239051542362498444876128405787257339705259631178955e-4";
      break;


    case 60:
    case 61:
      delivered_order = 61;
      _points.resize(31);
      _weight.resize(31);
      _points[0] = ".14114759654438001348256513581390393419562984667192779736338384440996519441026714363454611896215485e-2";
      _weight[0] = ".7230975650216755624745604235452245279656002216723509408307916172060648702594298932580225621218825020e-2";
      _points[1] = ".74220518264556959990299822731493801998436484709522442421562775961521474913238167448406046166512886e-2";
      _weight[1] = ".1666384739763897032812241273494349301940479298727467776618499701123988004490992340669678844400083006e-1";
      _points[2] = ".181747690952658038437108481803088021902684415825402595413629159809155223324316565262012634726615878e-1";
      _weight[2] = ".2571233502559233962916487514592441336832695124269937897406163393750519114984932213585990978514343900e-1";
      _points[3] = ".335684886938805776020351183673393300613167940828654962764585541412287201838144499516964047561630636e-1";
      _weight[3] = ".3415097128660151411552293359402711465242260074443127121977548875485479873197667931382868950372343074e-1";
      _points[4] = ".534552578512626080105203524342513779937693721718500046157950064301891595545140126867720429028677984e-1";
      _weight[4] = ".4178617160801825992915658801875977837905592813985782271826046732639763824111240518813120386902268786e-1";
      _points[5] = ".776436274924141509512371198122950867042384907445017214161071063022462809243149841328687393582680416e-1";
      _weight[5] = ".4845115329628569641400235641488049317751856187046068419552911791551587187988711061932896461090871948e-1";
      _points[6] = ".1059006743507898902323150186915157844736889361974601035488644790649877832087183842561556969865587640";
      _weight[6] = ".5401042910942297169606643634238107289080557340412569681213873962182967211009544484382516092556354715e-1";
      _points[7] = ".1379542774855552447128780719326255863550668361596339433657214819259907437335908860511917486876748687";
      _weight[7] = ".5836375229138350624160086990362615338239160080471286336192335984386192265975526908945540909274677080e-1";
      _points[8] = ".1734957478467754419324204886538899820795596100969803016910279626820120007603979994054583834072109771";
      _weight[8] = ".6144885509138399963208906732313442111944660705453147856358092910024558128442404871634775095734054840e-1";
      _points[9] = ".2121828040888040191351780039348599803712580510768313825900253541385619933886307214449555348905000950";
      _weight[9] = ".6324282395146252460962228399357097064629451333929175881113071479705576514084592429465799878090867965e-1";
      _points[10] = ".2536428700864666432082452431813143747831005223909369486026040434260267599265945644212698451850907894";
      _weight[10] = ".6376205679777034433887185779904126910661659948041441706014396168363015437816563331764831689201831860e-1";
      _points[11] = ".2974766635554075645053147462633574325365810656072451302443779042064099713369581234883434685332374988";
      _weight[11] = ".6306081016811023815063366225055830973064193329943389248977312015799791678018878924264416822274962415e-1";
      _points[12] = ".3432620416022793630998090225239495403051757556793224800045295652949384229369749325747176898568972376";
      _weight[12] = ".6122839910606623016083516397607929712359889718041574971984734730807128531033074166688103903282159795e-1";
      _points[13] = ".3905580663160595481669443532255889640119739535291665391197508692095761083793683382818158071394605710";
      _weight[13] = ".5838516403304980397938236524245392855998127762199298477601893806562625801132740459692252467239117685e-1";
      _points[14] = ".4389092513075168270421572355375920326554093292760278491838960877415263051727169311927625190648144359";
      _weight[14] = ".5467736526761173539523204053682411291515305478198601616271701663699064504367567004571196515961782495e-1";
      _points[15] = ".4878499483276243221234259221844367644251247402658100645076118919224730288083968168335729128892347285";
      _weight[15] = ".5027120597876520794900410958133807051720717588961402097129758603339362629583444196959462479095184530e-1";
      _points[16] = ".5369088317321095914497342490074296657907384825367613041415625936691425061246625821704741521455568662";
      _weight[16] = ".4534621667933985881749779656727066820681662775058860556728564399850914215218638600268285241138664088e-1";
      _points[17] = ".5856134376099925987278912540897165142616026682924333001806921183223956634540653543769719960785603366";
      _weight[17] = ".4008825767952754596264770738045083066907786976512135760856103031172796742597777430196433932228157118e-1";
      _points[18] = ".6334947138634949003275653909484439122889862153213787389931455390854347121392448677482017219298371185";
      _weight[18] = ".3468240935401616737828159765451323084923611155594248045105379003407352239380156383657820936225702828e-1";
      _points[19] = ".6800915374180712367044778297145377145120919846691833890205513428062919469560369571372697106424002856";
      _weight[19] = ".2930602312747382029070259723856409204900613580780841178372978455996881359391922812877220700618340040e-1";
      _points[20] = ".7249551550540660529091850992378788810843305525615528425468509817074607906933810574574799861320868234";
      _weight[20] = ".2412219864885692984554027268004476514570713341285851510911245483753078318480466778189683872369767099e-1";
      _points[21] = ".7676535050807021900513946022822988218884222022947288784940173065942976001602180565188762480511492416";
      _weight[21] = ".1927393500347561210274414657736369528739716154850885294306403397770541527835430503292412088596873442e-1";
      _points[22] = ".8077753782079414862781562853347802220882808558955060482906917367586304344645833319010154104094769936";
      _weight[22] = ".1487917669239610535935110809974107459177779203087820996598630854524461789174475235354270434541465544e-1";
      _points[23] = ".8449343774921062514064287344919565431900271420193003901458878575147974746179949038330386644409301552";
      _weight[23] = ".1102693954563673028627773823029815539275663335605092754584488542792032540755019077327673485480934167e-1";
      _points[24] = ".8787726390975521425669806413071461215080266752415391212208380529932518479277636784487635052984358835";
      _weight[24] = ".7774659106840380970358554163391920818229953794719842320238464165175390233650550923962976330020688400e-2";
      _points[25] = ".9089642777365259832428053473898178551206481174446911746120405937208542772309144429777671577363068498";
      _weight[25] = ".5146855981905776970511696158170320994675246401119572219172360040145011608975207596432949688805111505e-2";
      _points[26] = ".9352185227478344903005635619837840093875008866261301248284230002913241844856789158446614001933175108";
      _weight[26] = ".3135161039546822021790675745981601732773492778297033598408165845484191268636204404439790130023958754e-2";
      _points[27] = ".9572825118149126493832813913549764982221829460675596349535989927608206332156385580989282616894079588";
      _weight[27] = ".1699690182723932182540417652805511332197053633010356770823917463334720543387838323616785541913733903e-2";
      _points[28] = ".9749437042544240163360031479159922744282696526039622177198702095339328818125350799450505594514084376";
      _weight[28] = ".7717057396996697641517258768670426827188915944192573597223229681262995542318343939522690797685893250e-3";
      _points[29] = ".9880318304951722914880530368106836749146235982824393858168425335568924461010604907917735038483867468";
      _weight[29] = ".2574514681284442266230751751507317607746199866536766321397160733033418132062271464159105252778453157e-3";
      _points[30] = ".9964198154713465863814005035441978010799044283122436703650320561453919687873406872890135672697937513";
      _weight[30] = ".4300369105210562692826370639121461833320652605667711416578738547360188460016161942657143106316551968e-4";
      break;

    default:
      do { QuadratureOrderOutOfRange th__ex; std::ostringstream th__out; th__out << "QuadratureOrderOutOfRange" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules/jacobi_1_0_imp.hh" << ":" << 2517 << "]: " << "Quadrature rule " << p << " not supported!"; th__ex.message(th__out.str()); throw th__ex; } while (0);
    }
  }

}
# 423 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules.hh" 2

namespace Dune {




  template<typename ct, int dim>
  class Jacobi2QuadratureRule;


  template<typename ct,
           bool fundamental = std::numeric_limits<ct>::is_specialized>
  struct Jacobi2QuadratureInitHelper;
  template<typename ct>
  struct Jacobi2QuadratureInitHelper<ct, true> {
    static void init(int p,
                     std::vector< FieldVector<ct, 1> > & _points,
                     std::vector< ct > & _weight,
                     int & delivered_order);
  };
  template<typename ct>
  struct Jacobi2QuadratureInitHelper<ct, false> {
    static void init(int p,
                     std::vector< FieldVector<ct, 1> > & _points,
                     std::vector< ct > & _weight,
                     int & delivered_order);
  };




  template<typename ct>
  class Jacobi2QuadratureRule<ct,1> :
    public QuadratureRule<ct,1>
  {
  public:

 enum { d=1 };



 enum { dim=1 };


 enum { highest_order=61 };


 typedef ct CoordType;


 typedef Jacobi2QuadratureRule value_type;

    ~Jacobi2QuadratureRule(){}
  private:
    friend class QuadratureRuleFactory<ct,dim>;
    Jacobi2QuadratureRule (int p)
      : QuadratureRule<ct,1>(GeometryType(GeometryType::cube, 1))
    {

      std::vector< FieldVector<ct, dim> > _points;
      std::vector< ct > _weight;

      int delivered_order;

      Jacobi2QuadratureInitHelper<ct>::init
        (p, _points, _weight, delivered_order);

      this->delivered_order = delivered_order;
      ((_points.size() == _weight.size()) ? static_cast<void> (0) : __assert_fail ("_points.size() == _weight.size()", "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules.hh", 491, __PRETTY_FUNCTION__));
      for (size_t i = 0; i < _points.size(); i++)
        this->push_back(QuadraturePoint<ct,dim>(_points[i], _weight[i]));
    }
  };


  extern template Jacobi2QuadratureRule<float, 1>::Jacobi2QuadratureRule(int);
  extern template Jacobi2QuadratureRule<double, 1>::Jacobi2QuadratureRule(int);


}



# 1 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules/jacobi_2_0_imp.hh" 1
# 11 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules/jacobi_2_0_imp.hh"
namespace Dune {


  template<typename ct>
  void Jacobi2QuadratureInitHelper<ct,true>::init(int p,
         std::vector< FieldVector<ct, 1> > & _points,
         std::vector< ct > & _weight,
         int & delivered_order)
  {
    switch(p)
    {

    case 0:
    case 1:
      delivered_order = 1;
      _points.resize(1);
      _weight.resize(1);
      _points[0] = .2500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
      _weight[0] = 1.333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333;
      break;


    case 2:
    case 3:
      delivered_order = 3;
      _points.resize(2);
      _weight.resize(2);
      _points[0] = .1225148226554413778667404303711520977520296573783188782094996764804937040907174519103834594413799803;
      _weight[0] = .9301898050140316109999077953693932111432962616104347355714587377327162032199365184453540090316083595;
      _points[1] = .5441518440112252887999262362955145689146370092883477884571669901861729625759492147562832072252866863;
      _weight[1] = .4031435283193017223334255379639401221900370717228985977618745956006171301133968148879793243017249748;
      break;


    case 4:
    case 5:
      delivered_order = 5;
      _points.resize(3);
      _weight.resize(3);
      _points[0] = .729940240731497321558379790120032921193893633063541009933683897430064212672051211633618549674866608e-1;
      _weight[0] = .6285454442595464532733792888530666142789173779765677035150899364344248411716672672683453001807558540;
      _points[1] = .3470037660383518847217635434039484551401490745262501021878985827903559852608331357830049271464466709;
      _weight[1] = .5849850770394640880140480814569575834996833285430405912588393379710804430684155659655248860334828360;
      _points[2] = .7050022098884983831223984775840482527404615621673957968187330274666375934719617430536332178860666682;
      _weight[2] = .1198028120343227920459059630233091355547326268137250385594040589278280490932505000994631471190946468;
      break;


    case 6:
    case 7:
      delivered_order = 7;
      _points.resize(4);
      _weight.resize(4);
      _points[0] = .485005494469973292970672570989859947642728062280413830869767690680904314070023713075606183354633710e-1;
      _weight[0] = .4435536624451119347329252698757826095062322419475350982016036681051358053754859408526879761621947266;
      _points[1] = .2386007375518623050589814127247005854364576119213103511631588822122262502910235136980422897678595854;
      _weight[1] = .5738351591968568361933120571037518069418956396071874388407335580148000676687764498832734152418551450;
      _points[2] = .5170472951043675023405733693830732661441577674815143184126459202288394285156186604132268185358169055;
      _weight[2] = .2745355486916923012695053801672421777585462337521019227783801195324800153896617288464511839350699151;
      _points[3] = .7958514178967728633033779607932401536551118143691339473372184284908438897863554545811702733608601380;
      _weight[3] = .4140896299967226113759062618655673912665921802650887351261598768091744489940921375092075799421354486e-1;
      break;


    case 8:
    case 9:
      delivered_order = 9;
      _points.resize(5);
      _weight.resize(5);
      _points[0] = .345789399182150915244574286315265927239187537641449715598798784850241358383207885823883664303919420e-1;
      _weight[0] = .3270591371430836716195229316894094001951854345378653863487891391459565840633676758520507731631799328;
      _points[1] = .1734803207716957231045924179861795777093110520096575445025632205524389034895410507640407261570230984;
      _weight[1] = .5047958475996459521153317406586619053415566875203098209415548851614751993628466546158658687273253230;
      _points[2] = .3898863870655193282408954103849949929685699479384607713625473160659384788871254703280644555908817828;
      _weight[2] = .3568006448863600007450179722815356404122106902138793907440693610940259530233602522779046002721091406;
      _points[3] = .6343334726308867723471638889206191121277336440958369160307851769971809925102122993798727580295999098;
      _weight[3] = .1282224028918476770189957222265331112459675505313588758170175986042217305503148083830364356533270504;
      _points[4] = .8510542129470164181162241874100130578037999355252331298775577412327508226081337242789670271254366002;
      _weight[4] = .1645530081239603183446496647719327613841297052991985948190234932765386633344394220447565551739188852e-1;
      break;


    case 10:
    case 11:
      delivered_order = 11;
      _points.resize(6);
      _weight.resize(6);
      _points[0] = .259045550936671927546436069972345489568181239253192501586105742961026604543804289171169539890458962e-1;
      _weight[0] = .2501548109063237515141062258733267440660779616350562328954095848025901035201055026000940757458648719;
      _points[1] = .1315639416579851339869108507409737955754378625065300343093793277073462918773067828768175209181356068;
      _weight[1] = .4295059989471225304230227293918184474568448760971126335776727891320004073377218295979846284565251254;
      _points[2] = .3024369180228912327499055779185451938801342419623170862494499684632895155693734121375470591583017143;
      _weight[2] = .3783087469941648142731682068802065098680549714701846873490169027817905712014531819167360652747890990;
      _points[3] = .5090364131647520840110399051677197756066865099413616255162800068449833494040551477253328196372325307;
      _weight[3] = .2051582845184648408805173003076769826286071695771531963106651422253387765576255251446619284393054829;
      _points[4] = .7156811273117139187676626245936073635482655112817582867648513925864912489801365831589316400094114546;
      _weight[4] = .6288118873978020531140504852007971390788413793492071598436679202370012665529257375196229311689702310e-1;
      _points[5] = .8868056161775618663012660060104907510040863218112851455728573015303583622861762166128254348593013689;
      _weight[5] = .7324303227477190931113822360224935405864216618905867216202122367913348061134720321894342299951728890e-2;
      break;


    case 12:
    case 13:
      delivered_order = 13;
      _points.resize(7);
      _weight.resize(7);
      _points[0] = .201327737734005072305016871174723490776439849042327704641023363534020742986485227576064062396226182e-1;
      _weight[0] = .1971060071057524832937165163396190757998916431027808644906762554468035992816828007706400085856979715;
      _points[1] = .1030890291480490147522267860059511003289175929398917699266215140490606015002180084249458354155438582;
      _weight[1] = .3627952984507445781478699198894979377596337461185747060555815360747820057455407114922673477814265991;
      _points[2] = .2405541260480575366536991415009998007569481612880393788676693328520290703357844995390090665448625146;
      _weight[2] = .3669352131191810164456663835874689578389760346660241804814700152598403298079827010307664096906772920;
      _points[3] = .4140021445970597464182872488505667767590220835312978380704205456186698145026653746810963941381988064;
      _weight[3] = .2525855148355651908381357619247951567605016016259007795136116178216199124634212453015846804292228418;
      _points[4] = .6000215132789929301939687728899372881025806599131930023285085834549592653990404218944489240088978780;
      _weight[4] = .1176888451581144593629814079400447094617082760975046287638279082701242348479743647408809166847127139;
      _points[5] = .7735172465914375011119989964260274880261693660663484652005652442182303999883684940019383260571399260;
      _weight[5] = .3265170252921877802892723627488505435251712336400851214223824298292417299877194662090599291711606806e-1;
      _points[6] = .9111831665630027636393173672090451969487181513569967751421124434536487739752746787009550475957343986;
      _weight[6] = .3570752134756827216036107377022441360104908358539661885927757477239078187959563376287977244479836966e-2;
      break;


    case 14:
    case 15:
      delivered_order = 15;
      _points.resize(8);
      _weight.resize(8);
      _points[0] = .160977595519210335320135500966179290767371971739863490642143548559492760585294337697286608894534441e-1;
      _weight[0] = .1591158312267622393204258237055927962698083072365832925887173927737196747407707004967213458334627777;
      _points[1] = .829006174856511027003663533803883425046917851397832948276985705707819404543246577003479311740585638e-1;
      _weight[1] = .3072723730688904992180269402731618118770031436482066776403339468731082588061946079180966199553817186;
      _points[2] = .1954751684887399173242666095306123066183752190029232941588497041829344498467684123721199004984344214;
      _weight[2] = .3411390766877550608377649050607439697794440340647965636027033451873926715896541923933717408546950100;
      _points[3] = .3416519914772022202729622621623959437357864175820185645023555961530872229142955610693253060030617732;
      _weight[3] = .2737887336866130889881088024434078279685567928059228224395487281994529345472410304920512689098080728;
      _points[4] = .5055970781844891719400618650060764872884489602668891730627538404857596368160581228502258304169030991;
      _weight[4] = .1632577055541760927458463846085917092703302398116046797151312588917290824986672513574976000713409908;
      _points[5] = .6695522718243614518301145105543719346057236571343379507230403873080542508578187492621559364188985917;
      _weight[5] = .6898745512093993121697462309944726926414242801556028350923661517840760011679153538454549507030134070e-1;
      _points[6] = .8157717035832837607547517869758669198734561249520251057926437981546786829099776657599632715409829299;
      _weight[6] = .1789808685205763198302608401313458028471472087364949967388597034873997270243168913625909195923823936e-1;
      _points[7] = .9285089649599068972010186178492256918523361943035918234239993038443100956977829527716887186137627323;
      _weight[7] = .1874071136138789023159770129253368619333666877009514163776075880783138331582326154790170679105180862e-2;
      break;


    case 16:
    case 17:
      delivered_order = 17;
      _points.resize(9);
      _weight.resize(9);
      _points[0] = .131658855971144905451905378179721513608207608977023046598715551451003914692376947401267911574381431e-1;
      _weight[0] = .1310405804441588858472781603370944604810978794735901694842259117976972694085138327178975817670984660;
      _points[1] = .680845295937675874765058569868224421713297601092686688022203256854416426151243571888926792972427820e-1;
      _weight[1] = .2619581481335865271277564288156488230723919390691807445060226299938323279618906211527645641167543309;
      _points[2] = .1617595167640746420698109123291884182887719048042411253973851893042652216773926057713819903780351905;
      _weight[2] = .3106942766422220163143806819137749290612485831017087160757406643479124562180813880959865405613148486;
      _points[3] = .2858910883392203977279895669126411861610178692391895516747553642738332353741698871551056243758169287;
      _weight[3] = .2771375827592188368629111413955671111448010879552790959675288132265547247642744146956024875388283162;
      _points[4] = .4294536453878127925092480022865873331648138310301004847453416352653628845263290243369473840494158542;
      _weight[4] = .1941625114580260318381122496994582838080221982357833412996720724777967285153688457928679921481932566;
      _points[5] = .5796940563511631262657724133119889515943464601677762686678217724998474141044996039946483039194661255;
      _weight[5] = .1053731236101993429518987840106901998442418069136281392168534644913155857561231942134211646777062514;
      _points[6] = .7232685717403354318179601582002055305769054380507989053229094988979833043442432382442417433411755164;
      _weight[6] = .4162446631740894820970534894375261359629703551183251098420143946239913509520566870940318195593343388e-1;
      _points[7] = .8474368420132373201731804250196182721512229028198623679712683516725259240759225460110084747448902274;
      _weight[7] = .1029759458243489240932686362241481242050381516644947786284291452404221754858892924302398732118007706e-1;
      _points[8] = .9412458642132742114143421271349757145307710728810603227584263072556399818130810425576470087365192322;
      _weight[8] = .1045049386077851771963674594932099904728987905881137936245423011782888065286438712365833246324346947e-2;
      break;


    case 18:
    case 19:
      delivered_order = 19;
      _points.resize(10);
      _weight.resize(10);
      _points[0] = .109684524561741342502810329904322267331336681681923877355192963785056979625337637538110478171937810e-1;
      _weight[0] = .1097363548403899878418065943379411944061396284924080166565554103294093888964177063474961793610341660;
      _points[1] = .568981505336579207114348593791205479346782029866663214710813643608636285458860327482818305149150497e-1;
      _weight[1] = .2250917456112325051296633286108366420614951800309439606854274760475294326418691844787436851488093244;
      _points[2] = .1359502340502289542657634293851948978251888305899476260362867729648816564909173618213354134260413650;
      _weight[2] = .2802780308346653363454898212327328392359722478917409167971915727317879309984750999998056323426908454;
      _points[3] = .2422811961325235611113945553650933509790917920092800543802211222195903604925019606707436266710657207;
      _weight[3] = .2698088775257512998821031772547641973726038694971785623654789998437662428652904614577889155923326442;
      _points[4] = .3680078504493377176047695662501715962479825651139768906203685509520441959000004952464111033767211090;
      _weight[4] = .2115351550678566328395393557696844837464895827386582581706740133267465009849730196407481293438002146;
      _points[5] = .5038071264148739070055306420572277096670551499038191289399601781301074701278289240976204997968793742;
      _weight[5] = .1354182600672564641764042852374920057830707307904626801110973942414191156942172243587060817600027027;
      _points[6] = .6396094886547097093285365061669561436997898167778574491235731369280604031123928829202652930591428398;
      _weight[6] = .6879030018621203231655000929591000454971704580551112869775545888215954689422647507462355006505397945e-1;
      _points[7] = .7653476795481078962095331272446001935281254701059371299400639154174230207720369856446774138268604502;
      _weight[7] = .2587955627423411691892242624371044143548514233481194134088846643064833839260516482542276239452851360e-1;
      _points[8] = .8717100745744084876118613420054236108762703517899922187764993623709234200889090646472972713573702868;
      _weight[8] = .6182092778946314514341307258874506510233203740474247976315870788020555404045823349159258546354103850e-2;
      _points[9] = .9508742926405231664463494846103251770541386980088762475218808457321456010524470739041019546992645690;
      _weight[9] = .6129601467886433685130280913870182321267020111436205319486707118462805612131738008391387787268321585e-3;
      break;


    case 20:
    case 21:
      delivered_order = 21;
      _points.resize(11);
      _weight.resize(11);
      _points[0] = .92789738313488342029466103013447551800997855849886680190878920280353922373287330173966578953120426e-2;
      _weight[0] = .9320340020555350966024561740341972459706270009058980336483720700004390524125197996306174927564976905e-1;
      _points[1] = .482496920942862582864837237311316913676870715011786505761976953984693552751112447826229637678462464e-1;
      _weight[1] = .1949834441226579674578013161123198903391393493913141165710324158456011237446879391336948781555464535;
      _points[2] = .1157886266293952259603059182556492085885288892943482283961924853822757749603844675338080199944631068;
      _weight[2] = .2519181720014695773533359952445167095153987763649309891459044750285736696026664998184742228754718459;
      _points[3] = .2076683415970598824438954253005318541962122637198783812084003037910494205451576930868295318153374046;
      _weight[3] = .2567342373990237799701574852246926321540907801747927739535161665097322828812066091979315472275859598;
      _points[4] = .3181179519062339663774464665791396822719791120780551488743875923139814199674731765500037687261335592;
      _weight[4] = .2185288892841797042827148607708304088540070080506917135110024995552378489195340132318724808370494734;
      _points[5] = .4401983998588624670826813221763196944009306574309261115292338038944935336942601582950581383666207960;
      _weight[5] = .1571608711937424489861433436853150352752777007115971600215818769351715159348001703309820163758798218;
      _points[6] = .5662398391545683135675124719348766600394909006313209815451544722188689876257081925222297826462922053;
      _weight[6] = .9435865415522771459726664777523037712224413619385624135202085655621859469783133863488143428243946935e-1;
      _points[7] = .6883242398629566856955339758080896168877685614740687571663638191714222753183886142439845185572907490;
      _weight[7] = .4565836367239047299968505122712376695848768267382332792870551534558766774545305000710814687370878310e-1;
      _points[8] = .7987843585909146419746087280073481414657603642892225070265379669025781304819516320234507849776994694;
      _weight[8] = .1656001705287608941907074982129804342900595679782926547479362297629040174388475144000347871328583800e-1;
      _points[9] = .8906910993543921891508128999060838449706283276255334717255508939690538822374778360353169582497335915;
      _weight[9] = .3852082302172956332801494958270836731931512478701471975527043646190285928543688268734603836396649430e-2;
      _points[10] = .9583251437866482019244391246661515172975807330371457605995597415964384943234249185759655416699374958;
      _weight[10] = .3752019440391122741107711103159083566877304052064700344116539346860368934732933065887748803192681490e-3;
      break;


    case 22:
    case 23:
      delivered_order = 23;
      _points.resize(12);
      _weight.resize(12);
      _points[0] = .79520457026384368762190933400404230325878915790184511121195407760726095490609964436482770207445311e-2;
      _weight[0] = .8012445033899501177523089686688632200915300524216047110927662984377082923088939924661277616544758575e-1;
      _points[1] = .414278104542945907907701651947950823816903997895905535340366964689296682965310816537095434242500490e-1;
      _weight[1] = .1702264614696225510918739636030398201621484344112814996354913309233794603455227611295265426265052094;
      _points[2] = .997576255426141570660817034802997399391466596208525248283265996737723259867991798599807469204854668e-1;
      _weight[2] = .2263367389978962785859121446178675121101775526351403133866313748357859288961118901399429789565545167;
      _points[3] = .1798107890524232495416433443072131398519613973866393633683049652350649339970260755579436050297147396;
      _weight[3] = .2410024299504180726837413740036251216870850103778053650506861765213985586819288967273890504882743300;
      _points[4] = .2772734577993151198175389183105218031690793465049448069023914667625432657455874204304984154028694716;
      _weight[4] = .2182957646569263313022348391211610218077554917110947715591671593278409360063080187628820023513092505;
      _points[5] = .3868920099976897916656347038054368617573779726132266856600842411622840190011408572046787141187486327;
      _weight[5] = .1710590542807556092690637471435145484050330827664167870998504513030965741988066924842173071520581532;
      _points[6] = .5027573604490322032793092784391183027172079885763226380243920422697606141569862957949651716180958326;
      _weight[6] = .1156322073549094419776139687208225491632847535363357613046929611804166587438361502417881862465344624;
      _points[7] = .6186238634584560462935488618911381482947201802097017834975473646568443564057059863325639273576037680;
      _weight[7] = .6618937457843764840554885416015182450294519306581249015227764712822431773609940807764767959301801295e-1;
      _points[8] = .7282464529530726864288803300611436952397911534452751751134554512822045797431115007040988123166108502;
      _weight[8] = .3086546809554570647515094649861202512818448992619175640122761773789205214076726685224260000604713675e-1;
      _points[9] = .8257185142147869017640833629537027093736435575778818152064773066577478052593968978372571869786865628;
      _weight[9] = .1088336857641535741816614466540524551935021467910130060680909665551588747958855091474710790206616736e-1;
      _points[10] = .9057950735445437268017964703997392322761079119953073066163678713751459636010637378082399631441249724;
      _weight[10] = .2479813594178077693466924685437339297957267049610856766740237535355291735573310962968151138526175950e-2;
      _points[11] = .9642065352926715512129553062783893235051470791627773576749579921411683197960515088339540982065266615;
      _weight[11] = .2382014392332466553295292468100035402588379323819602604826503406568381379009877933689507069923315948e-3;
      break;


    case 24:
    case 25:
      delivered_order = 25;
      _points.resize(13);
      _weight.resize(13);
      _points[0] = .68908313099587313966815341534069891610312924295884216664646849739035899042293162858956714369214634e-2;
      _weight[0] = .6960491444024738195232456693410433617039772704751655810891567455689639937541737691245714317969168235e-1;
      _points[1] = .359533627001700955011328119695205132217760105545034090502050160774587979100248003869028934390782918e-1;
      _weight[1] = .1497068326753761598146651927458960902744233437073677525182599977520837201027626577281733847598025603;
      _points[2] = .868117801575854332842803076906012803586804672410818252448180070750565457367189549735536214157210137e-1;
      _weight[2] = .2036393228507800763716273887505590308873494434785424621492199411922564371066863588578324885545762954;
      _points[3] = .1570999741965092747305220655514795076460478559637808966768026561701334378832315878926359118028066284;
      _weight[3] = .2244461485233095847401594888146689643184503673613412256573886718574101869069388545716338949683699244;
      _points[4] = .2435328995871284444190341035677509233546420884568021588363910256954815690060216467377269714945612025;
      _weight[4] = .2133600864234869829016066656915215457043166425583673690879063724648569706987753465045737718877615788;
      _points[5] = .3420695126460753234745079965662670426694598946354515144515707529248230901101547245184760072145509804;
      _weight[5] = .1784984030224598177222653499089708881761495368969374648507406094628872556990281953015547320237188519;
      _points[6] = .4481026389057098536287343087939797087307694182346731421546001771139148336025010690279838386680578360;
      _weight[6] = .1317618067137311603345937815895239661737637824034451034501350134739730493893049812226124269295047472;
      _points[7] = .5566746226294550106969466423620805822740057901270505208647082398477423598381705261496298123849990970;
      _weight[7] = .8501998685902645212445243555463312092509357047145464604938440147163681074074875244898739601239204060e-1;
      _points[8] = .6627093135603885423214631521232583899762109853102761874503785215844447164251275965254928056783280667;
      _weight[8] = .4691303837240752265188152459747705248625923503706344789441878308197981725976028730594650682213315254e-1;
      _points[9] = .7612497663082769722766595263934307890962335595916809568123852946736417765204111824657718798518006691;
      _weight[9] = .2125427735533055379222365772738949202667956306189252700086140940284706736338427998038547922834835463e-1;
      _points[10] = .8476910439472323909103140489514170370916151645340936646068779732870007405006591332706754097819751746;
      _weight[10] = .7329564556957514349394257676697856873834127393279604943260422811450298594922588905052267132904185585e-2;
      _points[11] = .9179996455372066795336259702883514644585607264667402765509172640216951031101831301991193963406574748;
      _weight[11] = .1642883567163541667137135579634586264318797523514426083342476902975498845674881247797284810378192256e-2;
      _points[12] = .9689288942285889621118118173027414862466810321685627399195946722689891537382806172804214947762563872;
      _weight[12] = .1560679730565849110018877622564030522971963926107455394995589020798212499287723463265570237517659420e-3;
      break;


    case 26:
    case 27:
      delivered_order = 27;
      _points.resize(14);
      _weight.resize(14);
      _points[0] = .60288088710666481700887477121599714009165674033817505496952220432024037237434445714834787852825823e-2;
      _weight[0] = .6102082447779318149404536788951199265358380400157561994830938903862191015641396072434298492402421695e-1;
      _points[1] = .314942598186575907073067127663167080720502127198063557822381981372867976117993479760997886283534922e-1;
      _weight[1] = .1325583818798422395037209033460692313542102941236965236002400055105646280610200698756731543931528664;
      _points[2] = .762136224748538675864067863400226931624394106538800904358149503746059181670255653177174871778064644e-1;
      _weight[2] = .1836590884586847156456151997787713864338837649250093240214366377932523271705213409778289378543540772;
      _points[3] = .1383665259594740691451383329582450807329794609739600343780877691101025629072379526219736602142441636;
      _weight[3] = .2081034616428068073313094353978842445257334921914344569440612488730800245148651213554324071384101613;
      _points[4] = .2154097570688955749006955320851489135121375905412025496653310142236265218036971673059371903435771383;
      _weight[4] = .2055596961578860130952322610656504885177771188630820243106415066192827887029009016919044018841629724;
      _points[5] = .3041895281416563096323663549044031022663432275568421834000345432977346183474641407178311135015966832;
      _weight[5] = .1810137290178435258604894942640880460514514087650048923768556969517189589259791353365537617943430788;
      _points[6] = .4010713786971543575811860320519884685924384191572501525138619910884257329369228617255111752487734427;
      _weight[6] = .1429560411700584519366501032413827809654950517490789640352810210845232863752618039772883247583044508;
      _points[7] = .5020891397499784100693253980496002910686100916885675007465829924443020109731422291660366333167504029;
      _weight[7] = .1008647341473562201372248808088751043020521924647668486496396285323660848376666059202375068555835250;
      _points[8] = .6031073967275967836818955665403615514497986107892801003779313726143183351054969157643569313893089786;
      _weight[8] = .6277732914029182873972173919394741932291208929247041454114182049684592982407685936803284668904118040e-1;
      _points[9] = .6999909171699064974107366639384890954484520793287566604677488395049079890581595895812516182137613224;
      _weight[9] = .3365190694854584883843086111142799005260169355843994956162857554818205354238736452087127825321312233e-1;
      _points[10] = .7887742384345607153403048855989117812599118416749927874591230855514960253526748991496993842445561658;
      _weight[10] = .1489950270113143528621524991386061259196283121337933421213015237018974938111932684980666809215124472e-1;
      _points[11] = .8658249007315969536711408351810170671281166559680840985364216536761121893264203663610169524834368563;
      _weight[11] = .5047135580629952165313333678903904301766740735495618421679475165368531852851525344466712644979612030e-2;
      _points[12] = .9279957387467523249837781220393962330973069328106674535182517668455918785733163177668632107772943334;
      _weight[12] = .1116397363787513880357822426330897791338165514714505129793583213369776447193493631912488567194456030e-2;
      _points[13] = .9727771207411832304529633631672723761418322320666616155022099344216203494462325353075547090085913071;
      _weight[13] = .1051046466755994190066812166292344685646859351848575804945921359672835410758237589818594844183685276e-3;
      break;


    case 28:
    case 29:
      delivered_order = 29;
      _points.resize(15);
      _weight.resize(15);
      _points[0] = .53190520028437405909978402739773949501717786498451012390903885828654368422611951408021355398272097e-2;
      _weight[0] = .5392665090053721636106293416964196355047711087332304374347740716255549922473738865652698714009432220e-1;
      _points[1] = .278145619182600515719807092380735475953182923972000030059413426511354857749499595402805481020463428e-1;
      _weight[1] = .1181106030271928203575530674800549317555657907909469016820334832959564842606168165865226255747224674;
      _points[2] = .674318658389986133845685775718184944899402847113353901114015417427935646378617104759012487105886023e-1;
      _weight[2] = .1661252306064170614951978271811555413440569614651595199924632464948276552123825945778602473762662652;
      _points[3] = .1227482862154978393395873240130317032151265317293409309723332247616160353114996846526951659728971606;
      _weight[3] = .1925282306741192635536195068795429148549620175078239732019144990499724648233740495658097375475316038;
      _points[4] = .1917657062776536255028268450504200863445325847077754640124610110844518238511837287875868381479691005;
      _weight[4] = .1961650715776367222607857100338277674615403482968446824018357637392232405293324998845805559262668746;
      _points[5] = .2719899659294862030563380079302590480247942543957991004491026215444180175182375256505110567396822930;
      _weight[5] = .1799662232824637334629206112030205761825115733710491636849576725169740218336869361061489424124483476;
      _points[6] = .3605216935870576481577844407783965338450733048513006001751394159810417193512115614212035252137886290;
      _weight[6] = .1498955031684052123812771871602716067084415379038225419304375844804254640021209627209252643892922630;
      _points[7] = .4541612357544770991600962499618829704400282904120849921379677203156200105460801073784507410855614590;
      _weight[7] = .1133062126969649905762758964950627527929647767293146529704816117151296007557005216726923669605708808;
      _points[8] = .5495243555935513136546896219603138697609059893623113297331642759135899174924012857390026360474762955;
      _weight[8] = .7717366634109808194395315371897661481697794303982356504901090232725807785964281183615873931332253630e-1;
      _points[9] = .6431646017687849385394940088418749344687178001026537323433816746667626232189289933810809550840731543;
      _weight[9] = .4667432993910655425413732479156533084522800284809613605669453781660467725115778296456898579690543307e-1;
      _points[10] = .7316979730525232062993394846752112991776703416144255053301405080726071072308400265108448666008619891;
      _weight[10] = .2444420044082419616486125716889612243023339647683950965594801711901059340309718047264869243476430892e-1;
      _points[11] = .8119254772750096666896931212019542427716200088297330042968240740567022090056000155767305527743066810;
      _weight[11] = .1062265194309727672451284568453333373257143901288406177087267655658817988164428587123611239563599574e-1;
      _points[12] = .8809495287153136023880805549365229247192257620249850286280431657774932073581341528362053919854452733;
      _weight[12] = .3546294540936386695929109813840513953405630969412226155615325774569207011586893659157938322766830800e-2;
      _points[13] = .9362818217355187421025193722871475594082635803646883892837426450201379107391391453318432405302555506;
      _weight[13] = .7759490522557821973605351452471324906775817329617622870809982729562547897699646378604645579098471765e-3;
      _points[14] = .9759538743350237095620038412791153907886111958465214282812663898287649311216709075768610974652202594;
      _weight[14] = .7251514227803490388636640769623041371922231503159275050960701128191249448264412063567318483535829310e-4;
      break;


    case 30:
    case 31:
      delivered_order = 31;
      _points.resize(16);
      _weight.resize(16);
      _points[0] = .47276871229345922061506104450644771859877133490952080783156204719904618626220140980919888049437212e-2;
      _weight[0] = .4799762249876787834602678161657048141079099237527991579241094505115520768176249489883380354783575107e-1;
      _points[1] = .247429676194349845126034562695356720576152865062634410070289770741406286882253286205863380224719238e-1;
      _weight[1] = .1058433700693581081617490582582260489397739540049851972587515247508128778921240398581401703350950425;
      _points[2] = .600764377166379922752422553281124994904079423093944860417802813254670955428854321831735284854414748e-1;
      _weight[2] = .1507432987276742913332603257772435302414637148956054340274349733093010936907163841776698818476427980;
      _points[3] = .1096006092587706028678975846195003827709889318416547509152886361080137785970255407503143033719803360;
      _weight[3] = .1779862938901728599046041983508410784211710356810272044473323158434144748195799575920162751491628334;
      _points[4] = .1717247594830021079030741779126958738693210887070413817883535217741774057292701297715602601789514566;
      _weight[4] = .1860249575894506351880500844013307938590785059618964565637623170975868320778954318066738261222465300;
      _points[5] = .2444524317445113773020765616027520310335790553610620199645169384378290869715474713058869732710115018;
      _weight[5] = .1764506307035974844556454963572807953528221877075630527904162026163913063727413866339740371354312014;
      _points[6] = .3254462100241296148268368519018063901298314159028243246203929830145913417696717843549623084103386732;
      _weight[6] = .1533921878047438226943307636411683225532230366129434468301308130372556609842068604135406661181292008;
      _points[7] = .4121029641168595969172842136225134716264638462851170381104799491302816048435587877644761732164741742;
      _weight[7] = .1224481516713504381677953376318549301968971738616216687469062423535307787680712176524375047323900128;
      _points[8] = .5016375561531875937001304323508376116775809382887043798099322048009739763486344428459428277727638743;
      _weight[8] = .8942874259811972089333893705457462540747878902452832779327225337155148601273155358526763706035859380e-1;
      _points[9] = .5911723853165030889707605187763419229680436878682765211186872551925076536578972852139357400884025256;
      _weight[9] = .5921510663100695336095700399081714160082916113233465165244891577971830694111417358117886339758554005e-1;
      _points[10] = .6778299174145608113025127726414777500320971717496155010727267379426891048458460258015622127620921854;
      _weight[10] = .3499018198244827989832060255651272931793234290752719755245012805681995519918979378047157992202798460e-1;
      _points[11] = .7588252579491414133542794053511356108796435680365038583957695605622632533727925268078632201504708402;
      _weight[11] = .1797939540591943553282655904326541648736843405213664835704382086461644807389169392510655535237025878e-1;
      _points[12] = .8315558830264619518892063548240608922762470054306231569778660096958033620199460946608882490135090269;
      _weight[12] = .7694127704267096909529759414250766143904775295057170663912123460022589036462078267439682969987081825e-2;
      _points[13] = .8936859745488040188148696987681606327646834274095997914162494394444252336597543340153733132728571944;
      _weight[13] = .2537839998275347472043395873985655311218455216670758737222071145520472405641979123640571702420676269e-2;
      _points[14] = .9432242857122455935254506623929578257508869485688987484186741352804265152613888933335080761298126972;
      _weight[14] = .5503124159022070098783811162627949675055432854454242381238069353356523893162308519719894537981642205e-3;
      _points[15] = .9786064374986970125728009137812822496042690312088548040286436320973606732995221437659921341073019240;
      _weight[15] = .5111364227877400497664824914822312187523131871077788171487966030019098788805718497028848685166368265e-4;
      break;


    case 32:
    case 33:
      delivered_order = 33;
      _points.resize(17);
      _weight.resize(17);
      _points[0] = .42297654864907678749919877813006853403084357734313521853019734168161970175758573156495677257833779e-2;
      _weight[0] = .4299260412307448665133624881974499405574117159014690628896844257161210734057924717135855394818813300e-1;
      _points[1] = .221527053118302322942090021015730015485450584088220769434786399488156515355642000426239466001937198e-1;
      _weight[1] = .9535104807481297848202429866106118257566228137557417660332400853161662680302761699773305908707602550e-1;
      _points[2] = .538560148271848295667603220136445239020788940680251943301696458994841194715047205463051766316826524e-1;
      _weight[2] = .1372315591826875201137474777560073360546853485740573862533356511173364265079156697526661118335742896;
      _points[3] = .984349368305413624942469242370978263948897472429584127728864864700452356841861880413747313577256195e-1;
      _weight[3] = .1645759033882728284844431118628830743614989413169168358659006260722663488738016626358120054440550207;
      _points[4] = .1546079282658856298783890388078768159643889899573936780160589552820868047441765770328672418716605928;
      _weight[4] = .1756904750903703112344453123805424546908639066388433026089700387600911377246901618503645283610375911;
      _points[5] = .2207592251921513839136378776833585067846629363530123208654012539977418973898636052213362063366054318;
      _weight[5] = .1713016157117382132057565333805042728924534535143805371589947866964031301303853940997281246350753656;
      _points[6] = .2949858662980234886510059849705601329210424075903350147902591485628362645969755211291710565803372333;
      _weight[6] = .1542209677884094145128943284286812925327302523010098402991289260221514316057089544615700030218454265;
      _points[7] = .3751525416408178820083477139222646171835998951809981629079410853435870113997403594064257319049096888;
      _weight[7] = .1286542804495145568686598485110360146860251475979356089399894897424306248964305507294249894650268254;
      _points[8] = .4589530533530190808593345147437514652455985649810014296771181666727254937874683576150552189676820445;
      _weight[8] = .9931702444790433120952426058302138873908984792726837791724440362064021175262692440686069358710680235e-1;
      _points[9] = .5439766780904757097451521743554710584231978091980306940950977666498348773038378260887674018571215284;
      _weight[9] = .7055515732420044207392583546335768383670146789242918934183781450503912339593438180917722727222643095e-1;
      _points[10] = .6277775385468142725656053809477606660481926914076750686903817659859352892916227568745400677875818882;
      _weight[10] = .4565456895454675099029361310226524142448988405389158412248073822256735245132154460401903761295545271e-1;
      _points[11] = .7079450013850855679436224260730899232137170875245929183750474960756456985178763599106899686510620340;
      _weight[11] = .2646567904144685891462284647978091273368422635641062894104746521612846499613282277673498551270934060e-1;
      _points[12] = .7821731030812211281011385401557176313519720275190703032263911897342087238744392146926368605116440010;
      _weight[12] = .1338606916727926148618970164658395028370018090423553621907901080091060043469655162093802538030454562e-1;
      _points[13] = .8483270857099506075790635313717878056529164545129232857765525221759979278054482949739136814535756290;
      _weight[13] = .5655535035824528926649613561049219086512768112197461770524280675540737290522504605487405853420120605e-2;
      _points[14] = .9045054233143287003790610093283550812376120574920944369394302938533880974366435920451390516090983514;
      _weight[14] = .1846696235108452323081740268246607255059909970851485069280721260167157397850582769904163871856048294e-2;
      _points[15] = .9490970165965445702465476283565708297246607755586873532653724677803087032874699499858701150851049612;
      _weight[15] = .3974261013418958398496273404764511239692337872082450246160077318175409175170546288895012284090236850e-3;
      _points[16] = .9808438938474125636766637209275972068403939450087260749208889199283197846333843968554117528460090240;
      _weight[16] = .3672321680050201588893508809125700046531141997623090861092178661431081419170841266491721846689114246e-4;
      break;


    case 34:
    case 35:
      delivered_order = 35;
      _points.resize(18);
      _weight.resize(18);
      _points[0] = .38065822475018763836485343548908128836530842181437250558509157512865054835580682304550442871295647e-2;
      _weight[0] = .3872959521506409270998592307661178898880126487708449836871701251355028383578477016496915478943754123e-1;
      _points[1] = .199483510473430186663012735505779601074745750442251274143154167073987963870093079180150364373382788e-1;
      _weight[1] = .8631509071677530810863100163952706294278370989850041392675520998322403679573746872013264869844692825e-1;
      _points[2] = .485496453042246309655258182245965941520881026987912266146741918676385839045080050005500666072750888e-1;
      _weight[2] = .1253356306869180533118015916525710771304275652121960162491546992025945693808868351192974355689808138;
      _points[3] = .888762591164973880481813921949574688298959791547512835680204151798623849414160885332214861130374954e-1;
      _weight[3] = .1523005370137907506618312924014636112216561687461645368895555297544914491320199297299184079940310732;
      _points[4] = .1398845708351692649300383552676525748959865708235061557519490749172429745529982954346474136929129453;
      _weight[4] = .1655087291500782613306060164007111909015389149173326868684911715359303365087638368773296390156486496;
      _points[5] = .2002536959236303382067125585321085063433107257362303407043370644457116850092167808120166500781901474;
      _weight[5] = .1651346632398309976571473150915354252515252272981002584619642650179028278177299248154542524087422392;
      _points[6] = .2684201827866020844201471280361786628127359425869124458724958784949980847348751285744762131603672809;
      _weight[6] = .1530511786893971990313986250253572460871774396855398171527438104801138575696244796632962408451450569;
      _points[7] = .3426185978020083004514048444648040212380882146133496205314099376215388144800483221755275703026317422;
      _weight[7] = .1323839048082899911826910765424937040163915594177335399366773159697079625785760931901186843037828276;
      _points[8] = .4209272758703179558039109560839247557191088306211527841459293605637953895210495784407565029266997560;
      _weight[8] = .1068936974758404779443918912465824233672883504398824139817461678734416233217909028738142876058300017;
      _points[9] = .5013181027502735883646759853790557548582408474545762758344248448850577878823309680705395605759116039;
      _weight[9] = .8031456678547888071777527613084748403550086714243964330239128562327769673230247753017547024436125655e-1;
      _points[10] = .5817090526709179282288375852933077443864571121132991743769987023431980248853066657774790851887703592;
      _weight[10] = .5577559061459162570281412768389355996651397767708828589498056037792211480330590031535721170146035940e-1;
      _points[11] = .6600181272253155465521234027038088059575554457571711316782527733933985664095417196979606497396358233;
      _weight[11] = .3540911290037990977420098813904969531272785240516766309095652038688854805794084594012390191614815054e-1;
      _points[12] = .7342173081350132503192173614025312330653864334982702635244595308063572372883774041853861365278221064;
      _weight[12] = .2020099515341872526673649424020333062100969085759988997176723342299630382322198514555179632843120645e-1;
      _points[13] = .8023851498364174702066737905851700573574353078541166033802958270590653479162625703154687749291640618;
      _weight[13] = .1008288655374502320909828094580508673228285324540546402052877073095600352583258281978552537379408098e-1;
      _points[14] = .8627567207000550133608166202160961738680665986694630756476656758603077150109726400447325844934459159;
      _weight[14] = .4214201135828769484963761390752045700215974350846961473780225330124447098246374619584268057963833114e-2;
      _points[15] = .9137698641107929361661231897915912008421467877286301716092502878917492649700304674650319917326600689;
      _weight[15] = .1364364814750619931583941001892832710526596444814880095801559791422327117557391969710365759995404922e-2;
      _points[16] = .9541078955173166588189030938461288380596566681165619454485636499417392056850149493349451358778683790;
      _weight[16] = .2917480346564748213126518173258607508890442325216746931561102953965933068483693177921983263767078756e-3;
      _points[17] = .9827484075942869606330738995463030451490285627845328593674222417433378414637988294624743078554551718;
      _weight[17] = .2684034449817248636307890670990759607627648491468895416588504339235192716316452092184439475720265658e-4;
      break;


    case 36:
    case 37:
      delivered_order = 37;
      _points.resize(19);
      _weight.resize(19);
      _points[0] = .34438904038624902806940509331722218118237764002991412858481112615844728242693578816862624868339908e-2;
      _weight[0] = .3506918822751692946455730452233595458916116289923823285432079838303497328566987932630679733749297592e-1;
      _points[1] = .180569783379005628630300939543426866589488073359103469264101526778553509159512609080680306884745910e-1;
      _weight[1] = .7848342536092973805160513510880688200259433707189886999155358202518740624336539197330534120583627270e-1;
      _points[2] = .439873950908427344551988327736594826194320140153375528846514027207880410750838305286878028688002096e-1;
      _weight[2] = .1148325991148163444911640277657323543047270823476765245035320839854858063568929732605305534995216716;
      _points[3] = .806332763666614154697217766630158459957277447849651525951264834720273397104963125897285924387255855e-1;
      _weight[3] = .1411124687979040017383983383889387833636924536378786579842406801114338206400330468092921853091999434;
      _points[4] = .1271364098615602695300253508396918022790446090548847239057383641397465202768706860278890106271755373;
      _weight[4] = .1556895448890469502039433952460571175059219100966614582090178761629870656252840687807066368143396396;
      _points[5] = .1824069836690918531306969538712789495119226639431501787827330067269926177189844384572705963840879390;
      _weight[5] = .1583929928595227080602642462804924544723091598046442686562413911514004596788051226202861652567728365;
      _points[6] = .2451495690951685705524921770182137890794445582375331816751643930651784772617999016157149898754773395;
      _weight[6] = .1504300020813901758036486944453268769096163950084233519532702102196909305554659060185430103649064178;
      _points[7] = .3138935674182182241524085986530725421833888559124072140832271736633880973343121552225350975792017752;
      _weight[7] = .1341002722824411358436228022698388785145351066959596061980307557271397511811546203613438647447731976;
      _points[8] = .3870277027693322034154529075168274250441355570183945919149496613274873431354056703498844308990953008;
      _weight[8] = .1123664317444116305965655143169402510025365271744523979648159561101015872421911323846125879396222853;
      _points[9] = .4628377985520202782022048705469377514873721078497890685487969094434993704576336247176078079949870379;
      _weight[9] = .8836225259929596186133469102150733448918159724655286754038526721794532427584912859912903335150515705e-1;
      _points[10] = .5395469627920880876694306633299818817017043399462428376541362226335526976593984274704483496113346924;
      _weight[10] = .6492726128798530252071044988969133477365566175334068106698994747182582468433303021020195666737121265e-1;
      _points[11] = .6153572448045471654669401635833708805050867627458286076001673229030120048708698995373393775522832916;
      _weight[11] = .4424576251614803158884713918509202323760369304517733604518806841090123069603439631756455979147352903e-1;
      _points[12] = .6884917909140949891898655120380168800849788729479226796014048212433893444546592668647864865663296238;
      _weight[12] = .2764324431172879278940581658661853456999576463765561596565228984548554485346431017256946431651824712e-1;
      _points[13] = .7572365191732979354973693279466696491303870879952976126011813160845715548094948766085611653832161426;
      _weight[13] = .1555913925021236084119398351318324635350878964483833382275711925200825311327878919159166803224117512e-1;
      _points[14] = .8199803570632373353795400684102916116941435268852334780207569085081760303785333606287354427331798835;
      _weight[14] = .7679153890769252819349084362266762034680794496687220780226080890557707688737671772550611046437187465e-2;
      _points[15] = .8752531629838266800659489088760858408079696488715943336759069360574915944199538127854460103635272240;
      _weight[15] = .3180177301794237493019314012687144031688576745974063615856410069920493919217044916534773054163212654e-2;
      _points[16] = .9217606817291400488993742163227374545276684154855298882918293363660999418596388711657739790912190803;
      _weight[16] = .1022123435563885025902206640552076666567191786422602535420698723807095034807642183511143694820295308e-2;
      _points[17] = .9584169024234071451034779092669423904741880674092767651904315631184608661010553708352299289446592853;
      _weight[17] = .2173705725280176670944890960502804423166204597532801450098392340276614206659788761434319343454143889e-3;
      _points[18] = .9843828065517020106761276174556909144026325831604026447615399145866983347355888758046066379113914704;
      _weight[18] = .1992280932787647270670068121504406904050878009796350082427834039239683808319955860954897199266412788e-4;
      break;


    case 38:
    case 39:
      delivered_order = 39;
      _points.resize(20);
      _weight.resize(20);
      _points[0] = .31306837407435895621501417495462510065580878973398298412115393497382743148664968529827799082045388e-2;
      _weight[0] = .3190317094510660674090924062970198411577078121671833534897277070677203833980338615982242263137973616e-1;
      _points[1] = .164220881339878329025416142562575229809359983703355237059350695210504939834071599255435745962045506e-1;
      _weight[1] = .7165500930295423640709583546529029927063232240443669945496644251219376217691519736672483743823850830e-1;
      _points[2] = .400369004619067809963201498287928025191921820210062341892225390040998573431853908091672063417920826e-1;
      _weight[2] = .1055302577165023391780536338961832585932656024160937632538479770610925703787292264148375734920674494;
      _points[3] = .734771917852852830575665452858744671216295674682933156759792305664838530209481919649724781555323708e-1;
      _weight[3] = .1309385772702925921899186259959536648124379399531342254695653323236852472377607884882920170278896659;
      _points[4] = .1160309076554868049466974315674778539277330768012538553063813735353261223084763159059242881112719989;
      _weight[4] = .1463516662129082599464371823076988796401775386811170193209364125128477705820631778004347129886192058;
      _points[5] = .1667912534810094300129807014584903280447908397404053429938887652977094384333228625709776729362659786;
      _weight[5] = .1513895615076893628614187777974902875769289857347589080536723214276560283463670856505077453095048151;
      _points[6] = .2246764193843050384093819648321044864540754911683337333822542507266562834493851020811842664368541636;
      _weight[6] = .1467896818880725308530169982826116192006045612648753091087111859984896015533920748162929571737173545;
      _points[7] = .2884527121812723847719407066523953852068123046578582394812568730574474727765765420104187934722455199;
      _weight[7] = .1342257258139019739160108592909563151742579251223689347399582619654740155148596039252928397551154914;
      _points[8] = .3567608701024531056470550666332594421879937365627218234316645015120881052816834839729303782691229973;
      _weight[8] = .1160096189823571406796654290456113281805357426540610444070368909950710161534150063798066831796666304;
      _points[9] = .4281450409332566846154250347724519581718006946562795606850444879460088034322223621075385140190445604;
      _weight[9] = .9472916165698421592346580106597904566789390110319129543362928719528014089962861825723013260548530370e-1;
      _points[10] = .5010838154828485513706246541369263270496076238639477776074661526726511056457717245333351712537248934;
      _weight[10] = .7288201367307476620737326123903540949531459313127703706325526164891890426846954818738827733176229805e-1;
      _points[11] = .5740226581828268717275121966537067538016418929949592700206557877680052279117492170391822933202016281;
      _weight[11] = .5256367702664660696843253488312400143294584902673080355015772217448264100685386833519746415036752640e-1;
      _points[12] = .6454070457773675666173208347639696868480924890494238974440167033076937496843430736866993320402326217;
      _weight[12] = .3525422431297342131570109267190665101713924409722248740423389077510379965048840746566703817840967359e-1;
      _points[13] = .7137156110152876807420834353539261845083764977327116606392342641138367359145141329606212643884043525;
      _weight[13] = .2172836322449210980004804457059473249949021836957893650421253545420376191894281707541313281395819864e-1;
      _points[14] = .7774925920354867535511259458365767833501645594282318185786818344152523063340596941838540072199020284;
      _weight[14] = .1208995668362951749967394391224448828054059207291389348694724435189801244587869887557864332436285280e-1;
      _points[15] = .8353789146315617251715183947134126580844017599680593375160397110937599975115528768975851058881087349;
      _weight[15] = .5909777767885943225135430582621307955547100153876209416844747358074494910134249252257133135737806525e-2;
      _points[16] = .8861413029145471436872829303649495040166030756579052437556327864000033121939155088226394817590025458;
      _weight[16] = .2428182817069033016610894924350833114680897738357536155240424761102475327226118558922110561968133044e-2;
      _points[17] = .9286990149187505453450978371672693948888756101758623893390553359882107838318818368546819590506484100;
      _weight[17] = .7755532384700472430793540610379271893135838353708382828748805776320956014381700141548785595564677150e-3;
      _points[18] = .9621487121504981897091608064229207407940341288068742181995487210154653226478330645824175987235471688;
      _weight[18] = .1641564083492808221962961635922449664007417807376345432948175005715964939937779190026714134837790598e-3;
      _points[19] = .9857957888406418466800231313592152785604899067877207377306395965180365635041144860468676436334983788;
      _weight[19] = .1499688397334853909009654734905514945521257651242233497492603278336052697351239051006226204243528836e-4;
      break;


    case 40:
    case 41:
      delivered_order = 41;
      _points.resize(21);
      _weight.resize(21);
      _points[0] = .28583506000918943222556277168266894858285751245439686302779772142656766161766731194904431193569346e-2;
      _weight[0] = .2914652692549772359825191743397280020164868373562383178741132669912525302067096472110034590221450778e-1;
      _points[1] = .149993649720755223403571359160225470539361883131836778556516603903438708635668498472691708816024396e-1;
      _weight[1] = .6566824457697127529902981695220767771270006886685278602736453053393289071075554704667955406649786635e-1;
      _points[2] = .365938632811401226265450552821860085457234611801545310290922602501176971894880071315680511702106564e-1;
      _weight[2] = .9726429982522235339421302162613403019875891383246840547625842897557731247557947987411508487703896340e-1;
      _points[3] = .672264416679386385265639476746750035714407217096221424116585689782697613063862074819310720523387194e-1;
      _weight[3] = .1216954186195147767859181700852196598453398974387542750341310709128680231375238395840670148310722194;
      _points[4] = .1063014797376931175504486884739310046446260359816027861282438230188065644711946783060826726008415025;
      _weight[4] = .1375542142025096877653615060378353535237823217814758119642712415097028824989683064469150679287331653;
      _points[5] = .1530585749557192122497019530096285339475255004440860527688523339429919998362921566593935826956916887;
      _weight[5] = .1443411095395721799450733462238414248515479283870827912143456827382935051545476673209780808262551561;
      _points[6] = .2065877060825335686769803341751510840175689986107977624063634924301173628588357156175136088108009986;
      _weight[6] = .1424637790987724784544985952839802649730864625728979547070145816086846459169762856846041536053044903;
      _points[7] = .2658470140108159098108921515437181536788750914282933339485578881666960769687043708156597820375066452;
      _weight[7] = .1331241870513333849458925379704009194981324486702047607071260864313889685659564325467513394604774757;
      _points[8] = .3296830989901027237373491420545228582656516694202723447101849302637120749496599731334902543040306284;
      _weight[8] = .1181122908083299756311975390634647250493155093193591314865424228051155593226483354511888038664192100;
      _points[9] = .3968534769856190095039434290948319231559830819379799669417186235032912613191108923209116958842566661;
      _weight[9] = .9954033550102391323827171966064464287012304366428248944838945894154080711643726715650514184490663175e-1;
      _points[10] = .4660507666351746484729664900381236689850117104625250010739461671795351570200905473063913279087995362;
      _weight[10] = .7955912026541126007769813685510363475963878808713764989375842730287294266866641538077148042860200145e-1;
      _points[11] = .5359281386930321609326895183917609968520364389050114840655237758106639373854988648624902834575404957;
      _weight[11] = .6009811216766876110645301901080290470540542252779656010666162330015632690205531715683178923222126385e-1;
      _points[12] = .6051255339761019284481098523077407624240428731564207776008663713434935031358888405650262217950025242;
      _weight[12] = .4266508146203472287514740814497105426127212704884677528002189938589343854792402933566360152308841056e-1;
      _points[13] = .6722961409869296162899704994812126870277260383783201960320999269060656781743057964570096111577941914;
      _weight[13] = .2822928389744864174544586786898217788137229652458972736832397295131736231647885061286268917613281820e-1;
      _points[14] = .7361326205972873484641029767022052979157240580407462771652606168048533849135950252466274550522292080;
      _weight[14] = .1719724025685366088414548084037341187485771394568726343623778138278751292702859398535198066378698652e-1;
      _points[15] = .7953925737461314623249865033277437002775654540111543847783430994750663228409525643598837266227268829;
      _weight[15] = .9474486138446127589636908414029505700709517833191754141564237314203429084320420413231363560329652725e-2;
      _points[16] = .8489227735376888398440174689512629925240544749893709330516913793468738663135396111526364874935058052;
      _weight[16] = .4592965682865899309081525926914390207513681471407921864480309470237783124356199535498939949761317970e-2;
      _points[17] = .8956817429254667605282025742976504630403884116278020040145896760872923029903183803945118949524777898;
      _weight[17] = .1874294450135896801731784503573779401671276969326976735014995475320855077785022212257014128835779502e-2;
      _points[18] = .9347604364012299479827942935966019857975433066835579885667315868005288394577841513140255125926973832;
      _weight[18] = .5953999959462022743715146028300385175077092750037786268248278976636240495566479815754772126034662275e-3;
      _points[19] = .9654016073657424580929490790442942557127428617746879386553787549823009422401519559419539901187906329;
      _weight[19] = .1255089335871709281118126890978511883410232408935299359481594966361344340514817928666164954439064660e-3;
      _points[20] = .9870255665787578365469005516471821103487323205471391754376943598319864464211860106934058825645259436;
      _weight[20] = .1143393418724068380170413895308611060849814044915809164226820001407628104622909351779375360804506202e-4;
      break;


    case 42:
    case 43:
      delivered_order = 43;
      _points.resize(22);
      _weight.resize(22);
      _points[0] = .26200747203711594248593674552648889055282549059670753414142097164037660026957532599825054627939248e-2;
      _weight[0] = .2673172609568654751853295736245388910769904510379438631959110356067466777925600320462686650460560112e-1;
      _points[1] = .137536579873858040257567507090587296357787100752904979133010541135178259103557502106147159734870700e-1;
      _weight[1] = .6039224968649528527797201695304747719350890246767119584138949538030174755780883063573073921083354585e-1;
      _points[2] = .335752268480266927143081916401578225593655535425147961825613608524864409778100002908375565340915060e-1;
      _weight[2] = .8989485493810659201312259319068572635263313059560239420597839977609904961839090425684555758768323615e-1;
      _points[3] = .617355616230696016908265743953079923259323985343498161679544986939535882534951072547577098410362050e-1;
      _weight[3] = .1132978321011550534569339446690910280401715810568023622298179018105850110347547332801454825123080108;
      _points[4] = .977326966753686424584798849967233234692386909763349364030202305016480177189642811268885212451348131e-1;
      _weight[4] = .1293178958114777478613063500315394516761550424810764340961225637292240059327409033219261636472499914;
      _points[5] = .1409243977569515851945061977581645188461195970869053868578312970446406184300586658915338894104880520;
      _weight[5] = .1373943986576711189457038637687127484198195244023737460240143431480038626621631210916534351512640734;
      _points[6] = .1905399551842166284991396915288050974055091810716148172940553365188707797144828728812777249740083840;
      _weight[6] = .1377052393125228077987045052679605699295332423726478549816510583467911003227901128808596333174469450;
      _points[7] = .2456939996245033222244651990043465110400952191612821621011308886225917827575436024872494923702035976;
      _weight[7] = .1310983476019885069549959653684284929730374753089605272225430034875336215931548267651214213715268346;
      _points[8] = .3054023184425990231526085351824413364932159709089239800101319162552567160333479391342542847608906842;
      _weight[8] = .1189493465137092329856021923918966933745585084719621133590629255356233490617687640631696766904364930;
      _points[9] = .3685994249559412825032166420129271053410258894370369258634481384659319950868454860519985944915827024;
      _weight[9] = .1029672849391876735260280671946109142630666826269145737607246207862594409036669986746323585832975407;
      _points[10] = .4341575748401551375082012124710567475311318981229697451221181030460066453494908033714119124482954652;
      _weight[10] = .8497667125409721785945148880879745505881359027847151653606924351274875356349984209037489762238788015e-1;
      _points[11] = .5009068926479350501177501589277218806508226892948913257700098794311718939499484259368208163972501152;
      _weight[11] = .6670592951879767846792762476690622296014280028874613091699757533426509227995492281918325108396123330e-1;
      _points[12] = .5676562502726097870217726677178769223611025672537427859994804146174746381249794034881861040558801353;
      _weight[12] = .4960981404383829993700779271549480288885853637660176997186571280097470956587682931711438082157298982e-1;
      _points[13] = .6332145255726628427916625618237318565701781915004554642631578635011061799446656933683602264420425428;
      _weight[13] = .3474679389549965662247861906215097123019694954611807141411557017597677027192888562429244380178121512e-1;
      _points[14] = .6964118629859517266112670768971276038290954874249845702950806736765993872213401445317623482971794440;
      _weight[14] = .2272307353970016175798801382037590056507281990311145345973578790932392062647349992155849279080137204e-1;
      _points[15] = .7561205591789348712292879352778617261241380680902387401392793226178491537553553080545433141959526422;
      _weight[15] = .1370427408387923505535094139296990898530719232986605891147317475726272903114323254491117374113056886e-1;
      _points[16] = .8112752068392205078781186463119643007891999522242449004575256452024235067993066706011518445018605558;
      _weight[16] = .7485551813034275817216951148497417410643864099134073165862080079074318408799086608465326460065583840e-2;
      _points[17] = .8608917527628662173065612890887607980242804078166109331181252056491267361003793655013810947480807696;
      _weight[17] = .3602665011170079496010454313375118125820248682611777483518813337130543978051137706444943920819799096e-2;
      _points[18] = .9040851784977527206617013643188418266790222208067682092434771080729602120076277567836036898919524325;
      _weight[18] = .1461453138691387066178714368792017613580659773821636378785062623685765189258882757952421549396110384e-2;
      _points[19] = .9400856692108184696160307746610789762831294650129674325772200327073362883580966732090847381891664410;
      _weight[19] = .4620588367040999729282212179118719403671385452681342157971829216665667312380747639184954098698194135e-3;
      _points[20] = .9682538838165636528816421008794414241196089368489573782572610534009132752925859249504071948887714274;
      _weight[20] = .9705271167906710277821920044618755965438716605308287260605611296691915914345444845503275016391923235e-4;
      _points[21] = .9881024599908778831834893508543820892773502151203394249702418542482522913410591542225873730537641332;
      _weight[21] = .8819828241607839113836319188467664692011455724039965611658207161388061470286555951138804730569350675e-5;
      break;


    case 44:
    case 45:
      delivered_order = 45;
      _points.resize(23);
      _weight.resize(23);
      _points[0] = .24104039982517807924518565881019729090665297391197982121880462088142582890647721012738236191436092e-2;
      _weight[0] = .2460458715379363680944285409901799406845331559876742556717226362516710861484213381914679863785818294e-1;
      _points[1] = .126567991854554032486919041147616055178068993488019404920062315307023102839017774129144625521725830e-1;
      _weight[1] = .5572024457122334686306970307932336946322249656441291155755441029051172750463539491199941727180475030e-1;
      _points[2] = .309142052168577704252465926144989596746727031220608678386387208061810978842626908649325532451436072e-1;
      _weight[2] = .8330302639229947932606202543244005159580104495976244028104260557408709909900455946501899842558971420e-1;
      _points[3] = .568869707344469082103258883833696174365401590733972508265081974930562947362731613085632868973824758e-1;
      _weight[3] = .1056636634236599800025960030696444996116926205371369655056408389679930032480510185451900109913960647;
      _points[4] = .901491345577398469158994861292273721141325393164975822580806794943871185193486088915306872681911823e-1;
      _weight[4] = .1216392044936975061036741688714549551287865944305569473422823525233694802740589876102731729525532506;
      _points[5] = .1301546569620392647297136145470657135930380187181655783102116317627332537731657610993460755762509309;
      _weight[5] = .1306458637267026875983182867538939685731303811410348704694137140183344576684464387632647558938926052;
      _points[6] = .1762466912782491162874995389654770161435899409370830936250632217648999272579318891342051808242807321;
      _weight[6] = .1327030992078616851137716062422670407717193811777823788885466984107914606883493188467711293676171300;
      _points[7] = .2276684266411056773027710770956689945976517001579188130220661151724974754332539072451049501434355576;
      _weight[7] = .1283940193233969697677293919549598541264664191744484566283510181595252794240699445354258114229281919;
      _points[8] = .2835755302598378337994539658113249207907562733532297915625840729145925650514832273388671279031826859;
      _weight[8] = .1187676404312684393557883257269936135587246278818678797038987739015900277273626487102457050130226676;
      _points[9] = .3430500166905744572249642236228373303079210262636306213248867962132213743211306739909111276661963969;
      _weight[9] = .1051971301902735212171552740490809864687285728732286101918097259253218725264728006157687448724569254;
      _points[10] = .4051153234824939152589899821459852518084292041960127091818387323191589246479819549763061565524843400;
      _weight[10] = .8921331592042749615179791387250922454007077948520920020945311505702881983826510488006429430176552255e-1;
      _points[11] = .4687523477214090214073558308296168896809398353261455806058774838069360883559041595095033610401987426;
      _weight[11] = .7233501875091631840919628023809183145752557746817854260441269393620510970432941834632187160557783415e-1;
      _points[12] = .5329161809469259852961679422880949408372018266872169088225806359785246671619598639988003464099914504;
      _weight[12] = .5591706970939040592614623445525001285248857059702692030395415650257556886501471071456697084452361735e-1;
      _points[13] = .5965532681512670094276258199980622909368222170766033931827570264949111422639694369359726047707370604;
      _weight[13] = .4103337000606945503503522217670326104878723363104651468601157260930516194676854942670347964613293931e-1;
      _points[14] = .6586187096898888135130219138910443233073970121048619807684601196253997338641760466888560080659310002;
      _weight[14] = .2840664653778501707948217016440661524304227052022033505140575431516377941086740846607743484483161705e-1;
      _points[15] = .7180934230399323348705289685504155581364969503653955389526645485144502596400176203377598049080762145;
      _weight[15] = .1838949716531371895801221750607384775779877835883666504812201193134363107981822179196427825683023814e-1;
      _points[16] = .7740008848261039548706028650398502324593547673081739454184965735674190874482260530264986752197143283;
      _weight[16] = .1099396318272331474169753508597427233921996009999619601995167163454190521119038525024744167647521532e-1;
      _points[17] = .8254231835351607786693628066740285412448723033292098215120413379094288517271797907093120388750574780;
      _weight[17] = .5960272673820516018892550728367359102119125009944955607272944225823529645958240764551805101696205605e-2;
      _points[18] = .8715161336713438696663789268096078560203102425650686035780009545736051097600251592363012603490396263;
      _weight[18] = .2850497081093543249504950370776049252981886294476489764789366131665472664109268239563547260999774662e-2;
      _points[19] = .9115232476013712848631727800493825734445243013466233941759256931038532414323388171548016643162638202;
      _weight[19] = .1150314682984822344334855610916138444468915824198344682212336984814856306470038289503572913456088932e-2;
      _points[20] = .9447885021959101873192640703319531140411645602202181230261730429904477029248254097807519999563812720;
      _weight[20] = .3621778022397484227568716984452699810122401675080385621920809602503235452142352579992064771026627860e-3;
      _points[21] = .9707685195733889938794720318771182548024669818727768010084319949615096226307776604478341088419962470;
      _weight[21] = .7583423894827645199529497212749310045124079552553215845278302430393444077320694676832430473557877340e-4;
      _points[22] = .9890507733735791253543712469758400035281773409051211956278514761266032259261348911429860283320819928;
      _weight[22] = .6876667443448386873597174615624846641300742166712499390444623619723899261299135896561250086555721365e-5;
      break;


    case 46:
    case 47:
      delivered_order = 47;
      _points.resize(24);
      _weight.resize(24);
      _points[0] = .22249354526130536658919430692557500280014777996472055359662834121595147915829993046727584966003443e-2;
      _weight[0] = .2272123685713789434030881931524938582897026979966692028426173000267001400447472415898858193147616434e-1;
      _points[1] = .116860039697678411958597064537259621350626277559859336655638142444162076497727372185304393427526580e-1;
      _weight[1] = .5156450302852561733106515247255298513224662256829380501788829770758411341850704243499552632230453685e-1;
      _points[2] = .285566141910057507843377310699147431374818968939215074653067704539297268292695170889637302807545522e-1;
      _weight[2] = .7738771704125657665401015992403564121662898479846865035804772254684527134060060366460129521533423465e-1;
      _points[3] = .525848397643218343854147368843054235263457492940869184703056976531972677056533757103799011269986608e-1;
      _weight[3] = .9871617322318441702547220169324858290886567033955491182963415229959747527921243023604629810279797240e-1;
      _points[4] = .834069082711566934226571503191487071239351334940694362557319605382390528434147646059507613279901368e-1;
      _weight[4] = .1144998723800464282627119569938636431402696445948437363201340620984458709118113476601828043188131730;
      _points[5] = .1205557027005187819785359775783852711983906679686549822611192158244964090168065655430091806355872867;
      _weight[5] = .1241560818892750740513319197449305270799796663008705162149327212005494018765146066229281884953699292;
      _points[6] = .1634681244020306820900081449797999118733278369358442810228438232040837540450435199855004039271956991;
      _weight[6] = .1275967032512150077508959204123806314593760528903117432232790163652944697231707117691953613594326376;
      _points[7] = .2114936819377605655182888616348370137102012365281441126857995265139411092227855461865391104829794484;
      _weight[7] = .1252073956815181771346127294596215849298975190508766297740178851158073346196145842747014091497200859;
      _points[8] = .2639043660726025930345938310051340067520452082079640857559305951097397292053028574030042265001554287;
      _weight[8] = .1177809496131256963154687299353704343516432112100715198188912862742036151417784070771267150840848668;
      _points[9] = .3199056905142705147196284477592600478118677860085346296646837337943071384012733116212835394981488250;
      _weight[9] = .1064140204072954464118267057242311153891075934728738476926957640344192610080730226508773305006259690;
      _points[10] = .3786487375725983130255223763826594151980352418923449568992150385696141263998799737945727620052669868;
      _weight[10] = .9238041135649377632848298626350660907150032768554403014238224628817114536167770593375677111179163145e-1;
      _points[11] = .4392430280138590771400222586966484479281187490364367805606402616906997553927361513577773490887077744;
      _weight[11] = .7699630754163361492101271509761239393849942140377941862209472613642061946357771589251994659060800815e-1;
      _points[12] = .5007700206965443044420384481447814267438751908957880531164770293158552605883981361981888199260713036;
      _weight[12] = .6149308156503639872799358294626381094725788384605781475174499580448305892704309824786744398644990350e-1;
      _points[13] = .5622970377001162863211472577185407563882405046536041909948441852501756198349145685895124686912743446;
      _weight[13] = .4691155780914074351191359715317592062114564467849614405909797762356093740160687100859266520779691014e-1;
      _points[14] = .6228914041763613552769405578811627797744735067301256611232410007539390365503687846951176550441159124;
      _weight[14] = .3402821314534665504742300668651742375478680187207505350701851655484252062079811817240060870672024592e-1;
      _points[15] = .6816345890584223343347584224654693833359846182784640936142748749084889259843441535034498170983533270;
      _weight[15] = .2331919963843795558856289001178667829714874513151429202299104727270255015570026749611235251715162338e-1;
      _points[16] = .7376361331966650834319952799565664239997149439085959623604215726217384164028452637066239693458780328;
      _weight[16] = .1496293466914953505461657394313684425359985778938564411206391793398712847327829843346312174320029113e-1;
      _points[17] = .7900471558143551952024299464595864800685694943997857653563880504121078982496465547542056175539249178;
      _weight[17] = .8877010801018946117185025924342474510540324525513331403312263343710478394357406571414381506476965365e-2;
      _points[18] = .8380732394393357620477594707813738107956440957803211619128696670627887064733041577933862555402706288;
      _weight[18] = .4780991554881356318299278737356108506360151954128225642257285864494409119970728164251078957004786094e-2;
      _points[19] = .8809865112004901553982606734371066424293828263572332748538020660425345593942795437337711303415934298;
      _weight[19] = .2273816875030566631082337760719505683063855834506483104577945072621905255965654055089511952968493576e-2;
      _points[20] = .9181367783042758317115298970528403234116421141197280467998314494812585311720032200286955057989597077;
      _weight[20] = .9133865187289247367136496244884025935049017690707982258831296507599797381201681041293892913663144105e-3;
      _points[21] = .9489617024727324761890720630019867067891512669388670367116995074683944983852471238704034144706237931;
      _weight[21] = .2865262744228954315248621894840737436204226419751809547178299642115143727296322854938132591638281762e-3;
      _points[22] = .9729966238607434240581902575081331739557554587997081204643390924536815578867557077759207213916867342;
      _weight[22] = .5982741578200805140757442756876710357681187764184129492998044221027472286015156917522460628695894720e-4;
      _points[23] = .9898901712174520906251165597593773918847523673221438024487047832202131975743714655305404620841100670;
      _weight[23] = .5414795649621589410956891889788871742947297812794956478833735739984001890036849423513416387803433365e-5;
      break;


    case 48:
    case 49:
      delivered_order = 49;
      _points.resize(25);
      _weight.resize(25);
      _points[0] = .20600819290978834992305487712566416830306441355885579147790231016968362897147721462005308031489629e-2;
      _weight[0] = .2104584654991310894984769694957997264389234706488954830869366146363669643607673681284303221423900922e-1;
      _points[1] = .108226830135903113810584123863861074175441949501461857209984338280343289258064115821640072580259251e-1;
      _weight[1] = .4785247342860094090713410636696065372543581105275627351894179124877984338090126845614454514490370110e-1;
      _points[2] = .264581297235543328126111150274144876238158293048457907207494238085749449768684793471686045629576803e-1;
      _weight[2] = .7206284363820171160165937570261028877417915555039796312170958415818099948789627440765981158860916845e-1;
      _points[3] = .487504655197159425662604840549514986387265026200742769228905052346425858028303577264269365332051794e-1;
      _weight[3] = .9238508110486277697046072106183462307349301111542269581192066431251586682339655452945584717818739675e-1;
      _points[4] = .773871904794186405884454903565109546341932109346288774182004323075300704614515159942460690764711282e-1;
      _weight[4] = .1078731206753558255699920516316999773845920194453412445398199388813993235893370279142172655876824572;
      _points[5] = .1119664131211797080591453118900233568411335618341266482302911307568798211658937390561142794026764607;
      _weight[5] = .1179603120946719806730046151597300929107578524479463578273411646787924756993067021805466404652833203;
      _points[6] = .1520027529734087162506287551943575708665665516914832278052044133827396241518816510167155210118597588;
      _weight[6] = .1224872666186146488533662443240610951691534977442791141723136190727891953370651772473493690396277062;
      _points[7] = .1969342031254723248318136513226723837261617920675631369200407885476768048090584724200227907109777927;
      _weight[7] = .1216929757207637586818931039746277834402913288184501947402046698604718770716389339788734358809859118;
      _points[8] = .2461300326799557368501708657724630388374281519477683919406243379905396093914799829014978822920175094;
      _weight[8] = .1161699062528098563285204629158808188551384494639865932612070092262711343486676737524132437678548470;
      _points[9] = .2988996452854616817472628058730197227314433867599336194504840923830631129196201993067222862706236950;
      _weight[9] = .1067889173288499383103435803421296762480412898220799307294532420899026429787438563327810872649051310;
      _points[10] = .3545022754336092801330830225246756319748235396671835065241829375954950971669723822236925390213555706;
      _weight[10] = .9460303776621984255911428340425176633044568964941211415406548859126157076222722306525009261263872310e-1;
      _points[11] = .4121573881255929482897040156029304602803026810481251319022819080784439249416642297798100544798503956;
      _weight[11] = .8074110304100429667322390015353026479458249971802668553808949061734867458681218551998618063433486040e-1;
      _points[12] = .4710556365226797192363701668337433453652680273700752120149035736826756466148957367682835979522326213;
      _weight[12] = .6630287633400960740664405539791593674018482270105306573866739446952101295678770123011621440596649785e-1;
      _points[13] = .5303702240359852173396065663591384210267634451500462472121109299789877460508376633515105839528377266;
      _weight[13] = .5226654254025416026230055459765768735408748982342137352210401586284879927470555960353573242755475315e-1;
      _points[14] = .5892685115570647814127303043715788194113182486287723623739652905892272971097895471854805549415698537;
      _weight[14] = .3941749238248017695654904390708201200479612204684234083409815391209463268142666322461799547268657053e-1;
      _points[15] = .6469237071357920937508249478501848787366871342377897238574359882034872352624041632877614982121503126;
      _weight[15] = .2830437637751160048700083768002130944295668211190091848676117122152547090095035944438706910338870748e-1;
      _points[16] = .7025264744308617327764735628652519707991262430777878489777111185176795447563520263257678166613306624;
      _weight[16] = .1922488755916925990273545208551839304413598984038948928740273847627349626429186204670641466308664816e-1;
      _points[17] = .7552962978229513043581799301877042674961500659949106188709770331116463725525761120695916327062411800;
      _weight[17] = .1224007338868042622396387022609224838828698746567512089592318372920877496450321656939677888467607300e-1;
      _points[18] = .8044924465194527143198696101390306595020306714115014471218090194399979166482091146097001614651134796;
      _weight[18] = .7212634664746175919255619014411005105736855663414167780607988951879937275803487215993101186412011425e-2;
      _points[19] = .8494243882656275732290900248503280680907322871463571360374955681062300158144452515011786494799601120;
      _weight[19] = .3862047153394014885660554694647840111512019761959973821093873699280118779178659279767371567986827532e-2;
      _points[20] = .8894615186907393745656503873951861823090345844702245018938672248913223057207012920176380233027941396;
      _weight[20] = .1827746097251135206530204407903268733428075081612346622935423986110324998010804043842916884231459195e-2;
      _points[21] = .9240421075913750881838602702996034607162778399469706512026890165612157489271054019443733670963922680;
      _weight[21] = .7312150296955576038999427301489336061245571898075392624561063075884138374981784504825115223133789420e-3;
      _points[22] = .9526814786656007765604428427646471107128280724641542445681143547072496089803389360499312827713015474;
      _weight[22] = .2286333412778897125360878868810677218018864957423887924835086482637072540841046732817968526158322192e-3;
      _points[23] = .9749800156322561440080537979319428058608688920634258011461633746480601222229645349760627442123002214;
      _weight[23] = .4762148988535869484357810517214382489037315091947178037681066416731762841027085559169825803906717019e-4;
      _points[24] = .9906367009503252040186638786057673854869752103072860840212608497776729091053687956427078165918365860;
      _weight[24] = .4302755109283992853390612984473905388520107606420784662639203221026015612852498093180725123270944038e-5;
      break;


    case 50:
    case 51:
      delivered_order = 51;
      _points.resize(26);
      _weight.resize(26);
      _points[0] = .19128971711032702883607852452175290537822164387361021139258642261362003063805408576159111384445623e-2;
      _weight[0] = .1954892722439377291610145584289408938746223353894233403593192849234043653992666165163094243766870808e-1;
      _points[1] = .100515489590570582910183716377600783988728689417874642729565404290050683612552394324891041215558034e-1;
      _weight[1] = .4452377548054358057693152306974293779850488015842524187316405913445811445216693334480955695294329956e-1;
      _points[2] = .245822159356734413995995144294517360452522754200859768370653662906656289710655586389084613025688277e-1;
      _weight[2] = .6725495107308428165273852693974342265312725376252435168146700914145779601982415440151049601834443070e-1;
      _points[3] = .453187460896998514112593989287135239258234907004174445030641840360933829254328678041636904229728234e-1;
      _weight[3] = .8660682167204660370080193943728064352793416035738853172340408852080310732523056866625940444334256440e-1;
      _points[4] = .719912111332091389795230326331533799084497868259454309849621965493314095992624337097552292021463460e-1;
      _weight[4] = .1017277570591432847348180174383227213260284916100920427592935367507284866022929405674419032343979144;
      _points[5] = .1042519922933739349627321569155201289060616104436747962912852388186208673319729357666535825336731682;
      _weight[5] = .1120761181427334190032010245158099690638256138925814165287686360873920886305053666402692629197017782;
      _points[6] = .1416805541841085939424499105077162112269282743432822292773459439118180445686557930664348991933588237;
      _weight[6] = .1174470285752688860802839059280039691280440259409814273375947052982746441066239455155823968053011634;
      _points[7] = .1837889724621079951285773493909411733485119513609893231234408186596165165503607848643038915766772525;
      _weight[7] = .1179710549264457561782354350967497775907646397405245096492474927754560320390464932600093016761328566;
      _points[8] = .2300283068068220712641291993271690939020865858057241478025322546962153343757089150788080487183609627;
      _weight[8] = .1140844639890417668241464892471366407764480789831449930204960242372119155349985796101274928158011363;
      _points[9] = .2797957613012491859655855463898480988672060062249520276103935539643102128193564469419623506479628470;
      _weight[9] = .1064747741566808125685613705180191681616285462705784604164983200734269230552528149319398254833744568;
      _points[10] = .3324425444646478977643705916772193620886659867174346042315363799570973060383356369124115211571323784;
      _weight[10] = .9600780433395996459611005163022683822666687189995853795269920650589609941099345779579700299704646960e-1;
      _points[11] = .3872823280574549937989445036865958828972832166536714882484665313850184327167229220473239233584617594;
      _weight[11] = .8364408140790913806503136264243828949700520235558282644016434999787678203843397466411902861456776380e-1;
      _points[12] = .4436001949306515828559333823823612392858936114867615745808688805378474705116095676777622646630552513;
      _weight[12] = .7035322704434977742682228930847787787019711543667177558572243193480196890984850180718542235275479285e-1;
      _points[13] = .5006619595031362884856902687713503167221436363552477393781189311589046478109453733251474626310385349;
      _weight[13] = .5703475748022071828509619466256332516846561787218921379234532042280759325691321139002913907127018235e-1;
      _points[14] = .5577237395010012764647206840844501727253666372843105914449844804197466442981144131225215846683212315;
      _weight[14] = .4445264224788490718871711689716566481241895041904883850657992386825320854908231823847572097867075329e-1;
      _points[15] = .6140416543163906865961035725129271962910179605530973598443859211090243690612314978954036450474195975;
      _weight[15] = .3318912383294029289365821071167045100713239775208250096989712764224744184932990528332463294336166066e-1;
      _points[16] = .6688815237617270248821108145549645861198322343286327852974929404210073467991331540955757170564355138;
      _weight[16] = .2362092686671659042978174608045888691391205739211617575547205261057781698393797934731154080105219427e-1;
      _points[17] = .7215284411637628205782811219801685752763893687252454146020804663752143651812554588012584507935377953;
      _weight[17] = .1591836500223050457908558597913063177486827168378060246011515511359787919282859563519099594095542618e-1;
      _points[18] = .7712960967780431853930398083442015153386640842171062566103950893923844867230098706227918714691709292;
      _weight[18] = .1006529114352933492141859720393617288379654166295349784959577159585971733038057997542309190075883663e-1;
      _points[19] = .8175357317097885446226654263638273500789689214285257860423082060382710028297478571779544782286374176;
      _weight[19] = .5895624378770345168835737990923267314213457921731405554223994080869703797491624920386576121219775570e-2;
      _points[20] = .8596446098087925495341476044048610631434683111426290228292610152787315792738718461682721701424964985;
      _weight[20] = .3140570491033566324169178308200812903593777775611657950464043256177915220403707237044709032980166763e-2;
      _points[21] = .8970739084211864094916125355818095043974285476361644489211453364655049867582275024468773277447058454;
      _weight[21] = .1479803510496533483770404222388761836968823110573963984604554556290327130157655956042477025150714642e-2;
      _points[22] = .9293359602715748334061432334478793404990512001092018428658048417839597361733846070929979731803166088;
      _weight[22] = .5898711555596490013159173847175552002172211131197603246704873932959527131487834703954940100564916475e-3;
      _points[23] = .9560108839274215742662198697342406595278034313234337217490396871934265900098665899697971229408841536;
      _weight[23] = .1839034851575356489389594530597318328668080169779138264875530228689413045229252063322858580619723530e-3;
      _points[24] = .9767531733280232298662661702683429698796977567485282341214009937436918106009940247102813503324797746;
      _weight[24] = .3822053883255387900554746410523715204390828917060415678743895044994612478539092658170411525843891492e-4;
      _points[25] = .9913035622385110788790336653178278306638685473029327049342568556768750779226166802910464862467038120;
      _weight[25] = .3448114359757205756745360166489525198386376580749197638121869912495215206262890112928783159385423608e-5;
      break;


    case 52:
    case 53:
      delivered_order = 53;
      _points.resize(27);
      _weight.resize(27);
      _points[0] = .17809431435704608855587928866114468786307898470660003902705764595605162745697524798561564126761266e-2;
      _weight[0] = .1820603118871048582942728891063964187212465208682135554645716213359324348541984929906565483318952422e-1;
      _points[1] = .93599372582011150287054578298726684845105659955139082644440784972843705158637264028246006974799600e-2;
      _weight[1] = .4152785829844875717943172756938377186734953754235234311353404373544544228087795063553583138803786181e-1;
      _points[2] = .228985426390770205039529145556914131173897091918978865259237712745826314411040163239733144939444396e-1;
      _weight[2] = .6290119746144746482802734864589386618833347317601423057015638714495873048300389062763960852702919060e-1;
      _points[3] = .422354693834516052027485944384642742304266530428769304973172106288833079274724699509410823014493548e-1;
      _weight[3] = .8132436136446986193739170532758880791397877196523611071292546215873628519179693988262023812620746720e-1;
      _points[4] = .671363692990112465957839047905593365018540666341491788748814233309382335197310409511145494368294354e-1;
      _weight[4] = .9603082810201882415311963795104748870818268807470347887502846531247874858577708795486787797700101370e-1;
      _points[5] = .972990698736721763753164344064238004527912129365851467031032541694671325752127600065236562458456136e-1;
      _weight[5] = .1065088544552712310709129163765736239560946416142489520312256996469840584797893553601386044263009528;
      _points[6] = .1323574675652328254198509862867790334541690279550368666466192187710882991061076711351679865216258966;
      _weight[6] = .1125263755484285883365205837252928997215348671664386328271427347062622899654077798856301612961616694;
      _points[7] = .1718860139720701680722426766544501251353813244874586832784733002806207478525176577679137330683877836;
      _weight[7] = .1141343235447071384761478578769258902127350763147060770569388232507400711703976247938789690083039576;
      _points[8] = .2154048926944543171651652614570632101946667733364492996249967765409568376782797064089297968838453420;
      _weight[8] = .1116474563280293741109965065113128931866832316104691669164509221561199637581464430175629068932126426;
      _points[9] = .2623858474559273881160617913883325511276096577994481672721349608546023050783281843153256814191169230;
      _weight[9] = .1056050230492805119709298866476760648000510141882851923408616735140549390641398474028584341746594072;
      _points[10] = .3122585959444232262993504592262882061838804975738422821976444443102486079512087157897605571708467080;
      _weight[10] = .9671552705946981898751774104684219583762712809680328375846161035397016840278817983469759130132418535e-1;
      _points[11] = .3644177529904574950557756096570565098512806680305704179066355757972527488832137323378563137368606048;
      _weight[11] = .8579121209195122447243328295236127860714191311346550727152062805058661851930724613643640236403012940e-1;
      _points[12] = .4182301795447049734724846472391014243667560340702901180312848174318171551123809662146069605014604107;
      _weight[12] = .7367865526297174418825984472902459506331849312468798056148539468443217520004723844738101147944550970e-1;
      _points[13] = .4730426684520476703602592878224296830904178855899382298873897364315299239631836659193743186739257835;
      _weight[13] = .6119194926537683569355451543997997296618926203848359030101583951544914289940470883109383512474600590e-1;
      _points[14] = .5281898738355329340216577227400275085482081965054560134090357670850064365267690953455340248245174630;
      _weight[14] = .4905440341529198363865576676516031676767482097727449018102715309052236173245485358847778720174353104e-1;
      _points[15] = .5830023879264334250663902804376328580572440100955175317865653839064321210069269191484571926567993637;
      _weight[15] = .3785356234773460919311606411888319543129071813262592167579519593720136903085223560528795008414461006e-1;
      _points[16] = .6368148674104017419630307715995676902754314764405299930956289867406713625910027046038473059912601228;
      _weight[16] = .2801276453548874808009747976668363223186535565759695290998544442635238085147611006105071688900957438e-1;
      _points[17] = .6889741108323418280816571990178261232404686847403558539490499437753002791024731150404667801081009895;
      _weight[17] = .1978061738005189821681119732188615744078771959445292827828842468044747984641395372722160776435867028e-1;
      _points[18] = .7388469893624735910922449829548469590275526861901167534999751484805700903189045500413201466516638950;
      _weight[18] = .1323785353886628364655051789746491666869904914948154796436523205630295604837132271358219443077646624e-1;
      _points[19] = .7858281353779031227352117058077111616012152440575051383618183698144842122819671305036791359257551114;
      _weight[19] = .8319259767931359303359612245105396666555498914945895238762583811716697454039472166862699654837540950e-2;
      _points[20] = .8293472971383944771598355049274250058834269029021771996399619672863673163568105696112267907482083349;
      _weight[20] = .4846921295440348694709177690869156229797846446689132658058902702383248719112744082435663250437300584e-2;
      _points[21] = .8688762741806575564667761401536189780901445930466251209065034762678430393181039572235882829647507632;
      _weight[21] = .2570049171197175931361063941668867313971915134023462330557089030766363955154108296199490402099547780e-2;
      _points[22] = .9039353597784711070157033597360474229931818363030729923680719044761889533438408210305605660116503296;
      _weight[22] = .1206248346191819371376031994419143604659128577657921712696593137994525942080056531846628624316997367e-2;
      _points[23] = .9340992449559257825950427906558732935953068512720009591535099193403502312605076880588140292621822480;
      _weight[23] = .4792697453785258073340451419757222154191164076444721019392392800535122603874466076414342782675321384e-3;
      _points[24] = .9590024350798769967347900672867432755261033514982111722784661932934780135998830463243946849776918500;
      _weight[24] = .1490333111707578435026953455921951778699719566794053596354648989169784384847030615809215344280202658e-3;
      _points[25] = .9783447246593427423009234194577171124968296718365230530311186830121782128183606331424343744729398783;
      _weight[25] = .3091244161938983408314671147246492772583236893784015618585479755757538573429388679224858698333417363e-4;
      _points[26] = .9919016921030858633563363794429817847379787714779279595620322545994397707381328467786508349830424110;
      _weight[26] = .2785016388572537705690681609177755671609902607460882831309119306006182467890894946863712280688572524e-5;
      break;


    case 54:
    case 55:
      delivered_order = 55;
      _points.resize(28);
      _weight.resize(28);
      _points[0] = .16621883340103442578914617712118486091931026683663448863398514718237214116593066504342377079833743e-2;
      _weight[0] = .1699675331355490717411502137389388500094524603859825757063307660350119689582330208715669392854149888e-1;
      _points[1] = .87372844723921413906571224209064625702009044587044756728285549044870588819373520276783423437475107e-2;
      _weight[1] = .3882216114018575013737603191814056644438315299490187323801632134159387989617155982777213687966878158e-1;
      _points[2] = .213817648356837396303427133614951684126655686625838667903980608247507148781467808005105819246606026e-1;
      _weight[2] = .5894766595670255670963440873302383759119498225513535332185369018894998992852923394140340003085968345e-1;
      _points[3] = .394552086405397112115498627722666268514408071936493455767292870114142259094541477859745631718848510e-1;
      _weight[3] = .7648678602502570284486028791040104518348847178815882525438877759299820123608218610294754833091150535e-1;
      _points[4] = .627531871254588599998374362648159017925640088262320524375430453264886547027332271779063233736836296e-1;
      _weight[4] = .9074930386242807574850384737192231428927990682057845126440329212535996959549697865102396819307404255e-1;
      _points[5] = .910118093721329149303778633611797690726481076572154081942199645130174229163598831553269553038009018e-1;
      _weight[5] = .1012555974889907126108460496940755561934638347853673107289657786337559632509483599956011804344695646;
      _points[6] = .1239109225098248943986786571525365727357700121269974363446057563225513757008341619263478384404505007;
      _weight[6] = .1077593224554183504441506568716594810393974684605908180762875165119213414701629886814413209301776476;
      _points[7] = .1610777785030255860344834843178969921689415610167914129205340161602880766832367124554812169913634046;
      _weight[7] = .1102534472607597186864914711577228898952005094019551823025011564740940733845646315084518623795753890;
      _points[8] = .2020912680468832554423969706448920337400445843902748221160223851312616827201318751974338594370210968;
      _weight[8] = .1089584330514553833792479007201945848483678110902207242804925059301547571776537296722336107363232800;
      _points[9] = .2464866954363530558083411840821592805659340568933689671152241449226482215610440148989074112781469145;
      _weight[9] = .1042939762323390317306252800023900820145384876648703530515689827183667386399613716670604820101276627;
      _points[10] = .2937610451613514326972750749668948134956539051387656916985961515253610703405985442498156612536971400;
      _weight[10] = .9683723892284496243133400305982014503220595603741460800960591274877472218951050937958199531522486160e-1;
      _points[11] = .3433786819261913150681460413651973878949845823554863178403679470149846273838432659226376928927518388;
      _weight[11] = .8727159968574142456653607461431136580558843981507980115301946075240580150496406025982314095123915915e-1;
      _points[12] = .3947774199723313116769052107500062552907725427703361632104188629638226399349568702184562114618754642;
      _weight[12] = .7633065037704358677992173760070813754526876189118426523020012731468094178584030102693609615406548435e-1;
      _points[13] = .4473748931198531751312384976638757267785856330538905813203215779969809276248509403699505273214443104;
      _weight[13] = .6474239890218384617641579074397429560281200820034847743486255276201782999215045306318422919140676195e-1;
      _points[14] = .5005751534419836230938691110194789662558196515605232274175907389180847879527065705114712877735560730;
      _weight[14] = .5317840198085355889436749877935944937229816786481312186261562562730237943218926093884454876384009255e-1;
      _points[15] = .5537754238684313594769240249501645635328248608561576380556038385473320553947237200652050810344918645;
      _weight[15] = .4221188066485391017179843621910132663247325582481799896194480286103572326145048899412823414104578068e-1;
      _points[16] = .6063729282730147073480576391241726828720982008190425665943509503596611618340212969981896009477717553;
      _weight[16] = .3228783996502644895650898643668602554416833029918697762571085207553801460068086760948486028196731892e-1;
      _points[17] = .6577717217542247768084005053389194499315878203674783143278934979688418886464254544545346213089894431;
      _weight[17] = .2370693220667251758884754554263331205128739505850822623279313400923071925972365938987128520659085828e-1;
      _points[18] = .7073894438877855706285149361350268987939100593278504681962772015788814614262279003604123878408133930;
      _weight[18] = .1662340411686909034142413466450566565032418406426186662411255986983551839951256909951884474432223065e-1;
      _points[19] = .7546639187593059817872803597557685898853275116792760713753923349366380454793941649397924902062411340;
      _weight[19] = .1105609190631242552105479324746823601234418177691168238419979938124926144067391591450784016086480078e-1;
      _points[20] = .7990595276685624868995636153621286979861878231866964890727280422713114601123812756416012428130645730;
      _weight[20] = .6910213443566888748466176890723625292539468755284525612640801075874152045527474588594349530952288340e-2;
      _points[21] = .8400732837976637417846403075634608381826446882830863254766087793874579013383417858472750832694683481;
      _weight[21] = .4006769963826888763696941479740479731548662838861133975191667129930337746666938882273423775283880558e-2;
      _points[22] = .8772405436497879573891723774128885767103809571602310600748670880625265196548463651442992083091127510;
      _weight[22] = .2115799069802587276112448389274307711426310369019676527371289223126989553627023040825271243631318107e-2;
      _points[23] = .9101403003668531082536780547017155187065153962208111283714408048069939649812595801927679940070115836;
      _weight[23] = .9895645441188801027588830624824366661410419145577967624579589789470698427514257565113008958487668535e-3;
      _points[24] = .9384000294379855101586491825366150982471974093849676442221321111107915020236599462447922597108282784;
      _weight[24] = .3920317051831638475926050565561955006834349747351228816020734233503026528227612365403311989965344668e-3;
      _points[25] = .9617001463459457899861099885807198305217759101371616261805924955343739972380075801124042375869028367;
      _weight[25] = .1216212208108765183086984702980407460962842267066259167107608532532670446458238411716860247125496214e-3;
      _points[26] = .9797785960640749944438190057145039152741074495249043615408383040614782568644584229549468171687813243;
      _weight[26] = .2518191216312457714080057893628203062066238548219866715788280885486052172769692157028103974902227097e-4;
      _points[27] = .9924402145386934818494062074608256710512573670377708826247066201588500246796209226609635064997654468;
      _weight[27] = .2265958598962605196822743329763905246915735782078382024974317229330583473761254873410859862569461792e-5;
      break;


    case 56:
    case 57:
      delivered_order = 57;
      _points.resize(29);
      _weight.resize(29);
      _points[0] = .15549290312566654200067529424954278380274824751369305922110489293830712669786881003801986454401563e-2;
      _weight[0] = .1590395547416049373084283970446254939586728862730454297894007025395012962095072997157978392346254560e-1;
      _points[1] = .81747236744186115591038655443929481021570368880870523467902863077171313774494636389564981408046118e-2;
      _weight[1] = .3637065893665729571075344593916540199657241009646385824767892047382103100320527986841586952675574822e-1;
      _points[2] = .200105727753786372911844733724811523145402058468255418476041058357437938665882587330422928921001594e-1;
      _weight[2] = .5534795630399538850185456211297123893344168142281776267574745603114279671978481717366377866836630635e-1;
      _points[3] = .369396752916812645959209072886222502266940175506431296353140616816413196565410066864982546877591972e-1;
      _weight[3] = .7204878416716868669494228779171087877055190291879777468441869777323207283284792884098759434214146480e-1;
      _points[4] = .587829062660505588584086521808717404649548194425120799881037885209152278794077663051279782438127872e-1;
      _weight[4] = .8585111618606221894547223897051276062455717563898810682264732561837504271642097505351921489019968745e-1;
      _points[5] = .853088009332903356323647105585752362105880822371987537471884114197296052322213399245079081838509810e-1;
      _weight[5] = .9630795187080586094841976728359810551551172932908124410591486740160430723013263344014610396770461235e-1;
      _points[6] = .1162362048829853425076721375397609970107436875069462593303916880434153281948281248095660108756368225;
      _weight[6] = .1031676988619209181710558830873856413004363444827527678541306109133352094102382641985777841599329643;
      _points[7] = .1512372911316014780919207790227039606491053931442636445013472589695144451175544237584698175481237768;
      _weight[7] = .1063816687914308151764286948578946009532016371806181830429151351514918575960369656164303899739475778;
      _points[8] = .1899410449901282865692379014213471630254082529921559753456718118947261873986526053764810399620167616;
      _weight[8] = .1060973443529894398202373165023237945259903765282338008207222574643863851930328256989136309726571046;
      _points[9] = .2319372002063364238357113561581231468239578677677663627198771197540715838680988610437419882956982154;
      _weight[9] = .1026382437620365051961261302742550581710573153809810112602447887157691824281457449099765335918318602;
      _points[10] = .2767805891942973708577879729031042713879054366854930668603078587622459594790114634625651543742909700;
      _weight[10] = .9647238670452894868290795505134096581869886645007816822694179149988004663996108299166340298731353205e-1;
      _points[11] = .3239958625177051466248603397041584055661175398120534880219141687715302778163413540837796763370016145;
      _weight[11] = .8817225630680597612003660163949371818078447184949948235473102539086671161349867433599036467560066635e-1;
      _points[12] = .3730825280293374465690792859201248695856590531186829500141964698180241770761618137437466075148481282;
      _weight[12] = .7836975770978971115427402907838920161802800682518189208674079546857625920569703907869991396907689100e-1;
      _points[13] = .4235202564181097995474113146850489926682673472663289206460620937489498826422878291086158784870130803;
      _weight[13] = .6770995846565736534187178620911510510981331439007344136937490702077560334537629961218632220124974540e-1;
      _points[14] = .4747743970009873561917723160531700205066921026924445193997049795210527057905182697247116916931894192;
      _weight[14] = .5680734250845563585288858316504839656434131896796498476261765390734591853152656637737926312889479050e-1;
      _points[15] = .5263016453375968201653794928636041556860229130020205964062744256271705159139407454117566470052847889;
      _weight[15] = .4620793050943086619045368766579074375745787430897608290923105422272112793759027659747296191028447984e-1;
      _points[16] = .5775558026309174452553151152733625043245901657653645490736680818890881281137921627962913404073228690;
      _weight[16] = .3635995684886709788958406007756343059353121747834284301899201980737194866787438745763436873700570152e-1;
      _points[17] = .6279935659165262621820137075296171293948931529723415803682695857095547330445799962987023114707911310;
      _weight[17] = .2759491436298458106580574784196132821947800084432000401014943541800534280281110554230420725253138022e-1;
      _points[18] = .6770802877492443573266568704467015351806311769675395683120767898431579951848013577283510561777889768;
      _weight[18] = .2011976844683497331844387739702727260430369510653869789575590786230420302940347608481479643128532841e-1;
      _points[19] = .7242956444888707043560871701745064455538860059199548248154436973480104217103385414072838784155034150;
      _weight[19] = .1402009861333367145022482741179595153263656328537495601342898943949469294535231397346053110910842104e-1;
      _points[20] = .7691391534023484768538220758922565584262388759203507506806944987604814945430447384460512918718215715;
      _weight[20] = .9272946255348385389541458548765573070689017484996409398510543999367015481576466379271350135140451005e-2;
      _points[21] = .8111354807272444642075213249964705278931214853178016839227908886334439887655616436591190604415520376;
      _weight[21] = .5767322345572894815450450032797290470663786874293720580846143468974332971619800222681110962737865905e-2;
      _points[22] = .8498394858283586592068606159884429949323530710404946731082134176863686453602964965002298383195121124;
      _weight[22] = .3329732099534716525904959471022450189067525736458400646569973558736059350650571180620976465196888512e-2;
      _points[23] = .8848409513746070720478295357950882608136439751437339020150931391920340490511768348960488253412095868;
      _weight[23] = .1751756104040543812056707746636424489524091405182527252251987207967076087908850752406381958280347298e-2;
      _points[24] = .9157689585742375160527209731782209778138377544703193428562270193431316521163635958472103988871642976;
      _weight[24] = .8167123025929537791590779222624889046680614565866252043480296283513012023263276872664454961653957895e-3;
      _points[25] = .9422958895903871330495337162486475572840128154973285809341967704118304237104033071590241332038056748;
      _weight[25] = .3227041908195134456269653088472861986621444725248385753566297569081862963005760178210307805851007480e-3;
      _points[26] = .9641411217247745946828870542493190904639324758002400985928337168007851931895173178552116298526505152;
      _weight[26] = .9990263394095784408772527008183937133715876054979511341138744323762818463231844388641947861726885030e-4;
      _points[27] = .9810749076596256309006437136691611689533352449026726879855908015035858117277035374554302084570293180;
      _weight[27] = .2065193379483673723520305410719094953030456381599065092914301994814430006275832864616049559460649712e-4;
      _points[28] = .9929267893183628062269525350662871775653492285199651525986086819393629175725051227057650509336436908;
      _weight[28] = .1856283772081021646463917006645502930051466535420769785785415393719988368277496916641141664600612236e-5;
      break;


    case 58:
    case 59:
      delivered_order = 59;
      _points.resize(30);
      _weight.resize(30);
      _points[0] = .14577278339065035925893934906517591784720006531081560021374605404648933006075196495734035415179835e-2;
      _weight[0] = .1491315901155340446212604717451004862856152600028923881167748393402243077917276838298865755211496474e-1;
      _points[1] = .76647678648067906525107009436127588964900812501853348916506511042958766290893370855271954602497766e-2;
      _weight[1] = .3414270443637351996552524689520019651518918125519284231276373992492543701158246310282189202967903557e-1;
      _points[2] = .187669462746132244982993301440387916639043908855580554548242427097167553740409721090435065531863716e-1;
      _weight[2] = .5206201194506336946652736896631086980047779181323752545621446604559586912360486011754514731049188845e-1;
      _points[3] = .346564195659897349491044844339792828709394875646473158245898065449187036414264888486758751336809745e-1;
      _weight[3] = .6797009893843161497359823823660113226698137894136207676183867733482609286998692796304502954827124555e-1;
      _points[4] = .551755780880457697357990152123039880671824932248632334193666231040657023521810694723723646758532947e-1;
      _weight[4] = .8130576744926203003727351913523010351524516224444640024452683616344850950559158626110443004737743835e-1;
      _points[5] = .801205671123255358284023170655714428093086067072667641092319477037473845840075105460305473159416990e-1;
      _weight[5] = .9165404412254467064066511550040554298695455034951684961821682398973282747671045385852126493481605575e-1;
      _points[6] = .1092434970626521088746731873448846222774206414347470411530922780957733620062425548835010678262498436;
      _weight[6] = .9876432908795536536032697004673551868704851460757200597881816491701736581480140253672859671604839910e-1;
      _points[7] = .1422549415999572144877609341053898829708731999301570680786197421573754663025852228845161221643190058;
      _weight[7] = .1025585393150491257467352768657020962566165514453482039316467571702515714029648271882831900626400168;
      _points[8] = .1788268232673087628783417984246983287220358061763450736249227518897393446664815732877331590542644420;
      _weight[8] = .1031278694745945415596052946177605117292110687637337979963517529456830375931435175722170473445646078;
      _points[9] = .2185956771518845796303573075738189314253271962040366483829882206456924780212396799680806333911290556;
      _weight[9] = .1007186117616301279878554305959197341608245889317283916519828674052671542386577064173516014437280737;
      _points[10] = .2611662643784974751033364418861637841052167095569197616325843294380357783689767519724808893027703806;
      _weight[10] = .9570840225375843567066228341782746515568699099004602297281199062741108246051476093372412957708568490e-1;
      _points[11] = .3061155007205121813665886906735831563842230803361353335661166203013891520931517709134796871698281257;
      _weight[11] = .8857497394178217650471618391876129842077745883814547442007841660655316881345758283854245886495964015e-1;
      _points[12] = .3529966616853502786154550912575915364162723119239058502674939729539710162974658936315002971501451101;
      _weight[12] = .7986001209119680090675229090743842319473780511267993616803209051048773098007336509737306748332656620e-1;
      _points[13] = .4013438224374185454639967766405275317142917022652449466333117794386845094513689829895546561946178324;
      _weight[13] = .7013099742401690013591360102740147731104180921542862503107396753093730582466635836943847279118988900e-1;
      _points[14] = .4506764885015598873510899584766044215966881241176557888841618510954362349594222860652999748365539745;
      _weight[14] = .5994396892391193201878777221886819034342923382714188936785401233706685684647954234713000168528380985e-1;
      _points[15] = .5005043712628964789717639236953963031984790603234627725767742098965776650636318606390262908257531406;
      _weight[15] = .4980994243944509670193186882596801360805780285331470412300413488400333743558037202503741391583451746e-1;
      _points[16] = .5503322608308270557491787984340267743359031321325234333208060314419409333934168725488976010462177834;
      _weight[16] = .4016730562047342836983353438926568287679859907672033401806590163348537364732569259646213424815701807e-1;
      _points[17] = .5996649478704976551018373593654268159180810688501359806278139203431894217253568566355352104940005754;
      _weight[17] = .3136191451975259960451311523450739540697146877711414235255154582511143225744543683656798934447392539e-1;
      _points[18] = .6480121455331503208705669145595995298479983344533984988806949082338790572395468688493909284724971221;
      _weight[18] = .2363589773545442376826921873044047832436878049349748821622300008932827072699686486257968668165022054e-1;
      _points[19] = .6948933626480090846660737470948052491622820351678518066893206318036909102531481156845209039989461390;
      _weight[19] = .1712539544532892132744625893725802414621796017291600334410496954630813410240948250791722805901233146e-1;
      _points[20] = .7398426798885768781476865343971963892441993313179320887011131454876353948716056468750647185101546591;
      _weight[20] = .1186669231590524206744646319730034674869664293542161685991368345216694946396047626719698431526063282e-1;
      _points[21] = .7824133817283033117351654063389710102986058216354587982007414417461506029482383411221290125361310078;
      _weight[21] = .7809512179248871754925555522773352977101520748772132951069132653216374300984103933458927963386535875e-2;
      _points[22] = .8221823987382739350146679257725087410887946678055925816102530058347225710144385002987812579603921205;
      _weight[22] = .4835687651116839589207388506661792798688732351920846841568469474501450058791552883867819414242660050e-2;
      _points[23] = .8587545173866958177170051992400022157663057683841349552780806326443491728626503313132174680442975592;
      _weight[23] = .2781045433058290735823690629828006775647419013227642282327332200732301717026140608010957048347198602e-2;
      _points[24] = .8917663186820247113516809652625707882606996687232032911115396565436228032409797675321983300390940348;
      _weight[24] = .1458186687285437575395832778065189046874964252128656421832651017529503747672066055109429168733465271e-2;
      _points[25] = .9208898151139505953144638557329905235774970627249343559514095081325116537677830281076745417186461398;
      _weight[25] = .6779008760458223017485130976071363242102048739845894607466517544138420774229195628301905583717387815e-3;
      _points[26] = .9458357764492203337808419002032066885955503076575948450871012659368499041349175484945986129338126392;
      _weight[26] = .2672199620663056472135919658807958654052121724338065121842860076057742788764139847177940512925500145e-3;
      _points[27] = .9663568116103163316818297401241144720136983411529035659740348392196335889979163711332261986272454278;
      _weight[27] = .8256807322596642712675172300945914195274209200047916147521082294370472442789555182952396273449078565e-4;
      _points[28] = .9822506759732043911736678171948047795906753507549646731542099473217074609302325111913020773005316618;
      _weight[28] = .1704378210976846570170738949485625046237981076825018201228716265008270161857594461612623221607393820e-4;
      _points[29] = .9933678849972890218242967429754756290348422812012610131690790938192644595723658942993255322381011518;
      _weight[29] = .1530435692303559679202880600194069095291373243359882366029366110361351387216726316140978042653907890e-5;
      break;


    case 60:
    case 61:
      delivered_order = 61;
      _points.resize(31);
      _weight.resize(31);
      _points[0] = .13693652091001036629025380164977456272383684523521234900127384067726318496722619011961387090613028e-2;
      _weight[0] = .1401206490544436609023237121587349969746045006567761855081695008238920197145638847995501807124529058e-1;
      _points[1] = .72010601931879643676101441030972382654929360794719448717802733095433731824054932697113411144607260e-2;
      _weight[1] = .3211210056592242810234944055571401839762527500713589024854398810028566527822994469099430101708284774e-1;
      _points[2] = .176355646939865329440822116716716273399262730010942408040611658873861089397577052366737230486556502e-1;
      _weight[2] = .4905514352007358740541302270051117036844203516552518776904458507336171955803916799261247427652944802e-1;
      _points[3] = .325777977796646088672994269213666810024624811813755502223428228717706232177578554090061589106056242e-1;
      _weight[3] = .6421499003447563667095761947959886068101567810299905758943015986959607413434210293846080705011239590e-1;
      _points[4] = .518885361539292094789279328121263177510960203899266935069369167663322036535665181901584121342768086e-1;
      _weight[4] = .7708465591944440214978664678877579601642420763348919100177459902890693290204556226205252661470482730e-1;
      _points[5] = .753875499851403839471912751400818899083127543122825576050415338731219307557745532979157874326952974e-1;
      _weight[5] = .8727993087125598404851885924736203445983237573749491484102820440464420680359587875651980128704302290e-1;
      _points[6] = .1028554586750934067266630945993402582474933355366456224097962648238687615218992257756775517287884361;
      _weight[6] = .9455543857311113942533268852024714918001646007576128813201633172025531623575828933253563995121093005e-1;
      _points[7] = .1340358114983876564339860740140341196816667539203883664849981452786512463510185666317257255429798266;
      _weight[7] = .9881291012170006693456267092177765186618637716012470654782718891302456217838158452369578347983737910e-1;
      _points[8] = .1686374906442098356617268634134017813732783166791782966045346757082471444333592363931357649357419150;
      _weight[8] = .1001003159524530363104180663619783799874178898404524336779305249101130790426842115444324912977856132;
      _points[9] = .2063374321933079647369611133634897836240770185127581624195509150737302861230656791747631614142539590;
      _weight[9] = .9860204997970906763399803849822200678637561736800941509032055186211162575531237866562487533796561155e-1;
      _points[10] = .2467836436155710933199228384538418511090271873523499710413024876413592298225490102948311490242621480;
      _weight[10] = .9462109265174807424873122469747347887669228616198273398437836689671301713817820752750902057317242075e-1;
      _points[11] = .2895984907391475920138782464308026880200802349630140545217731202754357179091084031758311229993710233;
      _weight[11] = .8855464875380005756652072587576624284557300886023695065934716903300558691518263136396252572542543165e-1;
      _points[12] = .3343822238776351252419685447725649719691406591568741892752991492068380593197644708700909207098420006;
      _weight[12] = .8086518702868964921973768964419167020096598662788053379862951223461825278781407685710065195774684605e-1;
      _points[13] = .3807167103369646932919817405792130746606355782010403499486364214947528760107143133850084127060875172;
      _weight[13] = .7204908076371079309214829918846290043710821174646453642360675733877644714506224903242378673973549840e-1;
      _points[14] = .4281693385154156194417410742899825270370966980210852141448274402465912219366930868936595777620858798;
      _weight[14] = .6260514491381266112476446763960717503457148868267332156770556143624906440752520753898794314174248400e-1;
      _points[15] = .4762970571775839012599109438642786787910227011918298028869481968383657046401344160723604121339610397;
      _weight[15] = .5300528235407393210593432792415778543059070542062211133149380520643792420434901154289638364872976675e-1;
      _points[16] = .5246505122103465455728183462099190147096086687630914369775031785647986088465765153290482473234440025;
      _weight[16] = .4366919988107116389230886514702208452192610172539603303155281880114132121310772290910736617814420274e-1;
      _points[17] = .5727782422577024113870603024175540683472059621151315030913358644137301739485372481202450035572725180;
      _weight[17] = .3494475743428021057568935242276602073648520792237513277063007881830750670821227031289900085144260704e-1;
      _points[18] = .6202308940878964763528673529670363355339785112518597470011666286148975401503787651670787009253429760;
      _weight[18] = .2709500690386953751069178406838636815384967226318121133814435788253336859351359886090392628083637728e-1;
      _points[19] = .6665654183773303861601326760614604743638563595328351949371522965073714357445225242299623003309299511;
      _weight[19] = .2029240345068888340745950196253896611459665423948592268188679161016634008481953579096558613167856512e-1;
      _points[20] = .7113492068095685558133006667709819451575054362840455447176740142822369749162251926869838973346927817;
      _weight[20] = .1462008082783841976253308183893206231436847698410446515106255101009664107357060645472473645304267816e-1;
      _points[21] = .7541641319977899149388944264594135600637795973965264582163907849633878659064268645380961165020694565;
      _weight[21] = .1007952176991829850305258664289729474571005385425765929827171877545918882642476290287480808431840978e-1;
      _points[22] = .7946104527758169326169679366928319864361859757363904011714581588637172599413472813223525772026126160;
      _weight[22] = .6603470707394316985994280362337310811861259335771870656920474608040126953653365813322975128111132190e-2;
      _points[23] = .8323105489456515383744404260031629487070666431913964811955248376360356215462432754715923979789448138;
      _weight[23] = .4072567301324925286978191910109165210998809923518336725405684136878371982652710248244277228174452032e-2;
      _points[24] = .8669124518396082568693596616154962977199040720951216992805820343587833819211852462891270723734550161;
      _weight[24] = .2333953705311331245464177602173047072288137060715168141773548841446522030992039657051310429253516960e-2;
      _points[25] = .8980931407181669215572452752900580046388620566439707644527159091729569427638691092610084112863258932;
      _weight[25] = .1220041621260954623648068103750166494687433751337417055023692920392477150831347375209264568950430117e-2;
      _points[26] = .9255615822969551781356416726446810501492182917520502742877697614194101962468919439115832052929387404;
      _weight[26] = .5657189666091238390709933068514304280659458878866494461459971250893209363885838891543003998175482590e-3;
      _points[27] = .9490615100934992658665533661080479770940064242550734057590726835551016985542145903458461174895524149;
      _weight[27] = .2225184113616753332835954161816580608307938220209914664726703106957494701509062705878695387717845666e-3;
      _points[28] = .9683740118091604909480627251752021631877538352896943636065161160288890490739816800738966445706492363;
      _weight[28] = .6863667359946888101889453121545292318816146796189038823923159828041558018051222520500517382971962435e-4;
      _points[29] = .9833203701304175412485368480405225262637155639849370527489909821657295035574559858424684689500116547;
      _weight[29] = .1414938875337667805842756312550972005132023758238594466807507236888151577830837913533114513246692680e-4;
      _points[30] = .9937689943617638927613642550978404132193052847562085323183044817501866272149029814389654785746287744;
      _weight[30] = .1269380626764678675373195326975758127251201208308023241385711948424755100169194183545571759627754160e-5;
      break;

    default:
      do { QuadratureOrderOutOfRange th__ex; std::ostringstream th__out; th__out << "QuadratureOrderOutOfRange" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules/jacobi_2_0_imp.hh" << ":" << 1263 << "]: " << "Quadrature rule " << p << " not supported!"; th__ex.message(th__out.str()); throw th__ex; } while (0);
    }
  }


  template<typename ct>
  void Jacobi2QuadratureInitHelper<ct,false>::init(int p,
         std::vector< FieldVector<ct, 1> > & _points,
         std::vector< ct > & _weight,
         int & delivered_order)
  {
    switch(p)
    {

    case 0:
    case 1:
      delivered_order = 1;
      _points.resize(1);
      _weight.resize(1);
      _points[0] = ".2500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
      _weight[0] = "1.333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333";
      break;


    case 2:
    case 3:
      delivered_order = 3;
      _points.resize(2);
      _weight.resize(2);
      _points[0] = ".1225148226554413778667404303711520977520296573783188782094996764804937040907174519103834594413799803";
      _weight[0] = ".9301898050140316109999077953693932111432962616104347355714587377327162032199365184453540090316083595";
      _points[1] = ".5441518440112252887999262362955145689146370092883477884571669901861729625759492147562832072252866863";
      _weight[1] = ".4031435283193017223334255379639401221900370717228985977618745956006171301133968148879793243017249748";
      break;


    case 4:
    case 5:
      delivered_order = 5;
      _points.resize(3);
      _weight.resize(3);
      _points[0] = ".729940240731497321558379790120032921193893633063541009933683897430064212672051211633618549674866608e-1";
      _weight[0] = ".6285454442595464532733792888530666142789173779765677035150899364344248411716672672683453001807558540";
      _points[1] = ".3470037660383518847217635434039484551401490745262501021878985827903559852608331357830049271464466709";
      _weight[1] = ".5849850770394640880140480814569575834996833285430405912588393379710804430684155659655248860334828360";
      _points[2] = ".7050022098884983831223984775840482527404615621673957968187330274666375934719617430536332178860666682";
      _weight[2] = ".1198028120343227920459059630233091355547326268137250385594040589278280490932505000994631471190946468";
      break;


    case 6:
    case 7:
      delivered_order = 7;
      _points.resize(4);
      _weight.resize(4);
      _points[0] = ".485005494469973292970672570989859947642728062280413830869767690680904314070023713075606183354633710e-1";
      _weight[0] = ".4435536624451119347329252698757826095062322419475350982016036681051358053754859408526879761621947266";
      _points[1] = ".2386007375518623050589814127247005854364576119213103511631588822122262502910235136980422897678595854";
      _weight[1] = ".5738351591968568361933120571037518069418956396071874388407335580148000676687764498832734152418551450";
      _points[2] = ".5170472951043675023405733693830732661441577674815143184126459202288394285156186604132268185358169055";
      _weight[2] = ".2745355486916923012695053801672421777585462337521019227783801195324800153896617288464511839350699151";
      _points[3] = ".7958514178967728633033779607932401536551118143691339473372184284908438897863554545811702733608601380";
      _weight[3] = ".4140896299967226113759062618655673912665921802650887351261598768091744489940921375092075799421354486e-1";
      break;


    case 8:
    case 9:
      delivered_order = 9;
      _points.resize(5);
      _weight.resize(5);
      _points[0] = ".345789399182150915244574286315265927239187537641449715598798784850241358383207885823883664303919420e-1";
      _weight[0] = ".3270591371430836716195229316894094001951854345378653863487891391459565840633676758520507731631799328";
      _points[1] = ".1734803207716957231045924179861795777093110520096575445025632205524389034895410507640407261570230984";
      _weight[1] = ".5047958475996459521153317406586619053415566875203098209415548851614751993628466546158658687273253230";
      _points[2] = ".3898863870655193282408954103849949929685699479384607713625473160659384788871254703280644555908817828";
      _weight[2] = ".3568006448863600007450179722815356404122106902138793907440693610940259530233602522779046002721091406";
      _points[3] = ".6343334726308867723471638889206191121277336440958369160307851769971809925102122993798727580295999098";
      _weight[3] = ".1282224028918476770189957222265331112459675505313588758170175986042217305503148083830364356533270504";
      _points[4] = ".8510542129470164181162241874100130578037999355252331298775577412327508226081337242789670271254366002";
      _weight[4] = ".1645530081239603183446496647719327613841297052991985948190234932765386633344394220447565551739188852e-1";
      break;


    case 10:
    case 11:
      delivered_order = 11;
      _points.resize(6);
      _weight.resize(6);
      _points[0] = ".259045550936671927546436069972345489568181239253192501586105742961026604543804289171169539890458962e-1";
      _weight[0] = ".2501548109063237515141062258733267440660779616350562328954095848025901035201055026000940757458648719";
      _points[1] = ".1315639416579851339869108507409737955754378625065300343093793277073462918773067828768175209181356068";
      _weight[1] = ".4295059989471225304230227293918184474568448760971126335776727891320004073377218295979846284565251254";
      _points[2] = ".3024369180228912327499055779185451938801342419623170862494499684632895155693734121375470591583017143";
      _weight[2] = ".3783087469941648142731682068802065098680549714701846873490169027817905712014531819167360652747890990";
      _points[3] = ".5090364131647520840110399051677197756066865099413616255162800068449833494040551477253328196372325307";
      _weight[3] = ".2051582845184648408805173003076769826286071695771531963106651422253387765576255251446619284393054829";
      _points[4] = ".7156811273117139187676626245936073635482655112817582867648513925864912489801365831589316400094114546";
      _weight[4] = ".6288118873978020531140504852007971390788413793492071598436679202370012665529257375196229311689702310e-1";
      _points[5] = ".8868056161775618663012660060104907510040863218112851455728573015303583622861762166128254348593013689";
      _weight[5] = ".7324303227477190931113822360224935405864216618905867216202122367913348061134720321894342299951728890e-2";
      break;


    case 12:
    case 13:
      delivered_order = 13;
      _points.resize(7);
      _weight.resize(7);
      _points[0] = ".201327737734005072305016871174723490776439849042327704641023363534020742986485227576064062396226182e-1";
      _weight[0] = ".1971060071057524832937165163396190757998916431027808644906762554468035992816828007706400085856979715";
      _points[1] = ".1030890291480490147522267860059511003289175929398917699266215140490606015002180084249458354155438582";
      _weight[1] = ".3627952984507445781478699198894979377596337461185747060555815360747820057455407114922673477814265991";
      _points[2] = ".2405541260480575366536991415009998007569481612880393788676693328520290703357844995390090665448625146";
      _weight[2] = ".3669352131191810164456663835874689578389760346660241804814700152598403298079827010307664096906772920";
      _points[3] = ".4140021445970597464182872488505667767590220835312978380704205456186698145026653746810963941381988064";
      _weight[3] = ".2525855148355651908381357619247951567605016016259007795136116178216199124634212453015846804292228418";
      _points[4] = ".6000215132789929301939687728899372881025806599131930023285085834549592653990404218944489240088978780";
      _weight[4] = ".1176888451581144593629814079400447094617082760975046287638279082701242348479743647408809166847127139";
      _points[5] = ".7735172465914375011119989964260274880261693660663484652005652442182303999883684940019383260571399260";
      _weight[5] = ".3265170252921877802892723627488505435251712336400851214223824298292417299877194662090599291711606806e-1";
      _points[6] = ".9111831665630027636393173672090451969487181513569967751421124434536487739752746787009550475957343986";
      _weight[6] = ".3570752134756827216036107377022441360104908358539661885927757477239078187959563376287977244479836966e-2";
      break;


    case 14:
    case 15:
      delivered_order = 15;
      _points.resize(8);
      _weight.resize(8);
      _points[0] = ".160977595519210335320135500966179290767371971739863490642143548559492760585294337697286608894534441e-1";
      _weight[0] = ".1591158312267622393204258237055927962698083072365832925887173927737196747407707004967213458334627777";
      _points[1] = ".829006174856511027003663533803883425046917851397832948276985705707819404543246577003479311740585638e-1";
      _weight[1] = ".3072723730688904992180269402731618118770031436482066776403339468731082588061946079180966199553817186";
      _points[2] = ".1954751684887399173242666095306123066183752190029232941588497041829344498467684123721199004984344214";
      _weight[2] = ".3411390766877550608377649050607439697794440340647965636027033451873926715896541923933717408546950100";
      _points[3] = ".3416519914772022202729622621623959437357864175820185645023555961530872229142955610693253060030617732";
      _weight[3] = ".2737887336866130889881088024434078279685567928059228224395487281994529345472410304920512689098080728";
      _points[4] = ".5055970781844891719400618650060764872884489602668891730627538404857596368160581228502258304169030991";
      _weight[4] = ".1632577055541760927458463846085917092703302398116046797151312588917290824986672513574976000713409908";
      _points[5] = ".6695522718243614518301145105543719346057236571343379507230403873080542508578187492621559364188985917";
      _weight[5] = ".6898745512093993121697462309944726926414242801556028350923661517840760011679153538454549507030134070e-1";
      _points[6] = ".8157717035832837607547517869758669198734561249520251057926437981546786829099776657599632715409829299";
      _weight[6] = ".1789808685205763198302608401313458028471472087364949967388597034873997270243168913625909195923823936e-1";
      _points[7] = ".9285089649599068972010186178492256918523361943035918234239993038443100956977829527716887186137627323";
      _weight[7] = ".1874071136138789023159770129253368619333666877009514163776075880783138331582326154790170679105180862e-2";
      break;


    case 16:
    case 17:
      delivered_order = 17;
      _points.resize(9);
      _weight.resize(9);
      _points[0] = ".131658855971144905451905378179721513608207608977023046598715551451003914692376947401267911574381431e-1";
      _weight[0] = ".1310405804441588858472781603370944604810978794735901694842259117976972694085138327178975817670984660";
      _points[1] = ".680845295937675874765058569868224421713297601092686688022203256854416426151243571888926792972427820e-1";
      _weight[1] = ".2619581481335865271277564288156488230723919390691807445060226299938323279618906211527645641167543309";
      _points[2] = ".1617595167640746420698109123291884182887719048042411253973851893042652216773926057713819903780351905";
      _weight[2] = ".3106942766422220163143806819137749290612485831017087160757406643479124562180813880959865405613148486";
      _points[3] = ".2858910883392203977279895669126411861610178692391895516747553642738332353741698871551056243758169287";
      _weight[3] = ".2771375827592188368629111413955671111448010879552790959675288132265547247642744146956024875388283162";
      _points[4] = ".4294536453878127925092480022865873331648138310301004847453416352653628845263290243369473840494158542";
      _weight[4] = ".1941625114580260318381122496994582838080221982357833412996720724777967285153688457928679921481932566";
      _points[5] = ".5796940563511631262657724133119889515943464601677762686678217724998474141044996039946483039194661255";
      _weight[5] = ".1053731236101993429518987840106901998442418069136281392168534644913155857561231942134211646777062514";
      _points[6] = ".7232685717403354318179601582002055305769054380507989053229094988979833043442432382442417433411755164";
      _weight[6] = ".4162446631740894820970534894375261359629703551183251098420143946239913509520566870940318195593343388e-1";
      _points[7] = ".8474368420132373201731804250196182721512229028198623679712683516725259240759225460110084747448902274";
      _weight[7] = ".1029759458243489240932686362241481242050381516644947786284291452404221754858892924302398732118007706e-1";
      _points[8] = ".9412458642132742114143421271349757145307710728810603227584263072556399818130810425576470087365192322";
      _weight[8] = ".1045049386077851771963674594932099904728987905881137936245423011782888065286438712365833246324346947e-2";
      break;


    case 18:
    case 19:
      delivered_order = 19;
      _points.resize(10);
      _weight.resize(10);
      _points[0] = ".109684524561741342502810329904322267331336681681923877355192963785056979625337637538110478171937810e-1";
      _weight[0] = ".1097363548403899878418065943379411944061396284924080166565554103294093888964177063474961793610341660";
      _points[1] = ".568981505336579207114348593791205479346782029866663214710813643608636285458860327482818305149150497e-1";
      _weight[1] = ".2250917456112325051296633286108366420614951800309439606854274760475294326418691844787436851488093244";
      _points[2] = ".1359502340502289542657634293851948978251888305899476260362867729648816564909173618213354134260413650";
      _weight[2] = ".2802780308346653363454898212327328392359722478917409167971915727317879309984750999998056323426908454";
      _points[3] = ".2422811961325235611113945553650933509790917920092800543802211222195903604925019606707436266710657207";
      _weight[3] = ".2698088775257512998821031772547641973726038694971785623654789998437662428652904614577889155923326442";
      _points[4] = ".3680078504493377176047695662501715962479825651139768906203685509520441959000004952464111033767211090";
      _weight[4] = ".2115351550678566328395393557696844837464895827386582581706740133267465009849730196407481293438002146";
      _points[5] = ".5038071264148739070055306420572277096670551499038191289399601781301074701278289240976204997968793742";
      _weight[5] = ".1354182600672564641764042852374920057830707307904626801110973942414191156942172243587060817600027027";
      _points[6] = ".6396094886547097093285365061669561436997898167778574491235731369280604031123928829202652930591428398";
      _weight[6] = ".6879030018621203231655000929591000454971704580551112869775545888215954689422647507462355006505397945e-1";
      _points[7] = ".7653476795481078962095331272446001935281254701059371299400639154174230207720369856446774138268604502";
      _weight[7] = ".2587955627423411691892242624371044143548514233481194134088846643064833839260516482542276239452851360e-1";
      _points[8] = ".8717100745744084876118613420054236108762703517899922187764993623709234200889090646472972713573702868";
      _weight[8] = ".6182092778946314514341307258874506510233203740474247976315870788020555404045823349159258546354103850e-2";
      _points[9] = ".9508742926405231664463494846103251770541386980088762475218808457321456010524470739041019546992645690";
      _weight[9] = ".6129601467886433685130280913870182321267020111436205319486707118462805612131738008391387787268321585e-3";
      break;


    case 20:
    case 21:
      delivered_order = 21;
      _points.resize(11);
      _weight.resize(11);
      _points[0] = ".92789738313488342029466103013447551800997855849886680190878920280353922373287330173966578953120426e-2";
      _weight[0] = ".9320340020555350966024561740341972459706270009058980336483720700004390524125197996306174927564976905e-1";
      _points[1] = ".482496920942862582864837237311316913676870715011786505761976953984693552751112447826229637678462464e-1";
      _weight[1] = ".1949834441226579674578013161123198903391393493913141165710324158456011237446879391336948781555464535";
      _points[2] = ".1157886266293952259603059182556492085885288892943482283961924853822757749603844675338080199944631068";
      _weight[2] = ".2519181720014695773533359952445167095153987763649309891459044750285736696026664998184742228754718459";
      _points[3] = ".2076683415970598824438954253005318541962122637198783812084003037910494205451576930868295318153374046";
      _weight[3] = ".2567342373990237799701574852246926321540907801747927739535161665097322828812066091979315472275859598";
      _points[4] = ".3181179519062339663774464665791396822719791120780551488743875923139814199674731765500037687261335592";
      _weight[4] = ".2185288892841797042827148607708304088540070080506917135110024995552378489195340132318724808370494734";
      _points[5] = ".4401983998588624670826813221763196944009306574309261115292338038944935336942601582950581383666207960";
      _weight[5] = ".1571608711937424489861433436853150352752777007115971600215818769351715159348001703309820163758798218";
      _points[6] = ".5662398391545683135675124719348766600394909006313209815451544722188689876257081925222297826462922053";
      _weight[6] = ".9435865415522771459726664777523037712224413619385624135202085655621859469783133863488143428243946935e-1";
      _points[7] = ".6883242398629566856955339758080896168877685614740687571663638191714222753183886142439845185572907490";
      _weight[7] = ".4565836367239047299968505122712376695848768267382332792870551534558766774545305000710814687370878310e-1";
      _points[8] = ".7987843585909146419746087280073481414657603642892225070265379669025781304819516320234507849776994694";
      _weight[8] = ".1656001705287608941907074982129804342900595679782926547479362297629040174388475144000347871328583800e-1";
      _points[9] = ".8906910993543921891508128999060838449706283276255334717255508939690538822374778360353169582497335915";
      _weight[9] = ".3852082302172956332801494958270836731931512478701471975527043646190285928543688268734603836396649430e-2";
      _points[10] = ".9583251437866482019244391246661515172975807330371457605995597415964384943234249185759655416699374958";
      _weight[10] = ".3752019440391122741107711103159083566877304052064700344116539346860368934732933065887748803192681490e-3";
      break;


    case 22:
    case 23:
      delivered_order = 23;
      _points.resize(12);
      _weight.resize(12);
      _points[0] = ".79520457026384368762190933400404230325878915790184511121195407760726095490609964436482770207445311e-2";
      _weight[0] = ".8012445033899501177523089686688632200915300524216047110927662984377082923088939924661277616544758575e-1";
      _points[1] = ".414278104542945907907701651947950823816903997895905535340366964689296682965310816537095434242500490e-1";
      _weight[1] = ".1702264614696225510918739636030398201621484344112814996354913309233794603455227611295265426265052094";
      _points[2] = ".997576255426141570660817034802997399391466596208525248283265996737723259867991798599807469204854668e-1";
      _weight[2] = ".2263367389978962785859121446178675121101775526351403133866313748357859288961118901399429789565545167";
      _points[3] = ".1798107890524232495416433443072131398519613973866393633683049652350649339970260755579436050297147396";
      _weight[3] = ".2410024299504180726837413740036251216870850103778053650506861765213985586819288967273890504882743300";
      _points[4] = ".2772734577993151198175389183105218031690793465049448069023914667625432657455874204304984154028694716";
      _weight[4] = ".2182957646569263313022348391211610218077554917110947715591671593278409360063080187628820023513092505";
      _points[5] = ".3868920099976897916656347038054368617573779726132266856600842411622840190011408572046787141187486327";
      _weight[5] = ".1710590542807556092690637471435145484050330827664167870998504513030965741988066924842173071520581532";
      _points[6] = ".5027573604490322032793092784391183027172079885763226380243920422697606141569862957949651716180958326";
      _weight[6] = ".1156322073549094419776139687208225491632847535363357613046929611804166587438361502417881862465344624";
      _points[7] = ".6186238634584560462935488618911381482947201802097017834975473646568443564057059863325639273576037680";
      _weight[7] = ".6618937457843764840554885416015182450294519306581249015227764712822431773609940807764767959301801295e-1";
      _points[8] = ".7282464529530726864288803300611436952397911534452751751134554512822045797431115007040988123166108502";
      _weight[8] = ".3086546809554570647515094649861202512818448992619175640122761773789205214076726685224260000604713675e-1";
      _points[9] = ".8257185142147869017640833629537027093736435575778818152064773066577478052593968978372571869786865628";
      _weight[9] = ".1088336857641535741816614466540524551935021467910130060680909665551588747958855091474710790206616736e-1";
      _points[10] = ".9057950735445437268017964703997392322761079119953073066163678713751459636010637378082399631441249724";
      _weight[10] = ".2479813594178077693466924685437339297957267049610856766740237535355291735573310962968151138526175950e-2";
      _points[11] = ".9642065352926715512129553062783893235051470791627773576749579921411683197960515088339540982065266615";
      _weight[11] = ".2382014392332466553295292468100035402588379323819602604826503406568381379009877933689507069923315948e-3";
      break;


    case 24:
    case 25:
      delivered_order = 25;
      _points.resize(13);
      _weight.resize(13);
      _points[0] = ".68908313099587313966815341534069891610312924295884216664646849739035899042293162858956714369214634e-2";
      _weight[0] = ".6960491444024738195232456693410433617039772704751655810891567455689639937541737691245714317969168235e-1";
      _points[1] = ".359533627001700955011328119695205132217760105545034090502050160774587979100248003869028934390782918e-1";
      _weight[1] = ".1497068326753761598146651927458960902744233437073677525182599977520837201027626577281733847598025603";
      _points[2] = ".868117801575854332842803076906012803586804672410818252448180070750565457367189549735536214157210137e-1";
      _weight[2] = ".2036393228507800763716273887505590308873494434785424621492199411922564371066863588578324885545762954";
      _points[3] = ".1570999741965092747305220655514795076460478559637808966768026561701334378832315878926359118028066284";
      _weight[3] = ".2244461485233095847401594888146689643184503673613412256573886718574101869069388545716338949683699244";
      _points[4] = ".2435328995871284444190341035677509233546420884568021588363910256954815690060216467377269714945612025";
      _weight[4] = ".2133600864234869829016066656915215457043166425583673690879063724648569706987753465045737718877615788";
      _points[5] = ".3420695126460753234745079965662670426694598946354515144515707529248230901101547245184760072145509804";
      _weight[5] = ".1784984030224598177222653499089708881761495368969374648507406094628872556990281953015547320237188519";
      _points[6] = ".4481026389057098536287343087939797087307694182346731421546001771139148336025010690279838386680578360";
      _weight[6] = ".1317618067137311603345937815895239661737637824034451034501350134739730493893049812226124269295047472";
      _points[7] = ".5566746226294550106969466423620805822740057901270505208647082398477423598381705261496298123849990970";
      _weight[7] = ".8501998685902645212445243555463312092509357047145464604938440147163681074074875244898739601239204060e-1";
      _points[8] = ".6627093135603885423214631521232583899762109853102761874503785215844447164251275965254928056783280667";
      _weight[8] = ".4691303837240752265188152459747705248625923503706344789441878308197981725976028730594650682213315254e-1";
      _points[9] = ".7612497663082769722766595263934307890962335595916809568123852946736417765204111824657718798518006691";
      _weight[9] = ".2125427735533055379222365772738949202667956306189252700086140940284706736338427998038547922834835463e-1";
      _points[10] = ".8476910439472323909103140489514170370916151645340936646068779732870007405006591332706754097819751746";
      _weight[10] = ".7329564556957514349394257676697856873834127393279604943260422811450298594922588905052267132904185585e-2";
      _points[11] = ".9179996455372066795336259702883514644585607264667402765509172640216951031101831301991193963406574748";
      _weight[11] = ".1642883567163541667137135579634586264318797523514426083342476902975498845674881247797284810378192256e-2";
      _points[12] = ".9689288942285889621118118173027414862466810321685627399195946722689891537382806172804214947762563872";
      _weight[12] = ".1560679730565849110018877622564030522971963926107455394995589020798212499287723463265570237517659420e-3";
      break;


    case 26:
    case 27:
      delivered_order = 27;
      _points.resize(14);
      _weight.resize(14);
      _points[0] = ".60288088710666481700887477121599714009165674033817505496952220432024037237434445714834787852825823e-2";
      _weight[0] = ".6102082447779318149404536788951199265358380400157561994830938903862191015641396072434298492402421695e-1";
      _points[1] = ".314942598186575907073067127663167080720502127198063557822381981372867976117993479760997886283534922e-1";
      _weight[1] = ".1325583818798422395037209033460692313542102941236965236002400055105646280610200698756731543931528664";
      _points[2] = ".762136224748538675864067863400226931624394106538800904358149503746059181670255653177174871778064644e-1";
      _weight[2] = ".1836590884586847156456151997787713864338837649250093240214366377932523271705213409778289378543540772";
      _points[3] = ".1383665259594740691451383329582450807329794609739600343780877691101025629072379526219736602142441636";
      _weight[3] = ".2081034616428068073313094353978842445257334921914344569440612488730800245148651213554324071384101613";
      _points[4] = ".2154097570688955749006955320851489135121375905412025496653310142236265218036971673059371903435771383";
      _weight[4] = ".2055596961578860130952322610656504885177771188630820243106415066192827887029009016919044018841629724";
      _points[5] = ".3041895281416563096323663549044031022663432275568421834000345432977346183474641407178311135015966832";
      _weight[5] = ".1810137290178435258604894942640880460514514087650048923768556969517189589259791353365537617943430788";
      _points[6] = ".4010713786971543575811860320519884685924384191572501525138619910884257329369228617255111752487734427";
      _weight[6] = ".1429560411700584519366501032413827809654950517490789640352810210845232863752618039772883247583044508";
      _points[7] = ".5020891397499784100693253980496002910686100916885675007465829924443020109731422291660366333167504029";
      _weight[7] = ".1008647341473562201372248808088751043020521924647668486496396285323660848376666059202375068555835250";
      _points[8] = ".6031073967275967836818955665403615514497986107892801003779313726143183351054969157643569313893089786";
      _weight[8] = ".6277732914029182873972173919394741932291208929247041454114182049684592982407685936803284668904118040e-1";
      _points[9] = ".6999909171699064974107366639384890954484520793287566604677488395049079890581595895812516182137613224";
      _weight[9] = ".3365190694854584883843086111142799005260169355843994956162857554818205354238736452087127825321312233e-1";
      _points[10] = ".7887742384345607153403048855989117812599118416749927874591230855514960253526748991496993842445561658";
      _weight[10] = ".1489950270113143528621524991386061259196283121337933421213015237018974938111932684980666809215124472e-1";
      _points[11] = ".8658249007315969536711408351810170671281166559680840985364216536761121893264203663610169524834368563";
      _weight[11] = ".5047135580629952165313333678903904301766740735495618421679475165368531852851525344466712644979612030e-2";
      _points[12] = ".9279957387467523249837781220393962330973069328106674535182517668455918785733163177668632107772943334";
      _weight[12] = ".1116397363787513880357822426330897791338165514714505129793583213369776447193493631912488567194456030e-2";
      _points[13] = ".9727771207411832304529633631672723761418322320666616155022099344216203494462325353075547090085913071";
      _weight[13] = ".1051046466755994190066812166292344685646859351848575804945921359672835410758237589818594844183685276e-3";
      break;


    case 28:
    case 29:
      delivered_order = 29;
      _points.resize(15);
      _weight.resize(15);
      _points[0] = ".53190520028437405909978402739773949501717786498451012390903885828654368422611951408021355398272097e-2";
      _weight[0] = ".5392665090053721636106293416964196355047711087332304374347740716255549922473738865652698714009432220e-1";
      _points[1] = ".278145619182600515719807092380735475953182923972000030059413426511354857749499595402805481020463428e-1";
      _weight[1] = ".1181106030271928203575530674800549317555657907909469016820334832959564842606168165865226255747224674";
      _points[2] = ".674318658389986133845685775718184944899402847113353901114015417427935646378617104759012487105886023e-1";
      _weight[2] = ".1661252306064170614951978271811555413440569614651595199924632464948276552123825945778602473762662652";
      _points[3] = ".1227482862154978393395873240130317032151265317293409309723332247616160353114996846526951659728971606";
      _weight[3] = ".1925282306741192635536195068795429148549620175078239732019144990499724648233740495658097375475316038";
      _points[4] = ".1917657062776536255028268450504200863445325847077754640124610110844518238511837287875868381479691005";
      _weight[4] = ".1961650715776367222607857100338277674615403482968446824018357637392232405293324998845805559262668746";
      _points[5] = ".2719899659294862030563380079302590480247942543957991004491026215444180175182375256505110567396822930";
      _weight[5] = ".1799662232824637334629206112030205761825115733710491636849576725169740218336869361061489424124483476";
      _points[6] = ".3605216935870576481577844407783965338450733048513006001751394159810417193512115614212035252137886290";
      _weight[6] = ".1498955031684052123812771871602716067084415379038225419304375844804254640021209627209252643892922630";
      _points[7] = ".4541612357544770991600962499618829704400282904120849921379677203156200105460801073784507410855614590";
      _weight[7] = ".1133062126969649905762758964950627527929647767293146529704816117151296007557005216726923669605708808";
      _points[8] = ".5495243555935513136546896219603138697609059893623113297331642759135899174924012857390026360474762955";
      _weight[8] = ".7717366634109808194395315371897661481697794303982356504901090232725807785964281183615873931332253630e-1";
      _points[9] = ".6431646017687849385394940088418749344687178001026537323433816746667626232189289933810809550840731543";
      _weight[9] = ".4667432993910655425413732479156533084522800284809613605669453781660467725115778296456898579690543307e-1";
      _points[10] = ".7316979730525232062993394846752112991776703416144255053301405080726071072308400265108448666008619891";
      _weight[10] = ".2444420044082419616486125716889612243023339647683950965594801711901059340309718047264869243476430892e-1";
      _points[11] = ".8119254772750096666896931212019542427716200088297330042968240740567022090056000155767305527743066810";
      _weight[11] = ".1062265194309727672451284568453333373257143901288406177087267655658817988164428587123611239563599574e-1";
      _points[12] = ".8809495287153136023880805549365229247192257620249850286280431657774932073581341528362053919854452733";
      _weight[12] = ".3546294540936386695929109813840513953405630969412226155615325774569207011586893659157938322766830800e-2";
      _points[13] = ".9362818217355187421025193722871475594082635803646883892837426450201379107391391453318432405302555506";
      _weight[13] = ".7759490522557821973605351452471324906775817329617622870809982729562547897699646378604645579098471765e-3";
      _points[14] = ".9759538743350237095620038412791153907886111958465214282812663898287649311216709075768610974652202594";
      _weight[14] = ".7251514227803490388636640769623041371922231503159275050960701128191249448264412063567318483535829310e-4";
      break;


    case 30:
    case 31:
      delivered_order = 31;
      _points.resize(16);
      _weight.resize(16);
      _points[0] = ".47276871229345922061506104450644771859877133490952080783156204719904618626220140980919888049437212e-2";
      _weight[0] = ".4799762249876787834602678161657048141079099237527991579241094505115520768176249489883380354783575107e-1";
      _points[1] = ".247429676194349845126034562695356720576152865062634410070289770741406286882253286205863380224719238e-1";
      _weight[1] = ".1058433700693581081617490582582260489397739540049851972587515247508128778921240398581401703350950425";
      _points[2] = ".600764377166379922752422553281124994904079423093944860417802813254670955428854321831735284854414748e-1";
      _weight[2] = ".1507432987276742913332603257772435302414637148956054340274349733093010936907163841776698818476427980";
      _points[3] = ".1096006092587706028678975846195003827709889318416547509152886361080137785970255407503143033719803360";
      _weight[3] = ".1779862938901728599046041983508410784211710356810272044473323158434144748195799575920162751491628334";
      _points[4] = ".1717247594830021079030741779126958738693210887070413817883535217741774057292701297715602601789514566";
      _weight[4] = ".1860249575894506351880500844013307938590785059618964565637623170975868320778954318066738261222465300";
      _points[5] = ".2444524317445113773020765616027520310335790553610620199645169384378290869715474713058869732710115018";
      _weight[5] = ".1764506307035974844556454963572807953528221877075630527904162026163913063727413866339740371354312014";
      _points[6] = ".3254462100241296148268368519018063901298314159028243246203929830145913417696717843549623084103386732";
      _weight[6] = ".1533921878047438226943307636411683225532230366129434468301308130372556609842068604135406661181292008";
      _points[7] = ".4121029641168595969172842136225134716264638462851170381104799491302816048435587877644761732164741742";
      _weight[7] = ".1224481516713504381677953376318549301968971738616216687469062423535307787680712176524375047323900128";
      _points[8] = ".5016375561531875937001304323508376116775809382887043798099322048009739763486344428459428277727638743";
      _weight[8] = ".8942874259811972089333893705457462540747878902452832779327225337155148601273155358526763706035859380e-1";
      _points[9] = ".5911723853165030889707605187763419229680436878682765211186872551925076536578972852139357400884025256";
      _weight[9] = ".5921510663100695336095700399081714160082916113233465165244891577971830694111417358117886339758554005e-1";
      _points[10] = ".6778299174145608113025127726414777500320971717496155010727267379426891048458460258015622127620921854";
      _weight[10] = ".3499018198244827989832060255651272931793234290752719755245012805681995519918979378047157992202798460e-1";
      _points[11] = ".7588252579491414133542794053511356108796435680365038583957695605622632533727925268078632201504708402";
      _weight[11] = ".1797939540591943553282655904326541648736843405213664835704382086461644807389169392510655535237025878e-1";
      _points[12] = ".8315558830264619518892063548240608922762470054306231569778660096958033620199460946608882490135090269";
      _weight[12] = ".7694127704267096909529759414250766143904775295057170663912123460022589036462078267439682969987081825e-2";
      _points[13] = ".8936859745488040188148696987681606327646834274095997914162494394444252336597543340153733132728571944";
      _weight[13] = ".2537839998275347472043395873985655311218455216670758737222071145520472405641979123640571702420676269e-2";
      _points[14] = ".9432242857122455935254506623929578257508869485688987484186741352804265152613888933335080761298126972";
      _weight[14] = ".5503124159022070098783811162627949675055432854454242381238069353356523893162308519719894537981642205e-3";
      _points[15] = ".9786064374986970125728009137812822496042690312088548040286436320973606732995221437659921341073019240";
      _weight[15] = ".5111364227877400497664824914822312187523131871077788171487966030019098788805718497028848685166368265e-4";
      break;


    case 32:
    case 33:
      delivered_order = 33;
      _points.resize(17);
      _weight.resize(17);
      _points[0] = ".42297654864907678749919877813006853403084357734313521853019734168161970175758573156495677257833779e-2";
      _weight[0] = ".4299260412307448665133624881974499405574117159014690628896844257161210734057924717135855394818813300e-1";
      _points[1] = ".221527053118302322942090021015730015485450584088220769434786399488156515355642000426239466001937198e-1";
      _weight[1] = ".9535104807481297848202429866106118257566228137557417660332400853161662680302761699773305908707602550e-1";
      _points[2] = ".538560148271848295667603220136445239020788940680251943301696458994841194715047205463051766316826524e-1";
      _weight[2] = ".1372315591826875201137474777560073360546853485740573862533356511173364265079156697526661118335742896";
      _points[3] = ".984349368305413624942469242370978263948897472429584127728864864700452356841861880413747313577256195e-1";
      _weight[3] = ".1645759033882728284844431118628830743614989413169168358659006260722663488738016626358120054440550207";
      _points[4] = ".1546079282658856298783890388078768159643889899573936780160589552820868047441765770328672418716605928";
      _weight[4] = ".1756904750903703112344453123805424546908639066388433026089700387600911377246901618503645283610375911";
      _points[5] = ".2207592251921513839136378776833585067846629363530123208654012539977418973898636052213362063366054318";
      _weight[5] = ".1713016157117382132057565333805042728924534535143805371589947866964031301303853940997281246350753656";
      _points[6] = ".2949858662980234886510059849705601329210424075903350147902591485628362645969755211291710565803372333";
      _weight[6] = ".1542209677884094145128943284286812925327302523010098402991289260221514316057089544615700030218454265";
      _points[7] = ".3751525416408178820083477139222646171835998951809981629079410853435870113997403594064257319049096888";
      _weight[7] = ".1286542804495145568686598485110360146860251475979356089399894897424306248964305507294249894650268254";
      _points[8] = ".4589530533530190808593345147437514652455985649810014296771181666727254937874683576150552189676820445";
      _weight[8] = ".9931702444790433120952426058302138873908984792726837791724440362064021175262692440686069358710680235e-1";
      _points[9] = ".5439766780904757097451521743554710584231978091980306940950977666498348773038378260887674018571215284";
      _weight[9] = ".7055515732420044207392583546335768383670146789242918934183781450503912339593438180917722727222643095e-1";
      _points[10] = ".6277775385468142725656053809477606660481926914076750686903817659859352892916227568745400677875818882";
      _weight[10] = ".4565456895454675099029361310226524142448988405389158412248073822256735245132154460401903761295545271e-1";
      _points[11] = ".7079450013850855679436224260730899232137170875245929183750474960756456985178763599106899686510620340";
      _weight[11] = ".2646567904144685891462284647978091273368422635641062894104746521612846499613282277673498551270934060e-1";
      _points[12] = ".7821731030812211281011385401557176313519720275190703032263911897342087238744392146926368605116440010";
      _weight[12] = ".1338606916727926148618970164658395028370018090423553621907901080091060043469655162093802538030454562e-1";
      _points[13] = ".8483270857099506075790635313717878056529164545129232857765525221759979278054482949739136814535756290";
      _weight[13] = ".5655535035824528926649613561049219086512768112197461770524280675540737290522504605487405853420120605e-2";
      _points[14] = ".9045054233143287003790610093283550812376120574920944369394302938533880974366435920451390516090983514";
      _weight[14] = ".1846696235108452323081740268246607255059909970851485069280721260167157397850582769904163871856048294e-2";
      _points[15] = ".9490970165965445702465476283565708297246607755586873532653724677803087032874699499858701150851049612";
      _weight[15] = ".3974261013418958398496273404764511239692337872082450246160077318175409175170546288895012284090236850e-3";
      _points[16] = ".9808438938474125636766637209275972068403939450087260749208889199283197846333843968554117528460090240";
      _weight[16] = ".3672321680050201588893508809125700046531141997623090861092178661431081419170841266491721846689114246e-4";
      break;


    case 34:
    case 35:
      delivered_order = 35;
      _points.resize(18);
      _weight.resize(18);
      _points[0] = ".38065822475018763836485343548908128836530842181437250558509157512865054835580682304550442871295647e-2";
      _weight[0] = ".3872959521506409270998592307661178898880126487708449836871701251355028383578477016496915478943754123e-1";
      _points[1] = ".199483510473430186663012735505779601074745750442251274143154167073987963870093079180150364373382788e-1";
      _weight[1] = ".8631509071677530810863100163952706294278370989850041392675520998322403679573746872013264869844692825e-1";
      _points[2] = ".485496453042246309655258182245965941520881026987912266146741918676385839045080050005500666072750888e-1";
      _weight[2] = ".1253356306869180533118015916525710771304275652121960162491546992025945693808868351192974355689808138";
      _points[3] = ".888762591164973880481813921949574688298959791547512835680204151798623849414160885332214861130374954e-1";
      _weight[3] = ".1523005370137907506618312924014636112216561687461645368895555297544914491320199297299184079940310732";
      _points[4] = ".1398845708351692649300383552676525748959865708235061557519490749172429745529982954346474136929129453";
      _weight[4] = ".1655087291500782613306060164007111909015389149173326868684911715359303365087638368773296390156486496";
      _points[5] = ".2002536959236303382067125585321085063433107257362303407043370644457116850092167808120166500781901474";
      _weight[5] = ".1651346632398309976571473150915354252515252272981002584619642650179028278177299248154542524087422392";
      _points[6] = ".2684201827866020844201471280361786628127359425869124458724958784949980847348751285744762131603672809";
      _weight[6] = ".1530511786893971990313986250253572460871774396855398171527438104801138575696244796632962408451450569";
      _points[7] = ".3426185978020083004514048444648040212380882146133496205314099376215388144800483221755275703026317422";
      _weight[7] = ".1323839048082899911826910765424937040163915594177335399366773159697079625785760931901186843037828276";
      _points[8] = ".4209272758703179558039109560839247557191088306211527841459293605637953895210495784407565029266997560";
      _weight[8] = ".1068936974758404779443918912465824233672883504398824139817461678734416233217909028738142876058300017";
      _points[9] = ".5013181027502735883646759853790557548582408474545762758344248448850577878823309680705395605759116039";
      _weight[9] = ".8031456678547888071777527613084748403550086714243964330239128562327769673230247753017547024436125655e-1";
      _points[10] = ".5817090526709179282288375852933077443864571121132991743769987023431980248853066657774790851887703592";
      _weight[10] = ".5577559061459162570281412768389355996651397767708828589498056037792211480330590031535721170146035940e-1";
      _points[11] = ".6600181272253155465521234027038088059575554457571711316782527733933985664095417196979606497396358233";
      _weight[11] = ".3540911290037990977420098813904969531272785240516766309095652038688854805794084594012390191614815054e-1";
      _points[12] = ".7342173081350132503192173614025312330653864334982702635244595308063572372883774041853861365278221064";
      _weight[12] = ".2020099515341872526673649424020333062100969085759988997176723342299630382322198514555179632843120645e-1";
      _points[13] = ".8023851498364174702066737905851700573574353078541166033802958270590653479162625703154687749291640618";
      _weight[13] = ".1008288655374502320909828094580508673228285324540546402052877073095600352583258281978552537379408098e-1";
      _points[14] = ".8627567207000550133608166202160961738680665986694630756476656758603077150109726400447325844934459159";
      _weight[14] = ".4214201135828769484963761390752045700215974350846961473780225330124447098246374619584268057963833114e-2";
      _points[15] = ".9137698641107929361661231897915912008421467877286301716092502878917492649700304674650319917326600689";
      _weight[15] = ".1364364814750619931583941001892832710526596444814880095801559791422327117557391969710365759995404922e-2";
      _points[16] = ".9541078955173166588189030938461288380596566681165619454485636499417392056850149493349451358778683790";
      _weight[16] = ".2917480346564748213126518173258607508890442325216746931561102953965933068483693177921983263767078756e-3";
      _points[17] = ".9827484075942869606330738995463030451490285627845328593674222417433378414637988294624743078554551718";
      _weight[17] = ".2684034449817248636307890670990759607627648491468895416588504339235192716316452092184439475720265658e-4";
      break;


    case 36:
    case 37:
      delivered_order = 37;
      _points.resize(19);
      _weight.resize(19);
      _points[0] = ".34438904038624902806940509331722218118237764002991412858481112615844728242693578816862624868339908e-2";
      _weight[0] = ".3506918822751692946455730452233595458916116289923823285432079838303497328566987932630679733749297592e-1";
      _points[1] = ".180569783379005628630300939543426866589488073359103469264101526778553509159512609080680306884745910e-1";
      _weight[1] = ".7848342536092973805160513510880688200259433707189886999155358202518740624336539197330534120583627270e-1";
      _points[2] = ".439873950908427344551988327736594826194320140153375528846514027207880410750838305286878028688002096e-1";
      _weight[2] = ".1148325991148163444911640277657323543047270823476765245035320839854858063568929732605305534995216716";
      _points[3] = ".806332763666614154697217766630158459957277447849651525951264834720273397104963125897285924387255855e-1";
      _weight[3] = ".1411124687979040017383983383889387833636924536378786579842406801114338206400330468092921853091999434";
      _points[4] = ".1271364098615602695300253508396918022790446090548847239057383641397465202768706860278890106271755373";
      _weight[4] = ".1556895448890469502039433952460571175059219100966614582090178761629870656252840687807066368143396396";
      _points[5] = ".1824069836690918531306969538712789495119226639431501787827330067269926177189844384572705963840879390";
      _weight[5] = ".1583929928595227080602642462804924544723091598046442686562413911514004596788051226202861652567728365";
      _points[6] = ".2451495690951685705524921770182137890794445582375331816751643930651784772617999016157149898754773395";
      _weight[6] = ".1504300020813901758036486944453268769096163950084233519532702102196909305554659060185430103649064178";
      _points[7] = ".3138935674182182241524085986530725421833888559124072140832271736633880973343121552225350975792017752";
      _weight[7] = ".1341002722824411358436228022698388785145351066959596061980307557271397511811546203613438647447731976";
      _points[8] = ".3870277027693322034154529075168274250441355570183945919149496613274873431354056703498844308990953008";
      _weight[8] = ".1123664317444116305965655143169402510025365271744523979648159561101015872421911323846125879396222853";
      _points[9] = ".4628377985520202782022048705469377514873721078497890685487969094434993704576336247176078079949870379";
      _weight[9] = ".8836225259929596186133469102150733448918159724655286754038526721794532427584912859912903335150515705e-1";
      _points[10] = ".5395469627920880876694306633299818817017043399462428376541362226335526976593984274704483496113346924";
      _weight[10] = ".6492726128798530252071044988969133477365566175334068106698994747182582468433303021020195666737121265e-1";
      _points[11] = ".6153572448045471654669401635833708805050867627458286076001673229030120048708698995373393775522832916";
      _weight[11] = ".4424576251614803158884713918509202323760369304517733604518806841090123069603439631756455979147352903e-1";
      _points[12] = ".6884917909140949891898655120380168800849788729479226796014048212433893444546592668647864865663296238";
      _weight[12] = ".2764324431172879278940581658661853456999576463765561596565228984548554485346431017256946431651824712e-1";
      _points[13] = ".7572365191732979354973693279466696491303870879952976126011813160845715548094948766085611653832161426";
      _weight[13] = ".1555913925021236084119398351318324635350878964483833382275711925200825311327878919159166803224117512e-1";
      _points[14] = ".8199803570632373353795400684102916116941435268852334780207569085081760303785333606287354427331798835";
      _weight[14] = ".7679153890769252819349084362266762034680794496687220780226080890557707688737671772550611046437187465e-2";
      _points[15] = ".8752531629838266800659489088760858408079696488715943336759069360574915944199538127854460103635272240";
      _weight[15] = ".3180177301794237493019314012687144031688576745974063615856410069920493919217044916534773054163212654e-2";
      _points[16] = ".9217606817291400488993742163227374545276684154855298882918293363660999418596388711657739790912190803";
      _weight[16] = ".1022123435563885025902206640552076666567191786422602535420698723807095034807642183511143694820295308e-2";
      _points[17] = ".9584169024234071451034779092669423904741880674092767651904315631184608661010553708352299289446592853";
      _weight[17] = ".2173705725280176670944890960502804423166204597532801450098392340276614206659788761434319343454143889e-3";
      _points[18] = ".9843828065517020106761276174556909144026325831604026447615399145866983347355888758046066379113914704";
      _weight[18] = ".1992280932787647270670068121504406904050878009796350082427834039239683808319955860954897199266412788e-4";
      break;


    case 38:
    case 39:
      delivered_order = 39;
      _points.resize(20);
      _weight.resize(20);
      _points[0] = ".31306837407435895621501417495462510065580878973398298412115393497382743148664968529827799082045388e-2";
      _weight[0] = ".3190317094510660674090924062970198411577078121671833534897277070677203833980338615982242263137973616e-1";
      _points[1] = ".164220881339878329025416142562575229809359983703355237059350695210504939834071599255435745962045506e-1";
      _weight[1] = ".7165500930295423640709583546529029927063232240443669945496644251219376217691519736672483743823850830e-1";
      _points[2] = ".400369004619067809963201498287928025191921820210062341892225390040998573431853908091672063417920826e-1";
      _weight[2] = ".1055302577165023391780536338961832585932656024160937632538479770610925703787292264148375734920674494";
      _points[3] = ".734771917852852830575665452858744671216295674682933156759792305664838530209481919649724781555323708e-1";
      _weight[3] = ".1309385772702925921899186259959536648124379399531342254695653323236852472377607884882920170278896659";
      _points[4] = ".1160309076554868049466974315674778539277330768012538553063813735353261223084763159059242881112719989";
      _weight[4] = ".1463516662129082599464371823076988796401775386811170193209364125128477705820631778004347129886192058";
      _points[5] = ".1667912534810094300129807014584903280447908397404053429938887652977094384333228625709776729362659786";
      _weight[5] = ".1513895615076893628614187777974902875769289857347589080536723214276560283463670856505077453095048151";
      _points[6] = ".2246764193843050384093819648321044864540754911683337333822542507266562834493851020811842664368541636";
      _weight[6] = ".1467896818880725308530169982826116192006045612648753091087111859984896015533920748162929571737173545";
      _points[7] = ".2884527121812723847719407066523953852068123046578582394812568730574474727765765420104187934722455199";
      _weight[7] = ".1342257258139019739160108592909563151742579251223689347399582619654740155148596039252928397551154914";
      _points[8] = ".3567608701024531056470550666332594421879937365627218234316645015120881052816834839729303782691229973";
      _weight[8] = ".1160096189823571406796654290456113281805357426540610444070368909950710161534150063798066831796666304";
      _points[9] = ".4281450409332566846154250347724519581718006946562795606850444879460088034322223621075385140190445604";
      _weight[9] = ".9472916165698421592346580106597904566789390110319129543362928719528014089962861825723013260548530370e-1";
      _points[10] = ".5010838154828485513706246541369263270496076238639477776074661526726511056457717245333351712537248934";
      _weight[10] = ".7288201367307476620737326123903540949531459313127703706325526164891890426846954818738827733176229805e-1";
      _points[11] = ".5740226581828268717275121966537067538016418929949592700206557877680052279117492170391822933202016281";
      _weight[11] = ".5256367702664660696843253488312400143294584902673080355015772217448264100685386833519746415036752640e-1";
      _points[12] = ".6454070457773675666173208347639696868480924890494238974440167033076937496843430736866993320402326217";
      _weight[12] = ".3525422431297342131570109267190665101713924409722248740423389077510379965048840746566703817840967359e-1";
      _points[13] = ".7137156110152876807420834353539261845083764977327116606392342641138367359145141329606212643884043525";
      _weight[13] = ".2172836322449210980004804457059473249949021836957893650421253545420376191894281707541313281395819864e-1";
      _points[14] = ".7774925920354867535511259458365767833501645594282318185786818344152523063340596941838540072199020284";
      _weight[14] = ".1208995668362951749967394391224448828054059207291389348694724435189801244587869887557864332436285280e-1";
      _points[15] = ".8353789146315617251715183947134126580844017599680593375160397110937599975115528768975851058881087349";
      _weight[15] = ".5909777767885943225135430582621307955547100153876209416844747358074494910134249252257133135737806525e-2";
      _points[16] = ".8861413029145471436872829303649495040166030756579052437556327864000033121939155088226394817590025458";
      _weight[16] = ".2428182817069033016610894924350833114680897738357536155240424761102475327226118558922110561968133044e-2";
      _points[17] = ".9286990149187505453450978371672693948888756101758623893390553359882107838318818368546819590506484100";
      _weight[17] = ".7755532384700472430793540610379271893135838353708382828748805776320956014381700141548785595564677150e-3";
      _points[18] = ".9621487121504981897091608064229207407940341288068742181995487210154653226478330645824175987235471688";
      _weight[18] = ".1641564083492808221962961635922449664007417807376345432948175005715964939937779190026714134837790598e-3";
      _points[19] = ".9857957888406418466800231313592152785604899067877207377306395965180365635041144860468676436334983788";
      _weight[19] = ".1499688397334853909009654734905514945521257651242233497492603278336052697351239051006226204243528836e-4";
      break;


    case 40:
    case 41:
      delivered_order = 41;
      _points.resize(21);
      _weight.resize(21);
      _points[0] = ".28583506000918943222556277168266894858285751245439686302779772142656766161766731194904431193569346e-2";
      _weight[0] = ".2914652692549772359825191743397280020164868373562383178741132669912525302067096472110034590221450778e-1";
      _points[1] = ".149993649720755223403571359160225470539361883131836778556516603903438708635668498472691708816024396e-1";
      _weight[1] = ".6566824457697127529902981695220767771270006886685278602736453053393289071075554704667955406649786635e-1";
      _points[2] = ".365938632811401226265450552821860085457234611801545310290922602501176971894880071315680511702106564e-1";
      _weight[2] = ".9726429982522235339421302162613403019875891383246840547625842897557731247557947987411508487703896340e-1";
      _points[3] = ".672264416679386385265639476746750035714407217096221424116585689782697613063862074819310720523387194e-1";
      _weight[3] = ".1216954186195147767859181700852196598453398974387542750341310709128680231375238395840670148310722194";
      _points[4] = ".1063014797376931175504486884739310046446260359816027861282438230188065644711946783060826726008415025";
      _weight[4] = ".1375542142025096877653615060378353535237823217814758119642712415097028824989683064469150679287331653";
      _points[5] = ".1530585749557192122497019530096285339475255004440860527688523339429919998362921566593935826956916887";
      _weight[5] = ".1443411095395721799450733462238414248515479283870827912143456827382935051545476673209780808262551561";
      _points[6] = ".2065877060825335686769803341751510840175689986107977624063634924301173628588357156175136088108009986";
      _weight[6] = ".1424637790987724784544985952839802649730864625728979547070145816086846459169762856846041536053044903";
      _points[7] = ".2658470140108159098108921515437181536788750914282933339485578881666960769687043708156597820375066452";
      _weight[7] = ".1331241870513333849458925379704009194981324486702047607071260864313889685659564325467513394604774757";
      _points[8] = ".3296830989901027237373491420545228582656516694202723447101849302637120749496599731334902543040306284";
      _weight[8] = ".1181122908083299756311975390634647250493155093193591314865424228051155593226483354511888038664192100";
      _points[9] = ".3968534769856190095039434290948319231559830819379799669417186235032912613191108923209116958842566661";
      _weight[9] = ".9954033550102391323827171966064464287012304366428248944838945894154080711643726715650514184490663175e-1";
      _points[10] = ".4660507666351746484729664900381236689850117104625250010739461671795351570200905473063913279087995362";
      _weight[10] = ".7955912026541126007769813685510363475963878808713764989375842730287294266866641538077148042860200145e-1";
      _points[11] = ".5359281386930321609326895183917609968520364389050114840655237758106639373854988648624902834575404957";
      _weight[11] = ".6009811216766876110645301901080290470540542252779656010666162330015632690205531715683178923222126385e-1";
      _points[12] = ".6051255339761019284481098523077407624240428731564207776008663713434935031358888405650262217950025242";
      _weight[12] = ".4266508146203472287514740814497105426127212704884677528002189938589343854792402933566360152308841056e-1";
      _points[13] = ".6722961409869296162899704994812126870277260383783201960320999269060656781743057964570096111577941914";
      _weight[13] = ".2822928389744864174544586786898217788137229652458972736832397295131736231647885061286268917613281820e-1";
      _points[14] = ".7361326205972873484641029767022052979157240580407462771652606168048533849135950252466274550522292080";
      _weight[14] = ".1719724025685366088414548084037341187485771394568726343623778138278751292702859398535198066378698652e-1";
      _points[15] = ".7953925737461314623249865033277437002775654540111543847783430994750663228409525643598837266227268829";
      _weight[15] = ".9474486138446127589636908414029505700709517833191754141564237314203429084320420413231363560329652725e-2";
      _points[16] = ".8489227735376888398440174689512629925240544749893709330516913793468738663135396111526364874935058052";
      _weight[16] = ".4592965682865899309081525926914390207513681471407921864480309470237783124356199535498939949761317970e-2";
      _points[17] = ".8956817429254667605282025742976504630403884116278020040145896760872923029903183803945118949524777898";
      _weight[17] = ".1874294450135896801731784503573779401671276969326976735014995475320855077785022212257014128835779502e-2";
      _points[18] = ".9347604364012299479827942935966019857975433066835579885667315868005288394577841513140255125926973832";
      _weight[18] = ".5953999959462022743715146028300385175077092750037786268248278976636240495566479815754772126034662275e-3";
      _points[19] = ".9654016073657424580929490790442942557127428617746879386553787549823009422401519559419539901187906329";
      _weight[19] = ".1255089335871709281118126890978511883410232408935299359481594966361344340514817928666164954439064660e-3";
      _points[20] = ".9870255665787578365469005516471821103487323205471391754376943598319864464211860106934058825645259436";
      _weight[20] = ".1143393418724068380170413895308611060849814044915809164226820001407628104622909351779375360804506202e-4";
      break;


    case 42:
    case 43:
      delivered_order = 43;
      _points.resize(22);
      _weight.resize(22);
      _points[0] = ".26200747203711594248593674552648889055282549059670753414142097164037660026957532599825054627939248e-2";
      _weight[0] = ".2673172609568654751853295736245388910769904510379438631959110356067466777925600320462686650460560112e-1";
      _points[1] = ".137536579873858040257567507090587296357787100752904979133010541135178259103557502106147159734870700e-1";
      _weight[1] = ".6039224968649528527797201695304747719350890246767119584138949538030174755780883063573073921083354585e-1";
      _points[2] = ".335752268480266927143081916401578225593655535425147961825613608524864409778100002908375565340915060e-1";
      _weight[2] = ".8989485493810659201312259319068572635263313059560239420597839977609904961839090425684555758768323615e-1";
      _points[3] = ".617355616230696016908265743953079923259323985343498161679544986939535882534951072547577098410362050e-1";
      _weight[3] = ".1132978321011550534569339446690910280401715810568023622298179018105850110347547332801454825123080108";
      _points[4] = ".977326966753686424584798849967233234692386909763349364030202305016480177189642811268885212451348131e-1";
      _weight[4] = ".1293178958114777478613063500315394516761550424810764340961225637292240059327409033219261636472499914";
      _points[5] = ".1409243977569515851945061977581645188461195970869053868578312970446406184300586658915338894104880520";
      _weight[5] = ".1373943986576711189457038637687127484198195244023737460240143431480038626621631210916534351512640734";
      _points[6] = ".1905399551842166284991396915288050974055091810716148172940553365188707797144828728812777249740083840";
      _weight[6] = ".1377052393125228077987045052679605699295332423726478549816510583467911003227901128808596333174469450";
      _points[7] = ".2456939996245033222244651990043465110400952191612821621011308886225917827575436024872494923702035976";
      _weight[7] = ".1310983476019885069549959653684284929730374753089605272225430034875336215931548267651214213715268346";
      _points[8] = ".3054023184425990231526085351824413364932159709089239800101319162552567160333479391342542847608906842";
      _weight[8] = ".1189493465137092329856021923918966933745585084719621133590629255356233490617687640631696766904364930";
      _points[9] = ".3685994249559412825032166420129271053410258894370369258634481384659319950868454860519985944915827024";
      _weight[9] = ".1029672849391876735260280671946109142630666826269145737607246207862594409036669986746323585832975407";
      _points[10] = ".4341575748401551375082012124710567475311318981229697451221181030460066453494908033714119124482954652";
      _weight[10] = ".8497667125409721785945148880879745505881359027847151653606924351274875356349984209037489762238788015e-1";
      _points[11] = ".5009068926479350501177501589277218806508226892948913257700098794311718939499484259368208163972501152";
      _weight[11] = ".6670592951879767846792762476690622296014280028874613091699757533426509227995492281918325108396123330e-1";
      _points[12] = ".5676562502726097870217726677178769223611025672537427859994804146174746381249794034881861040558801353";
      _weight[12] = ".4960981404383829993700779271549480288885853637660176997186571280097470956587682931711438082157298982e-1";
      _points[13] = ".6332145255726628427916625618237318565701781915004554642631578635011061799446656933683602264420425428";
      _weight[13] = ".3474679389549965662247861906215097123019694954611807141411557017597677027192888562429244380178121512e-1";
      _points[14] = ".6964118629859517266112670768971276038290954874249845702950806736765993872213401445317623482971794440";
      _weight[14] = ".2272307353970016175798801382037590056507281990311145345973578790932392062647349992155849279080137204e-1";
      _points[15] = ".7561205591789348712292879352778617261241380680902387401392793226178491537553553080545433141959526422";
      _weight[15] = ".1370427408387923505535094139296990898530719232986605891147317475726272903114323254491117374113056886e-1";
      _points[16] = ".8112752068392205078781186463119643007891999522242449004575256452024235067993066706011518445018605558";
      _weight[16] = ".7485551813034275817216951148497417410643864099134073165862080079074318408799086608465326460065583840e-2";
      _points[17] = ".8608917527628662173065612890887607980242804078166109331181252056491267361003793655013810947480807696";
      _weight[17] = ".3602665011170079496010454313375118125820248682611777483518813337130543978051137706444943920819799096e-2";
      _points[18] = ".9040851784977527206617013643188418266790222208067682092434771080729602120076277567836036898919524325";
      _weight[18] = ".1461453138691387066178714368792017613580659773821636378785062623685765189258882757952421549396110384e-2";
      _points[19] = ".9400856692108184696160307746610789762831294650129674325772200327073362883580966732090847381891664410";
      _weight[19] = ".4620588367040999729282212179118719403671385452681342157971829216665667312380747639184954098698194135e-3";
      _points[20] = ".9682538838165636528816421008794414241196089368489573782572610534009132752925859249504071948887714274";
      _weight[20] = ".9705271167906710277821920044618755965438716605308287260605611296691915914345444845503275016391923235e-4";
      _points[21] = ".9881024599908778831834893508543820892773502151203394249702418542482522913410591542225873730537641332";
      _weight[21] = ".8819828241607839113836319188467664692011455724039965611658207161388061470286555951138804730569350675e-5";
      break;


    case 44:
    case 45:
      delivered_order = 45;
      _points.resize(23);
      _weight.resize(23);
      _points[0] = ".24104039982517807924518565881019729090665297391197982121880462088142582890647721012738236191436092e-2";
      _weight[0] = ".2460458715379363680944285409901799406845331559876742556717226362516710861484213381914679863785818294e-1";
      _points[1] = ".126567991854554032486919041147616055178068993488019404920062315307023102839017774129144625521725830e-1";
      _weight[1] = ".5572024457122334686306970307932336946322249656441291155755441029051172750463539491199941727180475030e-1";
      _points[2] = ".309142052168577704252465926144989596746727031220608678386387208061810978842626908649325532451436072e-1";
      _weight[2] = ".8330302639229947932606202543244005159580104495976244028104260557408709909900455946501899842558971420e-1";
      _points[3] = ".568869707344469082103258883833696174365401590733972508265081974930562947362731613085632868973824758e-1";
      _weight[3] = ".1056636634236599800025960030696444996116926205371369655056408389679930032480510185451900109913960647";
      _points[4] = ".901491345577398469158994861292273721141325393164975822580806794943871185193486088915306872681911823e-1";
      _weight[4] = ".1216392044936975061036741688714549551287865944305569473422823525233694802740589876102731729525532506";
      _points[5] = ".1301546569620392647297136145470657135930380187181655783102116317627332537731657610993460755762509309";
      _weight[5] = ".1306458637267026875983182867538939685731303811410348704694137140183344576684464387632647558938926052";
      _points[6] = ".1762466912782491162874995389654770161435899409370830936250632217648999272579318891342051808242807321";
      _weight[6] = ".1327030992078616851137716062422670407717193811777823788885466984107914606883493188467711293676171300";
      _points[7] = ".2276684266411056773027710770956689945976517001579188130220661151724974754332539072451049501434355576";
      _weight[7] = ".1283940193233969697677293919549598541264664191744484566283510181595252794240699445354258114229281919";
      _points[8] = ".2835755302598378337994539658113249207907562733532297915625840729145925650514832273388671279031826859";
      _weight[8] = ".1187676404312684393557883257269936135587246278818678797038987739015900277273626487102457050130226676";
      _points[9] = ".3430500166905744572249642236228373303079210262636306213248867962132213743211306739909111276661963969";
      _weight[9] = ".1051971301902735212171552740490809864687285728732286101918097259253218725264728006157687448724569254";
      _points[10] = ".4051153234824939152589899821459852518084292041960127091818387323191589246479819549763061565524843400";
      _weight[10] = ".8921331592042749615179791387250922454007077948520920020945311505702881983826510488006429430176552255e-1";
      _points[11] = ".4687523477214090214073558308296168896809398353261455806058774838069360883559041595095033610401987426";
      _weight[11] = ".7233501875091631840919628023809183145752557746817854260441269393620510970432941834632187160557783415e-1";
      _points[12] = ".5329161809469259852961679422880949408372018266872169088225806359785246671619598639988003464099914504";
      _weight[12] = ".5591706970939040592614623445525001285248857059702692030395415650257556886501471071456697084452361735e-1";
      _points[13] = ".5965532681512670094276258199980622909368222170766033931827570264949111422639694369359726047707370604";
      _weight[13] = ".4103337000606945503503522217670326104878723363104651468601157260930516194676854942670347964613293931e-1";
      _points[14] = ".6586187096898888135130219138910443233073970121048619807684601196253997338641760466888560080659310002";
      _weight[14] = ".2840664653778501707948217016440661524304227052022033505140575431516377941086740846607743484483161705e-1";
      _points[15] = ".7180934230399323348705289685504155581364969503653955389526645485144502596400176203377598049080762145";
      _weight[15] = ".1838949716531371895801221750607384775779877835883666504812201193134363107981822179196427825683023814e-1";
      _points[16] = ".7740008848261039548706028650398502324593547673081739454184965735674190874482260530264986752197143283";
      _weight[16] = ".1099396318272331474169753508597427233921996009999619601995167163454190521119038525024744167647521532e-1";
      _points[17] = ".8254231835351607786693628066740285412448723033292098215120413379094288517271797907093120388750574780";
      _weight[17] = ".5960272673820516018892550728367359102119125009944955607272944225823529645958240764551805101696205605e-2";
      _points[18] = ".8715161336713438696663789268096078560203102425650686035780009545736051097600251592363012603490396263";
      _weight[18] = ".2850497081093543249504950370776049252981886294476489764789366131665472664109268239563547260999774662e-2";
      _points[19] = ".9115232476013712848631727800493825734445243013466233941759256931038532414323388171548016643162638202";
      _weight[19] = ".1150314682984822344334855610916138444468915824198344682212336984814856306470038289503572913456088932e-2";
      _points[20] = ".9447885021959101873192640703319531140411645602202181230261730429904477029248254097807519999563812720";
      _weight[20] = ".3621778022397484227568716984452699810122401675080385621920809602503235452142352579992064771026627860e-3";
      _points[21] = ".9707685195733889938794720318771182548024669818727768010084319949615096226307776604478341088419962470";
      _weight[21] = ".7583423894827645199529497212749310045124079552553215845278302430393444077320694676832430473557877340e-4";
      _points[22] = ".9890507733735791253543712469758400035281773409051211956278514761266032259261348911429860283320819928";
      _weight[22] = ".6876667443448386873597174615624846641300742166712499390444623619723899261299135896561250086555721365e-5";
      break;


    case 46:
    case 47:
      delivered_order = 47;
      _points.resize(24);
      _weight.resize(24);
      _points[0] = ".22249354526130536658919430692557500280014777996472055359662834121595147915829993046727584966003443e-2";
      _weight[0] = ".2272123685713789434030881931524938582897026979966692028426173000267001400447472415898858193147616434e-1";
      _points[1] = ".116860039697678411958597064537259621350626277559859336655638142444162076497727372185304393427526580e-1";
      _weight[1] = ".5156450302852561733106515247255298513224662256829380501788829770758411341850704243499552632230453685e-1";
      _points[2] = ".285566141910057507843377310699147431374818968939215074653067704539297268292695170889637302807545522e-1";
      _weight[2] = ".7738771704125657665401015992403564121662898479846865035804772254684527134060060366460129521533423465e-1";
      _points[3] = ".525848397643218343854147368843054235263457492940869184703056976531972677056533757103799011269986608e-1";
      _weight[3] = ".9871617322318441702547220169324858290886567033955491182963415229959747527921243023604629810279797240e-1";
      _points[4] = ".834069082711566934226571503191487071239351334940694362557319605382390528434147646059507613279901368e-1";
      _weight[4] = ".1144998723800464282627119569938636431402696445948437363201340620984458709118113476601828043188131730";
      _points[5] = ".1205557027005187819785359775783852711983906679686549822611192158244964090168065655430091806355872867";
      _weight[5] = ".1241560818892750740513319197449305270799796663008705162149327212005494018765146066229281884953699292";
      _points[6] = ".1634681244020306820900081449797999118733278369358442810228438232040837540450435199855004039271956991";
      _weight[6] = ".1275967032512150077508959204123806314593760528903117432232790163652944697231707117691953613594326376";
      _points[7] = ".2114936819377605655182888616348370137102012365281441126857995265139411092227855461865391104829794484";
      _weight[7] = ".1252073956815181771346127294596215849298975190508766297740178851158073346196145842747014091497200859";
      _points[8] = ".2639043660726025930345938310051340067520452082079640857559305951097397292053028574030042265001554287";
      _weight[8] = ".1177809496131256963154687299353704343516432112100715198188912862742036151417784070771267150840848668";
      _points[9] = ".3199056905142705147196284477592600478118677860085346296646837337943071384012733116212835394981488250";
      _weight[9] = ".1064140204072954464118267057242311153891075934728738476926957640344192610080730226508773305006259690";
      _points[10] = ".3786487375725983130255223763826594151980352418923449568992150385696141263998799737945727620052669868";
      _weight[10] = ".9238041135649377632848298626350660907150032768554403014238224628817114536167770593375677111179163145e-1";
      _points[11] = ".4392430280138590771400222586966484479281187490364367805606402616906997553927361513577773490887077744";
      _weight[11] = ".7699630754163361492101271509761239393849942140377941862209472613642061946357771589251994659060800815e-1";
      _points[12] = ".5007700206965443044420384481447814267438751908957880531164770293158552605883981361981888199260713036";
      _weight[12] = ".6149308156503639872799358294626381094725788384605781475174499580448305892704309824786744398644990350e-1";
      _points[13] = ".5622970377001162863211472577185407563882405046536041909948441852501756198349145685895124686912743446";
      _weight[13] = ".4691155780914074351191359715317592062114564467849614405909797762356093740160687100859266520779691014e-1";
      _points[14] = ".6228914041763613552769405578811627797744735067301256611232410007539390365503687846951176550441159124";
      _weight[14] = ".3402821314534665504742300668651742375478680187207505350701851655484252062079811817240060870672024592e-1";
      _points[15] = ".6816345890584223343347584224654693833359846182784640936142748749084889259843441535034498170983533270";
      _weight[15] = ".2331919963843795558856289001178667829714874513151429202299104727270255015570026749611235251715162338e-1";
      _points[16] = ".7376361331966650834319952799565664239997149439085959623604215726217384164028452637066239693458780328";
      _weight[16] = ".1496293466914953505461657394313684425359985778938564411206391793398712847327829843346312174320029113e-1";
      _points[17] = ".7900471558143551952024299464595864800685694943997857653563880504121078982496465547542056175539249178";
      _weight[17] = ".8877010801018946117185025924342474510540324525513331403312263343710478394357406571414381506476965365e-2";
      _points[18] = ".8380732394393357620477594707813738107956440957803211619128696670627887064733041577933862555402706288";
      _weight[18] = ".4780991554881356318299278737356108506360151954128225642257285864494409119970728164251078957004786094e-2";
      _points[19] = ".8809865112004901553982606734371066424293828263572332748538020660425345593942795437337711303415934298";
      _weight[19] = ".2273816875030566631082337760719505683063855834506483104577945072621905255965654055089511952968493576e-2";
      _points[20] = ".9181367783042758317115298970528403234116421141197280467998314494812585311720032200286955057989597077";
      _weight[20] = ".9133865187289247367136496244884025935049017690707982258831296507599797381201681041293892913663144105e-3";
      _points[21] = ".9489617024727324761890720630019867067891512669388670367116995074683944983852471238704034144706237931";
      _weight[21] = ".2865262744228954315248621894840737436204226419751809547178299642115143727296322854938132591638281762e-3";
      _points[22] = ".9729966238607434240581902575081331739557554587997081204643390924536815578867557077759207213916867342";
      _weight[22] = ".5982741578200805140757442756876710357681187764184129492998044221027472286015156917522460628695894720e-4";
      _points[23] = ".9898901712174520906251165597593773918847523673221438024487047832202131975743714655305404620841100670";
      _weight[23] = ".5414795649621589410956891889788871742947297812794956478833735739984001890036849423513416387803433365e-5";
      break;


    case 48:
    case 49:
      delivered_order = 49;
      _points.resize(25);
      _weight.resize(25);
      _points[0] = ".20600819290978834992305487712566416830306441355885579147790231016968362897147721462005308031489629e-2";
      _weight[0] = ".2104584654991310894984769694957997264389234706488954830869366146363669643607673681284303221423900922e-1";
      _points[1] = ".108226830135903113810584123863861074175441949501461857209984338280343289258064115821640072580259251e-1";
      _weight[1] = ".4785247342860094090713410636696065372543581105275627351894179124877984338090126845614454514490370110e-1";
      _points[2] = ".264581297235543328126111150274144876238158293048457907207494238085749449768684793471686045629576803e-1";
      _weight[2] = ".7206284363820171160165937570261028877417915555039796312170958415818099948789627440765981158860916845e-1";
      _points[3] = ".487504655197159425662604840549514986387265026200742769228905052346425858028303577264269365332051794e-1";
      _weight[3] = ".9238508110486277697046072106183462307349301111542269581192066431251586682339655452945584717818739675e-1";
      _points[4] = ".773871904794186405884454903565109546341932109346288774182004323075300704614515159942460690764711282e-1";
      _weight[4] = ".1078731206753558255699920516316999773845920194453412445398199388813993235893370279142172655876824572";
      _points[5] = ".1119664131211797080591453118900233568411335618341266482302911307568798211658937390561142794026764607";
      _weight[5] = ".1179603120946719806730046151597300929107578524479463578273411646787924756993067021805466404652833203";
      _points[6] = ".1520027529734087162506287551943575708665665516914832278052044133827396241518816510167155210118597588";
      _weight[6] = ".1224872666186146488533662443240610951691534977442791141723136190727891953370651772473493690396277062";
      _points[7] = ".1969342031254723248318136513226723837261617920675631369200407885476768048090584724200227907109777927";
      _weight[7] = ".1216929757207637586818931039746277834402913288184501947402046698604718770716389339788734358809859118";
      _points[8] = ".2461300326799557368501708657724630388374281519477683919406243379905396093914799829014978822920175094";
      _weight[8] = ".1161699062528098563285204629158808188551384494639865932612070092262711343486676737524132437678548470";
      _points[9] = ".2988996452854616817472628058730197227314433867599336194504840923830631129196201993067222862706236950";
      _weight[9] = ".1067889173288499383103435803421296762480412898220799307294532420899026429787438563327810872649051310";
      _points[10] = ".3545022754336092801330830225246756319748235396671835065241829375954950971669723822236925390213555706";
      _weight[10] = ".9460303776621984255911428340425176633044568964941211415406548859126157076222722306525009261263872310e-1";
      _points[11] = ".4121573881255929482897040156029304602803026810481251319022819080784439249416642297798100544798503956";
      _weight[11] = ".8074110304100429667322390015353026479458249971802668553808949061734867458681218551998618063433486040e-1";
      _points[12] = ".4710556365226797192363701668337433453652680273700752120149035736826756466148957367682835979522326213";
      _weight[12] = ".6630287633400960740664405539791593674018482270105306573866739446952101295678770123011621440596649785e-1";
      _points[13] = ".5303702240359852173396065663591384210267634451500462472121109299789877460508376633515105839528377266";
      _weight[13] = ".5226654254025416026230055459765768735408748982342137352210401586284879927470555960353573242755475315e-1";
      _points[14] = ".5892685115570647814127303043715788194113182486287723623739652905892272971097895471854805549415698537";
      _weight[14] = ".3941749238248017695654904390708201200479612204684234083409815391209463268142666322461799547268657053e-1";
      _points[15] = ".6469237071357920937508249478501848787366871342377897238574359882034872352624041632877614982121503126";
      _weight[15] = ".2830437637751160048700083768002130944295668211190091848676117122152547090095035944438706910338870748e-1";
      _points[16] = ".7025264744308617327764735628652519707991262430777878489777111185176795447563520263257678166613306624";
      _weight[16] = ".1922488755916925990273545208551839304413598984038948928740273847627349626429186204670641466308664816e-1";
      _points[17] = ".7552962978229513043581799301877042674961500659949106188709770331116463725525761120695916327062411800";
      _weight[17] = ".1224007338868042622396387022609224838828698746567512089592318372920877496450321656939677888467607300e-1";
      _points[18] = ".8044924465194527143198696101390306595020306714115014471218090194399979166482091146097001614651134796";
      _weight[18] = ".7212634664746175919255619014411005105736855663414167780607988951879937275803487215993101186412011425e-2";
      _points[19] = ".8494243882656275732290900248503280680907322871463571360374955681062300158144452515011786494799601120";
      _weight[19] = ".3862047153394014885660554694647840111512019761959973821093873699280118779178659279767371567986827532e-2";
      _points[20] = ".8894615186907393745656503873951861823090345844702245018938672248913223057207012920176380233027941396";
      _weight[20] = ".1827746097251135206530204407903268733428075081612346622935423986110324998010804043842916884231459195e-2";
      _points[21] = ".9240421075913750881838602702996034607162778399469706512026890165612157489271054019443733670963922680";
      _weight[21] = ".7312150296955576038999427301489336061245571898075392624561063075884138374981784504825115223133789420e-3";
      _points[22] = ".9526814786656007765604428427646471107128280724641542445681143547072496089803389360499312827713015474";
      _weight[22] = ".2286333412778897125360878868810677218018864957423887924835086482637072540841046732817968526158322192e-3";
      _points[23] = ".9749800156322561440080537979319428058608688920634258011461633746480601222229645349760627442123002214";
      _weight[23] = ".4762148988535869484357810517214382489037315091947178037681066416731762841027085559169825803906717019e-4";
      _points[24] = ".9906367009503252040186638786057673854869752103072860840212608497776729091053687956427078165918365860";
      _weight[24] = ".4302755109283992853390612984473905388520107606420784662639203221026015612852498093180725123270944038e-5";
      break;


    case 50:
    case 51:
      delivered_order = 51;
      _points.resize(26);
      _weight.resize(26);
      _points[0] = ".19128971711032702883607852452175290537822164387361021139258642261362003063805408576159111384445623e-2";
      _weight[0] = ".1954892722439377291610145584289408938746223353894233403593192849234043653992666165163094243766870808e-1";
      _points[1] = ".100515489590570582910183716377600783988728689417874642729565404290050683612552394324891041215558034e-1";
      _weight[1] = ".4452377548054358057693152306974293779850488015842524187316405913445811445216693334480955695294329956e-1";
      _points[2] = ".245822159356734413995995144294517360452522754200859768370653662906656289710655586389084613025688277e-1";
      _weight[2] = ".6725495107308428165273852693974342265312725376252435168146700914145779601982415440151049601834443070e-1";
      _points[3] = ".453187460896998514112593989287135239258234907004174445030641840360933829254328678041636904229728234e-1";
      _weight[3] = ".8660682167204660370080193943728064352793416035738853172340408852080310732523056866625940444334256440e-1";
      _points[4] = ".719912111332091389795230326331533799084497868259454309849621965493314095992624337097552292021463460e-1";
      _weight[4] = ".1017277570591432847348180174383227213260284916100920427592935367507284866022929405674419032343979144";
      _points[5] = ".1042519922933739349627321569155201289060616104436747962912852388186208673319729357666535825336731682";
      _weight[5] = ".1120761181427334190032010245158099690638256138925814165287686360873920886305053666402692629197017782";
      _points[6] = ".1416805541841085939424499105077162112269282743432822292773459439118180445686557930664348991933588237";
      _weight[6] = ".1174470285752688860802839059280039691280440259409814273375947052982746441066239455155823968053011634";
      _points[7] = ".1837889724621079951285773493909411733485119513609893231234408186596165165503607848643038915766772525";
      _weight[7] = ".1179710549264457561782354350967497775907646397405245096492474927754560320390464932600093016761328566";
      _points[8] = ".2300283068068220712641291993271690939020865858057241478025322546962153343757089150788080487183609627";
      _weight[8] = ".1140844639890417668241464892471366407764480789831449930204960242372119155349985796101274928158011363";
      _points[9] = ".2797957613012491859655855463898480988672060062249520276103935539643102128193564469419623506479628470";
      _weight[9] = ".1064747741566808125685613705180191681616285462705784604164983200734269230552528149319398254833744568";
      _points[10] = ".3324425444646478977643705916772193620886659867174346042315363799570973060383356369124115211571323784";
      _weight[10] = ".9600780433395996459611005163022683822666687189995853795269920650589609941099345779579700299704646960e-1";
      _points[11] = ".3872823280574549937989445036865958828972832166536714882484665313850184327167229220473239233584617594";
      _weight[11] = ".8364408140790913806503136264243828949700520235558282644016434999787678203843397466411902861456776380e-1";
      _points[12] = ".4436001949306515828559333823823612392858936114867615745808688805378474705116095676777622646630552513";
      _weight[12] = ".7035322704434977742682228930847787787019711543667177558572243193480196890984850180718542235275479285e-1";
      _points[13] = ".5006619595031362884856902687713503167221436363552477393781189311589046478109453733251474626310385349";
      _weight[13] = ".5703475748022071828509619466256332516846561787218921379234532042280759325691321139002913907127018235e-1";
      _points[14] = ".5577237395010012764647206840844501727253666372843105914449844804197466442981144131225215846683212315";
      _weight[14] = ".4445264224788490718871711689716566481241895041904883850657992386825320854908231823847572097867075329e-1";
      _points[15] = ".6140416543163906865961035725129271962910179605530973598443859211090243690612314978954036450474195975";
      _weight[15] = ".3318912383294029289365821071167045100713239775208250096989712764224744184932990528332463294336166066e-1";
      _points[16] = ".6688815237617270248821108145549645861198322343286327852974929404210073467991331540955757170564355138";
      _weight[16] = ".2362092686671659042978174608045888691391205739211617575547205261057781698393797934731154080105219427e-1";
      _points[17] = ".7215284411637628205782811219801685752763893687252454146020804663752143651812554588012584507935377953";
      _weight[17] = ".1591836500223050457908558597913063177486827168378060246011515511359787919282859563519099594095542618e-1";
      _points[18] = ".7712960967780431853930398083442015153386640842171062566103950893923844867230098706227918714691709292";
      _weight[18] = ".1006529114352933492141859720393617288379654166295349784959577159585971733038057997542309190075883663e-1";
      _points[19] = ".8175357317097885446226654263638273500789689214285257860423082060382710028297478571779544782286374176";
      _weight[19] = ".5895624378770345168835737990923267314213457921731405554223994080869703797491624920386576121219775570e-2";
      _points[20] = ".8596446098087925495341476044048610631434683111426290228292610152787315792738718461682721701424964985";
      _weight[20] = ".3140570491033566324169178308200812903593777775611657950464043256177915220403707237044709032980166763e-2";
      _points[21] = ".8970739084211864094916125355818095043974285476361644489211453364655049867582275024468773277447058454";
      _weight[21] = ".1479803510496533483770404222388761836968823110573963984604554556290327130157655956042477025150714642e-2";
      _points[22] = ".9293359602715748334061432334478793404990512001092018428658048417839597361733846070929979731803166088";
      _weight[22] = ".5898711555596490013159173847175552002172211131197603246704873932959527131487834703954940100564916475e-3";
      _points[23] = ".9560108839274215742662198697342406595278034313234337217490396871934265900098665899697971229408841536";
      _weight[23] = ".1839034851575356489389594530597318328668080169779138264875530228689413045229252063322858580619723530e-3";
      _points[24] = ".9767531733280232298662661702683429698796977567485282341214009937436918106009940247102813503324797746";
      _weight[24] = ".3822053883255387900554746410523715204390828917060415678743895044994612478539092658170411525843891492e-4";
      _points[25] = ".9913035622385110788790336653178278306638685473029327049342568556768750779226166802910464862467038120";
      _weight[25] = ".3448114359757205756745360166489525198386376580749197638121869912495215206262890112928783159385423608e-5";
      break;


    case 52:
    case 53:
      delivered_order = 53;
      _points.resize(27);
      _weight.resize(27);
      _points[0] = ".17809431435704608855587928866114468786307898470660003902705764595605162745697524798561564126761266e-2";
      _weight[0] = ".1820603118871048582942728891063964187212465208682135554645716213359324348541984929906565483318952422e-1";
      _points[1] = ".93599372582011150287054578298726684845105659955139082644440784972843705158637264028246006974799600e-2";
      _weight[1] = ".4152785829844875717943172756938377186734953754235234311353404373544544228087795063553583138803786181e-1";
      _points[2] = ".228985426390770205039529145556914131173897091918978865259237712745826314411040163239733144939444396e-1";
      _weight[2] = ".6290119746144746482802734864589386618833347317601423057015638714495873048300389062763960852702919060e-1";
      _points[3] = ".422354693834516052027485944384642742304266530428769304973172106288833079274724699509410823014493548e-1";
      _weight[3] = ".8132436136446986193739170532758880791397877196523611071292546215873628519179693988262023812620746720e-1";
      _points[4] = ".671363692990112465957839047905593365018540666341491788748814233309382335197310409511145494368294354e-1";
      _weight[4] = ".9603082810201882415311963795104748870818268807470347887502846531247874858577708795486787797700101370e-1";
      _points[5] = ".972990698736721763753164344064238004527912129365851467031032541694671325752127600065236562458456136e-1";
      _weight[5] = ".1065088544552712310709129163765736239560946416142489520312256996469840584797893553601386044263009528";
      _points[6] = ".1323574675652328254198509862867790334541690279550368666466192187710882991061076711351679865216258966";
      _weight[6] = ".1125263755484285883365205837252928997215348671664386328271427347062622899654077798856301612961616694";
      _points[7] = ".1718860139720701680722426766544501251353813244874586832784733002806207478525176577679137330683877836";
      _weight[7] = ".1141343235447071384761478578769258902127350763147060770569388232507400711703976247938789690083039576";
      _points[8] = ".2154048926944543171651652614570632101946667733364492996249967765409568376782797064089297968838453420";
      _weight[8] = ".1116474563280293741109965065113128931866832316104691669164509221561199637581464430175629068932126426";
      _points[9] = ".2623858474559273881160617913883325511276096577994481672721349608546023050783281843153256814191169230";
      _weight[9] = ".1056050230492805119709298866476760648000510141882851923408616735140549390641398474028584341746594072";
      _points[10] = ".3122585959444232262993504592262882061838804975738422821976444443102486079512087157897605571708467080";
      _weight[10] = ".9671552705946981898751774104684219583762712809680328375846161035397016840278817983469759130132418535e-1";
      _points[11] = ".3644177529904574950557756096570565098512806680305704179066355757972527488832137323378563137368606048";
      _weight[11] = ".8579121209195122447243328295236127860714191311346550727152062805058661851930724613643640236403012940e-1";
      _points[12] = ".4182301795447049734724846472391014243667560340702901180312848174318171551123809662146069605014604107";
      _weight[12] = ".7367865526297174418825984472902459506331849312468798056148539468443217520004723844738101147944550970e-1";
      _points[13] = ".4730426684520476703602592878224296830904178855899382298873897364315299239631836659193743186739257835";
      _weight[13] = ".6119194926537683569355451543997997296618926203848359030101583951544914289940470883109383512474600590e-1";
      _points[14] = ".5281898738355329340216577227400275085482081965054560134090357670850064365267690953455340248245174630";
      _weight[14] = ".4905440341529198363865576676516031676767482097727449018102715309052236173245485358847778720174353104e-1";
      _points[15] = ".5830023879264334250663902804376328580572440100955175317865653839064321210069269191484571926567993637";
      _weight[15] = ".3785356234773460919311606411888319543129071813262592167579519593720136903085223560528795008414461006e-1";
      _points[16] = ".6368148674104017419630307715995676902754314764405299930956289867406713625910027046038473059912601228";
      _weight[16] = ".2801276453548874808009747976668363223186535565759695290998544442635238085147611006105071688900957438e-1";
      _points[17] = ".6889741108323418280816571990178261232404686847403558539490499437753002791024731150404667801081009895";
      _weight[17] = ".1978061738005189821681119732188615744078771959445292827828842468044747984641395372722160776435867028e-1";
      _points[18] = ".7388469893624735910922449829548469590275526861901167534999751484805700903189045500413201466516638950";
      _weight[18] = ".1323785353886628364655051789746491666869904914948154796436523205630295604837132271358219443077646624e-1";
      _points[19] = ".7858281353779031227352117058077111616012152440575051383618183698144842122819671305036791359257551114";
      _weight[19] = ".8319259767931359303359612245105396666555498914945895238762583811716697454039472166862699654837540950e-2";
      _points[20] = ".8293472971383944771598355049274250058834269029021771996399619672863673163568105696112267907482083349";
      _weight[20] = ".4846921295440348694709177690869156229797846446689132658058902702383248719112744082435663250437300584e-2";
      _points[21] = ".8688762741806575564667761401536189780901445930466251209065034762678430393181039572235882829647507632";
      _weight[21] = ".2570049171197175931361063941668867313971915134023462330557089030766363955154108296199490402099547780e-2";
      _points[22] = ".9039353597784711070157033597360474229931818363030729923680719044761889533438408210305605660116503296";
      _weight[22] = ".1206248346191819371376031994419143604659128577657921712696593137994525942080056531846628624316997367e-2";
      _points[23] = ".9340992449559257825950427906558732935953068512720009591535099193403502312605076880588140292621822480";
      _weight[23] = ".4792697453785258073340451419757222154191164076444721019392392800535122603874466076414342782675321384e-3";
      _points[24] = ".9590024350798769967347900672867432755261033514982111722784661932934780135998830463243946849776918500";
      _weight[24] = ".1490333111707578435026953455921951778699719566794053596354648989169784384847030615809215344280202658e-3";
      _points[25] = ".9783447246593427423009234194577171124968296718365230530311186830121782128183606331424343744729398783";
      _weight[25] = ".3091244161938983408314671147246492772583236893784015618585479755757538573429388679224858698333417363e-4";
      _points[26] = ".9919016921030858633563363794429817847379787714779279595620322545994397707381328467786508349830424110";
      _weight[26] = ".2785016388572537705690681609177755671609902607460882831309119306006182467890894946863712280688572524e-5";
      break;


    case 54:
    case 55:
      delivered_order = 55;
      _points.resize(28);
      _weight.resize(28);
      _points[0] = ".16621883340103442578914617712118486091931026683663448863398514718237214116593066504342377079833743e-2";
      _weight[0] = ".1699675331355490717411502137389388500094524603859825757063307660350119689582330208715669392854149888e-1";
      _points[1] = ".87372844723921413906571224209064625702009044587044756728285549044870588819373520276783423437475107e-2";
      _weight[1] = ".3882216114018575013737603191814056644438315299490187323801632134159387989617155982777213687966878158e-1";
      _points[2] = ".213817648356837396303427133614951684126655686625838667903980608247507148781467808005105819246606026e-1";
      _weight[2] = ".5894766595670255670963440873302383759119498225513535332185369018894998992852923394140340003085968345e-1";
      _points[3] = ".394552086405397112115498627722666268514408071936493455767292870114142259094541477859745631718848510e-1";
      _weight[3] = ".7648678602502570284486028791040104518348847178815882525438877759299820123608218610294754833091150535e-1";
      _points[4] = ".627531871254588599998374362648159017925640088262320524375430453264886547027332271779063233736836296e-1";
      _weight[4] = ".9074930386242807574850384737192231428927990682057845126440329212535996959549697865102396819307404255e-1";
      _points[5] = ".910118093721329149303778633611797690726481076572154081942199645130174229163598831553269553038009018e-1";
      _weight[5] = ".1012555974889907126108460496940755561934638347853673107289657786337559632509483599956011804344695646";
      _points[6] = ".1239109225098248943986786571525365727357700121269974363446057563225513757008341619263478384404505007";
      _weight[6] = ".1077593224554183504441506568716594810393974684605908180762875165119213414701629886814413209301776476";
      _points[7] = ".1610777785030255860344834843178969921689415610167914129205340161602880766832367124554812169913634046";
      _weight[7] = ".1102534472607597186864914711577228898952005094019551823025011564740940733845646315084518623795753890";
      _points[8] = ".2020912680468832554423969706448920337400445843902748221160223851312616827201318751974338594370210968";
      _weight[8] = ".1089584330514553833792479007201945848483678110902207242804925059301547571776537296722336107363232800";
      _points[9] = ".2464866954363530558083411840821592805659340568933689671152241449226482215610440148989074112781469145";
      _weight[9] = ".1042939762323390317306252800023900820145384876648703530515689827183667386399613716670604820101276627";
      _points[10] = ".2937610451613514326972750749668948134956539051387656916985961515253610703405985442498156612536971400";
      _weight[10] = ".9683723892284496243133400305982014503220595603741460800960591274877472218951050937958199531522486160e-1";
      _points[11] = ".3433786819261913150681460413651973878949845823554863178403679470149846273838432659226376928927518388";
      _weight[11] = ".8727159968574142456653607461431136580558843981507980115301946075240580150496406025982314095123915915e-1";
      _points[12] = ".3947774199723313116769052107500062552907725427703361632104188629638226399349568702184562114618754642";
      _weight[12] = ".7633065037704358677992173760070813754526876189118426523020012731468094178584030102693609615406548435e-1";
      _points[13] = ".4473748931198531751312384976638757267785856330538905813203215779969809276248509403699505273214443104";
      _weight[13] = ".6474239890218384617641579074397429560281200820034847743486255276201782999215045306318422919140676195e-1";
      _points[14] = ".5005751534419836230938691110194789662558196515605232274175907389180847879527065705114712877735560730";
      _weight[14] = ".5317840198085355889436749877935944937229816786481312186261562562730237943218926093884454876384009255e-1";
      _points[15] = ".5537754238684313594769240249501645635328248608561576380556038385473320553947237200652050810344918645";
      _weight[15] = ".4221188066485391017179843621910132663247325582481799896194480286103572326145048899412823414104578068e-1";
      _points[16] = ".6063729282730147073480576391241726828720982008190425665943509503596611618340212969981896009477717553";
      _weight[16] = ".3228783996502644895650898643668602554416833029918697762571085207553801460068086760948486028196731892e-1";
      _points[17] = ".6577717217542247768084005053389194499315878203674783143278934979688418886464254544545346213089894431";
      _weight[17] = ".2370693220667251758884754554263331205128739505850822623279313400923071925972365938987128520659085828e-1";
      _points[18] = ".7073894438877855706285149361350268987939100593278504681962772015788814614262279003604123878408133930";
      _weight[18] = ".1662340411686909034142413466450566565032418406426186662411255986983551839951256909951884474432223065e-1";
      _points[19] = ".7546639187593059817872803597557685898853275116792760713753923349366380454793941649397924902062411340";
      _weight[19] = ".1105609190631242552105479324746823601234418177691168238419979938124926144067391591450784016086480078e-1";
      _points[20] = ".7990595276685624868995636153621286979861878231866964890727280422713114601123812756416012428130645730";
      _weight[20] = ".6910213443566888748466176890723625292539468755284525612640801075874152045527474588594349530952288340e-2";
      _points[21] = ".8400732837976637417846403075634608381826446882830863254766087793874579013383417858472750832694683481";
      _weight[21] = ".4006769963826888763696941479740479731548662838861133975191667129930337746666938882273423775283880558e-2";
      _points[22] = ".8772405436497879573891723774128885767103809571602310600748670880625265196548463651442992083091127510";
      _weight[22] = ".2115799069802587276112448389274307711426310369019676527371289223126989553627023040825271243631318107e-2";
      _points[23] = ".9101403003668531082536780547017155187065153962208111283714408048069939649812595801927679940070115836";
      _weight[23] = ".9895645441188801027588830624824366661410419145577967624579589789470698427514257565113008958487668535e-3";
      _points[24] = ".9384000294379855101586491825366150982471974093849676442221321111107915020236599462447922597108282784";
      _weight[24] = ".3920317051831638475926050565561955006834349747351228816020734233503026528227612365403311989965344668e-3";
      _points[25] = ".9617001463459457899861099885807198305217759101371616261805924955343739972380075801124042375869028367";
      _weight[25] = ".1216212208108765183086984702980407460962842267066259167107608532532670446458238411716860247125496214e-3";
      _points[26] = ".9797785960640749944438190057145039152741074495249043615408383040614782568644584229549468171687813243";
      _weight[26] = ".2518191216312457714080057893628203062066238548219866715788280885486052172769692157028103974902227097e-4";
      _points[27] = ".9924402145386934818494062074608256710512573670377708826247066201588500246796209226609635064997654468";
      _weight[27] = ".2265958598962605196822743329763905246915735782078382024974317229330583473761254873410859862569461792e-5";
      break;


    case 56:
    case 57:
      delivered_order = 57;
      _points.resize(29);
      _weight.resize(29);
      _points[0] = ".15549290312566654200067529424954278380274824751369305922110489293830712669786881003801986454401563e-2";
      _weight[0] = ".1590395547416049373084283970446254939586728862730454297894007025395012962095072997157978392346254560e-1";
      _points[1] = ".81747236744186115591038655443929481021570368880870523467902863077171313774494636389564981408046118e-2";
      _weight[1] = ".3637065893665729571075344593916540199657241009646385824767892047382103100320527986841586952675574822e-1";
      _points[2] = ".200105727753786372911844733724811523145402058468255418476041058357437938665882587330422928921001594e-1";
      _weight[2] = ".5534795630399538850185456211297123893344168142281776267574745603114279671978481717366377866836630635e-1";
      _points[3] = ".369396752916812645959209072886222502266940175506431296353140616816413196565410066864982546877591972e-1";
      _weight[3] = ".7204878416716868669494228779171087877055190291879777468441869777323207283284792884098759434214146480e-1";
      _points[4] = ".587829062660505588584086521808717404649548194425120799881037885209152278794077663051279782438127872e-1";
      _weight[4] = ".8585111618606221894547223897051276062455717563898810682264732561837504271642097505351921489019968745e-1";
      _points[5] = ".853088009332903356323647105585752362105880822371987537471884114197296052322213399245079081838509810e-1";
      _weight[5] = ".9630795187080586094841976728359810551551172932908124410591486740160430723013263344014610396770461235e-1";
      _points[6] = ".1162362048829853425076721375397609970107436875069462593303916880434153281948281248095660108756368225";
      _weight[6] = ".1031676988619209181710558830873856413004363444827527678541306109133352094102382641985777841599329643";
      _points[7] = ".1512372911316014780919207790227039606491053931442636445013472589695144451175544237584698175481237768";
      _weight[7] = ".1063816687914308151764286948578946009532016371806181830429151351514918575960369656164303899739475778";
      _points[8] = ".1899410449901282865692379014213471630254082529921559753456718118947261873986526053764810399620167616";
      _weight[8] = ".1060973443529894398202373165023237945259903765282338008207222574643863851930328256989136309726571046";
      _points[9] = ".2319372002063364238357113561581231468239578677677663627198771197540715838680988610437419882956982154";
      _weight[9] = ".1026382437620365051961261302742550581710573153809810112602447887157691824281457449099765335918318602";
      _points[10] = ".2767805891942973708577879729031042713879054366854930668603078587622459594790114634625651543742909700";
      _weight[10] = ".9647238670452894868290795505134096581869886645007816822694179149988004663996108299166340298731353205e-1";
      _points[11] = ".3239958625177051466248603397041584055661175398120534880219141687715302778163413540837796763370016145";
      _weight[11] = ".8817225630680597612003660163949371818078447184949948235473102539086671161349867433599036467560066635e-1";
      _points[12] = ".3730825280293374465690792859201248695856590531186829500141964698180241770761618137437466075148481282";
      _weight[12] = ".7836975770978971115427402907838920161802800682518189208674079546857625920569703907869991396907689100e-1";
      _points[13] = ".4235202564181097995474113146850489926682673472663289206460620937489498826422878291086158784870130803";
      _weight[13] = ".6770995846565736534187178620911510510981331439007344136937490702077560334537629961218632220124974540e-1";
      _points[14] = ".4747743970009873561917723160531700205066921026924445193997049795210527057905182697247116916931894192";
      _weight[14] = ".5680734250845563585288858316504839656434131896796498476261765390734591853152656637737926312889479050e-1";
      _points[15] = ".5263016453375968201653794928636041556860229130020205964062744256271705159139407454117566470052847889";
      _weight[15] = ".4620793050943086619045368766579074375745787430897608290923105422272112793759027659747296191028447984e-1";
      _points[16] = ".5775558026309174452553151152733625043245901657653645490736680818890881281137921627962913404073228690";
      _weight[16] = ".3635995684886709788958406007756343059353121747834284301899201980737194866787438745763436873700570152e-1";
      _points[17] = ".6279935659165262621820137075296171293948931529723415803682695857095547330445799962987023114707911310";
      _weight[17] = ".2759491436298458106580574784196132821947800084432000401014943541800534280281110554230420725253138022e-1";
      _points[18] = ".6770802877492443573266568704467015351806311769675395683120767898431579951848013577283510561777889768";
      _weight[18] = ".2011976844683497331844387739702727260430369510653869789575590786230420302940347608481479643128532841e-1";
      _points[19] = ".7242956444888707043560871701745064455538860059199548248154436973480104217103385414072838784155034150";
      _weight[19] = ".1402009861333367145022482741179595153263656328537495601342898943949469294535231397346053110910842104e-1";
      _points[20] = ".7691391534023484768538220758922565584262388759203507506806944987604814945430447384460512918718215715";
      _weight[20] = ".9272946255348385389541458548765573070689017484996409398510543999367015481576466379271350135140451005e-2";
      _points[21] = ".8111354807272444642075213249964705278931214853178016839227908886334439887655616436591190604415520376";
      _weight[21] = ".5767322345572894815450450032797290470663786874293720580846143468974332971619800222681110962737865905e-2";
      _points[22] = ".8498394858283586592068606159884429949323530710404946731082134176863686453602964965002298383195121124";
      _weight[22] = ".3329732099534716525904959471022450189067525736458400646569973558736059350650571180620976465196888512e-2";
      _points[23] = ".8848409513746070720478295357950882608136439751437339020150931391920340490511768348960488253412095868";
      _weight[23] = ".1751756104040543812056707746636424489524091405182527252251987207967076087908850752406381958280347298e-2";
      _points[24] = ".9157689585742375160527209731782209778138377544703193428562270193431316521163635958472103988871642976";
      _weight[24] = ".8167123025929537791590779222624889046680614565866252043480296283513012023263276872664454961653957895e-3";
      _points[25] = ".9422958895903871330495337162486475572840128154973285809341967704118304237104033071590241332038056748";
      _weight[25] = ".3227041908195134456269653088472861986621444725248385753566297569081862963005760178210307805851007480e-3";
      _points[26] = ".9641411217247745946828870542493190904639324758002400985928337168007851931895173178552116298526505152";
      _weight[26] = ".9990263394095784408772527008183937133715876054979511341138744323762818463231844388641947861726885030e-4";
      _points[27] = ".9810749076596256309006437136691611689533352449026726879855908015035858117277035374554302084570293180";
      _weight[27] = ".2065193379483673723520305410719094953030456381599065092914301994814430006275832864616049559460649712e-4";
      _points[28] = ".9929267893183628062269525350662871775653492285199651525986086819393629175725051227057650509336436908";
      _weight[28] = ".1856283772081021646463917006645502930051466535420769785785415393719988368277496916641141664600612236e-5";
      break;


    case 58:
    case 59:
      delivered_order = 59;
      _points.resize(30);
      _weight.resize(30);
      _points[0] = ".14577278339065035925893934906517591784720006531081560021374605404648933006075196495734035415179835e-2";
      _weight[0] = ".1491315901155340446212604717451004862856152600028923881167748393402243077917276838298865755211496474e-1";
      _points[1] = ".76647678648067906525107009436127588964900812501853348916506511042958766290893370855271954602497766e-2";
      _weight[1] = ".3414270443637351996552524689520019651518918125519284231276373992492543701158246310282189202967903557e-1";
      _points[2] = ".187669462746132244982993301440387916639043908855580554548242427097167553740409721090435065531863716e-1";
      _weight[2] = ".5206201194506336946652736896631086980047779181323752545621446604559586912360486011754514731049188845e-1";
      _points[3] = ".346564195659897349491044844339792828709394875646473158245898065449187036414264888486758751336809745e-1";
      _weight[3] = ".6797009893843161497359823823660113226698137894136207676183867733482609286998692796304502954827124555e-1";
      _points[4] = ".551755780880457697357990152123039880671824932248632334193666231040657023521810694723723646758532947e-1";
      _weight[4] = ".8130576744926203003727351913523010351524516224444640024452683616344850950559158626110443004737743835e-1";
      _points[5] = ".801205671123255358284023170655714428093086067072667641092319477037473845840075105460305473159416990e-1";
      _weight[5] = ".9165404412254467064066511550040554298695455034951684961821682398973282747671045385852126493481605575e-1";
      _points[6] = ".1092434970626521088746731873448846222774206414347470411530922780957733620062425548835010678262498436";
      _weight[6] = ".9876432908795536536032697004673551868704851460757200597881816491701736581480140253672859671604839910e-1";
      _points[7] = ".1422549415999572144877609341053898829708731999301570680786197421573754663025852228845161221643190058";
      _weight[7] = ".1025585393150491257467352768657020962566165514453482039316467571702515714029648271882831900626400168";
      _points[8] = ".1788268232673087628783417984246983287220358061763450736249227518897393446664815732877331590542644420";
      _weight[8] = ".1031278694745945415596052946177605117292110687637337979963517529456830375931435175722170473445646078";
      _points[9] = ".2185956771518845796303573075738189314253271962040366483829882206456924780212396799680806333911290556";
      _weight[9] = ".1007186117616301279878554305959197341608245889317283916519828674052671542386577064173516014437280737";
      _points[10] = ".2611662643784974751033364418861637841052167095569197616325843294380357783689767519724808893027703806";
      _weight[10] = ".9570840225375843567066228341782746515568699099004602297281199062741108246051476093372412957708568490e-1";
      _points[11] = ".3061155007205121813665886906735831563842230803361353335661166203013891520931517709134796871698281257";
      _weight[11] = ".8857497394178217650471618391876129842077745883814547442007841660655316881345758283854245886495964015e-1";
      _points[12] = ".3529966616853502786154550912575915364162723119239058502674939729539710162974658936315002971501451101";
      _weight[12] = ".7986001209119680090675229090743842319473780511267993616803209051048773098007336509737306748332656620e-1";
      _points[13] = ".4013438224374185454639967766405275317142917022652449466333117794386845094513689829895546561946178324";
      _weight[13] = ".7013099742401690013591360102740147731104180921542862503107396753093730582466635836943847279118988900e-1";
      _points[14] = ".4506764885015598873510899584766044215966881241176557888841618510954362349594222860652999748365539745";
      _weight[14] = ".5994396892391193201878777221886819034342923382714188936785401233706685684647954234713000168528380985e-1";
      _points[15] = ".5005043712628964789717639236953963031984790603234627725767742098965776650636318606390262908257531406";
      _weight[15] = ".4980994243944509670193186882596801360805780285331470412300413488400333743558037202503741391583451746e-1";
      _points[16] = ".5503322608308270557491787984340267743359031321325234333208060314419409333934168725488976010462177834";
      _weight[16] = ".4016730562047342836983353438926568287679859907672033401806590163348537364732569259646213424815701807e-1";
      _points[17] = ".5996649478704976551018373593654268159180810688501359806278139203431894217253568566355352104940005754";
      _weight[17] = ".3136191451975259960451311523450739540697146877711414235255154582511143225744543683656798934447392539e-1";
      _points[18] = ".6480121455331503208705669145595995298479983344533984988806949082338790572395468688493909284724971221";
      _weight[18] = ".2363589773545442376826921873044047832436878049349748821622300008932827072699686486257968668165022054e-1";
      _points[19] = ".6948933626480090846660737470948052491622820351678518066893206318036909102531481156845209039989461390";
      _weight[19] = ".1712539544532892132744625893725802414621796017291600334410496954630813410240948250791722805901233146e-1";
      _points[20] = ".7398426798885768781476865343971963892441993313179320887011131454876353948716056468750647185101546591";
      _weight[20] = ".1186669231590524206744646319730034674869664293542161685991368345216694946396047626719698431526063282e-1";
      _points[21] = ".7824133817283033117351654063389710102986058216354587982007414417461506029482383411221290125361310078";
      _weight[21] = ".7809512179248871754925555522773352977101520748772132951069132653216374300984103933458927963386535875e-2";
      _points[22] = ".8221823987382739350146679257725087410887946678055925816102530058347225710144385002987812579603921205";
      _weight[22] = ".4835687651116839589207388506661792798688732351920846841568469474501450058791552883867819414242660050e-2";
      _points[23] = ".8587545173866958177170051992400022157663057683841349552780806326443491728626503313132174680442975592";
      _weight[23] = ".2781045433058290735823690629828006775647419013227642282327332200732301717026140608010957048347198602e-2";
      _points[24] = ".8917663186820247113516809652625707882606996687232032911115396565436228032409797675321983300390940348";
      _weight[24] = ".1458186687285437575395832778065189046874964252128656421832651017529503747672066055109429168733465271e-2";
      _points[25] = ".9208898151139505953144638557329905235774970627249343559514095081325116537677830281076745417186461398";
      _weight[25] = ".6779008760458223017485130976071363242102048739845894607466517544138420774229195628301905583717387815e-3";
      _points[26] = ".9458357764492203337808419002032066885955503076575948450871012659368499041349175484945986129338126392";
      _weight[26] = ".2672199620663056472135919658807958654052121724338065121842860076057742788764139847177940512925500145e-3";
      _points[27] = ".9663568116103163316818297401241144720136983411529035659740348392196335889979163711332261986272454278";
      _weight[27] = ".8256807322596642712675172300945914195274209200047916147521082294370472442789555182952396273449078565e-4";
      _points[28] = ".9822506759732043911736678171948047795906753507549646731542099473217074609302325111913020773005316618";
      _weight[28] = ".1704378210976846570170738949485625046237981076825018201228716265008270161857594461612623221607393820e-4";
      _points[29] = ".9933678849972890218242967429754756290348422812012610131690790938192644595723658942993255322381011518";
      _weight[29] = ".1530435692303559679202880600194069095291373243359882366029366110361351387216726316140978042653907890e-5";
      break;


    case 60:
    case 61:
      delivered_order = 61;
      _points.resize(31);
      _weight.resize(31);
      _points[0] = ".13693652091001036629025380164977456272383684523521234900127384067726318496722619011961387090613028e-2";
      _weight[0] = ".1401206490544436609023237121587349969746045006567761855081695008238920197145638847995501807124529058e-1";
      _points[1] = ".72010601931879643676101441030972382654929360794719448717802733095433731824054932697113411144607260e-2";
      _weight[1] = ".3211210056592242810234944055571401839762527500713589024854398810028566527822994469099430101708284774e-1";
      _points[2] = ".176355646939865329440822116716716273399262730010942408040611658873861089397577052366737230486556502e-1";
      _weight[2] = ".4905514352007358740541302270051117036844203516552518776904458507336171955803916799261247427652944802e-1";
      _points[3] = ".325777977796646088672994269213666810024624811813755502223428228717706232177578554090061589106056242e-1";
      _weight[3] = ".6421499003447563667095761947959886068101567810299905758943015986959607413434210293846080705011239590e-1";
      _points[4] = ".518885361539292094789279328121263177510960203899266935069369167663322036535665181901584121342768086e-1";
      _weight[4] = ".7708465591944440214978664678877579601642420763348919100177459902890693290204556226205252661470482730e-1";
      _points[5] = ".753875499851403839471912751400818899083127543122825576050415338731219307557745532979157874326952974e-1";
      _weight[5] = ".8727993087125598404851885924736203445983237573749491484102820440464420680359587875651980128704302290e-1";
      _points[6] = ".1028554586750934067266630945993402582474933355366456224097962648238687615218992257756775517287884361";
      _weight[6] = ".9455543857311113942533268852024714918001646007576128813201633172025531623575828933253563995121093005e-1";
      _points[7] = ".1340358114983876564339860740140341196816667539203883664849981452786512463510185666317257255429798266";
      _weight[7] = ".9881291012170006693456267092177765186618637716012470654782718891302456217838158452369578347983737910e-1";
      _points[8] = ".1686374906442098356617268634134017813732783166791782966045346757082471444333592363931357649357419150";
      _weight[8] = ".1001003159524530363104180663619783799874178898404524336779305249101130790426842115444324912977856132";
      _points[9] = ".2063374321933079647369611133634897836240770185127581624195509150737302861230656791747631614142539590";
      _weight[9] = ".9860204997970906763399803849822200678637561736800941509032055186211162575531237866562487533796561155e-1";
      _points[10] = ".2467836436155710933199228384538418511090271873523499710413024876413592298225490102948311490242621480";
      _weight[10] = ".9462109265174807424873122469747347887669228616198273398437836689671301713817820752750902057317242075e-1";
      _points[11] = ".2895984907391475920138782464308026880200802349630140545217731202754357179091084031758311229993710233";
      _weight[11] = ".8855464875380005756652072587576624284557300886023695065934716903300558691518263136396252572542543165e-1";
      _points[12] = ".3343822238776351252419685447725649719691406591568741892752991492068380593197644708700909207098420006";
      _weight[12] = ".8086518702868964921973768964419167020096598662788053379862951223461825278781407685710065195774684605e-1";
      _points[13] = ".3807167103369646932919817405792130746606355782010403499486364214947528760107143133850084127060875172";
      _weight[13] = ".7204908076371079309214829918846290043710821174646453642360675733877644714506224903242378673973549840e-1";
      _points[14] = ".4281693385154156194417410742899825270370966980210852141448274402465912219366930868936595777620858798";
      _weight[14] = ".6260514491381266112476446763960717503457148868267332156770556143624906440752520753898794314174248400e-1";
      _points[15] = ".4762970571775839012599109438642786787910227011918298028869481968383657046401344160723604121339610397";
      _weight[15] = ".5300528235407393210593432792415778543059070542062211133149380520643792420434901154289638364872976675e-1";
      _points[16] = ".5246505122103465455728183462099190147096086687630914369775031785647986088465765153290482473234440025";
      _weight[16] = ".4366919988107116389230886514702208452192610172539603303155281880114132121310772290910736617814420274e-1";
      _points[17] = ".5727782422577024113870603024175540683472059621151315030913358644137301739485372481202450035572725180";
      _weight[17] = ".3494475743428021057568935242276602073648520792237513277063007881830750670821227031289900085144260704e-1";
      _points[18] = ".6202308940878964763528673529670363355339785112518597470011666286148975401503787651670787009253429760";
      _weight[18] = ".2709500690386953751069178406838636815384967226318121133814435788253336859351359886090392628083637728e-1";
      _points[19] = ".6665654183773303861601326760614604743638563595328351949371522965073714357445225242299623003309299511";
      _weight[19] = ".2029240345068888340745950196253896611459665423948592268188679161016634008481953579096558613167856512e-1";
      _points[20] = ".7113492068095685558133006667709819451575054362840455447176740142822369749162251926869838973346927817";
      _weight[20] = ".1462008082783841976253308183893206231436847698410446515106255101009664107357060645472473645304267816e-1";
      _points[21] = ".7541641319977899149388944264594135600637795973965264582163907849633878659064268645380961165020694565";
      _weight[21] = ".1007952176991829850305258664289729474571005385425765929827171877545918882642476290287480808431840978e-1";
      _points[22] = ".7946104527758169326169679366928319864361859757363904011714581588637172599413472813223525772026126160";
      _weight[22] = ".6603470707394316985994280362337310811861259335771870656920474608040126953653365813322975128111132190e-2";
      _points[23] = ".8323105489456515383744404260031629487070666431913964811955248376360356215462432754715923979789448138";
      _weight[23] = ".4072567301324925286978191910109165210998809923518336725405684136878371982652710248244277228174452032e-2";
      _points[24] = ".8669124518396082568693596616154962977199040720951216992805820343587833819211852462891270723734550161";
      _weight[24] = ".2333953705311331245464177602173047072288137060715168141773548841446522030992039657051310429253516960e-2";
      _points[25] = ".8980931407181669215572452752900580046388620566439707644527159091729569427638691092610084112863258932";
      _weight[25] = ".1220041621260954623648068103750166494687433751337417055023692920392477150831347375209264568950430117e-2";
      _points[26] = ".9255615822969551781356416726446810501492182917520502742877697614194101962468919439115832052929387404";
      _weight[26] = ".5657189666091238390709933068514304280659458878866494461459971250893209363885838891543003998175482590e-3";
      _points[27] = ".9490615100934992658665533661080479770940064242550734057590726835551016985542145903458461174895524149";
      _weight[27] = ".2225184113616753332835954161816580608307938220209914664726703106957494701509062705878695387717845666e-3";
      _points[28] = ".9683740118091604909480627251752021631877538352896943636065161160288890490739816800738966445706492363";
      _weight[28] = ".6863667359946888101889453121545292318816146796189038823923159828041558018051222520500517382971962435e-4";
      _points[29] = ".9833203701304175412485368480405225262637155639849370527489909821657295035574559858424684689500116547";
      _weight[29] = ".1414938875337667805842756312550972005132023758238594466807507236888151577830837913533114513246692680e-4";
      _points[30] = ".9937689943617638927613642550978404132193052847562085323183044817501866272149029814389654785746287744";
      _weight[30] = ".1269380626764678675373195326975758127251201208308023241385711948424755100169194183545571759627754160e-5";
      break;

    default:
      do { QuadratureOrderOutOfRange th__ex; std::ostringstream th__out; th__out << "QuadratureOrderOutOfRange" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules/jacobi_2_0_imp.hh" << ":" << 2517 << "]: " << "Quadrature rule " << p << " not supported!"; th__ex.message(th__out.str()); throw th__ex; } while (0);
    }
  }

}
# 506 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules.hh" 2

namespace Dune {
# 516 "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules.hh"
  template<typename ct, int dim>
  class SimplexQuadratureRule;




  template<typename ct>
  class SimplexQuadratureRule<ct,2> : public QuadratureRule<ct,2>
  {
  public:


    enum{d=2};


    enum { highest_order=CubeQuadratureRule<ct,1>::highest_order -1 };


    typedef ct CoordType;


    typedef SimplexQuadratureRule value_type;
    ~SimplexQuadratureRule(){}
  private:
    friend class QuadratureRuleFactory<ct,d>;
    SimplexQuadratureRule (int p);
  };




  template<typename ct>
  class SimplexQuadratureRule<ct,3> : public QuadratureRule<ct,3>
  {
  public:


    enum{d=3};


    enum { highest_order=CubeQuadratureRule<ct,1>::highest_order -2 };


    typedef ct CoordType;


    typedef SimplexQuadratureRule<ct,3> value_type;
    ~SimplexQuadratureRule(){}
  private:
    friend class QuadratureRuleFactory<ct,d>;
    SimplexQuadratureRule (int p);
  };






  template<int dim>
  class PrismQuadraturePoints;


  template<>
  class PrismQuadraturePoints<3>
  {
  public:
 enum { MAXP=6};
 enum { highest_order=2 };


 PrismQuadraturePoints ()
      {
        int m = 0;
        O[m] = 0;


        m = 6;
        G[m][0][0] = 0.0;
        G[m][0][1] = 0.0;
        G[m][0][2] = 0.0;

        G[m][1][0] = 1.0;
        G[m][1][1] = 0.0;
        G[m][1][2] = 0.0;

        G[m][2][0] = 0.0;
        G[m][2][1] = 1.0;
        G[m][2][2] = 0.0;

        G[m][3][0] = 0.0;
        G[m][3][1] = 0.0;
        G[m][3][2] = 1.0;

        G[m][4][0] = 1.0;
        G[m][4][1] = 0.0;
        G[m][4][2] = 1.0;

        G[m][5][0] = 0.0;
        G[m][5][1] = 0.1;
        G[m][5][2] = 1.0;

        W[m][0] = 0.16666666666666666 / 2.0;
        W[m][1] = 0.16666666666666666 / 2.0;
        W[m][2] = 0.16666666666666666 / 2.0;
        W[m][3] = 0.16666666666666666 / 2.0;
        W[m][4] = 0.16666666666666666 / 2.0;
        W[m][5] = 0.16666666666666666 / 2.0;

        O[m] = 0;



        m = 6;
        G[m][0][0] =0.66666666666666666 ;
        G[m][0][1] =0.16666666666666666 ;
        G[m][0][2] =0.211324865405187 ;

        G[m][1][0] = 0.16666666666666666;
        G[m][1][1] =0.66666666666666666 ;
        G[m][1][2] = 0.211324865405187;

        G[m][2][0] = 0.16666666666666666;
        G[m][2][1] = 0.16666666666666666;
        G[m][2][2] = 0.211324865405187;

        G[m][3][0] = 0.66666666666666666;
        G[m][3][1] = 0.16666666666666666;
        G[m][3][2] = 0.788675134594813;

        G[m][4][0] = 0.16666666666666666;
        G[m][4][1] = 0.66666666666666666;
        G[m][4][2] = 0.788675134594813;

        G[m][5][0] = 0.16666666666666666;
        G[m][5][1] = 0.16666666666666666;
        G[m][5][2] = 0.788675134594813;

        W[m][0] = 0.16666666666666666 / 2.0;
        W[m][1] = 0.16666666666666666 / 2.0;
        W[m][2] = 0.16666666666666666 / 2.0;
        W[m][3] = 0.16666666666666666 / 2.0;
        W[m][4] = 0.16666666666666666 / 2.0;
        W[m][5] = 0.16666666666666666 / 2.0;

        O[m] = 2;

      }


      FieldVector<double, 3> point(int m, int i)
      {
        return G[m][i];
      }


 double weight (int m, int i)
      {
        return W[m][i];
      }


 int order (int m)
      {
        return O[m];
      }

  private:
    FieldVector<double, 3> G[MAXP+1][MAXP];

 double W[MAXP+1][MAXP];
 int O[MAXP+1];
  };





  template<int dim>
  struct PrismQuadraturePointsSingleton {
 static PrismQuadraturePoints<3> prqp;
  };




  template<>
  struct PrismQuadraturePointsSingleton<3> {
 static PrismQuadraturePoints<3> prqp;
  };




  template<typename ct, int dim>
  class PrismQuadratureRule;




  template<typename ct>
  class PrismQuadratureRule<ct,3> : public QuadratureRule<ct,3>
  {
  public:


    enum{ d=3 };


    enum{

      highest_order =
        (int)CubeQuadratureRule<ct,1>::highest_order
        < (int)SimplexQuadratureRule<ct,2>::highest_order
        ? (int)CubeQuadratureRule<ct,1>::highest_order
        : (int)SimplexQuadratureRule<ct,2>::highest_order
        };


    typedef ct CoordType;


    typedef PrismQuadratureRule<ct,3> value_type;

    ~PrismQuadratureRule(){}
  private:
    friend class QuadratureRuleFactory<ct,d>;
    PrismQuadratureRule(int p) : QuadratureRule<ct,3>(GeometryType(GeometryType::prism, d))
      {
        if (p>highest_order)
          do { QuadratureOrderOutOfRange th__ex; std::ostringstream th__out; th__out << "QuadratureOrderOutOfRange" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules.hh" << ":" << 747 << "]: " << "QuadratureRule for order " << p << " and GeometryType " << this->type() << " not available"; th__ex.message(th__out.str()); throw th__ex; } while (0);



        if (p<=2) {
          int m=6;
          this->delivered_order = PrismQuadraturePointsSingleton<3>::prqp.order(m);
          for(int i=0;i<m;++i)
          {
            FieldVector<ct,3> local;
            for (int k=0; k<d; k++)
              local[k] = PrismQuadraturePointsSingleton<3>::prqp.point(m,i)[k];
            double weight =
              PrismQuadraturePointsSingleton<3>::prqp.weight(m,i);

            this->push_back(QuadraturePoint<ct,d>(local,weight));
          }
        }
        else {
          const QuadratureRule<ct,2> & triangle = QuadratureRules<ct,2>::rule(GeometryType::simplex, p);
          const QuadratureRule<ct,1> & line = QuadratureRules<ct,1>::rule(GeometryType::cube, p);

          this->delivered_order = std::min(triangle.order(),line.order());

          for (typename QuadratureRule<ct,1>::const_iterator
                 lit = line.begin(); lit != line.end(); ++lit)
          {
            for (typename QuadratureRule<ct,2>::const_iterator
                   tit = triangle.begin(); tit != triangle.end(); ++tit)
            {
              FieldVector<ct, d> local;
              local[0] = tit->position()[0];
              local[1] = tit->position()[1];
              local[2] = lit->position()[0];

              double weight = tit->weight() * lit->weight();


              this->push_back(QuadraturePoint<ct,d>(local,weight));
            }
          }
        }
      }
  };


  class PyramidQuadraturePoints
  {
  public:
 enum { MAXP=8};
 enum { highest_order=2 };


 PyramidQuadraturePoints()
      {
        int m = 0;
        O[m] = 0;



        m = 8;
        G[m][0][0] =0.58541020;
        G[m][0][1] =0.72819660;
        G[m][0][2] =0.13819660;

        G[m][1][0] =0.13819660;
        G[m][1][1] =0.72819660;
        G[m][1][2] =0.13819660;

        G[m][2][0] =0.13819660;
        G[m][2][1] =0.27630920;
        G[m][2][2] =0.58541020;

        G[m][3][0] =0.13819660;
        G[m][3][1] =0.27630920;
        G[m][3][2] =0.13819660;

        G[m][4][0] =0.72819660;
        G[m][4][1] =0.13819660;
        G[m][4][2] =0.13819660;

        G[m][5][0] =0.72819660;
        G[m][5][1] =0.58541020;
        G[m][5][2] =0.13819660;

        G[m][6][0] =0.27630920;
        G[m][6][1] =0.13819660;
        G[m][6][2] =0.58541020;

        G[m][7][0] =0.27630920;
        G[m][7][1] =0.13819660;
        G[m][7][2] =0.13819660;

        W[m][0] = 0.125 / 3.0;
        W[m][1] = 0.125 / 3.0;
        W[m][2] = 0.125 / 3.0;
        W[m][3] = 0.125 / 3.0;
        W[m][4] = 0.125 / 3.0;
        W[m][5] = 0.125 / 3.0;
        W[m][6] = 0.125 / 3.0;
        W[m][7] = 0.125 / 3.0;

        O[m] = 2;

      }


    FieldVector<double, 3> point(int m, int i)
      {
        return G[m][i];
      }


 double weight (int m, int i)
      {
        return W[m][i];
      }


 int order (int m)
      {
        return O[m];
      }

  private:
    FieldVector<double, 3> G[MAXP+1][MAXP];
 double W[MAXP+1][MAXP];
 int O[MAXP+1];
  };




  template<int dim>
  struct PyramidQuadraturePointsSingleton {};




  template<>
  struct PyramidQuadraturePointsSingleton<3> {
 static PyramidQuadraturePoints pyqp;
  };




  template<typename ct, int dim>
  class PyramidQuadratureRule;




  template<typename ct>
  class PyramidQuadratureRule<ct,3> : public QuadratureRule<ct,3>
  {
  public:


    enum{d=3};


    enum{highest_order=CubeQuadratureRule<ct,1>::highest_order};


    typedef ct CoordType;


    typedef PyramidQuadratureRule<ct,3> value_type;

    ~PyramidQuadratureRule(){}
  private:
    friend class QuadratureRuleFactory<ct,d>;
    PyramidQuadratureRule(int p) : QuadratureRule<ct,3>(GeometryType(GeometryType::pyramid, d))
      {
        int m;

        if (p>highest_order)
          do { QuadratureOrderOutOfRange th__ex; std::ostringstream th__out; th__out << "QuadratureOrderOutOfRange" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules.hh" << ":" << 925 << "]: " << "QuadratureRule for order " << p << " and GeometryType " << this->type() << " not available"; th__ex.message(th__out.str()); throw th__ex; } while (0);



        if(false) {

          m=8;
          this->delivered_order = PyramidQuadraturePointsSingleton<3>::pyqp.order(m);
          FieldVector<ct, d> local;
          double weight;
          for(int i=0;i<m;++i)
          {
            for(int k=0;k<d;++k)
              local[k]=PyramidQuadraturePointsSingleton<3>::pyqp.point(m,i)[k];
            weight=PyramidQuadraturePointsSingleton<3>::pyqp.weight(m,i);

            this->push_back(QuadraturePoint<ct,d>(local,weight));
          }
        }
        else
        {

          QuadratureRule<ct,3> simplex =
            QuadratureRules<ct,3>::rule(GeometryType::simplex,p);

          for (typename QuadratureRule<ct,3>::const_iterator
                 it=simplex.begin(); it != simplex.end(); ++it)
          {
            FieldVector<ct,3> local = it->position();
            ct weight = it->weight();


            local[0] = local[0]+local[1];
            this->push_back(QuadraturePoint<ct,d>(local,weight));


            local[0] = it->position()[0];
            local[1] = local[0]+local[1];
            this->push_back(QuadraturePoint<ct,d>(local,weight));
          }

          this->delivered_order = simplex.order();
        }
      }
  };







  template<typename ctype, int dim>
  class QuadratureRuleFactory {
  private:
    friend class QuadratureRules<ctype, dim>;
    static QuadratureRule<ctype, dim> rule(const GeometryType& t, int p, QuadratureType::Enum qt)
      {
        if (t.isCube())
        {
          return CubeQuadratureRule<ctype,dim>(p);
        }
        if (t.isSimplex())
        {
          return SimplexQuadratureRule<ctype,dim>(p);
        }
        do { Exception th__ex; std::ostringstream th__out; th__out << "Exception" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules.hh" << ":" << 989 << "]: " << "Unknown GeometryType"; th__ex.message(th__out.str()); throw th__ex; } while (0);
      }
  };

  template<typename ctype>
  class QuadratureRuleFactory<ctype, 0> {
  private:
    enum { dim = 0 };
    friend class QuadratureRules<ctype, dim>;
    static QuadratureRule<ctype, dim> rule(const GeometryType& t, int p, QuadratureType::Enum qt)
      {
        if (t.isVertex())
        {
   return CubeQuadratureRule<ctype,dim>(p);
        }
        do { Exception th__ex; std::ostringstream th__out; th__out << "Exception" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules.hh" << ":" << 1004 << "]: " << "Unknown GeometryType"; th__ex.message(th__out.str()); throw th__ex; } while (0);
      }
  };

  template<typename ctype>
  class QuadratureRuleFactory<ctype, 1> {
  private:
    enum { dim = 1 };
    friend class QuadratureRules<ctype, dim>;
    static QuadratureRule<ctype, dim> rule(const GeometryType& t, int p, QuadratureType::Enum qt)
      {
        if (t.isLine())
        {
          switch (qt) {
          case QuadratureType::Gauss:
            return CubeQuadratureRule<ctype,dim>(p);
          case QuadratureType::Jacobian_1_0:
            return Jacobi1QuadratureRule<ctype,dim>(p);
          case QuadratureType::Jacobian_2_0:
            return Jacobi2QuadratureRule<ctype,dim>(p);
          default:
            do { Exception th__ex; std::ostringstream th__out; th__out << "Exception" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules.hh" << ":" << 1025 << "]: " << "Unknown QuadratureType"; th__ex.message(th__out.str()); throw th__ex; } while (0);
          }
        }
        do { Exception th__ex; std::ostringstream th__out; th__out << "Exception" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules.hh" << ":" << 1028 << "]: " << "Unknown GeometryType"; th__ex.message(th__out.str()); throw th__ex; } while (0);
      }
  };

  template<typename ctype>
  class QuadratureRuleFactory<ctype, 3> {
  private:
    enum { dim = 3 };
    friend class QuadratureRules<ctype, dim>;
    static QuadratureRule<ctype, dim> rule(const GeometryType& t, int p, QuadratureType::Enum qt)
      {
        if (t.isCube())
        {
          return CubeQuadratureRule<ctype,dim>(p);
        }
        if (t.isSimplex())
        {
          return SimplexQuadratureRule<ctype,dim>(p);
        }
        if (t.isPrism())
     {
          return PrismQuadratureRule<ctype,dim>(p);
     }
        if (t.isPyramid())
     {
          return PyramidQuadratureRule<ctype,dim>(p);
     }
        do { Exception th__ex; std::ostringstream th__out; th__out << "Exception" << " [" << __func__ << ":" << "/home/cocktail/pipping/dune-git-svn/dune-grid/dune/grid/common/quadraturerules.hh" << ":" << 1055 << "]: " << "Unknown GeometryType"; th__ex.message(th__out.str()); throw th__ex; } while (0);
      }
  };

}
# 20 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/test/test-fe.hh" 2






template<class FE>
class FEFunction {
  typedef typename FE::Traits::Basis::Traits::DomainLocal DomainLocal;
  typedef typename FE::Traits::Basis::Traits::Range Range;

  const FE& fe;

public:
  typedef typename FE::Traits::Basis::Traits::RangeField CT;

  std::vector<CT> coeff;

  FEFunction(const FE& fe_) : fe(fe_) { resetCoefficients(); }

  void resetCoefficients() {
    coeff.resize(fe.basis().size());
    for(std::size_t i=0; i<coeff.size(); ++i)
      coeff[i] = 0;
  }

  void setRandom(double max) {
    coeff.resize(fe.basis().size());
    for(std::size_t i=0; i<coeff.size(); ++i)
      coeff[i] = ((1.0*std::rand()) / 2147483647 - 0.5)*2.0*max;
  }

  void evaluate (const DomainLocal& x, Range& y) const {
    std::vector<Range> yy;
    fe.basis().evaluateFunction(x, yy);

    y = 0.0;
    for (std::size_t i=0; i<yy.size(); ++i)
      y.axpy(coeff[i], yy[i]);
  }
};
# 75 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/test/test-fe.hh"
template<class FE>
bool testInterpolation(const FE& fe, double eps, int n=5)
{
  bool success = true;
  FEFunction<FE> f(fe);

  std::vector<typename FEFunction<FE>::CT> coeff;
  for(int i=0; i<n && success; ++i) {

    f.setRandom(100);


    fe.interpolation().interpolate(f, coeff);


    if (coeff.size() != fe.basis().size()) {
      std::cout << "Bug in LocalInterpolation for finite element type "
                << Dune::className<FE>() << ":" << std::endl;
      std::cout << "    Interpolation vector has size " << coeff.size()
                << std::endl;
      std::cout << "    Basis has size " << fe.basis().size() << std::endl;
      std::cout << std::endl;
      success = false;


      continue;
    }


    for(std::size_t j=0; j<coeff.size() && success; ++j) {
      if ( std::abs(coeff[j]-f.coeff[j]) >
           eps*(std::max(std::abs(f.coeff[j]), 1.0)) )
      {
        std::cout << std::setprecision(16);
        std::cout << "Bug in LocalInterpolation for finite element type "
                  << Dune::className<FE>() << ":" << std::endl;
        std::cout << "    Interpolation weight " << j << " differs by "
                  << std::abs(coeff[j]-f.coeff[j]) << " from coefficient of "
                  << "linear combination." << std::endl;
        std::cout << std::endl;
        success = false;
      }
    }
  }
  return success;
}
# 134 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/test/test-fe.hh"
template<class Geo, class FE>
bool testJacobian(const Geo &geo, const FE& fe, double eps, double delta,
                  std::size_t order = 2)
{
  typedef typename FE::Traits::Basis Basis;

  typedef typename Basis::Traits::DomainField DF;
  static const std::size_t dimDLocal = Basis::Traits::dimDomainLocal;
  typedef typename Basis::Traits::DomainLocal DomainLocal;
  static const std::size_t dimDGlobal = Basis::Traits::dimDomainGlobal;

  static const std::size_t dimR = Basis::Traits::dimRange;
  typedef typename Basis::Traits::Range Range;

  typedef typename Basis::Traits::Jacobian Jacobian;

  bool success = true;







  const Dune::QuadratureRule<DF, dimDLocal> quad =
    Dune::QuadratureRules<DF, dimDLocal>::rule(fe.type(),order);


  for (std::size_t i=0; i < quad.size(); i++) {


    const DomainLocal& testPoint = quad[i].position();


    std::vector<Jacobian> jacobians;
    fe.basis().evaluateJacobian(testPoint, jacobians);
    if(jacobians.size() != fe.basis().size()) {
      std::cout << "Bug in evaluateJacobianGlobal() for finite element type "
                << Dune::className<FE>() << ":" << std::endl;
      std::cout << "    Jacobian vector has size " << jacobians.size()
                << std::endl;
      std::cout << "    Basis has size " << fe.basis().size() << std::endl;
      std::cout << std::endl;
      return false;
    }

    Dune::FieldMatrix<DF, dimDLocal, dimDGlobal> geoJT =
      geo.jacobianTransposed(testPoint);


    for (std::size_t j=0; j<fe.basis().size(); ++j) {




      Dune::FieldMatrix<double, dimR, dimDLocal> localJacobian(0);
      for(std::size_t k = 0; k < dimR; ++k)
        for(std::size_t l = 0; l < dimDGlobal; ++l)
          for(std::size_t m = 0; m < dimDLocal; ++m)
            localJacobian[k][m] += jacobians[j][k][l] * geoJT[m][l];


      for (std::size_t m = 0; m < dimDLocal; ++m) {


        DomainLocal upPos = testPoint;
        DomainLocal downPos = testPoint;

        upPos[m] += delta;
        downPos[m] -= delta;

        std::vector<Range> upValues, downValues;

        fe.basis().evaluateFunction(upPos, upValues);
        fe.basis().evaluateFunction(downPos, downValues);


        for(std::size_t k = 0; k < dimR; ++k) {


          double derivative = localJacobian[k][m];

          double finiteDiff = (upValues[j][k] - downValues[j][k]) / (2*delta);


          if ( std::abs(derivative-finiteDiff) >
               eps/delta*(std::max(std::abs(finiteDiff), 1.0)) )
          {
            std::cout << std::setprecision(16);
            std::cout << "Bug in evaluateJacobian() for finite element type "
                      << Dune::className<FE>() << ":" << std::endl;
            std::cout << "    Shape function derivative does not agree with "
                      << "FD approximation" << std::endl;
            std::cout << "    Shape function " << j << " component " << k
                      << " at position " << testPoint << ": derivative in "
                      << "local direction " << m << " is "
                      << derivative << ", but " << finiteDiff << " is "
                      << "expected." << std::endl;
            std::cout << std::endl;
            success = false;
          }
        }
      }
    }
  }

  return success;
}


template<class Geo, class FE>
bool testFE(const Geo &geo, const FE& fe, double eps, double delta,
            unsigned order = 2)
{
  bool success = true;

  success = testInterpolation(fe, eps) and success;
  success = testJacobian(geo, fe, eps, delta, order) and success;

  return success;
}
# 24 "/home/cocktail/pipping/dune-git-svn/dune-localfunctions/dune/localfunctions/test/test-edges0.5.cc" 2

template<std::size_t dim>
void testEdgeS0_5(int &result) {

  static const double eps = 1e-9;

  static const double delta = 1e-5;

  std::cout << "== Checking global-valued EdgeS0_5 elements (with "
            << "dim=" << dim << ")" << std::endl;

  Dune::GeometryType gt;
  gt.makeSimplex(dim);

  typedef TestGeometries<double, dim> TestGeos;
  static const TestGeos testGeos;

  typedef typename TestGeos::Geometry Geometry;
  const Geometry &geo = testGeos.get(gt);

  typedef static_assert_test< sizeof(static_assert_failure< (bool)( dim <= 3 )>) > dune_static_assert_typedef_44;
  std::size_t vertexIds[] = {0, 1, 2, 3};
  Dune::GeneralVertexOrder<dim, std::size_t>
    vo(gt, vertexIds+0, vertexIds+dim+1);

  Dune::EdgeS0_5FiniteElementFactory<Geometry, double> feFactory;
  bool success = testFE(geo, feFactory.make(geo, vo), eps, delta);

  if(success && result != 1)
    result = 0;
  else
    result = 1;
}

int main(int argc, char** argv) {
  try {
    int result = 77;

    testEdgeS0_5<2>(result);
    testEdgeS0_5<3>(result);

    return result;
  }
  catch (const Dune::Exception& e) {
    std::cout << e << std::endl;
    throw;
  }
}
