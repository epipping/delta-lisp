typedef __typeof__(sizeof(int)) size_t;
namespace std __attribute__ ((__visibility__ ("default")))
{
    using ::size_t;
}


typedef struct
{
}


__mbstate_t;
extern "C++"
{
    inline void* operator new(std::size_t, void* __p) throw()
    {
    }
}


namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{
    template<typename _Tp>     class new_allocator
    {
    };
}


namespace std __attribute__ ((__visibility__ ("default")))
{
    template<typename _Tp>     class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
    };
}


namespace Dune
{
    class Exception
    {
    };
    template<bool first, class T1, class T2>   struct SelectType
    {
        typedef T1 Type;
    };
    template<typename V>   class DenseVector
    {
    };
    template< class K, int SIZE >   class FieldVector :     public DenseVector< FieldVector<K,SIZE> >
    {
    };
    class GeometryType
    {
        private:           unsigned int topologyId_;
        unsigned char dim_ : 7;
        bool none_ : 1;
        public:          GeometryType ()             : topologyId_(0), dim_(0), none_(true)
        {
        }
        unsigned int id() const
        {
        }
    };
}


template <bool x> struct static_assert_failure;
template<int x> struct static_assert_test
{
};
namespace std __attribute__ ((__visibility__ ("default")))
{
    template<typename _Tp, typename _Alloc>     struct _Vector_base
    {
    };
    template<typename _Tp, typename _Alloc = std::allocator<_Tp> >     class vector : protected _Vector_base<_Tp, _Alloc>
    {
        public:       typedef _Tp value_type;
        public:        void       push_back(const value_type& __x)
        {
        }
    };
}


namespace Dune
{
    template<typename MAT>   class DenseMatrix
    {
    };
    template<class K, int ROWS, int COLS>   class FieldMatrix : public DenseMatrix< FieldMatrix<K,ROWS,COLS> >
    {
    };
    template< template< class, class > class Operation, template< int > class Value, int first, int last >   class GenericForLoop   : public Operation< Value< first >, GenericForLoop< Operation, Value, first+1, last > >
    {
    };
    template< template< class, class > class Operation, template< int > class Value, int last >   class GenericForLoop< Operation, Value, last, last >   : public Value< last >
    {
    };
    namespace ForLoopHelper
    {
        template< class A, class B >     struct Apply
        {
            template< class T1 >       static void apply ( T1 &p1 )
            {
                A::apply( p1 );
            }
        };
    }
    template< template< int > class Operation, int first, int last >   class ForLoop   : public GenericForLoop< ForLoopHelper::Apply, Operation, first, last >
    {
    };
    namespace GenericGeometry
    {
        struct Point
        {
            static const unsigned int dimension = 0;
        };
        template< class BaseTopology >     struct Prism
        {
            static const unsigned int dimension = BaseTopology :: dimension + 1;
        };
        template< unsigned int id, unsigned int dim >     class Topology
        {
            static const unsigned int dimension = dim;
            static const bool isPrism = ((id >> (dimension-1)) != 0);
            typedef typename Topology< (id & ~(1 << (dimension-1))), dimension-1 >::type         BaseTopology;
            template< bool >       struct Prism
            {
                typedef GenericGeometry :: Prism< BaseTopology > type;
            };
            template< bool >       struct Pyramid
            {
            };
            public:       typedef typename SelectType< isPrism, Prism<true>, Pyramid<false> >::Type::type type;
        };
        template< unsigned int id >     class Topology< id, 0 >
        {
            public:       typedef Point type;
        };
    }
}


namespace std
{
    namespace tr1
    {
        template<int _Idx, typename... _Elements>     struct _Tuple_impl;
        template<int _Idx>     struct _Tuple_impl<_Idx>
        {
        };
        template<int _Idx, typename _Head, typename... _Tail>     struct _Tuple_impl<_Idx, _Head, _Tail...>     : public _Tuple_impl<_Idx + 1, _Tail...>
        {
            _Head _M_head;
        };
        template<typename... _Elements>     class tuple : public _Tuple_impl<0, _Elements...>
        {
        };
    }
}


namespace Dune
{
    using std::tr1::tuple;
    template< class Tuple, class T>   struct PushBackTuple
    {
        typedef typename Dune::tuple<T> type;
    };
    namespace GenericGeometry
    {
        template< template< int > class Element, int dim >     class CodimTable
        {
            typedef typename PushBackTuple<         typename CodimTable< Element, dim-1 >::ElementTuple,         Element< dim > >::type ElementTuple;
            ElementTuple map_;
        };
        template< template< int > class Element>     class CodimTable< Element, -1 >
        {
            friend class CodimTable< Element, 0 >;
            typedef typename Dune::tuple<> ElementTuple;
        };
        template< class Topology, unsigned int dim, unsigned int codim >     class SizeImpl;
        template< class BaseTopology, unsigned int dim, unsigned int codim >     class SizeImpl< Prism< BaseTopology >, dim, codim >
        {
            typedef Prism< BaseTopology > Topology;
            typedef static_assert_test< sizeof(static_assert_failure< (bool)( (dim == Topology :: dimension) )>) > dune_static_assert_typedef_58;
        };
        template< class BaseTopology, unsigned int dim >     class SizeImpl< Prism< BaseTopology >, dim, 0 >
        {
            typedef Prism< BaseTopology > Topology;
            typedef static_assert_test< sizeof(static_assert_failure< (bool)( (dim == Topology :: dimension) )>) > dune_static_assert_typedef_72;
        };
        template< class Topology, unsigned int codim >     struct Size
        {
            enum
            {
                value = SizeImpl< Topology, Topology :: dimension, codim > :: value
            };
        };
        template< class Topology, class ctype >     struct ReferenceElement
        {
            static const unsigned int dimension = Topology :: dimension;
            private:       template< int codim >       class BaryCenterArray;
            CodimTable< BaryCenterArray, dimension > baryCenters_;
        };
        template< class Topology, class ctype >     template< int codim >     class ReferenceElement< Topology, ctype > :: BaryCenterArray
        {
            enum
            {
                Size = GenericGeometry :: Size< Topology, codim > :: value
            };
        };
        template< class CT, unsigned int dim, unsigned int dimW >     struct MappingTraits;
        template< class Topology, class Traits, bool affine, unsigned int offset = 0 >     class GenericCornerMapping;
        template< class BaseTopology, class Traits, bool affine, unsigned int offset >     class GenericCornerMapping< Prism< BaseTopology >, Traits, affine, offset >
        {
            typedef Prism< BaseTopology > Topology;
            public:       static const unsigned int dim = Topology :: dimension;
            static const bool alwaysAffine = ((dim < 2) || affine);
        };
        template< class CoordTraits, class Topology, unsigned int dimW >     class CoordStorage
        {
        };
        template< class CoordTraits, class Topo, unsigned int dimW,               class CStorage = CoordStorage< CoordTraits, Topo, dimW >,               bool affine = false >     class CornerMapping
        {
            public:       typedef Topo Topology;
            typedef CStorage CornerStorage;
            typedef MappingTraits< CoordTraits, Topology :: dimension, dimW > Traits;
            private:       typedef GenericGeometry :: GenericCornerMapping< Topology, Traits, affine > GenericMapping;
            public:       static const bool alwaysAffine = GenericMapping :: alwaysAffine;
            protected:       CornerStorage coords_;
            public:       template< class CoordVector >       explicit CornerMapping ( const CoordVector &coords )       : coords_( coords )
            {
            }
        };
        template< class ct >     struct DuneCoordTraits
        {
            typedef ct ctype;
            template< int dim >       struct Vector
            {
                typedef FieldVector< ctype, dim > type;
            };
        };
        template< class CT, unsigned int dim, unsigned int dimW >     struct MappingTraits
        {
            typedef CT CoordTraits;
            static const unsigned int dimension = dim;
            typedef typename CoordTraits :: ctype FieldType;
            typedef typename CoordTraits :: template Vector< dimension > :: type LocalCoordinate;
        };
        template< class ctype, int dimG, int dimW, bool alwaysAffine = false >     struct DefaultGeometryTraits
        {
            typedef DuneCoordTraits< ctype > CoordTraits;
            static const int dimGrid = dimG;
            static const int dimWorld = dimW;
            static const bool hybrid = true;
            template< class Topology >       struct Mapping
            {
                typedef CoordStorage< CoordTraits, Topology, dimWorld > CornerStorage;
                typedef CornerMapping< CoordTraits, Topology, dimWorld, CornerStorage, alwaysAffine > type;
            };
        };
        template< class CoordTraits, class Topo, int dimW, class Impl >     class Mapping
        {
            typedef Impl Implementation;
            public:       typedef Topo Topology;
            static const bool alwaysAffine = Implementation :: alwaysAffine;
            protected:       Implementation impl_;
            public:       template< class CoordVector >       explicit Mapping ( const CoordVector &coords )       : impl_( coords )
            {
            }
        };
        template< unsigned int dim, class GeometryTraits >     class CachedStorage
        {
            public:       static const unsigned int dimension = dim;
            bool affine;
        };
        template< unsigned int dim, class GeometryTraits >     class CachedJacobianTransposed
        {
        };
        template< unsigned int dim, class GeometryTraits >     class CachedJacobianInverseTransposed
        {
            typedef CachedJacobianTransposed< dim, GeometryTraits > JacobianTransposed;
            private:       JacobianTransposed &jacobianTransposed ()
            {
            }
        };
        template< class Topology, class GeometryTraits >     class CachedMapping
        {
            typedef typename GeometryTraits::template Mapping< Topology >::type         MappingImpl;
            public:       typedef MappingTraits         < typename GeometryTraits::CoordTraits, Topology::dimension, GeometryTraits::dimWorld >         Traits;
            typedef GenericGeometry::Mapping         < typename GeometryTraits::CoordTraits, Topology, GeometryTraits::dimWorld, MappingImpl >         Mapping;
            static const unsigned int dimension = Traits::dimension;
            typedef typename Traits::FieldType FieldType;
            typedef typename Traits::LocalCoordinate LocalCoordinate;
            typedef CachedStorage< dimension, GeometryTraits > Storage;
            typedef GenericGeometry::ReferenceElement< Topology, FieldType > ReferenceElement;
            static const bool alwaysAffine = Mapping::alwaysAffine;
            public:       template< class CoordVector >       explicit CachedMapping ( const CoordVector &coords )       : mapping_( coords )
            {
                if( alwaysAffine )           storage().affine = true;
                else           computeJacobianTransposed( baryCenter() );
            }
            bool affine () const
            {
            }
            private:       static const LocalCoordinate &baryCenter ()
            {
                return ReferenceElement::template baryCenter< 0 >( 0 );
            }
            Storage &storage () const
            {
            }
            void computeJacobianTransposed ( const LocalCoordinate &x ) const
            {
            }
            private:       Mapping mapping_;
        };
        template< unsigned int dim, class GeometryTraits, unsigned int codim = dim >     class HybridMappingBase;
        template< unsigned int dim, class GeometryTraits, unsigned int codim >     class HybridMappingBase     : public virtual HybridMappingBase< dim, GeometryTraits, codim-1 >
        {
        };
        template< unsigned int dim, class GeometryTraits >     class HybridMapping      : public virtual HybridMappingBase< dim, GeometryTraits >
        {
        };
        template< class Topology, class GeometryTraits, unsigned int codim = Topology :: dimension >     class VirtualMappingBase;
        template< class Topology, class GeometryTraits, unsigned int codim >     class VirtualMappingBase     : public VirtualMappingBase< Topology, GeometryTraits, codim-1 >,       public virtual HybridMappingBase< Topology :: dimension, GeometryTraits, codim >
        {
        };
        template< class Topology, class GeometryTraits >     class VirtualMappingBase< Topology, GeometryTraits, 0 >     : public virtual HybridMappingBase< Topology :: dimension, GeometryTraits, 0 >
        {
        };
        template< class Topology, class GeometryTraits >     class VirtualMapping     : public HybridMapping< Topology :: dimension, GeometryTraits >,        public VirtualMappingBase< Topology, GeometryTraits >
        {
            typedef CachedMapping< Topology, GeometryTraits > Mapping;
            private:       Mapping mapping_;
            public:       template< class CoordVector >       explicit VirtualMapping ( const CoordVector &coordVector )       : mapping_( coordVector )
            {
            }
        };
        template< class A, class B >     struct StaticMaximum
        {
            static const int v = (A::v > B::v ? A::v : B::v);
        };
        template< template< int > class Value, int first, int last >     struct Maximum     : public GenericForLoop< StaticMaximum, Value, first, last >
        {
        };
        template< unsigned int dim, class GeometryTraits >     class VirtualMappingFactory
        {
            static const unsigned int numTopologies = (1 << dim);
            template< int topologyId >       struct MappingSize
            {
                typedef typename GenericGeometry::Topology< (unsigned int)topologyId, dim >::type Topology;
                static const int v = sizeof( VirtualMapping< Topology, GeometryTraits > );
            };
            template< class CoordVector >       class ConstructorTable;
            public:       typedef HybridMapping< dim, GeometryTraits > Mapping;
            static const unsigned int maxMappingSize = Maximum< MappingSize, 0, numTopologies-1 >::v;
            template< class CoordVector >       static Mapping*       construct ( const unsigned int topologyId, const CoordVector &coords, char *mappingStorage )
            {
                static ConstructorTable< CoordVector > construct;
            }
        };
        template< unsigned int dim, class GeometryTraits >     template< class CoordVector >     class VirtualMappingFactory< dim, GeometryTraits >::ConstructorTable
        {
            typedef Mapping* (*Construct) ( const CoordVector &coords, char *mappingStorage );
            template< int i >       struct Builder;
            public:       ConstructorTable ()
            {
                ForLoop< Builder, 0, numTopologies-1 >::apply( construct_ );
            }
            private:       template< class Topology >       static Mapping*       construct ( const CoordVector &coords, char *mappingStorage )
            {
                typedef VirtualMapping< Topology, GeometryTraits > VMapping;
                return new( mappingStorage ) VMapping( coords );
            }
            Construct construct_[ numTopologies ];
        };
        template< unsigned int dim, class GeometryTraits >     template< class CoordVector >     template< int topologyId >     struct VirtualMappingFactory< dim, GeometryTraits >::ConstructorTable< CoordVector >::Builder
        {
            static void apply ( Construct (&construct)[ numTopologies ] )
            {
                typedef typename GenericGeometry::Topology< (unsigned int)topologyId, dim >::type Topology;
                construct[ topologyId ] = ConstructorTable< CoordVector >::template construct< Topology >;
            }
        };
        template< class ElementMapping, unsigned int codim >     class MappingProvider;
        template< unsigned int dim, class GeometryTraits, unsigned int codim >     class MappingProvider< HybridMapping< dim, GeometryTraits >, codim >
        {
            public:       static const unsigned int dimension = dim;
            static const unsigned int codimension = codim;
            static const unsigned int mydimension = dimension - codimension;
            private:       typedef VirtualMappingFactory< mydimension, GeometryTraits > Factory;
            public:        static const unsigned int maxMappingSize = Factory::maxMappingSize;
            typedef typename Factory::Mapping Mapping;
            template< class CoordVector >       static Mapping*       construct ( const unsigned int topologyId, const CoordVector &coords, char *mappingStorage )
            {
                return Factory::construct( topologyId, coords, mappingStorage );
            }
        };
        template< int mydim, class Traits >     class BasicGeometry
        {
            static const int dimGrid = Traits :: dimGrid;
            public:         static const int mydimension = mydim;
            static const int codimension = dimGrid - mydimension;
            template< bool >       struct Hybrid
            {
                typedef HybridMapping< dimGrid, Traits > Mapping;
            };
            template< bool >       struct NonHybrid
            {
            };
            typedef typename SelectType< Traits::hybrid, Hybrid< true >, NonHybrid< false > >::Type::Mapping         ElementMapping;
            typedef GenericGeometry::MappingProvider< ElementMapping, codimension > MappingProvider;
            protected:       typedef typename MappingProvider::Mapping Mapping;
            template< class CoordVector >       BasicGeometry ( const GeometryType &type, const CoordVector &coords )
            {
                mapping_ = MappingProvider::construct( type.id(), coords, mappingStorage_ );
            }
            private:         Mapping* mapping_;
            char mappingStorage_[ MappingProvider::maxMappingSize ];
        };
    }
    template<class ctype, std::size_t mydim, std::size_t coorddim>   class MockGeometry :     public GenericGeometry::BasicGeometry<       mydim, GenericGeometry::DefaultGeometryTraits<ctype, coorddim, coorddim>       >
    {
        typedef GenericGeometry::DefaultGeometryTraits<ctype, coorddim, coorddim>       Traits;
        typedef GenericGeometry::BasicGeometry<mydim, Traits> Base;
        public:      typedef FieldMatrix<ctype, coorddim, mydim> Jacobian;
        template<class CoordVector>     MockGeometry(const GeometryType &type, const CoordVector &coords) :       Base(type, coords)
        {
        }
    };
}


template<class ctype, std::size_t dim> class TestGeometries;
template<class ctype> class TestGeometries<ctype, 2> :   public std::vector<Dune::MockGeometry<ctype, 2, 2> >
{
    static const std::size_t dim = 2;
    public:   typedef Dune::MockGeometry<ctype, dim, dim> Geometry;
    TestGeometries()
    {
        Dune::GeometryType gt;
        std::vector<Dune::FieldVector<ctype, dim> > coords;
        push_back(Geometry(gt, coords));
    }
};
template<std::size_t dim> void testEdgeS0_5(int &result)
{
    typedef TestGeometries<double, dim> TestGeos;
    static const TestGeos testGeos;
}


int main(int argc, char** argv)
{
    try
    {
        int result = 77;
        testEdgeS0_5<2>(result);
    }
    catch (const Dune::Exception& e)
    {
    }
}
